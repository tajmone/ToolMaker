########## DOL ##########
//============ ArrayAttributeType.cc
//=======================================================================

#include "DOL.hh"
#include "ArrayAttributeType.hh"




//-----------------------------------------------------------------------
// ArrayAttributeType::create

ArrayAttributeType* ArrayAttributeType::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(ArrayAttributeType_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// ArrayAttributeType::getClassNo

int ArrayAttributeType::getClassNo()
{
    return ArrayAttributeType_CLASS_ID;
}



//-----------------------------------------------------------------------
// ArrayAttributeType::open

ArrayAttributeType* ArrayAttributeType::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (ArrayAttributeType*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case ArrayAttributeType_CLASS_ID:
	    return new ArrayAttributeType (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// ArrayAttributeType::open

ArrayAttributeType* ArrayAttributeType::open(DbTitle *title, DbResultCode& result, ArrayAttributeType* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// ArrayAttributeType::ArrayAttributeType

ArrayAttributeType::ArrayAttributeType(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    ArrayAttributeType::init(op);
}


//-----------------------------------------------------------------------
// ArrayAttributeType::init

void ArrayAttributeType::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	AttributeType::init(op);
    if (op == CREATE) {
    }
    int i = 0;
}


//-----------------------------------------------------------------------
// ArrayAttributeType::lowIndex

Integer ArrayAttributeType::lowIndex(void) // get
{
    Integer temp;
    lowIndex_.get(theObject, 2, temp);
    return temp;
}


//-----------------------------------------------------------------------
// ArrayAttributeType::lowIndex

void ArrayAttributeType::lowIndex(Integer data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        lowIndex_.set(theObject, 2, data);
    }
    else error("ArrayAttributeType::lowIndex");
}


//-----------------------------------------------------------------------
// ArrayAttributeType::highIndex

Integer ArrayAttributeType::highIndex(void) // get
{
    Integer temp;
    highIndex_.get(theObject, 3, temp);
    return temp;
}


//-----------------------------------------------------------------------
// ArrayAttributeType::highIndex

void ArrayAttributeType::highIndex(Integer data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        highIndex_.set(theObject, 3, data);
    }
    else error("ArrayAttributeType::highIndex");
}




//-----------------------------------------------------------------------
// ArrayAttributeType::prepare

DbResultCode ArrayAttributeType::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    return AttributeType::prepare();
}


//-----------------------------------------------------------------------
// ArrayAttributeType::commit

void ArrayAttributeType::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    AttributeType::commit();
}


//-----------------------------------------------------------------------
// ArrayAttributeType::rollback

void ArrayAttributeType::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    AttributeType::rollback();
}







//-- EoF ------------------------------------------------------------
//============ Attribute.cc
//=======================================================================

#include "DOL.hh"
#include "Attribute.hh"


// Include referenced classes:
#include "AttributeType.hh"
#include "AttributeProperty.hh"


//-----------------------------------------------------------------------
// Attribute::create

Attribute* Attribute::create(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Attribute_CLASS_ID, &key, 64);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// Attribute::update

Attribute* Attribute::update(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Attribute_CLASS_ID, &key, 64);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// Attribute::remove

Attribute* Attribute::remove(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Attribute_CLASS_ID, &key, 64);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// Attribute::openrlock

Attribute* Attribute::openrlock(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Attribute_CLASS_ID, &key, 64);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// Attribute::open

Attribute* Attribute::open(UniqueName key,
	DbResultCode& result,
	Attribute* dol)
{
    DbTitle title (Attribute_CLASS_ID, &key, 64);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// Attribute::getClassNo

int Attribute::getClassNo()
{
    return Attribute_CLASS_ID;
}


//-----------------------------------------------------------------------
// Attribute::getIterator

AttributeIterator* Attribute::getIterator()
{
    return new AttributeIterator;
}


//-----------------------------------------------------------------------
// Attribute::open

Attribute* Attribute::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (Attribute*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case Attribute_CLASS_ID:
	    return new Attribute (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// Attribute::open

Attribute* Attribute::open(DbTitle *title, DbResultCode& result, Attribute* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN);
        return dol;
    }
}


//-----------------------------------------------------------------------
// Attribute::Attribute

Attribute::Attribute(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    Attribute::init(op);
}


//-----------------------------------------------------------------------
// Attribute::init

void Attribute::init(DBOperation op)
{
    if (op == CREATE) {
    }
    int i = 0;
    type_ = NULL;
    properties_ = NULL;
}


//-----------------------------------------------------------------------
// Attribute::name

UniqueName Attribute::name(void) // get
{
    UniqueName temp;
    name_.get(theObject, 0, temp);
    return temp;
}


//-----------------------------------------------------------------------
// Attribute::searchname

AttributeIterator* Attribute::searchname(UniqueName value)
{
    return new AttributeIterator (0, (void*) &value, 64);
}



//-----------------------------------------------------------------------
// Attribute::updatetype

AttributeType* Attribute::updatetype(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (type_ != NULL)
        title = type_->getTitle();
    else {
        type_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return AttributeType::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Attribute::removetype

AttributeType* Attribute::removetype(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (type_ != NULL)
        title = type_->getTitle();
    else {
        type_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return AttributeType::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Attribute::openrlocktype

AttributeType* Attribute::openrlocktype(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (type_ != NULL)
        title = type_->getTitle();
    else {
        type_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return AttributeType::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// Attribute::opentype

AttributeType* Attribute::opentype(DbResultCode& result, AttributeType* dol)
{
    DbTitle* title;
    if (type_ != NULL)
        title = type_->getTitle();
    else {
        type_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return AttributeType::open(title, result, OPEN, NULL);
        else
            return AttributeType::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Attribute::type

void Attribute::type(AttributeType* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (type_ &&  type_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete type_;
	if (data)
            type_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    type_ = DbTitleRef::nilRef();
    }
    else error("Attribute::type");
}



//-----------------------------------------------------------------------
// Attribute::updateproperties

AttributeProperty* Attribute::updateproperties(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (properties_ != NULL)
        title = properties_->getTitle();
    else {
        properties_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return AttributeProperty::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Attribute::removeproperties

AttributeProperty* Attribute::removeproperties(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (properties_ != NULL)
        title = properties_->getTitle();
    else {
        properties_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return AttributeProperty::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Attribute::openrlockproperties

AttributeProperty* Attribute::openrlockproperties(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (properties_ != NULL)
        title = properties_->getTitle();
    else {
        properties_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return AttributeProperty::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// Attribute::openproperties

AttributeProperty* Attribute::openproperties(DbResultCode& result, AttributeProperty* dol)
{
    DbTitle* title;
    if (properties_ != NULL)
        title = properties_->getTitle();
    else {
        properties_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return AttributeProperty::open(title, result, OPEN, NULL);
        else
            return AttributeProperty::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Attribute::properties

void Attribute::properties(AttributeProperty* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (properties_ &&  properties_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete properties_;
	if (data)
            properties_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    properties_ = DbTitleRef::nilRef();
    }
    else error("Attribute::properties");
}



//-----------------------------------------------------------------------
// Attribute::attributeIdentity

Integer Attribute::attributeIdentity(void) // get
{
    Integer temp;
    attributeIdentity_.get(theObject, 3, temp);
    return temp;
}


//-----------------------------------------------------------------------
// Attribute::attributeIdentity

void Attribute::attributeIdentity(Integer data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        attributeIdentity_.set(theObject, 3, data);
    }
    else error("Attribute::attributeIdentity");
}

//-----------------------------------------------------------------------
// Attribute::searchattributeIdentity

AttributeIterator* Attribute::searchattributeIdentity(Integer value)
{
    return new AttributeIterator (3, (void*) &value, 4);
}





//-----------------------------------------------------------------------
// Attribute::prepare

DbResultCode Attribute::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (type_ != NULL) {
        DbTitle* title = type_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            type_->prepare(theObject, &temp);  //byt namn
    }
    if (properties_ != NULL) {
        DbTitle* title = properties_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            properties_->prepare(theObject, &temp);  //byt namn
    }
    return DbAbstractObject::prepare();
}


//-----------------------------------------------------------------------
// Attribute::commit

void Attribute::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (type_ != NULL) {
        type_->commit(theObject, 1);
	if (type_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete type_;
	type_ = NULL;
    }
    if (properties_ != NULL) {
        properties_->commit(theObject, 2);
	if (properties_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete properties_;
	properties_ = NULL;
    }
    DbAbstractObject::commit();
}


//-----------------------------------------------------------------------
// Attribute::rollback

void Attribute::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (type_)
	if (type_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete type_;
    type_ = NULL;
    if (properties_)
	if (properties_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete properties_;
    properties_ = NULL;
    DbAbstractObject::rollback();
}


//-----------------------------------------------------------------------
// AttributeIterator::AttributeIterator

AttributeIterator::AttributeIterator()
{
    attrNumber = -1;
    index = -1;
}


//-----------------------------------------------------------------------
// AttributeIterator::AttributeIterator

AttributeIterator::AttributeIterator(AttributeIndex attr, void* value, int length)
{
    attrNumber = attr;
    memcpy(searchValue, value, length);
    index = -1;
}


//-----------------------------------------------------------------------
// AttributeIterator::updateNext

Attribute* AttributeIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Attribute* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(Attribute_CLASS_ID, index, object);
        else 
            result = dbmanager->search(Attribute_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Attribute_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = Attribute::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// AttributeIterator::openrlockNext

Attribute* AttributeIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Attribute* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(Attribute_CLASS_ID, index, object);
        else 
            result = dbmanager->search(Attribute_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Attribute_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = Attribute::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// AttributeIterator::openNext

Attribute* AttributeIterator::openNext(DbResultCode& result, Attribute* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Attribute* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(Attribute_CLASS_ID, index, object);
        else 
           result = dbmanager->search(Attribute_CLASS_ID, attrNumber,
				      index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Attribute_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = Attribute::open(&title, result, OPEN, NULL);
	else
            temp = Attribute::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// AttributeIterator::reset

void AttributeIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ AttributeProperty.cc
//=======================================================================

#include "DOL.hh"
#include "AttributeProperty.hh"


// Include referenced classes:
#include "Value.hh"


//-----------------------------------------------------------------------
// AttributeProperty::create

AttributeProperty* AttributeProperty::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(AttributeProperty_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// AttributeProperty::getClassNo

int AttributeProperty::getClassNo()
{
    return AttributeProperty_CLASS_ID;
}



//-----------------------------------------------------------------------
// AttributeProperty::open

AttributeProperty* AttributeProperty::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (AttributeProperty*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case AttributeProperty_CLASS_ID:
	    return new AttributeProperty (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// AttributeProperty::open

AttributeProperty* AttributeProperty::open(DbTitle *title, DbResultCode& result, AttributeProperty* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN);
        return dol;
    }
}


//-----------------------------------------------------------------------
// AttributeProperty::AttributeProperty

AttributeProperty::AttributeProperty(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    AttributeProperty::init(op);
}


//-----------------------------------------------------------------------
// AttributeProperty::init

void AttributeProperty::init(DBOperation op)
{
    if (op == CREATE) {
    }
    int i = 0;
    initial_ = NULL;
    reset_ = NULL;
}


//-----------------------------------------------------------------------
// AttributeProperty::null

Boolean AttributeProperty::null(void) // get
{
    Boolean temp;
    null_.get(theObject, 1, temp);
    return temp;
}


//-----------------------------------------------------------------------
// AttributeProperty::null

void AttributeProperty::null(Boolean data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        null_.set(theObject, 1, data);
    }
    else error("AttributeProperty::null");
}


//-----------------------------------------------------------------------
// AttributeProperty::updateinitial

Value* AttributeProperty::updateinitial(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (initial_ != NULL)
        title = initial_->getTitle();
    else {
        initial_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return Value::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// AttributeProperty::removeinitial

Value* AttributeProperty::removeinitial(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (initial_ != NULL)
        title = initial_->getTitle();
    else {
        initial_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Value::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// AttributeProperty::openrlockinitial

Value* AttributeProperty::openrlockinitial(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (initial_ != NULL)
        title = initial_->getTitle();
    else {
        initial_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Value::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// AttributeProperty::openinitial

Value* AttributeProperty::openinitial(DbResultCode& result, Value* dol)
{
    DbTitle* title;
    if (initial_ != NULL)
        title = initial_->getTitle();
    else {
        initial_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return Value::open(title, result, OPEN, NULL);
        else
            return Value::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// AttributeProperty::initial

void AttributeProperty::initial(Value* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (initial_ &&  initial_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete initial_;
	if (data)
            initial_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    initial_ = DbTitleRef::nilRef();
    }
    else error("AttributeProperty::initial");
}



//-----------------------------------------------------------------------
// AttributeProperty::updatereset

Value* AttributeProperty::updatereset(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (reset_ != NULL)
        title = reset_->getTitle();
    else {
        reset_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return Value::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// AttributeProperty::removereset

Value* AttributeProperty::removereset(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (reset_ != NULL)
        title = reset_->getTitle();
    else {
        reset_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Value::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// AttributeProperty::openrlockreset

Value* AttributeProperty::openrlockreset(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (reset_ != NULL)
        title = reset_->getTitle();
    else {
        reset_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Value::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// AttributeProperty::openreset

Value* AttributeProperty::openreset(DbResultCode& result, Value* dol)
{
    DbTitle* title;
    if (reset_ != NULL)
        title = reset_->getTitle();
    else {
        reset_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return Value::open(title, result, OPEN, NULL);
        else
            return Value::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// AttributeProperty::reset

void AttributeProperty::reset(Value* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (reset_ &&  reset_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete reset_;
	if (data)
            reset_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    reset_ = DbTitleRef::nilRef();
    }
    else error("AttributeProperty::reset");
}





//-----------------------------------------------------------------------
// AttributeProperty::prepare

DbResultCode AttributeProperty::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (initial_ != NULL) {
        DbTitle* title = initial_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            initial_->prepare(theObject, &temp);  //byt namn
    }
    if (reset_ != NULL) {
        DbTitle* title = reset_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            reset_->prepare(theObject, &temp);  //byt namn
    }
    return DbAbstractObject::prepare();
}


//-----------------------------------------------------------------------
// AttributeProperty::commit

void AttributeProperty::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (initial_ != NULL) {
        initial_->commit(theObject, 2);
	if (initial_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete initial_;
	initial_ = NULL;
    }
    if (reset_ != NULL) {
        reset_->commit(theObject, 3);
	if (reset_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete reset_;
	reset_ = NULL;
    }
    DbAbstractObject::commit();
}


//-----------------------------------------------------------------------
// AttributeProperty::rollback

void AttributeProperty::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (initial_)
	if (initial_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete initial_;
    initial_ = NULL;
    if (reset_)
	if (reset_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete reset_;
    reset_ = NULL;
    DbAbstractObject::rollback();
}







//-- EoF ------------------------------------------------------------
//============ AttributeType.cc
//=======================================================================

#include "DOL.hh"
#include "AttributeType.hh"

// Include subclasses:
#include "ArrayAttributeType.hh"

// Include referenced classes:
#include "DbEntity.hh"


//-----------------------------------------------------------------------
// AttributeType::create

AttributeType* AttributeType::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(AttributeType_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// AttributeType::getClassNo

int AttributeType::getClassNo()
{
    return AttributeType_CLASS_ID;
}



//-----------------------------------------------------------------------
// AttributeType::open

AttributeType* AttributeType::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (AttributeType*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case AttributeType_CLASS_ID:
	    return new AttributeType (object, tempObject, op, trId, title);
	case ArrayAttributeType_CLASS_ID:
	    return (AttributeType*) new ArrayAttributeType (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// AttributeType::open

AttributeType* AttributeType::open(DbTitle *title, DbResultCode& result, AttributeType* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN);
        return dol;
    }
}


//-----------------------------------------------------------------------
// AttributeType::AttributeType

AttributeType::AttributeType(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    AttributeType::init(op);
}


//-----------------------------------------------------------------------
// AttributeType::init

void AttributeType::init(DBOperation op)
{
    if (op == CREATE) {
    }
    int i = 0;
    item_ = NULL;
}


//-----------------------------------------------------------------------
// AttributeType::updateitem

DbEntity* AttributeType::updateitem(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (item_ != NULL)
        title = item_->getTitle();
    else {
        item_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return DbEntity::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// AttributeType::removeitem

DbEntity* AttributeType::removeitem(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (item_ != NULL)
        title = item_->getTitle();
    else {
        item_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return DbEntity::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// AttributeType::openrlockitem

DbEntity* AttributeType::openrlockitem(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (item_ != NULL)
        title = item_->getTitle();
    else {
        item_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return DbEntity::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// AttributeType::openitem

DbEntity* AttributeType::openitem(DbResultCode& result, DbEntity* dol)
{
    DbTitle* title;
    if (item_ != NULL)
        title = item_->getTitle();
    else {
        item_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return DbEntity::open(title, result, OPEN, NULL);
        else
            return DbEntity::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// AttributeType::item

void AttributeType::item(DbEntity* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (item_ &&  item_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete item_;
	if (data)
            item_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    item_ = DbTitleRef::nilRef();
    }
    else error("AttributeType::item");
}





//-----------------------------------------------------------------------
// AttributeType::prepare

DbResultCode AttributeType::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (item_ != NULL) {
        DbTitle* title = item_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            item_->prepare(theObject, &temp);  //byt namn
    }
    return DbAbstractObject::prepare();
}


//-----------------------------------------------------------------------
// AttributeType::commit

void AttributeType::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (item_ != NULL) {
        item_->commit(theObject, 1);
	if (item_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete item_;
	item_ = NULL;
    }
    DbAbstractObject::commit();
}


//-----------------------------------------------------------------------
// AttributeType::rollback

void AttributeType::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (item_)
	if (item_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete item_;
    item_ = NULL;
    DbAbstractObject::rollback();
}







//-- EoF ------------------------------------------------------------
//============ Boolean.cc
//=======================================================================

#include "DOL.hh"
#include "Boolean.hh"


//-----------------------------------------------------------------------
// Boolean::Boolean

Boolean::Boolean(Boolean arg1)
{
    value = arg1;
}

//-----------------------------------------------------------------------
// Boolean::Boolean

Boolean::Boolean()
{}

//-----------------------------------------------------------------------
// Boolean::operator==

Boolean Boolean::operator==(Boolean x)
{
    return memcmp(this, &x, 1) == 0;
}

//-----------------------------------------------------------------------
// Boolean::operator<

Boolean Boolean::operator<(Boolean x)
{
    return memcmp(this, &x, 1) < 0;
}


//-----------------------------------------------------------------------
// BooleanAttribute::get

DbResultCode BooleanAttribute::get(DbBaseObject* dbObject, AttributeIndex index, Boolean& buffer)
{	
    return dbObject->getValue(index, &buffer);
}

//-----------------------------------------------------------------------
// BooleanAttribute::get

DbResultCode BooleanAttribute::get(DbBaseObject* dbObject, AttributeIndex index, Boolean& buffer, int arrayindex)
{	
    return dbObject->getSlice(index, arrayindex*1, 1, &buffer);
}

//-----------------------------------------------------------------------
// BooleanAttribute::set

DbResultCode BooleanAttribute::set(DbBaseObject* dbObject, AttributeIndex index, Boolean buffer)
{	
    return dbObject->putValue(index, &buffer);
}

//-----------------------------------------------------------------------
// BooleanAttribute::set

DbResultCode BooleanAttribute::set(DbBaseObject* dbObject, AttributeIndex index, Boolean buffer, int arrayindex)
{	
    return dbObject->putSlice(index, arrayindex*1, 1, &buffer);
}

//-- EoF ------------------------------------------------------------
//============ BooleanValue.cc
//=======================================================================

#include "DOL.hh"
#include "BooleanValue.hh"




//-----------------------------------------------------------------------
// BooleanValue::create

BooleanValue* BooleanValue::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(BooleanValue_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// BooleanValue::getClassNo

int BooleanValue::getClassNo()
{
    return BooleanValue_CLASS_ID;
}



//-----------------------------------------------------------------------
// BooleanValue::open

BooleanValue* BooleanValue::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (BooleanValue*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case BooleanValue_CLASS_ID:
	    return new BooleanValue (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// BooleanValue::open

BooleanValue* BooleanValue::open(DbTitle *title, DbResultCode& result, BooleanValue* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// BooleanValue::BooleanValue

BooleanValue::BooleanValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    BooleanValue::init(op);
}


//-----------------------------------------------------------------------
// BooleanValue::init

void BooleanValue::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	PrimitiveValue::init(op, initBase);
    if (op == CREATE) {
    }
    int i = 0;
}


//-----------------------------------------------------------------------
// BooleanValue::value

Boolean BooleanValue::value(void) // get
{
    Boolean temp;
    value_.get(theObject, 2, temp);
    return temp;
}


//-----------------------------------------------------------------------
// BooleanValue::value

void BooleanValue::value(Boolean data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        value_.set(theObject, 2, data);
    }
    else error("BooleanValue::value");
}




//-----------------------------------------------------------------------
// BooleanValue::prepare

DbResultCode BooleanValue::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    return PrimitiveValue::prepare();
}


//-----------------------------------------------------------------------
// BooleanValue::commit

void BooleanValue::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    PrimitiveValue::commit();
}


//-----------------------------------------------------------------------
// BooleanValue::rollback

void BooleanValue::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    PrimitiveValue::rollback();
}







//-- EoF ------------------------------------------------------------
//============ Class.cc
//=======================================================================

#include "DOL.hh"
#include "Class.hh"


// Include referenced classes:
#include "keySpecifikation.hh"
#include "ClassAttributes.hh"


//-----------------------------------------------------------------------
// Class::create

Class* Class::create(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Class_CLASS_ID, &key, 32);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// Class::update

Class* Class::update(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Class_CLASS_ID, &key, 32);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// Class::remove

Class* Class::remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Class_CLASS_ID, &key, 32);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// Class::openrlock

Class* Class::openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Class_CLASS_ID, &key, 32);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// Class::open

Class* Class::open(Name key,
	DbResultCode& result,
	Class* dol)
{
    DbTitle title (Class_CLASS_ID, &key, 32);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// Class::getClassNo

int Class::getClassNo()
{
    return Class_CLASS_ID;
}


//-----------------------------------------------------------------------
// Class::getIterator

ClassIterator* Class::getIterator()
{
    return new ClassIterator;
}


//-----------------------------------------------------------------------
// Class::open

Class* Class::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (Class*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case Class_CLASS_ID:
	    return new Class (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// Class::open

Class* Class::open(DbTitle *title, DbResultCode& result, Class* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// Class::Class

Class::Class(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    Class::init(op);
}


//-----------------------------------------------------------------------
// Class::init

void Class::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	DbObject::init(op, initBase);
    if (op == CREATE) {
    }
    int i = 0;
    primaryKey_ = NULL;
    base_ = NULL;
    attributes_ = NULL;
}


//-----------------------------------------------------------------------
// Class::updateprimaryKey

keySpecifikation* Class::updateprimaryKey(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (primaryKey_ != NULL)
        title = primaryKey_->getTitle();
    else {
        primaryKey_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return keySpecifikation::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Class::removeprimaryKey

keySpecifikation* Class::removeprimaryKey(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (primaryKey_ != NULL)
        title = primaryKey_->getTitle();
    else {
        primaryKey_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return keySpecifikation::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Class::openrlockprimaryKey

keySpecifikation* Class::openrlockprimaryKey(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (primaryKey_ != NULL)
        title = primaryKey_->getTitle();
    else {
        primaryKey_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return keySpecifikation::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// Class::openprimaryKey

keySpecifikation* Class::openprimaryKey(DbResultCode& result, keySpecifikation* dol)
{
    DbTitle* title;
    if (primaryKey_ != NULL)
        title = primaryKey_->getTitle();
    else {
        primaryKey_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return keySpecifikation::open(title, result, OPEN, NULL);
        else
            return keySpecifikation::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Class::primaryKey

void Class::primaryKey(keySpecifikation* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (primaryKey_ &&  primaryKey_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete primaryKey_;
	if (data)
            primaryKey_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    primaryKey_ = DbTitleRef::nilRef();
    }
    else error("Class::primaryKey");
}



//-----------------------------------------------------------------------
// Class::allocate

Boolean Class::allocate(void) // get
{
    Boolean temp;
    allocate_.get(theObject, 3, temp);
    return temp;
}


//-----------------------------------------------------------------------
// Class::allocate

void Class::allocate(Boolean data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        allocate_.set(theObject, 3, data);
    }
    else error("Class::allocate");
}

//-----------------------------------------------------------------------
// Class::searchallocate

ClassIterator* Class::searchallocate(Boolean value)
{
    return new ClassIterator (3, (void*) &value, 1);
}



//-----------------------------------------------------------------------
// Class::updatebase

Class* Class::updatebase(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (base_ != NULL)
        title = base_->getTitle();
    else {
        base_->get(theObject, 4, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return Class::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Class::removebase

Class* Class::removebase(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (base_ != NULL)
        title = base_->getTitle();
    else {
        base_->get(theObject, 4, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Class::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Class::openrlockbase

Class* Class::openrlockbase(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (base_ != NULL)
        title = base_->getTitle();
    else {
        base_->get(theObject, 4, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Class::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// Class::openbase

Class* Class::openbase(DbResultCode& result, Class* dol)
{
    DbTitle* title;
    if (base_ != NULL)
        title = base_->getTitle();
    else {
        base_->get(theObject, 4, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return Class::open(title, result, OPEN, NULL);
        else
            return Class::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Class::base

void Class::base(Class* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (base_ &&  base_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete base_;
	if (data)
            base_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    base_ = DbTitleRef::nilRef();
    }
    else error("Class::base");
}



//-----------------------------------------------------------------------
// Class::createattributes

ClassAttributes* Class::createattributes(DbResultCode& result)

{
   if (operation != CREATE && operation != UPDATE) {
	result = FAILED;
	return NULL;
   }
   return attributes_ = new ClassAttributes (ClassAttributes_CLASS_ID, this, result);
}

//-----------------------------------------------------------------------
// Class::openattributes

ClassAttributes* Class::openattributes(DbResultCode& result)
{
   if (attributes_ != NULL) {
      result = SUCCEEDED;
      return attributes_;
   }
   else {
      char* buf = new char[2*sizeof(int)];
      theObject->getValue(5, buf);
      LocalReferense* ref = (LocalReferense*) buf;
      if (ref->clid == 0 && ref->lid == 0) {    // 4f - Nil reference
	 result = OBJECT_NOT_FOUND;
         return NULL;   	
      }
      DbTitle* title = new DbTitle(-1, -1, ref->clid, ref->lid);
      return attributes_ = new ClassAttributes (title, operation, this, result);
   }
}







//-----------------------------------------------------------------------
// Class::prepare

DbResultCode Class::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (primaryKey_ != NULL) {
        DbTitle* title = primaryKey_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            primaryKey_->prepare(theObject, &temp);  //byt namn
    }
    if (base_ != NULL) {
        DbTitle* title = base_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            base_->prepare(theObject, &temp);  //byt namn
    }
    if (attributes_ != NULL) {
        result = attributes_->prepare();
        if (result != SUCCEEDED)
            return result;
    }   
    return DbObject::prepare();
}


//-----------------------------------------------------------------------
// Class::commit

void Class::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (primaryKey_ != NULL) {
        primaryKey_->commit(theObject, 2);
	if (primaryKey_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete primaryKey_;
	primaryKey_ = NULL;
    }
    if (base_ != NULL) {
        base_->commit(theObject, 4);
	if (base_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete base_;
	base_ = NULL;
    }
    if (attributes_ != NULL) {
        title = attributes_->commitSubObject();
        if (title != NULL)
            theObject->putValue(5, title);
    }
    attributes_ = NULL;
    DbObject::commit();
}


//-----------------------------------------------------------------------
// Class::rollback

void Class::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (primaryKey_)
	if (primaryKey_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete primaryKey_;
    primaryKey_ = NULL;
    if (base_)
	if (base_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete base_;
    base_ = NULL;
    if (attributes_ != NULL)
        attributes_->rollbackSubObject();
    attributes_ = NULL;
    DbObject::rollback();
}


//-----------------------------------------------------------------------
// ClassIterator::ClassIterator

ClassIterator::ClassIterator()
{
    attrNumber = -1;
    index = -1;
}


//-----------------------------------------------------------------------
// ClassIterator::ClassIterator

ClassIterator::ClassIterator(AttributeIndex attr, void* value, int length)
{
    attrNumber = attr;
    memcpy(searchValue, value, length);
    index = -1;
}


//-----------------------------------------------------------------------
// ClassIterator::updateNext

Class* ClassIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Class* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(Class_CLASS_ID, index, object);
        else 
            result = dbmanager->search(Class_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Class_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = Class::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// ClassIterator::openrlockNext

Class* ClassIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Class* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(Class_CLASS_ID, index, object);
        else 
            result = dbmanager->search(Class_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Class_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = Class::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// ClassIterator::openNext

Class* ClassIterator::openNext(DbResultCode& result, Class* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Class* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(Class_CLASS_ID, index, object);
        else 
           result = dbmanager->search(Class_CLASS_ID, attrNumber,
				      index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Class_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = Class::open(&title, result, OPEN, NULL);
	else
            temp = Class::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// ClassIterator::reset

void ClassIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ ClassAttributes.cc
//=======================================================================

#include "DOL.hh"
#include "ClassAttributes.hh"
#include "Class.hh"




//-----------------------------------------------------------------------
// ClassAttributes::ClassAttributes

ClassAttributes::ClassAttributes(DbTitle* title, DBOperation op, Class* mainObject, DbResultCode& result)
    : (title, op, result, mainObject->get_Transaction()) 
{
    main_Object = mainObject;
}


//-----------------------------------------------------------------------
// ClassAttributes::ClassAttributes

ClassAttributes::ClassAttributes(ClassIdentity classIdentity, Class* mainObject, DbResultCode& result)
    : (classIdentity, result, mainObject->get_Transaction())
{
    main_Object = mainObject;
}


//-----------------------------------------------------------------------
// ClassAttributes::add

void ClassAttributes::add(Attribute* dol)
{
    if (operation == UPDATE || operation == CREATE) {
        switch (dol->getTitle()->getClassIdentity()) {
        case Attribute_CLASS_ID:
	    addElement(dol->getTitle());
	    break;
        default:
	    error("ClassAttributes::add : 2");
        }
    }
    else error("ClassAttributes::add : 3");
}


//-----------------------------------------------------------------------
// ClassAttributes::sub

void ClassAttributes::sub(Attribute* dol)
{
    if (operation == UPDATE || operation == CREATE) {
        switch (dol->getTitle()->getClassIdentity()) {
        case Attribute_CLASS_ID:
	    removeElement(dol->getTitle());
	    break;
        default:
	    error("ClassAttributes::sub");
        }
    }
    else error("ClassAttributes::sub");
}



//-----------------------------------------------------------------------
// ClassAttributes::updateNext

Attribute* ClassAttributes::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbSetAbstractObject::iterate();
    if (title)
    	return Attribute::open(title, result, UPDATE, trId);
    else {
	result = END_OF_SET;
 	return NULL;
    }
}


//-----------------------------------------------------------------------
// ClassAttributes::openrlockNext

Attribute* ClassAttributes::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbSetAbstractObject::iterate();
    if (title)
    	return Attribute::open(title, result, OPENRLOCK, trId);
    else {
	result = END_OF_SET;
 	return NULL;
    }
}


//-----------------------------------------------------------------------
// ClassAttributes::openNext

Attribute* ClassAttributes::openNext(DbResultCode& result, Attribute* dol)
{
    DbTitle* title = DbSetAbstractObject::iterate();
    if (title) {
	if (dol == NULL)
	    return Attribute::open(title, result, OPEN, NULL);
	else
	    return Attribute::open(title, result, dol);
    }
    else {
        result = END_OF_SET;
 	return NULL;
    }
}


//-----------------------------------------------------------------------
// ClassAttributes::isMember

Boolean ClassAttributes::isMember(Attribute* dol)
{
    return DbSetAbstractObject::isMember(dol->getTitle());
}






//-----------------------------------------------------------------------
// ClassAttributes::prepare

DbResultCode ClassAttributes::prepare()
{
    CLID clid;
    LID lid;
    DbAbstractObject* temp;
    DbResultCode result;
    for (int i = 0; i<insertCounter; ++i) {
        temp = new DbAbstractObject (addList[i], OPEN, result);
        if (result == SUCCEEDED) {
            temp->getClidLid(clid, lid);
            addList[i]->putClidLid(clid, lid);
	}
        delete temp;
    }
    for (int j = 0; j < deleteCounter; ++j) {
        temp = new DbAbstractObject (deleteList[j],OPEN,result);
        if (result == SUCCEEDED) {
            temp->getClidLid(clid,lid);
            deleteList[j]->putClidLid(clid,lid);
	}
        delete temp;
    }
    return SUCCEEDED;
}


//-----------------------------------------------------------------------
// ClassAttributes::rollbackSubObject

void ClassAttributes::rollbackSubObject()
{
    for (int i = 0; i<insertCounter; ++i)
        addList[i]= 0;
    for (int j = 0; j<deleteCounter; ++j)
        deleteList[j] = 0;
    insertCounter = deleteCounter = 0;
    LocalTransItem::rollbackSubObject(operation, theObject, uo_object);
}

//-- EoF ------------------------------------------------------------
#include "DOL.hh"

//=======================================================================
// Database initialisations
void DB_init(void)
{
    DbmGeneral::init();
    DataBaseManager* dbmanager = getDbManager_t();
    install_t(dbmanager, DbEntity_CLASS_ID, "DbEntity.dbLoad");
    install_t(dbmanager, DbObject_CLASS_ID, "DbObject.dbLoad");
    install_t(dbmanager, Class_CLASS_ID, "Class.dbLoad");
    install_t(dbmanager, keySpecifikation_CLASS_ID, "keySpecifikation.dbLoad");
    install_t(dbmanager, Attribute_CLASS_ID, "Attribute.dbLoad");
    install_t(dbmanager, AttributeType_CLASS_ID, "AttributeType.dbLoad");
    install_t(dbmanager, ArrayAttributeType_CLASS_ID, "ArrayAttributeType.dbLoad");
    install_t(dbmanager, AttributeProperty_CLASS_ID, "AttributeProperty.dbLoad");
    install_t(dbmanager, Value_CLASS_ID, "Value.dbLoad");
    install_t(dbmanager, PrimitiveValue_CLASS_ID, "PrimitiveValue.dbLoad");
    install_t(dbmanager, IntegerValue_CLASS_ID, "IntegerValue.dbLoad");
    install_t(dbmanager, FloatValue_CLASS_ID, "FloatValue.dbLoad");
    install_t(dbmanager, BooleanValue_CLASS_ID, "BooleanValue.dbLoad");
    install_t(dbmanager, StringValue_CLASS_ID, "StringValue.dbLoad");
    install_t(dbmanager, NilValue_CLASS_ID, "NilValue.dbLoad");
    install_t(dbmanager, StructureValue_CLASS_ID, "StructureValue.dbLoad");
    install_t(dbmanager, Relation_CLASS_ID, "Relation.dbLoad");
    install_t(dbmanager, Structure_CLASS_ID, "Structure.dbLoad");
    install_t(dbmanager, PersistentStructure_CLASS_ID, "PersistentStructure.dbLoad");
    install_t(dbmanager, DynamicStructure_CLASS_ID, "DynamicStructure.dbLoad");
    install_t(dbmanager, Element_CLASS_ID, "Element.dbLoad");
    install_t(dbmanager, PersistentElement_CLASS_ID, "PersistentElement.dbLoad");
    install_t(dbmanager, PredefinedType_CLASS_ID, "PredefinedType.dbLoad");
    install_t(dbmanager, VolatileElement_CLASS_ID, "VolatileElement.dbLoad");
    install_t(dbmanager, DynamicString_CLASS_ID, "DynamicString.dbLoad");
    install_t(dbmanager, ClassAttributes_CLASS_ID, "ClassAttributes.dbLoad");
} 

//=======================================================================
// error() : Temporary solution. Will be replaced by exceptions.
void error(char* str)
{
cout << "error: " << str << "\n";
exit(1);
}

//-- EoF ------------------------------------------------------------

//============ DbEntity.cc
//=======================================================================

#include "DOL.hh"
#include "DbEntity.hh"

// Include subclasses:
#include "DbObject.hh"
#include "Class.hh"
#include "Relation.hh"
#include "Structure.hh"
#include "PersistentStructure.hh"
#include "DynamicStructure.hh"

// Include referenced classes:
#include "DynamicString.hh"


//-----------------------------------------------------------------------
// DbEntity::create

DbEntity* DbEntity::create(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DbEntity_CLASS_ID, &key, 32);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// DbEntity::update

DbEntity* DbEntity::update(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DbEntity_CLASS_ID, &key, 32);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// DbEntity::remove

DbEntity* DbEntity::remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DbEntity_CLASS_ID, &key, 32);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// DbEntity::openrlock

DbEntity* DbEntity::openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DbEntity_CLASS_ID, &key, 32);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// DbEntity::open

DbEntity* DbEntity::open(Name key,
	DbResultCode& result,
	DbEntity* dol)
{
    DbTitle title (DbEntity_CLASS_ID, &key, 32);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// DbEntity::getClassNo

int DbEntity::getClassNo()
{
    return DbEntity_CLASS_ID;
}


//-----------------------------------------------------------------------
// DbEntity::getIterator

DbEntityIterator* DbEntity::getIterator()
{
    return new DbEntityIterator;
}


//-----------------------------------------------------------------------
// DbEntity::open

DbEntity* DbEntity::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (DbEntity*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case DbEntity_CLASS_ID:
	    return new DbEntity (object, tempObject, op, trId, title);
	case DbObject_CLASS_ID:
	    return (DbEntity*) new DbObject (object, tempObject, op, trId, title);
	case Class_CLASS_ID:
	    return (DbEntity*) new Class (object, tempObject, op, trId, title);
	case Relation_CLASS_ID:
	    return (DbEntity*) new Relation (object, tempObject, op, trId, title);
	case Structure_CLASS_ID:
	    return (DbEntity*) new Structure (object, tempObject, op, trId, title);
	case PersistentStructure_CLASS_ID:
	    return (DbEntity*) new PersistentStructure (object, tempObject, op, trId, title);
	case DynamicStructure_CLASS_ID:
	    return (DbEntity*) new DynamicStructure (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// DbEntity::open

DbEntity* DbEntity::open(DbTitle *title, DbResultCode& result, DbEntity* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN);
        return dol;
    }
}


//-----------------------------------------------------------------------
// DbEntity::DbEntity

DbEntity::DbEntity(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    DbEntity::init(op);
}


//-----------------------------------------------------------------------
// DbEntity::init

void DbEntity::init(DBOperation op)
{
    if (op == CREATE) {
    }
    int i = 0;
    version_ = NULL;
}


//-----------------------------------------------------------------------
// DbEntity::name

Name DbEntity::name(void) // get
{
    Name temp;
    name_.get(theObject, 0, temp);
    return temp;
}


//-----------------------------------------------------------------------
// DbEntity::searchname

DbEntityIterator* DbEntity::searchname(Name value)
{
    return new DbEntityIterator (0, (void*) &value, 32);
}



//-----------------------------------------------------------------------
// DbEntity::updateversion

DynamicString* DbEntity::updateversion(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (version_ != NULL)
        title = version_->getTitle();
    else {
        version_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return DynamicString::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// DbEntity::removeversion

DynamicString* DbEntity::removeversion(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (version_ != NULL)
        title = version_->getTitle();
    else {
        version_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return DynamicString::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// DbEntity::openrlockversion

DynamicString* DbEntity::openrlockversion(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (version_ != NULL)
        title = version_->getTitle();
    else {
        version_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return DynamicString::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// DbEntity::openversion

DynamicString* DbEntity::openversion(DbResultCode& result, DynamicString* dol)
{
    DbTitle* title;
    if (version_ != NULL)
        title = version_->getTitle();
    else {
        version_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return DynamicString::open(title, result, OPEN, NULL);
        else
            return DynamicString::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// DbEntity::version

void DbEntity::version(DynamicString* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (version_ &&  version_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete version_;
	if (data)
            version_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    version_ = DbTitleRef::nilRef();
    }
    else error("DbEntity::version");
}





//-----------------------------------------------------------------------
// DbEntity::prepare

DbResultCode DbEntity::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (version_ != NULL) {
        DbTitle* title = version_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            version_->prepare(theObject, &temp);  //byt namn
    }
    return DbAbstractObject::prepare();
}


//-----------------------------------------------------------------------
// DbEntity::commit

void DbEntity::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (version_ != NULL) {
        version_->commit(theObject, 1);
	if (version_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete version_;
	version_ = NULL;
    }
    DbAbstractObject::commit();
}


//-----------------------------------------------------------------------
// DbEntity::rollback

void DbEntity::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (version_)
	if (version_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete version_;
    version_ = NULL;
    DbAbstractObject::rollback();
}


//-----------------------------------------------------------------------
// DbEntityIterator::DbEntityIterator

DbEntityIterator::DbEntityIterator()
{
    attrNumber = -1;
    index = -1;
}


//-----------------------------------------------------------------------
// DbEntityIterator::DbEntityIterator

DbEntityIterator::DbEntityIterator(AttributeIndex attr, void* value, int length)
{
    attrNumber = attr;
    memcpy(searchValue, value, length);
    index = -1;
}


//-----------------------------------------------------------------------
// DbEntityIterator::updateNext

DbEntity* DbEntityIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    DbEntity* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(DbEntity_CLASS_ID, index, object);
        else 
            result = dbmanager->search(DbEntity_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (DbEntity_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = DbEntity::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// DbEntityIterator::openrlockNext

DbEntity* DbEntityIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    DbEntity* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(DbEntity_CLASS_ID, index, object);
        else 
            result = dbmanager->search(DbEntity_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (DbEntity_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = DbEntity::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// DbEntityIterator::openNext

DbEntity* DbEntityIterator::openNext(DbResultCode& result, DbEntity* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    DbEntity* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(DbEntity_CLASS_ID, index, object);
        else 
           result = dbmanager->search(DbEntity_CLASS_ID, attrNumber,
				      index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (DbEntity_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = DbEntity::open(&title, result, OPEN, NULL);
	else
            temp = DbEntity::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// DbEntityIterator::reset

void DbEntityIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ DbObject.cc
//=======================================================================

#include "DOL.hh"
#include "DbObject.hh"

// Include subclasses:
#include "Class.hh"
#include "Relation.hh"



//-----------------------------------------------------------------------
// DbObject::create

DbObject* DbObject::create(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DbObject_CLASS_ID, &key, 32);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// DbObject::update

DbObject* DbObject::update(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DbObject_CLASS_ID, &key, 32);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// DbObject::remove

DbObject* DbObject::remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DbObject_CLASS_ID, &key, 32);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// DbObject::openrlock

DbObject* DbObject::openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DbObject_CLASS_ID, &key, 32);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// DbObject::open

DbObject* DbObject::open(Name key,
	DbResultCode& result,
	DbObject* dol)
{
    DbTitle title (DbObject_CLASS_ID, &key, 32);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// DbObject::getClassNo

int DbObject::getClassNo()
{
    return DbObject_CLASS_ID;
}


//-----------------------------------------------------------------------
// DbObject::getIterator

DbObjectIterator* DbObject::getIterator()
{
    return new DbObjectIterator;
}


//-----------------------------------------------------------------------
// DbObject::open

DbObject* DbObject::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (DbObject*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case DbObject_CLASS_ID:
	    return new DbObject (object, tempObject, op, trId, title);
	case Class_CLASS_ID:
	    return (DbObject*) new Class (object, tempObject, op, trId, title);
	case Relation_CLASS_ID:
	    return (DbObject*) new Relation (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// DbObject::open

DbObject* DbObject::open(DbTitle *title, DbResultCode& result, DbObject* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// DbObject::DbObject

DbObject::DbObject(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    DbObject::init(op);
}


//-----------------------------------------------------------------------
// DbObject::init

void DbObject::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	DbEntity::init(op);
    if (op == CREATE) {
    }
    int i = 0;
}




//-----------------------------------------------------------------------
// DbObject::prepare

DbResultCode DbObject::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    return DbEntity::prepare();
}


//-----------------------------------------------------------------------
// DbObject::commit

void DbObject::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    DbEntity::commit();
}


//-----------------------------------------------------------------------
// DbObject::rollback

void DbObject::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    DbEntity::rollback();
}


//-----------------------------------------------------------------------
// DbObjectIterator::DbObjectIterator

DbObjectIterator::DbObjectIterator()
{
    attrNumber = -1;
    index = -1;
}



//-----------------------------------------------------------------------
// DbObjectIterator::updateNext

DbObject* DbObjectIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    DbObject* temp;
    while (TRUE) {
        result = dbmanager->iterate(DbObject_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (DbObject_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = DbObject::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// DbObjectIterator::openrlockNext

DbObject* DbObjectIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    DbObject* temp;
    while (TRUE) {
        result = dbmanager->iterate(DbObject_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (DbObject_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = DbObject::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// DbObjectIterator::openNext

DbObject* DbObjectIterator::openNext(DbResultCode& result, DbObject* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    DbObject* temp;
    while (TRUE) {
        result = dbmanager->iterate(DbObject_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (DbObject_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = DbObject::open(&title, result, OPEN, NULL);
	else
            temp = DbObject::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// DbObjectIterator::reset

void DbObjectIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ DynString.cc
//=======================================================================

#include "DOL.hh"
#include "DynString.hh"


//-----------------------------------------------------------------------
// DynString::DynString

DynString::DynString(Boolean arg1,Integer_16 arg2,char *arg3)
{
    full = arg1;
    length = arg2;
    memset(buffer, 0, 200);
    strcpy(buffer, arg3);
}

//-----------------------------------------------------------------------
// DynString::DynString

DynString::DynString()
{}

//-----------------------------------------------------------------------
// DynString::operator==

Boolean DynString::operator==(DynString x)
{
    return memcmp(this, &x, 203) == 0;
}

//-----------------------------------------------------------------------
// DynString::operator<

Boolean DynString::operator<(DynString x)
{
    return memcmp(this, &x, 203) < 0;
}


//-----------------------------------------------------------------------
// DynStringAttribute::get

DbResultCode DynStringAttribute::get(DbBaseObject* dbObject, AttributeIndex index, DynString& buffer)
{	
    return dbObject->getValue(index, &buffer);
}

//-----------------------------------------------------------------------
// DynStringAttribute::get

DbResultCode DynStringAttribute::get(DbBaseObject* dbObject, AttributeIndex index, DynString& buffer, int arrayindex)
{	
    return dbObject->getSlice(index, arrayindex*203, 203, &buffer);
}

//-----------------------------------------------------------------------
// DynStringAttribute::set

DbResultCode DynStringAttribute::set(DbBaseObject* dbObject, AttributeIndex index, DynString buffer)
{	
    return dbObject->putValue(index, &buffer);
}

//-----------------------------------------------------------------------
// DynStringAttribute::set

DbResultCode DynStringAttribute::set(DbBaseObject* dbObject, AttributeIndex index, DynString buffer, int arrayindex)
{	
    return dbObject->putSlice(index, arrayindex*203, 203, &buffer);
}

//-- EoF ------------------------------------------------------------
//============ DynamicString.cc
//=======================================================================

#include "DOL.hh"
#include "DynamicString.hh"


// Include referenced classes:


//-----------------------------------------------------------------------
// DynamicString::create

DynamicString* DynamicString::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(DynamicString_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// DynamicString::getClassNo

int DynamicString::getClassNo()
{
    return DynamicString_CLASS_ID;
}



//-----------------------------------------------------------------------
// DynamicString::open

DynamicString* DynamicString::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (DynamicString*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case DynamicString_CLASS_ID:
	    return new DynamicString (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// DynamicString::open

DynamicString* DynamicString::open(DbTitle *title, DbResultCode& result, DynamicString* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN);
        return dol;
    }
}


//-----------------------------------------------------------------------
// DynamicString::DynamicString

DynamicString::DynamicString(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    DynamicString::init(op);
}


//-----------------------------------------------------------------------
// DynamicString::init

void DynamicString::init(DBOperation op)
{
    if (op == CREATE) {
        // next_ = DbTitleRef::nilRef();    // 4f - Nil reference
    }
    int i = 0;
    next_ = NULL;
}


//-----------------------------------------------------------------------
// DynamicString::string

DynString DynamicString::string(void) // get
{
    DynString temp;
    string_.get(theObject, 1, temp);
    return temp;
}


//-----------------------------------------------------------------------
// DynamicString::string

void DynamicString::string(DynString data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        string_.set(theObject, 1, data);
    }
    else error("DynamicString::string");
}


//-----------------------------------------------------------------------
// DynamicString::updatenext

DynamicString* DynamicString::updatenext(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return DynamicString::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// DynamicString::removenext

DynamicString* DynamicString::removenext(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return DynamicString::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// DynamicString::openrlocknext

DynamicString* DynamicString::openrlocknext(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return DynamicString::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// DynamicString::opennext

DynamicString* DynamicString::opennext(DbResultCode& result, DynamicString* dol)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return DynamicString::open(title, result, OPEN, NULL);
        else
            return DynamicString::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// DynamicString::next

void DynamicString::next(DynamicString* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (next_ &&  next_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete next_;
	if (data)
            next_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    next_ = DbTitleRef::nilRef();
    }
    else error("DynamicString::next");
}





//-----------------------------------------------------------------------
// DynamicString::prepare

DbResultCode DynamicString::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (next_ != NULL) {
        DbTitle* title = next_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            next_->prepare(theObject, &temp);  //byt namn
    }
    return DbAbstractObject::prepare();
}


//-----------------------------------------------------------------------
// DynamicString::commit

void DynamicString::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (next_ != NULL) {
        next_->commit(theObject, 2);
	if (next_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete next_;
	next_ = NULL;
    }
    DbAbstractObject::commit();
}


//-----------------------------------------------------------------------
// DynamicString::rollback

void DynamicString::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (next_)
	if (next_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete next_;
    next_ = NULL;
    DbAbstractObject::rollback();
}







//-- EoF ------------------------------------------------------------

//============ DynamicStructure.cc
//=======================================================================

#include "DOL.hh"
#include "DynamicStructure.hh"


// Include referenced classes:
#include "PersistentElement.hh"


//-----------------------------------------------------------------------
// DynamicStructure::create

DynamicStructure* DynamicStructure::create(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DynamicStructure_CLASS_ID, &key, 32);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// DynamicStructure::update

DynamicStructure* DynamicStructure::update(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DynamicStructure_CLASS_ID, &key, 32);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// DynamicStructure::remove

DynamicStructure* DynamicStructure::remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DynamicStructure_CLASS_ID, &key, 32);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// DynamicStructure::openrlock

DynamicStructure* DynamicStructure::openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (DynamicStructure_CLASS_ID, &key, 32);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// DynamicStructure::open

DynamicStructure* DynamicStructure::open(Name key,
	DbResultCode& result,
	DynamicStructure* dol)
{
    DbTitle title (DynamicStructure_CLASS_ID, &key, 32);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// DynamicStructure::getClassNo

int DynamicStructure::getClassNo()
{
    return DynamicStructure_CLASS_ID;
}


//-----------------------------------------------------------------------
// DynamicStructure::getIterator

DynamicStructureIterator* DynamicStructure::getIterator()
{
    return new DynamicStructureIterator;
}


//-----------------------------------------------------------------------
// DynamicStructure::open

DynamicStructure* DynamicStructure::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (DynamicStructure*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case DynamicStructure_CLASS_ID:
	    return new DynamicStructure (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// DynamicStructure::open

DynamicStructure* DynamicStructure::open(DbTitle *title, DbResultCode& result, DynamicStructure* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// DynamicStructure::DynamicStructure

DynamicStructure::DynamicStructure(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    DynamicStructure::init(op);
}


//-----------------------------------------------------------------------
// DynamicStructure::init

void DynamicStructure::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	Structure::init(op, initBase);
    if (op == CREATE) {
    }
    int i = 0;
    dynamic_ = NULL;
}


//-----------------------------------------------------------------------
// DynamicStructure::updatedynamic

PersistentElement* DynamicStructure::updatedynamic(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (dynamic_ != NULL)
        title = dynamic_->getTitle();
    else {
        dynamic_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return PersistentElement::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// DynamicStructure::removedynamic

PersistentElement* DynamicStructure::removedynamic(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (dynamic_ != NULL)
        title = dynamic_->getTitle();
    else {
        dynamic_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return PersistentElement::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// DynamicStructure::openrlockdynamic

PersistentElement* DynamicStructure::openrlockdynamic(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (dynamic_ != NULL)
        title = dynamic_->getTitle();
    else {
        dynamic_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return PersistentElement::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// DynamicStructure::opendynamic

PersistentElement* DynamicStructure::opendynamic(DbResultCode& result, PersistentElement* dol)
{
    DbTitle* title;
    if (dynamic_ != NULL)
        title = dynamic_->getTitle();
    else {
        dynamic_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return PersistentElement::open(title, result, OPEN, NULL);
        else
            return PersistentElement::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// DynamicStructure::dynamic

void DynamicStructure::dynamic(PersistentElement* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (dynamic_ &&  dynamic_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete dynamic_;
	if (data)
            dynamic_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    dynamic_ = DbTitleRef::nilRef();
    }
    else error("DynamicStructure::dynamic");
}





//-----------------------------------------------------------------------
// DynamicStructure::prepare

DbResultCode DynamicStructure::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (dynamic_ != NULL) {
        DbTitle* title = dynamic_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            dynamic_->prepare(theObject, &temp);  //byt namn
    }
    return Structure::prepare();
}


//-----------------------------------------------------------------------
// DynamicStructure::commit

void DynamicStructure::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (dynamic_ != NULL) {
        dynamic_->commit(theObject, 3);
	if (dynamic_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete dynamic_;
	dynamic_ = NULL;
    }
    Structure::commit();
}


//-----------------------------------------------------------------------
// DynamicStructure::rollback

void DynamicStructure::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (dynamic_)
	if (dynamic_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete dynamic_;
    dynamic_ = NULL;
    Structure::rollback();
}


//-----------------------------------------------------------------------
// DynamicStructureIterator::DynamicStructureIterator

DynamicStructureIterator::DynamicStructureIterator()
{
    attrNumber = -1;
    index = -1;
}



//-----------------------------------------------------------------------
// DynamicStructureIterator::updateNext

DynamicStructure* DynamicStructureIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    DynamicStructure* temp;
    while (TRUE) {
        result = dbmanager->iterate(DynamicStructure_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (DynamicStructure_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = DynamicStructure::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// DynamicStructureIterator::openrlockNext

DynamicStructure* DynamicStructureIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    DynamicStructure* temp;
    while (TRUE) {
        result = dbmanager->iterate(DynamicStructure_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (DynamicStructure_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = DynamicStructure::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// DynamicStructureIterator::openNext

DynamicStructure* DynamicStructureIterator::openNext(DbResultCode& result, DynamicStructure* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    DynamicStructure* temp;
    while (TRUE) {
        result = dbmanager->iterate(DynamicStructure_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (DynamicStructure_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = DynamicStructure::open(&title, result, OPEN, NULL);
	else
            temp = DynamicStructure::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// DynamicStructureIterator::reset

void DynamicStructureIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ Element.cc
//=======================================================================

#include "DOL.hh"
#include "Element.hh"

// Include subclasses:
#include "PersistentElement.hh"
#include "VolatileElement.hh"

// Include referenced classes:


//-----------------------------------------------------------------------
// Element::create

Element* Element::create(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Element_CLASS_ID, &key, 64);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// Element::update

Element* Element::update(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Element_CLASS_ID, &key, 64);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// Element::remove

Element* Element::remove(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Element_CLASS_ID, &key, 64);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// Element::openrlock

Element* Element::openrlock(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Element_CLASS_ID, &key, 64);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// Element::open

Element* Element::open(UniqueName key,
	DbResultCode& result,
	Element* dol)
{
    DbTitle title (Element_CLASS_ID, &key, 64);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// Element::getClassNo

int Element::getClassNo()
{
    return Element_CLASS_ID;
}


//-----------------------------------------------------------------------
// Element::getIterator

ElementIterator* Element::getIterator()
{
    return new ElementIterator;
}


//-----------------------------------------------------------------------
// Element::open

Element* Element::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (Element*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case Element_CLASS_ID:
	    return new Element (object, tempObject, op, trId, title);
	case PersistentElement_CLASS_ID:
	    return (Element*) new PersistentElement (object, tempObject, op, trId, title);
	case VolatileElement_CLASS_ID:
	    return (Element*) new VolatileElement (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// Element::open

Element* Element::open(DbTitle *title, DbResultCode& result, Element* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN);
        return dol;
    }
}


//-----------------------------------------------------------------------
// Element::Element

Element::Element(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    Element::init(op);
}


//-----------------------------------------------------------------------
// Element::init

void Element::init(DBOperation op)
{
    if (op == CREATE) {
        // next_ = DbTitleRef::nilRef();    // 4f - Nil reference
    }
    int i = 0;
    next_ = NULL;
}


//-----------------------------------------------------------------------
// Element::name

UniqueName Element::name(void) // get
{
    UniqueName temp;
    name_.get(theObject, 0, temp);
    return temp;
}


//-----------------------------------------------------------------------
// Element::searchname

ElementIterator* Element::searchname(UniqueName value)
{
    return new ElementIterator (0, (void*) &value, 64);
}



//-----------------------------------------------------------------------
// Element::updatenext

Element* Element::updatenext(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return Element::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Element::removenext

Element* Element::removenext(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Element::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Element::openrlocknext

Element* Element::openrlocknext(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Element::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// Element::opennext

Element* Element::opennext(DbResultCode& result, Element* dol)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return Element::open(title, result, OPEN, NULL);
        else
            return Element::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Element::next

void Element::next(Element* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (next_ &&  next_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete next_;
	if (data)
            next_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    next_ = DbTitleRef::nilRef();
    }
    else error("Element::next");
}





//-----------------------------------------------------------------------
// Element::prepare

DbResultCode Element::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (next_ != NULL) {
        DbTitle* title = next_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            next_->prepare(theObject, &temp);  //byt namn
    }
    return DbAbstractObject::prepare();
}


//-----------------------------------------------------------------------
// Element::commit

void Element::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (next_ != NULL) {
        next_->commit(theObject, 1);
	if (next_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete next_;
	next_ = NULL;
    }
    DbAbstractObject::commit();
}


//-----------------------------------------------------------------------
// Element::rollback

void Element::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (next_)
	if (next_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete next_;
    next_ = NULL;
    DbAbstractObject::rollback();
}


//-----------------------------------------------------------------------
// ElementIterator::ElementIterator

ElementIterator::ElementIterator()
{
    attrNumber = -1;
    index = -1;
}


//-----------------------------------------------------------------------
// ElementIterator::ElementIterator

ElementIterator::ElementIterator(AttributeIndex attr, void* value, int length)
{
    attrNumber = attr;
    memcpy(searchValue, value, length);
    index = -1;
}


//-----------------------------------------------------------------------
// ElementIterator::updateNext

Element* ElementIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Element* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(Element_CLASS_ID, index, object);
        else 
            result = dbmanager->search(Element_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Element_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = Element::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// ElementIterator::openrlockNext

Element* ElementIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Element* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(Element_CLASS_ID, index, object);
        else 
            result = dbmanager->search(Element_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Element_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = Element::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// ElementIterator::openNext

Element* ElementIterator::openNext(DbResultCode& result, Element* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Element* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(Element_CLASS_ID, index, object);
        else 
           result = dbmanager->search(Element_CLASS_ID, attrNumber,
				      index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Element_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = Element::open(&title, result, OPEN, NULL);
	else
            temp = Element::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// ElementIterator::reset

void ElementIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ Float.cc
//=======================================================================

#include "DOL.hh"
#include "Float.hh"


//-----------------------------------------------------------------------
// Float::Float

Float::Float(Real_64 arg1)
{
    value = arg1;
}

//-----------------------------------------------------------------------
// Float::Float

Float::Float()
{}

//-----------------------------------------------------------------------
// Float::operator==

Boolean Float::operator==(Float x)
{
    return memcmp(this, &x, 8) == 0;
}

//-----------------------------------------------------------------------
// Float::operator<

Boolean Float::operator<(Float x)
{
    return memcmp(this, &x, 8) < 0;
}


//-----------------------------------------------------------------------
// FloatAttribute::get

DbResultCode FloatAttribute::get(DbBaseObject* dbObject, AttributeIndex index, Float& buffer)
{	
    return dbObject->getValue(index, &buffer);
}

//-----------------------------------------------------------------------
// FloatAttribute::get

DbResultCode FloatAttribute::get(DbBaseObject* dbObject, AttributeIndex index, Float& buffer, int arrayindex)
{	
    return dbObject->getSlice(index, arrayindex*8, 8, &buffer);
}

//-----------------------------------------------------------------------
// FloatAttribute::set

DbResultCode FloatAttribute::set(DbBaseObject* dbObject, AttributeIndex index, Float buffer)
{	
    return dbObject->putValue(index, &buffer);
}

//-----------------------------------------------------------------------
// FloatAttribute::set

DbResultCode FloatAttribute::set(DbBaseObject* dbObject, AttributeIndex index, Float buffer, int arrayindex)
{	
    return dbObject->putSlice(index, arrayindex*8, 8, &buffer);
}

//-- EoF ------------------------------------------------------------
//============ FloatValue.cc
//=======================================================================

#include "DOL.hh"
#include "FloatValue.hh"




//-----------------------------------------------------------------------
// FloatValue::create

FloatValue* FloatValue::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(FloatValue_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// FloatValue::getClassNo

int FloatValue::getClassNo()
{
    return FloatValue_CLASS_ID;
}



//-----------------------------------------------------------------------
// FloatValue::open

FloatValue* FloatValue::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (FloatValue*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case FloatValue_CLASS_ID:
	    return new FloatValue (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// FloatValue::open

FloatValue* FloatValue::open(DbTitle *title, DbResultCode& result, FloatValue* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// FloatValue::FloatValue

FloatValue::FloatValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    FloatValue::init(op);
}


//-----------------------------------------------------------------------
// FloatValue::init

void FloatValue::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	PrimitiveValue::init(op, initBase);
    if (op == CREATE) {
    }
    int i = 0;
}


//-----------------------------------------------------------------------
// FloatValue::value

Float FloatValue::value(void) // get
{
    Float temp;
    value_.get(theObject, 2, temp);
    return temp;
}


//-----------------------------------------------------------------------
// FloatValue::value

void FloatValue::value(Float data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        value_.set(theObject, 2, data);
    }
    else error("FloatValue::value");
}




//-----------------------------------------------------------------------
// FloatValue::prepare

DbResultCode FloatValue::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    return PrimitiveValue::prepare();
}


//-----------------------------------------------------------------------
// FloatValue::commit

void FloatValue::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    PrimitiveValue::commit();
}


//-----------------------------------------------------------------------
// FloatValue::rollback

void FloatValue::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    PrimitiveValue::rollback();
}







//-- EoF ------------------------------------------------------------
//============ Integer.cc
//=======================================================================

#include "DOL.hh"
#include "Integer.hh"


//-----------------------------------------------------------------------
// Integer::Integer

Integer::Integer(Integer_32 arg1)
{
    value = arg1;
}

//-----------------------------------------------------------------------
// Integer::Integer

Integer::Integer()
{}

//-----------------------------------------------------------------------
// Integer::operator==

Boolean Integer::operator==(Integer x)
{
    return memcmp(this, &x, 4) == 0;
}

//-----------------------------------------------------------------------
// Integer::operator<

Boolean Integer::operator<(Integer x)
{
    return memcmp(this, &x, 4) < 0;
}


//-----------------------------------------------------------------------
// IntegerAttribute::get

DbResultCode IntegerAttribute::get(DbBaseObject* dbObject, AttributeIndex index, Integer& buffer)
{	
    return dbObject->getValue(index, &buffer);
}

//-----------------------------------------------------------------------
// IntegerAttribute::get

DbResultCode IntegerAttribute::get(DbBaseObject* dbObject, AttributeIndex index, Integer& buffer, int arrayindex)
{	
    return dbObject->getSlice(index, arrayindex*4, 4, &buffer);
}

//-----------------------------------------------------------------------
// IntegerAttribute::set

DbResultCode IntegerAttribute::set(DbBaseObject* dbObject, AttributeIndex index, Integer buffer)
{	
    return dbObject->putValue(index, &buffer);
}

//-----------------------------------------------------------------------
// IntegerAttribute::set

DbResultCode IntegerAttribute::set(DbBaseObject* dbObject, AttributeIndex index, Integer buffer, int arrayindex)
{	
    return dbObject->putSlice(index, arrayindex*4, 4, &buffer);
}

//-- EoF ------------------------------------------------------------
//============ IntegerValue.cc
//=======================================================================

#include "DOL.hh"
#include "IntegerValue.hh"




//-----------------------------------------------------------------------
// IntegerValue::create

IntegerValue* IntegerValue::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(IntegerValue_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// IntegerValue::getClassNo

int IntegerValue::getClassNo()
{
    return IntegerValue_CLASS_ID;
}



//-----------------------------------------------------------------------
// IntegerValue::open

IntegerValue* IntegerValue::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (IntegerValue*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case IntegerValue_CLASS_ID:
	    return new IntegerValue (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// IntegerValue::open

IntegerValue* IntegerValue::open(DbTitle *title, DbResultCode& result, IntegerValue* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// IntegerValue::IntegerValue

IntegerValue::IntegerValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    IntegerValue::init(op);
}


//-----------------------------------------------------------------------
// IntegerValue::init

void IntegerValue::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	PrimitiveValue::init(op, initBase);
    if (op == CREATE) {
    }
    int i = 0;
}


//-----------------------------------------------------------------------
// IntegerValue::value

Integer IntegerValue::value(void) // get
{
    Integer temp;
    value_.get(theObject, 2, temp);
    return temp;
}


//-----------------------------------------------------------------------
// IntegerValue::value

void IntegerValue::value(Integer data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        value_.set(theObject, 2, data);
    }
    else error("IntegerValue::value");
}




//-----------------------------------------------------------------------
// IntegerValue::prepare

DbResultCode IntegerValue::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    return PrimitiveValue::prepare();
}


//-----------------------------------------------------------------------
// IntegerValue::commit

void IntegerValue::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    PrimitiveValue::commit();
}


//-----------------------------------------------------------------------
// IntegerValue::rollback

void IntegerValue::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    PrimitiveValue::rollback();
}







//-- EoF ------------------------------------------------------------
//============ Name.cc
//=======================================================================

#include "DOL.hh"
#include "Name.hh"


//-----------------------------------------------------------------------
// Name::Name

Name::Name(char *arg1)
{
    memset(value, 0, 32);
    strcpy(value, arg1);
}

//-----------------------------------------------------------------------
// Name::Name

Name::Name()
{}

//-----------------------------------------------------------------------
// Name::operator==

Boolean Name::operator==(Name x)
{
    return memcmp(this, &x, 32) == 0;
}

//-----------------------------------------------------------------------
// Name::operator<

Boolean Name::operator<(Name x)
{
    return memcmp(this, &x, 32) < 0;
}


//-----------------------------------------------------------------------
// NameAttribute::get

DbResultCode NameAttribute::get(DbBaseObject* dbObject, AttributeIndex index, Name& buffer)
{	
    return dbObject->getValue(index, &buffer);
}

//-----------------------------------------------------------------------
// NameAttribute::get

DbResultCode NameAttribute::get(DbBaseObject* dbObject, AttributeIndex index, Name& buffer, int arrayindex)
{	
    return dbObject->getSlice(index, arrayindex*32, 32, &buffer);
}

//-----------------------------------------------------------------------
// NameAttribute::set

DbResultCode NameAttribute::set(DbBaseObject* dbObject, AttributeIndex index, Name buffer)
{	
    return dbObject->putValue(index, &buffer);
}

//-----------------------------------------------------------------------
// NameAttribute::set

DbResultCode NameAttribute::set(DbBaseObject* dbObject, AttributeIndex index, Name buffer, int arrayindex)
{	
    return dbObject->putSlice(index, arrayindex*32, 32, &buffer);
}

//-- EoF ------------------------------------------------------------
//============ NilValue.cc
//=======================================================================

#include "DOL.hh"
#include "NilValue.hh"




//-----------------------------------------------------------------------
// NilValue::create

NilValue* NilValue::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(NilValue_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// NilValue::getClassNo

int NilValue::getClassNo()
{
    return NilValue_CLASS_ID;
}



//-----------------------------------------------------------------------
// NilValue::open

NilValue* NilValue::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (NilValue*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case NilValue_CLASS_ID:
	    return new NilValue (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// NilValue::open

NilValue* NilValue::open(DbTitle *title, DbResultCode& result, NilValue* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// NilValue::NilValue

NilValue::NilValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    NilValue::init(op);
}


//-----------------------------------------------------------------------
// NilValue::init

void NilValue::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	PrimitiveValue::init(op, initBase);
    if (op == CREATE) {
    }
    int i = 0;
}




//-----------------------------------------------------------------------
// NilValue::prepare

DbResultCode NilValue::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    return PrimitiveValue::prepare();
}


//-----------------------------------------------------------------------
// NilValue::commit

void NilValue::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    PrimitiveValue::commit();
}


//-----------------------------------------------------------------------
// NilValue::rollback

void NilValue::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    PrimitiveValue::rollback();
}







//-- EoF ------------------------------------------------------------
//============ PersistentElement.cc
//=======================================================================

#include "DOL.hh"
#include "PersistentElement.hh"


// Include referenced classes:
#include "PredefinedType.hh"


//-----------------------------------------------------------------------
// PersistentElement::create

PersistentElement* PersistentElement::create(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PersistentElement_CLASS_ID, &key, 64);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// PersistentElement::update

PersistentElement* PersistentElement::update(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PersistentElement_CLASS_ID, &key, 64);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// PersistentElement::remove

PersistentElement* PersistentElement::remove(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PersistentElement_CLASS_ID, &key, 64);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// PersistentElement::openrlock

PersistentElement* PersistentElement::openrlock(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PersistentElement_CLASS_ID, &key, 64);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// PersistentElement::open

PersistentElement* PersistentElement::open(UniqueName key,
	DbResultCode& result,
	PersistentElement* dol)
{
    DbTitle title (PersistentElement_CLASS_ID, &key, 64);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// PersistentElement::getClassNo

int PersistentElement::getClassNo()
{
    return PersistentElement_CLASS_ID;
}


//-----------------------------------------------------------------------
// PersistentElement::getIterator

PersistentElementIterator* PersistentElement::getIterator()
{
    return new PersistentElementIterator;
}


//-----------------------------------------------------------------------
// PersistentElement::open

PersistentElement* PersistentElement::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (PersistentElement*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case PersistentElement_CLASS_ID:
	    return new PersistentElement (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// PersistentElement::open

PersistentElement* PersistentElement::open(DbTitle *title, DbResultCode& result, PersistentElement* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// PersistentElement::PersistentElement

PersistentElement::PersistentElement(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    PersistentElement::init(op);
}


//-----------------------------------------------------------------------
// PersistentElement::init

void PersistentElement::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	Element::init(op);
    if (op == CREATE) {
    }
    int i = 0;
    type_ = NULL;
}


//-----------------------------------------------------------------------
// PersistentElement::updatetype

PredefinedType* PersistentElement::updatetype(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (type_ != NULL)
        title = type_->getTitle();
    else {
        type_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return PredefinedType::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// PersistentElement::removetype

PredefinedType* PersistentElement::removetype(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (type_ != NULL)
        title = type_->getTitle();
    else {
        type_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return PredefinedType::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// PersistentElement::openrlocktype

PredefinedType* PersistentElement::openrlocktype(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (type_ != NULL)
        title = type_->getTitle();
    else {
        type_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return PredefinedType::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// PersistentElement::opentype

PredefinedType* PersistentElement::opentype(DbResultCode& result, PredefinedType* dol)
{
    DbTitle* title;
    if (type_ != NULL)
        title = type_->getTitle();
    else {
        type_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return PredefinedType::open(title, result, OPEN, NULL);
        else
            return PredefinedType::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// PersistentElement::type

void PersistentElement::type(PredefinedType* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (type_ &&  type_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete type_;
	if (data)
            type_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    type_ = DbTitleRef::nilRef();
    }
    else error("PersistentElement::type");
}



//-----------------------------------------------------------------------
// PersistentElement::size

Integer PersistentElement::size(void) // get
{
    Integer temp;
    size_.get(theObject, 3, temp);
    return temp;
}


//-----------------------------------------------------------------------
// PersistentElement::size

void PersistentElement::size(Integer data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        size_.set(theObject, 3, data);
    }
    else error("PersistentElement::size");
}

//-----------------------------------------------------------------------
// PersistentElement::searchsize

PersistentElementIterator* PersistentElement::searchsize(Integer value)
{
    return new PersistentElementIterator (3, (void*) &value, 4);
}





//-----------------------------------------------------------------------
// PersistentElement::prepare

DbResultCode PersistentElement::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (type_ != NULL) {
        DbTitle* title = type_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            type_->prepare(theObject, &temp);  //byt namn
    }
    return Element::prepare();
}


//-----------------------------------------------------------------------
// PersistentElement::commit

void PersistentElement::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (type_ != NULL) {
        type_->commit(theObject, 2);
	if (type_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete type_;
	type_ = NULL;
    }
    Element::commit();
}


//-----------------------------------------------------------------------
// PersistentElement::rollback

void PersistentElement::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (type_)
	if (type_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete type_;
    type_ = NULL;
    Element::rollback();
}


//-----------------------------------------------------------------------
// PersistentElementIterator::PersistentElementIterator

PersistentElementIterator::PersistentElementIterator()
{
    attrNumber = -1;
    index = -1;
}


//-----------------------------------------------------------------------
// PersistentElementIterator::PersistentElementIterator

PersistentElementIterator::PersistentElementIterator(AttributeIndex attr, void* value, int length)
{
    attrNumber = attr;
    memcpy(searchValue, value, length);
    index = -1;
}


//-----------------------------------------------------------------------
// PersistentElementIterator::updateNext

PersistentElement* PersistentElementIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    PersistentElement* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(PersistentElement_CLASS_ID, index, object);
        else 
            result = dbmanager->search(PersistentElement_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (PersistentElement_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = PersistentElement::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// PersistentElementIterator::openrlockNext

PersistentElement* PersistentElementIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    PersistentElement* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(PersistentElement_CLASS_ID, index, object);
        else 
            result = dbmanager->search(PersistentElement_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (PersistentElement_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = PersistentElement::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// PersistentElementIterator::openNext

PersistentElement* PersistentElementIterator::openNext(DbResultCode& result, PersistentElement* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    PersistentElement* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(PersistentElement_CLASS_ID, index, object);
        else 
           result = dbmanager->search(PersistentElement_CLASS_ID, attrNumber,
				      index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (PersistentElement_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = PersistentElement::open(&title, result, OPEN, NULL);
	else
            temp = PersistentElement::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// PersistentElementIterator::reset

void PersistentElementIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ PersistentStructure.cc
//=======================================================================

#include "DOL.hh"
#include "PersistentStructure.hh"


// Include referenced classes:
#include "PersistentElement.hh"


//-----------------------------------------------------------------------
// PersistentStructure::create

PersistentStructure* PersistentStructure::create(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PersistentStructure_CLASS_ID, &key, 32);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// PersistentStructure::update

PersistentStructure* PersistentStructure::update(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PersistentStructure_CLASS_ID, &key, 32);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// PersistentStructure::remove

PersistentStructure* PersistentStructure::remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PersistentStructure_CLASS_ID, &key, 32);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// PersistentStructure::openrlock

PersistentStructure* PersistentStructure::openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PersistentStructure_CLASS_ID, &key, 32);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// PersistentStructure::open

PersistentStructure* PersistentStructure::open(Name key,
	DbResultCode& result,
	PersistentStructure* dol)
{
    DbTitle title (PersistentStructure_CLASS_ID, &key, 32);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// PersistentStructure::getClassNo

int PersistentStructure::getClassNo()
{
    return PersistentStructure_CLASS_ID;
}


//-----------------------------------------------------------------------
// PersistentStructure::getIterator

PersistentStructureIterator* PersistentStructure::getIterator()
{
    return new PersistentStructureIterator;
}


//-----------------------------------------------------------------------
// PersistentStructure::open

PersistentStructure* PersistentStructure::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (PersistentStructure*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case PersistentStructure_CLASS_ID:
	    return new PersistentStructure (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// PersistentStructure::open

PersistentStructure* PersistentStructure::open(DbTitle *title, DbResultCode& result, PersistentStructure* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// PersistentStructure::PersistentStructure

PersistentStructure::PersistentStructure(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    PersistentStructure::init(op);
}


//-----------------------------------------------------------------------
// PersistentStructure::init

void PersistentStructure::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	Structure::init(op, initBase);
    if (op == CREATE) {
    }
    int i = 0;
    persistent_ = NULL;
}


//-----------------------------------------------------------------------
// PersistentStructure::updatepersistent

PersistentElement* PersistentStructure::updatepersistent(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (persistent_ != NULL)
        title = persistent_->getTitle();
    else {
        persistent_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return PersistentElement::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// PersistentStructure::removepersistent

PersistentElement* PersistentStructure::removepersistent(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (persistent_ != NULL)
        title = persistent_->getTitle();
    else {
        persistent_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return PersistentElement::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// PersistentStructure::openrlockpersistent

PersistentElement* PersistentStructure::openrlockpersistent(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (persistent_ != NULL)
        title = persistent_->getTitle();
    else {
        persistent_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return PersistentElement::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// PersistentStructure::openpersistent

PersistentElement* PersistentStructure::openpersistent(DbResultCode& result, PersistentElement* dol)
{
    DbTitle* title;
    if (persistent_ != NULL)
        title = persistent_->getTitle();
    else {
        persistent_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return PersistentElement::open(title, result, OPEN, NULL);
        else
            return PersistentElement::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// PersistentStructure::persistent

void PersistentStructure::persistent(PersistentElement* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (persistent_ &&  persistent_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete persistent_;
	if (data)
            persistent_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    persistent_ = DbTitleRef::nilRef();
    }
    else error("PersistentStructure::persistent");
}





//-----------------------------------------------------------------------
// PersistentStructure::prepare

DbResultCode PersistentStructure::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (persistent_ != NULL) {
        DbTitle* title = persistent_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            persistent_->prepare(theObject, &temp);  //byt namn
    }
    return Structure::prepare();
}


//-----------------------------------------------------------------------
// PersistentStructure::commit

void PersistentStructure::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (persistent_ != NULL) {
        persistent_->commit(theObject, 3);
	if (persistent_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete persistent_;
	persistent_ = NULL;
    }
    Structure::commit();
}


//-----------------------------------------------------------------------
// PersistentStructure::rollback

void PersistentStructure::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (persistent_)
	if (persistent_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete persistent_;
    persistent_ = NULL;
    Structure::rollback();
}


//-----------------------------------------------------------------------
// PersistentStructureIterator::PersistentStructureIterator

PersistentStructureIterator::PersistentStructureIterator()
{
    attrNumber = -1;
    index = -1;
}



//-----------------------------------------------------------------------
// PersistentStructureIterator::updateNext

PersistentStructure* PersistentStructureIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    PersistentStructure* temp;
    while (TRUE) {
        result = dbmanager->iterate(PersistentStructure_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (PersistentStructure_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = PersistentStructure::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// PersistentStructureIterator::openrlockNext

PersistentStructure* PersistentStructureIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    PersistentStructure* temp;
    while (TRUE) {
        result = dbmanager->iterate(PersistentStructure_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (PersistentStructure_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = PersistentStructure::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// PersistentStructureIterator::openNext

PersistentStructure* PersistentStructureIterator::openNext(DbResultCode& result, PersistentStructure* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    PersistentStructure* temp;
    while (TRUE) {
        result = dbmanager->iterate(PersistentStructure_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (PersistentStructure_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = PersistentStructure::open(&title, result, OPEN, NULL);
	else
            temp = PersistentStructure::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// PersistentStructureIterator::reset

void PersistentStructureIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ PredefinedType.cc
//=======================================================================

#include "DOL.hh"
#include "PredefinedType.hh"




//-----------------------------------------------------------------------
// PredefinedType::create

PredefinedType* PredefinedType::create(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PredefinedType_CLASS_ID, &key, 32);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// PredefinedType::update

PredefinedType* PredefinedType::update(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PredefinedType_CLASS_ID, &key, 32);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// PredefinedType::remove

PredefinedType* PredefinedType::remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PredefinedType_CLASS_ID, &key, 32);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// PredefinedType::openrlock

PredefinedType* PredefinedType::openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (PredefinedType_CLASS_ID, &key, 32);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// PredefinedType::open

PredefinedType* PredefinedType::open(Name key,
	DbResultCode& result,
	PredefinedType* dol)
{
    DbTitle title (PredefinedType_CLASS_ID, &key, 32);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// PredefinedType::getClassNo

int PredefinedType::getClassNo()
{
    return PredefinedType_CLASS_ID;
}


//-----------------------------------------------------------------------
// PredefinedType::getIterator

PredefinedTypeIterator* PredefinedType::getIterator()
{
    return new PredefinedTypeIterator;
}


//-----------------------------------------------------------------------
// PredefinedType::open

PredefinedType* PredefinedType::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (PredefinedType*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case PredefinedType_CLASS_ID:
	    return new PredefinedType (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// PredefinedType::open

PredefinedType* PredefinedType::open(DbTitle *title, DbResultCode& result, PredefinedType* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN);
        return dol;
    }
}


//-----------------------------------------------------------------------
// PredefinedType::PredefinedType

PredefinedType::PredefinedType(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    PredefinedType::init(op);
}


//-----------------------------------------------------------------------
// PredefinedType::init

void PredefinedType::init(DBOperation op)
{
    if (op == CREATE) {
    }
    int i = 0;
}


//-----------------------------------------------------------------------
// PredefinedType::name

Name PredefinedType::name(void) // get
{
    Name temp;
    name_.get(theObject, 0, temp);
    return temp;
}


//-----------------------------------------------------------------------
// PredefinedType::searchname

PredefinedTypeIterator* PredefinedType::searchname(Name value)
{
    return new PredefinedTypeIterator (0, (void*) &value, 32);
}





//-----------------------------------------------------------------------
// PredefinedType::prepare

DbResultCode PredefinedType::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    return DbAbstractObject::prepare();
}


//-----------------------------------------------------------------------
// PredefinedType::commit

void PredefinedType::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    DbAbstractObject::commit();
}


//-----------------------------------------------------------------------
// PredefinedType::rollback

void PredefinedType::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    DbAbstractObject::rollback();
}


//-----------------------------------------------------------------------
// PredefinedTypeIterator::PredefinedTypeIterator

PredefinedTypeIterator::PredefinedTypeIterator()
{
    attrNumber = -1;
    index = -1;
}


//-----------------------------------------------------------------------
// PredefinedTypeIterator::PredefinedTypeIterator

PredefinedTypeIterator::PredefinedTypeIterator(AttributeIndex attr, void* value, int length)
{
    attrNumber = attr;
    memcpy(searchValue, value, length);
    index = -1;
}


//-----------------------------------------------------------------------
// PredefinedTypeIterator::updateNext

PredefinedType* PredefinedTypeIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    PredefinedType* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(PredefinedType_CLASS_ID, index, object);
        else 
            result = dbmanager->search(PredefinedType_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (PredefinedType_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = PredefinedType::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// PredefinedTypeIterator::openrlockNext

PredefinedType* PredefinedTypeIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    PredefinedType* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(PredefinedType_CLASS_ID, index, object);
        else 
            result = dbmanager->search(PredefinedType_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (PredefinedType_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = PredefinedType::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// PredefinedTypeIterator::openNext

PredefinedType* PredefinedTypeIterator::openNext(DbResultCode& result, PredefinedType* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    PredefinedType* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(PredefinedType_CLASS_ID, index, object);
        else 
           result = dbmanager->search(PredefinedType_CLASS_ID, attrNumber,
				      index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (PredefinedType_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = PredefinedType::open(&title, result, OPEN, NULL);
	else
            temp = PredefinedType::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// PredefinedTypeIterator::reset

void PredefinedTypeIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ PrimitiveValue.cc
//=======================================================================

#include "DOL.hh"
#include "PrimitiveValue.hh"

// Include subclasses:
#include "IntegerValue.hh"
#include "FloatValue.hh"
#include "BooleanValue.hh"
#include "StringValue.hh"
#include "NilValue.hh"



//-----------------------------------------------------------------------
// PrimitiveValue::create

PrimitiveValue* PrimitiveValue::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(PrimitiveValue_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// PrimitiveValue::getClassNo

int PrimitiveValue::getClassNo()
{
    return PrimitiveValue_CLASS_ID;
}



//-----------------------------------------------------------------------
// PrimitiveValue::open

PrimitiveValue* PrimitiveValue::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (PrimitiveValue*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case PrimitiveValue_CLASS_ID:
	    return new PrimitiveValue (object, tempObject, op, trId, title);
	case IntegerValue_CLASS_ID:
	    return (PrimitiveValue*) new IntegerValue (object, tempObject, op, trId, title);
	case FloatValue_CLASS_ID:
	    return (PrimitiveValue*) new FloatValue (object, tempObject, op, trId, title);
	case BooleanValue_CLASS_ID:
	    return (PrimitiveValue*) new BooleanValue (object, tempObject, op, trId, title);
	case StringValue_CLASS_ID:
	    return (PrimitiveValue*) new StringValue (object, tempObject, op, trId, title);
	case NilValue_CLASS_ID:
	    return (PrimitiveValue*) new NilValue (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// PrimitiveValue::open

PrimitiveValue* PrimitiveValue::open(DbTitle *title, DbResultCode& result, PrimitiveValue* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// PrimitiveValue::PrimitiveValue

PrimitiveValue::PrimitiveValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    PrimitiveValue::init(op);
}


//-----------------------------------------------------------------------
// PrimitiveValue::init

void PrimitiveValue::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	Value::init(op);
    if (op == CREATE) {
    }
    int i = 0;
}




//-----------------------------------------------------------------------
// PrimitiveValue::prepare

DbResultCode PrimitiveValue::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    return Value::prepare();
}


//-----------------------------------------------------------------------
// PrimitiveValue::commit

void PrimitiveValue::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    Value::commit();
}


//-----------------------------------------------------------------------
// PrimitiveValue::rollback

void PrimitiveValue::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    Value::rollback();
}







//-- EoF ------------------------------------------------------------
//============ Relation.cc
//=======================================================================

#include "DOL.hh"
#include "Relation.hh"


// Include referenced classes:
#include "Class.hh"


//-----------------------------------------------------------------------
// Relation::create

Relation* Relation::create(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Relation_CLASS_ID, &key, 32);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// Relation::update

Relation* Relation::update(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Relation_CLASS_ID, &key, 32);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// Relation::remove

Relation* Relation::remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Relation_CLASS_ID, &key, 32);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// Relation::openrlock

Relation* Relation::openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Relation_CLASS_ID, &key, 32);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// Relation::open

Relation* Relation::open(Name key,
	DbResultCode& result,
	Relation* dol)
{
    DbTitle title (Relation_CLASS_ID, &key, 32);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// Relation::getClassNo

int Relation::getClassNo()
{
    return Relation_CLASS_ID;
}


//-----------------------------------------------------------------------
// Relation::getIterator

RelationIterator* Relation::getIterator()
{
    return new RelationIterator;
}


//-----------------------------------------------------------------------
// Relation::open

Relation* Relation::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (Relation*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case Relation_CLASS_ID:
	    return new Relation (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// Relation::open

Relation* Relation::open(DbTitle *title, DbResultCode& result, Relation* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// Relation::Relation

Relation::Relation(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    Relation::init(op);
}


//-----------------------------------------------------------------------
// Relation::init

void Relation::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	DbObject::init(op, initBase);
    if (op == CREATE) {
    }
    int i = 0;
    from_ = NULL;
    to_ = NULL;
}


//-----------------------------------------------------------------------
// Relation::updatefrom

Class* Relation::updatefrom(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (from_ != NULL)
        title = from_->getTitle();
    else {
        from_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return Class::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Relation::removefrom

Class* Relation::removefrom(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (from_ != NULL)
        title = from_->getTitle();
    else {
        from_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Class::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Relation::openrlockfrom

Class* Relation::openrlockfrom(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (from_ != NULL)
        title = from_->getTitle();
    else {
        from_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Class::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// Relation::openfrom

Class* Relation::openfrom(DbResultCode& result, Class* dol)
{
    DbTitle* title;
    if (from_ != NULL)
        title = from_->getTitle();
    else {
        from_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return Class::open(title, result, OPEN, NULL);
        else
            return Class::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Relation::from

void Relation::from(Class* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (from_ &&  from_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete from_;
	if (data)
            from_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    from_ = DbTitleRef::nilRef();
    }
    else error("Relation::from");
}



//-----------------------------------------------------------------------
// Relation::updateto

Class* Relation::updateto(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (to_ != NULL)
        title = to_->getTitle();
    else {
        to_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return Class::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Relation::removeto

Class* Relation::removeto(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (to_ != NULL)
        title = to_->getTitle();
    else {
        to_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Class::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Relation::openrlockto

Class* Relation::openrlockto(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (to_ != NULL)
        title = to_->getTitle();
    else {
        to_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Class::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// Relation::opento

Class* Relation::opento(DbResultCode& result, Class* dol)
{
    DbTitle* title;
    if (to_ != NULL)
        title = to_->getTitle();
    else {
        to_->get(theObject, 3, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return Class::open(title, result, OPEN, NULL);
        else
            return Class::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Relation::to

void Relation::to(Class* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (to_ &&  to_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete to_;
	if (data)
            to_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    to_ = DbTitleRef::nilRef();
    }
    else error("Relation::to");
}





//-----------------------------------------------------------------------
// Relation::prepare

DbResultCode Relation::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (from_ != NULL) {
        DbTitle* title = from_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            from_->prepare(theObject, &temp);  //byt namn
    }
    if (to_ != NULL) {
        DbTitle* title = to_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            to_->prepare(theObject, &temp);  //byt namn
    }
    return DbObject::prepare();
}


//-----------------------------------------------------------------------
// Relation::commit

void Relation::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (from_ != NULL) {
        from_->commit(theObject, 2);
	if (from_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete from_;
	from_ = NULL;
    }
    if (to_ != NULL) {
        to_->commit(theObject, 3);
	if (to_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete to_;
	to_ = NULL;
    }
    DbObject::commit();
}


//-----------------------------------------------------------------------
// Relation::rollback

void Relation::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (from_)
	if (from_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete from_;
    from_ = NULL;
    if (to_)
	if (to_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete to_;
    to_ = NULL;
    DbObject::rollback();
}


//-----------------------------------------------------------------------
// RelationIterator::RelationIterator

RelationIterator::RelationIterator()
{
    attrNumber = -1;
    index = -1;
}



//-----------------------------------------------------------------------
// RelationIterator::updateNext

Relation* RelationIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Relation* temp;
    while (TRUE) {
        result = dbmanager->iterate(Relation_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Relation_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = Relation::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// RelationIterator::openrlockNext

Relation* RelationIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Relation* temp;
    while (TRUE) {
        result = dbmanager->iterate(Relation_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Relation_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = Relation::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// RelationIterator::openNext

Relation* RelationIterator::openNext(DbResultCode& result, Relation* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Relation* temp;
    while (TRUE) {
        result = dbmanager->iterate(Relation_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Relation_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = Relation::open(&title, result, OPEN, NULL);
	else
            temp = Relation::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// RelationIterator::reset

void RelationIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ StringValue.cc
//=======================================================================

#include "DOL.hh"
#include "StringValue.hh"


// Include referenced classes:
#include "DynamicString.hh"


//-----------------------------------------------------------------------
// StringValue::create

StringValue* StringValue::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(StringValue_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// StringValue::getClassNo

int StringValue::getClassNo()
{
    return StringValue_CLASS_ID;
}



//-----------------------------------------------------------------------
// StringValue::open

StringValue* StringValue::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (StringValue*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case StringValue_CLASS_ID:
	    return new StringValue (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// StringValue::open

StringValue* StringValue::open(DbTitle *title, DbResultCode& result, StringValue* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// StringValue::StringValue

StringValue::StringValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    StringValue::init(op);
}


//-----------------------------------------------------------------------
// StringValue::init

void StringValue::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	PrimitiveValue::init(op, initBase);
    if (op == CREATE) {
    }
    int i = 0;
    value_ = NULL;
}


//-----------------------------------------------------------------------
// StringValue::updatevalue

DynamicString* StringValue::updatevalue(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (value_ != NULL)
        title = value_->getTitle();
    else {
        value_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return DynamicString::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// StringValue::removevalue

DynamicString* StringValue::removevalue(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (value_ != NULL)
        title = value_->getTitle();
    else {
        value_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return DynamicString::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// StringValue::openrlockvalue

DynamicString* StringValue::openrlockvalue(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (value_ != NULL)
        title = value_->getTitle();
    else {
        value_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return DynamicString::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// StringValue::openvalue

DynamicString* StringValue::openvalue(DbResultCode& result, DynamicString* dol)
{
    DbTitle* title;
    if (value_ != NULL)
        title = value_->getTitle();
    else {
        value_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return DynamicString::open(title, result, OPEN, NULL);
        else
            return DynamicString::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// StringValue::value

void StringValue::value(DynamicString* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (value_ &&  value_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete value_;
	if (data)
            value_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    value_ = DbTitleRef::nilRef();
    }
    else error("StringValue::value");
}





//-----------------------------------------------------------------------
// StringValue::prepare

DbResultCode StringValue::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (value_ != NULL) {
        DbTitle* title = value_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            value_->prepare(theObject, &temp);  //byt namn
    }
    return PrimitiveValue::prepare();
}


//-----------------------------------------------------------------------
// StringValue::commit

void StringValue::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (value_ != NULL) {
        value_->commit(theObject, 2);
	if (value_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete value_;
	value_ = NULL;
    }
    PrimitiveValue::commit();
}


//-----------------------------------------------------------------------
// StringValue::rollback

void StringValue::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (value_)
	if (value_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete value_;
    value_ = NULL;
    PrimitiveValue::rollback();
}







//-- EoF ------------------------------------------------------------
//============ Structure.cc
//=======================================================================

#include "DOL.hh"
#include "Structure.hh"

// Include subclasses:
#include "PersistentStructure.hh"
#include "DynamicStructure.hh"

// Include referenced classes:
#include "VolatileElement.hh"


//-----------------------------------------------------------------------
// Structure::create

Structure* Structure::create(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Structure_CLASS_ID, &key, 32);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// Structure::update

Structure* Structure::update(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Structure_CLASS_ID, &key, 32);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// Structure::remove

Structure* Structure::remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Structure_CLASS_ID, &key, 32);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// Structure::openrlock

Structure* Structure::openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (Structure_CLASS_ID, &key, 32);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// Structure::open

Structure* Structure::open(Name key,
	DbResultCode& result,
	Structure* dol)
{
    DbTitle title (Structure_CLASS_ID, &key, 32);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// Structure::getClassNo

int Structure::getClassNo()
{
    return Structure_CLASS_ID;
}


//-----------------------------------------------------------------------
// Structure::getIterator

StructureIterator* Structure::getIterator()
{
    return new StructureIterator;
}


//-----------------------------------------------------------------------
// Structure::open

Structure* Structure::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (Structure*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case Structure_CLASS_ID:
	    return new Structure (object, tempObject, op, trId, title);
	case PersistentStructure_CLASS_ID:
	    return (Structure*) new PersistentStructure (object, tempObject, op, trId, title);
	case DynamicStructure_CLASS_ID:
	    return (Structure*) new DynamicStructure (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// Structure::open

Structure* Structure::open(DbTitle *title, DbResultCode& result, Structure* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// Structure::Structure

Structure::Structure(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    Structure::init(op);
}


//-----------------------------------------------------------------------
// Structure::init

void Structure::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	DbEntity::init(op);
    if (op == CREATE) {
    }
    int i = 0;
    volatile_ = NULL;
}


//-----------------------------------------------------------------------
// Structure::updatevolatile

VolatileElement* Structure::updatevolatile(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (volatile_ != NULL)
        title = volatile_->getTitle();
    else {
        volatile_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return VolatileElement::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Structure::removevolatile

VolatileElement* Structure::removevolatile(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (volatile_ != NULL)
        title = volatile_->getTitle();
    else {
        volatile_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return VolatileElement::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Structure::openrlockvolatile

VolatileElement* Structure::openrlockvolatile(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (volatile_ != NULL)
        title = volatile_->getTitle();
    else {
        volatile_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return VolatileElement::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// Structure::openvolatile

VolatileElement* Structure::openvolatile(DbResultCode& result, VolatileElement* dol)
{
    DbTitle* title;
    if (volatile_ != NULL)
        title = volatile_->getTitle();
    else {
        volatile_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return VolatileElement::open(title, result, OPEN, NULL);
        else
            return VolatileElement::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Structure::volatile

void Structure::volatile(VolatileElement* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (volatile_ &&  volatile_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete volatile_;
	if (data)
            volatile_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    volatile_ = DbTitleRef::nilRef();
    }
    else error("Structure::volatile");
}





//-----------------------------------------------------------------------
// Structure::prepare

DbResultCode Structure::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (volatile_ != NULL) {
        DbTitle* title = volatile_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            volatile_->prepare(theObject, &temp);  //byt namn
    }
    return DbEntity::prepare();
}


//-----------------------------------------------------------------------
// Structure::commit

void Structure::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (volatile_ != NULL) {
        volatile_->commit(theObject, 2);
	if (volatile_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete volatile_;
	volatile_ = NULL;
    }
    DbEntity::commit();
}


//-----------------------------------------------------------------------
// Structure::rollback

void Structure::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (volatile_)
	if (volatile_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete volatile_;
    volatile_ = NULL;
    DbEntity::rollback();
}


//-----------------------------------------------------------------------
// StructureIterator::StructureIterator

StructureIterator::StructureIterator()
{
    attrNumber = -1;
    index = -1;
}



//-----------------------------------------------------------------------
// StructureIterator::updateNext

Structure* StructureIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Structure* temp;
    while (TRUE) {
        result = dbmanager->iterate(Structure_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Structure_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = Structure::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// StructureIterator::openrlockNext

Structure* StructureIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Structure* temp;
    while (TRUE) {
        result = dbmanager->iterate(Structure_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Structure_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = Structure::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// StructureIterator::openNext

Structure* StructureIterator::openNext(DbResultCode& result, Structure* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    Structure* temp;
    while (TRUE) {
        result = dbmanager->iterate(Structure_CLASS_ID, index, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (Structure_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = Structure::open(&title, result, OPEN, NULL);
	else
            temp = Structure::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// StructureIterator::reset

void StructureIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ StructureValue.cc
//=======================================================================

#include "DOL.hh"
#include "StructureValue.hh"


// Include referenced classes:
#include "PrimitiveValue.hh"


//-----------------------------------------------------------------------
// StructureValue::create

StructureValue* StructureValue::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(StructureValue_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// StructureValue::getClassNo

int StructureValue::getClassNo()
{
    return StructureValue_CLASS_ID;
}



//-----------------------------------------------------------------------
// StructureValue::open

StructureValue* StructureValue::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (StructureValue*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case StructureValue_CLASS_ID:
	    return new StructureValue (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// StructureValue::open

StructureValue* StructureValue::open(DbTitle *title, DbResultCode& result, StructureValue* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// StructureValue::StructureValue

StructureValue::StructureValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    StructureValue::init(op);
}


//-----------------------------------------------------------------------
// StructureValue::init

void StructureValue::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	Value::init(op);
    if (op == CREATE) {
    }
    int i = 0;
    values_ = NULL;
}


//-----------------------------------------------------------------------
// StructureValue::updatevalues

PrimitiveValue* StructureValue::updatevalues(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (values_ != NULL)
        title = values_->getTitle();
    else {
        values_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return PrimitiveValue::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// StructureValue::removevalues

PrimitiveValue* StructureValue::removevalues(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (values_ != NULL)
        title = values_->getTitle();
    else {
        values_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return PrimitiveValue::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// StructureValue::openrlockvalues

PrimitiveValue* StructureValue::openrlockvalues(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (values_ != NULL)
        title = values_->getTitle();
    else {
        values_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return PrimitiveValue::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// StructureValue::openvalues

PrimitiveValue* StructureValue::openvalues(DbResultCode& result, PrimitiveValue* dol)
{
    DbTitle* title;
    if (values_ != NULL)
        title = values_->getTitle();
    else {
        values_->get(theObject, 2, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return PrimitiveValue::open(title, result, OPEN, NULL);
        else
            return PrimitiveValue::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// StructureValue::values

void StructureValue::values(PrimitiveValue* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (values_ &&  values_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete values_;
	if (data)
            values_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    values_ = DbTitleRef::nilRef();
    }
    else error("StructureValue::values");
}





//-----------------------------------------------------------------------
// StructureValue::prepare

DbResultCode StructureValue::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (values_ != NULL) {
        DbTitle* title = values_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            values_->prepare(theObject, &temp);  //byt namn
    }
    return Value::prepare();
}


//-----------------------------------------------------------------------
// StructureValue::commit

void StructureValue::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (values_ != NULL) {
        values_->commit(theObject, 2);
	if (values_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete values_;
	values_ = NULL;
    }
    Value::commit();
}


//-----------------------------------------------------------------------
// StructureValue::rollback

void StructureValue::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (values_)
	if (values_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete values_;
    values_ = NULL;
    Value::rollback();
}







//-- EoF ------------------------------------------------------------
//============ UniqueName.cc
//=======================================================================

#include "DOL.hh"
#include "UniqueName.hh"


//-----------------------------------------------------------------------
// UniqueName::UniqueName

UniqueName::UniqueName(char *arg1,char *arg2)
{
    memset(base, 0, 32);
    strcpy(base, arg1);
    memset(name, 0, 32);
    strcpy(name, arg2);
}

//-----------------------------------------------------------------------
// UniqueName::UniqueName

UniqueName::UniqueName()
{}

//-----------------------------------------------------------------------
// UniqueName::operator==

Boolean UniqueName::operator==(UniqueName x)
{
    return memcmp(this, &x, 64) == 0;
}

//-----------------------------------------------------------------------
// UniqueName::operator<

Boolean UniqueName::operator<(UniqueName x)
{
    return memcmp(this, &x, 64) < 0;
}


//-----------------------------------------------------------------------
// UniqueNameAttribute::get

DbResultCode UniqueNameAttribute::get(DbBaseObject* dbObject, AttributeIndex index, UniqueName& buffer)
{	
    return dbObject->getValue(index, &buffer);
}

//-----------------------------------------------------------------------
// UniqueNameAttribute::get

DbResultCode UniqueNameAttribute::get(DbBaseObject* dbObject, AttributeIndex index, UniqueName& buffer, int arrayindex)
{	
    return dbObject->getSlice(index, arrayindex*64, 64, &buffer);
}

//-----------------------------------------------------------------------
// UniqueNameAttribute::set

DbResultCode UniqueNameAttribute::set(DbBaseObject* dbObject, AttributeIndex index, UniqueName buffer)
{	
    return dbObject->putValue(index, &buffer);
}

//-----------------------------------------------------------------------
// UniqueNameAttribute::set

DbResultCode UniqueNameAttribute::set(DbBaseObject* dbObject, AttributeIndex index, UniqueName buffer, int arrayindex)
{	
    return dbObject->putSlice(index, arrayindex*64, 64, &buffer);
}

//-- EoF ------------------------------------------------------------
//============ Value.cc
//=======================================================================

#include "DOL.hh"
#include "Value.hh"

// Include subclasses:
#include "PrimitiveValue.hh"
#include "IntegerValue.hh"
#include "FloatValue.hh"
#include "BooleanValue.hh"
#include "StringValue.hh"
#include "NilValue.hh"
#include "StructureValue.hh"

// Include referenced classes:


//-----------------------------------------------------------------------
// Value::create

Value* Value::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(Value_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// Value::getClassNo

int Value::getClassNo()
{
    return Value_CLASS_ID;
}



//-----------------------------------------------------------------------
// Value::open

Value* Value::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (Value*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case Value_CLASS_ID:
	    return new Value (object, tempObject, op, trId, title);
	case PrimitiveValue_CLASS_ID:
	    return (Value*) new PrimitiveValue (object, tempObject, op, trId, title);
	case IntegerValue_CLASS_ID:
	    return (Value*) new IntegerValue (object, tempObject, op, trId, title);
	case FloatValue_CLASS_ID:
	    return (Value*) new FloatValue (object, tempObject, op, trId, title);
	case BooleanValue_CLASS_ID:
	    return (Value*) new BooleanValue (object, tempObject, op, trId, title);
	case StringValue_CLASS_ID:
	    return (Value*) new StringValue (object, tempObject, op, trId, title);
	case NilValue_CLASS_ID:
	    return (Value*) new NilValue (object, tempObject, op, trId, title);
	case StructureValue_CLASS_ID:
	    return (Value*) new StructureValue (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// Value::open

Value* Value::open(DbTitle *title, DbResultCode& result, Value* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN);
        return dol;
    }
}


//-----------------------------------------------------------------------
// Value::Value

Value::Value(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    Value::init(op);
}


//-----------------------------------------------------------------------
// Value::init

void Value::init(DBOperation op)
{
    if (op == CREATE) {
        // next_ = DbTitleRef::nilRef();    // 4f - Nil reference
    }
    int i = 0;
    next_ = NULL;
}


//-----------------------------------------------------------------------
// Value::updatenext

Value* Value::updatenext(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return Value::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Value::removenext

Value* Value::removenext(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Value::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Value::openrlocknext

Value* Value::openrlocknext(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Value::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// Value::opennext

Value* Value::opennext(DbResultCode& result, Value* dol)
{
    DbTitle* title;
    if (next_ != NULL)
        title = next_->getTitle();
    else {
        next_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return Value::open(title, result, OPEN, NULL);
        else
            return Value::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// Value::next

void Value::next(Value* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (next_ &&  next_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete next_;
	if (data)
            next_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    next_ = DbTitleRef::nilRef();
    }
    else error("Value::next");
}





//-----------------------------------------------------------------------
// Value::prepare

DbResultCode Value::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (next_ != NULL) {
        DbTitle* title = next_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            next_->prepare(theObject, &temp);  //byt namn
    }
    return DbAbstractObject::prepare();
}


//-----------------------------------------------------------------------
// Value::commit

void Value::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (next_ != NULL) {
        next_->commit(theObject, 1);
	if (next_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete next_;
	next_ = NULL;
    }
    DbAbstractObject::commit();
}


//-----------------------------------------------------------------------
// Value::rollback

void Value::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (next_)
	if (next_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete next_;
    next_ = NULL;
    DbAbstractObject::rollback();
}







//-- EoF ------------------------------------------------------------
//============ VolatileElement.cc
//=======================================================================

#include "DOL.hh"
#include "VolatileElement.hh"




//-----------------------------------------------------------------------
// VolatileElement::create

VolatileElement* VolatileElement::create(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (VolatileElement_CLASS_ID, &key, 64);
    return open(&title, result, CREATE, trId);
}



//-----------------------------------------------------------------------
// VolatileElement::update

VolatileElement* VolatileElement::update(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (VolatileElement_CLASS_ID, &key, 64);
    return open(&title, result, UPDATE, trId);
}


//-----------------------------------------------------------------------
// VolatileElement::remove

VolatileElement* VolatileElement::remove(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (VolatileElement_CLASS_ID, &key, 64);
    return open(&title, result, REMOVE, trId);
}


//-----------------------------------------------------------------------
// VolatileElement::openrlock

VolatileElement* VolatileElement::openrlock(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId)
{
    DbTitle title (VolatileElement_CLASS_ID, &key, 64);
    return open(&title, result, OPENRLOCK, trId);
}


//-----------------------------------------------------------------------
// VolatileElement::open

VolatileElement* VolatileElement::open(UniqueName key,
	DbResultCode& result,
	VolatileElement* dol)
{
    DbTitle title (VolatileElement_CLASS_ID, &key, 64);
    if (dol == NULL)
        return open(&title, result, OPEN, NULL);
    else
        return open(&title, result, dol);
}


//-----------------------------------------------------------------------
// VolatileElement::getClassNo

int VolatileElement::getClassNo()
{
    return VolatileElement_CLASS_ID;
}


//-----------------------------------------------------------------------
// VolatileElement::getIterator

VolatileElementIterator* VolatileElement::getIterator()
{
    return new VolatileElementIterator;
}


//-----------------------------------------------------------------------
// VolatileElement::open

VolatileElement* VolatileElement::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (VolatileElement*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case VolatileElement_CLASS_ID:
	    return new VolatileElement (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// VolatileElement::open

VolatileElement* VolatileElement::open(DbTitle *title, DbResultCode& result, VolatileElement* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN, TRUE);
        return dol;
    }
}


//-----------------------------------------------------------------------
// VolatileElement::VolatileElement

VolatileElement::VolatileElement(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    VolatileElement::init(op);
}


//-----------------------------------------------------------------------
// VolatileElement::init

void VolatileElement::init(DBOperation op, Boolean initBase)
{
    if (initBase)
	Element::init(op);
    if (op == CREATE) {
    }
    int i = 0;
}


//-----------------------------------------------------------------------
// VolatileElement::type

Name VolatileElement::type(void) // get
{
    Name temp;
    type_.get(theObject, 2, temp);
    return temp;
}


//-----------------------------------------------------------------------
// VolatileElement::type

void VolatileElement::type(Name data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        type_.set(theObject, 2, data);
    }
    else error("VolatileElement::type");
}

//-----------------------------------------------------------------------
// VolatileElement::searchtype

VolatileElementIterator* VolatileElement::searchtype(Name value)
{
    return new VolatileElementIterator (2, (void*) &value, 32);
}





//-----------------------------------------------------------------------
// VolatileElement::prepare

DbResultCode VolatileElement::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    return Element::prepare();
}


//-----------------------------------------------------------------------
// VolatileElement::commit

void VolatileElement::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    Element::commit();
}


//-----------------------------------------------------------------------
// VolatileElement::rollback

void VolatileElement::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    Element::rollback();
}


//-----------------------------------------------------------------------
// VolatileElementIterator::VolatileElementIterator

VolatileElementIterator::VolatileElementIterator()
{
    attrNumber = -1;
    index = -1;
}


//-----------------------------------------------------------------------
// VolatileElementIterator::VolatileElementIterator

VolatileElementIterator::VolatileElementIterator(AttributeIndex attr, void* value, int length)
{
    attrNumber = attr;
    memcpy(searchValue, value, length);
    index = -1;
}


//-----------------------------------------------------------------------
// VolatileElementIterator::updateNext

VolatileElement* VolatileElementIterator::updateNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    VolatileElement* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(VolatileElement_CLASS_ID, index, object);
        else 
            result = dbmanager->search(VolatileElement_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (VolatileElement_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = VolatileElement::open(&title, result, UPDATE, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// VolatileElementIterator::openrlockNext

VolatileElement* VolatileElementIterator::openrlockNext(DbResultCode& result, LocalTransaction* trId)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    VolatileElement* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(VolatileElement_CLASS_ID, index, object);
        else 
            result = dbmanager->search(VolatileElement_CLASS_ID, attrNumber,
				       index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (VolatileElement_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        temp = VolatileElement::open(&title, result, OPENRLOCK, trId);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// VolatileElementIterator::openNext

VolatileElement* VolatileElementIterator::openNext(DbResultCode& result, VolatileElement* dol)
{
    DataBaseManager* dbmanager = getDbManager_t();
    DbBaseObject* object;
    VolatileElement* temp;
    while (TRUE) {
        if (attrNumber == -1)
            result = dbmanager->iterate(VolatileElement_CLASS_ID, index, object);
        else 
           result = dbmanager->search(VolatileElement_CLASS_ID, attrNumber,
				      index, searchValue, object);
        if (result != SUCCEEDED)
	    return NULL;
        DbTitle title (VolatileElement_CLASS_ID, -1,
		       object->getClid(), object->getLid());
        if (dol == NULL)
	    temp = VolatileElement::open(&title, result, OPEN, NULL);
	else
            temp = VolatileElement::open(&title, result, dol);
	if (result != OBJECT_NOT_SUBCLASS)
	    return temp;
    }
}


//-----------------------------------------------------------------------
// VolatileElementIterator::reset

void VolatileElementIterator::reset()
{
    index = -1;
}

//-- EoF ------------------------------------------------------------
//============ keySpecifikation.cc
//=======================================================================

#include "DOL.hh"
#include "keySpecifikation.hh"


// Include referenced classes:
#include "Attribute.hh"


//-----------------------------------------------------------------------
// keySpecifikation::create

keySpecifikation* keySpecifikation::create(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title = DbTitle::generateTitle(keySpecifikation_CLASS_ID);
    return open(title, result, CREATE, trId);
}







//-----------------------------------------------------------------------
// keySpecifikation::getClassNo

int keySpecifikation::getClassNo()
{
    return keySpecifikation_CLASS_ID;
}



//-----------------------------------------------------------------------
// keySpecifikation::open

keySpecifikation* keySpecifikation::open(DbTitle *title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId)
{
    DbBaseObject* object;
    DbBaseObject* tempObject;
    LocalTransItem* item;
    if (item=trId->find(title))
	return (keySpecifikation*) item;
    result = DbAbstractObject::open(title, op, object, tempObject);
    if (result != SUCCEEDED) 
	return NULL;
    else {
	switch (object->getClassId()) {
	case keySpecifikation_CLASS_ID:
	    return new keySpecifikation (object, tempObject, op, trId, title);
	default:
	    result = OBJECT_NOT_SUBCLASS;
            return NULL;
	}
    }
}


//-----------------------------------------------------------------------
// keySpecifikation::open

keySpecifikation* keySpecifikation::open(DbTitle *title, DbResultCode& result, keySpecifikation* dol)
{
    result = dol->reOpen(title);
    if (result != SUCCEEDED) 
        return NULL;
    else {
        dol->init(OPEN);
        return dol;
    }
}


//-----------------------------------------------------------------------
// keySpecifikation::keySpecifikation

keySpecifikation::keySpecifikation(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
	DbTitle* title)
    : (object, tempObject, op, trId, title)
{
    keySpecifikation::init(op);
}


//-----------------------------------------------------------------------
// keySpecifikation::init

void keySpecifikation::init(DBOperation op)
{
    if (op == CREATE) {
    }
    int i = 0;
    name_ = NULL;
}


//-----------------------------------------------------------------------
// keySpecifikation::updatename

Attribute* keySpecifikation::updatename(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (name_ != NULL)
        title = name_->getTitle();
    else {
        name_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
	return Attribute::open(title, result, UPDATE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// keySpecifikation::removename

Attribute* keySpecifikation::removename(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (name_ != NULL)
        title = name_->getTitle();
    else {
        name_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Attribute::open(title, result, REMOVE, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// keySpecifikation::openrlockname

Attribute* keySpecifikation::openrlockname(DbResultCode& result, LocalTransaction* trId)
{
    DbTitle* title;
    if (name_ != NULL)
        title = name_->getTitle();
    else {
        name_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0)     // 4f - Nil reference
        return Attribute::open(title, result, OPENRLOCK, trId);
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}



//-----------------------------------------------------------------------
// keySpecifikation::openname

Attribute* keySpecifikation::openname(DbResultCode& result, Attribute* dol)
{
    DbTitle* title;
    if (name_ != NULL)
        title = name_->getTitle();
    else {
        name_->get(theObject, 1, title);
    };
    if (title->getClassIdentity() != 0) {     // 4f - Nil reference
        if (dol == NULL)
	    return Attribute::open(title, result, OPEN, NULL);
        else
            return Attribute::open(title, result, dol);
    }
    else {
	result = OBJECT_NOT_FOUND;
	return NULL;
    }
}


//-----------------------------------------------------------------------
// keySpecifikation::name

void keySpecifikation::name(Attribute* data) // set
{
    if (operation == UPDATE || operation == CREATE) {
	if (name_ &&  name_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete name_;
	if (data)
            name_ = new DbTitleRef(UPDATE, data->getTitle());
	else
	    name_ = DbTitleRef::nilRef();
    }
    else error("keySpecifikation::name");
}



//-----------------------------------------------------------------------
// keySpecifikation::indexStructure

Name keySpecifikation::indexStructure(void) // get
{
    Name temp;
    indexStructure_.get(theObject, 2, temp);
    return temp;
}


//-----------------------------------------------------------------------
// keySpecifikation::indexStructure

void keySpecifikation::indexStructure(Name data) // set
{
    if (operation == UPDATE || operation == CREATE) {
        indexStructure_.set(theObject, 2, data);
    }
    else error("keySpecifikation::indexStructure");
}




//-----------------------------------------------------------------------
// keySpecifikation::prepare

DbResultCode keySpecifikation::prepare()
{
    DbResultCode result = SUCCEEDED;
    int i = 0;
    if (name_ != NULL) {
        DbTitle* title = name_->getTitle();
        DbAbstractObject temp(title, OPEN, result);
        if (result == SUCCEEDED)
            name_->prepare(theObject, &temp);  //byt namn
    }
    return DbAbstractObject::prepare();
}


//-----------------------------------------------------------------------
// keySpecifikation::commit

void keySpecifikation::commit()
{
    if (theObject == NULL)
	return;
    DbTitle* title = NULL;
    int i = 0;
    if (name_ != NULL) {
        name_->commit(theObject, 1);
	if (name_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
	    delete name_;
	name_ = NULL;
    }
    DbAbstractObject::commit();
}


//-----------------------------------------------------------------------
// keySpecifikation::rollback

void keySpecifikation::rollback()
{
    if (theObject == NULL)
	return;
    int i = 0;
    if (name_)
	if (name_->getTitle()->getClassIdentity() != 0)     // 4f - Nil reference
    	    delete name_;
    name_ = NULL;
    DbAbstractObject::rollback();
}







//-- EoF ------------------------------------------------------------
//============ ArrayAttributeType.hh
//=======================================================================

#ifndef _ArrayAttributeType_hh
#define _ArrayAttributeType_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "AttributeType.hh"


//-----------------------------------------------------------------------
// ArrayAttributeType

#ifndef ArrayAttributeType_CLASS_ID
#define ArrayAttributeType_CLASS_ID 7
#endif



class ArrayAttributeType : public AttributeType {
public:
    static ArrayAttributeType* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface
    Integer lowIndex(void); // get
    void lowIndex(Integer data); // set

    Integer highIndex(void); // get
    void highIndex(Integer data); // set


protected:
    // Constructors
    ArrayAttributeType(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    ArrayAttributeType(ClassIdentity classIdentity, DbResultCode& result);

    static ArrayAttributeType* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static ArrayAttributeType* open(DbTitle* title,
	DbResultCode& result,
	ArrayAttributeType* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    IntegerAttribute lowIndex_;
    IntegerAttribute highIndex_;

    friend AttributeType* AttributeType::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend AttributeType* AttributeType::open(DbTitle*, DbResultCode&, AttributeType*);
}; // ArrayAttributeType

#endif
//-- EoF ------------------------------------------------------------
//============ Attribute.hh
//=======================================================================

#ifndef _Attribute_hh
#define _Attribute_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;



//-----------------------------------------------------------------------
// Attribute

#ifndef Attribute_CLASS_ID
#define Attribute_CLASS_ID 5
#endif

class AttributeIterator {
public:
    void reset();
    Attribute* updateNext(DbResultCode& result, LocalTransaction* trId);
    Attribute* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    Attribute* openNext(DbResultCode& result, Attribute* dol = NULL);
protected:
    friend Attribute;
    AttributeIterator();
    AttributeIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    char searchValue[64];
    ObjectIndex index; 
};

class Attribute : public DbAbstractObject {
public:
    static Attribute* create(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Attribute* update(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Attribute* remove(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Attribute* openrlock(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Attribute* open(UniqueName key,
	DbResultCode& result,
	Attribute* dol = NULL);

    int getClassNo();

    static AttributeIterator* getIterator();

    // Attribute interface
    UniqueName name(void); // get
    static AttributeIterator* searchname(UniqueName);

    AttributeType* updatetype(DbResultCode& result, LocalTransaction* trId);
    AttributeType* removetype(DbResultCode& result, LocalTransaction* trId);
    AttributeType* openrlocktype(DbResultCode& result, LocalTransaction* trId);
    AttributeType* opentype(DbResultCode& result, AttributeType* dol = NULL);
    void type(AttributeType* data); // set

    AttributeProperty* updateproperties(DbResultCode& result, LocalTransaction* trId);
    AttributeProperty* removeproperties(DbResultCode& result, LocalTransaction* trId);
    AttributeProperty* openrlockproperties(DbResultCode& result, LocalTransaction* trId);
    AttributeProperty* openproperties(DbResultCode& result, AttributeProperty* dol = NULL);
    void properties(AttributeProperty* data); // set

    Integer attributeIdentity(void); // get
    void attributeIdentity(Integer data); // set
    static AttributeIterator* searchattributeIdentity(Integer);


protected:
    friend AttributeIterator;
    // Constructors
    Attribute(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static Attribute* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static Attribute* open(DbTitle* title,
	DbResultCode& result,
	Attribute* dol);

    void init(DBOperation);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    UniqueNameAttribute name_;
    DbTitleRef* type_;
    DbTitleRef* properties_;
    IntegerAttribute attributeIdentity_;

    friend keySpecifikation;
    friend ClassAttributes;
}; // Attribute

#endif
//-- EoF ------------------------------------------------------------
//============ AttributeProperty.hh
//=======================================================================

#ifndef _AttributeProperty_hh
#define _AttributeProperty_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;



//-----------------------------------------------------------------------
// AttributeProperty

#ifndef AttributeProperty_CLASS_ID
#define AttributeProperty_CLASS_ID 8
#endif


class AttributeProperty : public DbAbstractObject {
public:
    static AttributeProperty* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface
    Boolean null(void); // get
    void null(Boolean data); // set

    Value* updateinitial(DbResultCode& result, LocalTransaction* trId);
    Value* removeinitial(DbResultCode& result, LocalTransaction* trId);
    Value* openrlockinitial(DbResultCode& result, LocalTransaction* trId);
    Value* openinitial(DbResultCode& result, Value* dol = NULL);
    void initial(Value* data); // set

    Value* updatereset(DbResultCode& result, LocalTransaction* trId);
    Value* removereset(DbResultCode& result, LocalTransaction* trId);
    Value* openrlockreset(DbResultCode& result, LocalTransaction* trId);
    Value* openreset(DbResultCode& result, Value* dol = NULL);
    void reset(Value* data); // set


protected:
    // Constructors
    AttributeProperty(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    AttributeProperty(ClassIdentity classIdentity, DbResultCode& result);

    static AttributeProperty* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static AttributeProperty* open(DbTitle* title,
	DbResultCode& result,
	AttributeProperty* dol);

    void init(DBOperation);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    BooleanAttribute null_;
    DbTitleRef* initial_;
    DbTitleRef* reset_;

    friend Attribute;
}; // AttributeProperty

#endif
//-- EoF ------------------------------------------------------------
//============ AttributeType.hh
//=======================================================================

#ifndef _AttributeType_hh
#define _AttributeType_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;



//-----------------------------------------------------------------------
// AttributeType

#ifndef AttributeType_CLASS_ID
#define AttributeType_CLASS_ID 6
#endif


class AttributeType : public DbAbstractObject {
public:
    static AttributeType* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface
    DbEntity* updateitem(DbResultCode& result, LocalTransaction* trId);
    DbEntity* removeitem(DbResultCode& result, LocalTransaction* trId);
    DbEntity* openrlockitem(DbResultCode& result, LocalTransaction* trId);
    DbEntity* openitem(DbResultCode& result, DbEntity* dol = NULL);
    void item(DbEntity* data); // set


protected:
    // Constructors
    AttributeType(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    AttributeType(ClassIdentity classIdentity, DbResultCode& result);

    static AttributeType* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static AttributeType* open(DbTitle* title,
	DbResultCode& result,
	AttributeType* dol);

    void init(DBOperation);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DbTitleRef* item_;

    friend Attribute;
}; // AttributeType

#endif
//-- EoF ------------------------------------------------------------
//============ Boolean.hh
//=======================================================================

#ifndef _Boolean_hh
#define _Boolean_hh


//-----------------------------------------------------------------------
// Boolean

class Boolean {
public:
    // Persistent elements
    Boolean value;

    // Constructor
    Boolean(Boolean);   
    Boolean();   

    // Ranking operators
    Boolean operator==(Boolean);
    Boolean operator<(Boolean);
}; // Boolean

class BooleanAttribute {
public:
    DbResultCode get(DbBaseObject*, AttributeIndex, Boolean&);
    DbResultCode get(DbBaseObject*, AttributeIndex, Boolean&, int index);
    DbResultCode set(DbBaseObject*, AttributeIndex, Boolean);
    DbResultCode set(DbBaseObject*, AttributeIndex, Boolean, int index);

}; // BooleanAttribute

#endif
//-- EoF ------------------------------------------------------------
//============ BooleanValue.hh
//=======================================================================

#ifndef _BooleanValue_hh
#define _BooleanValue_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "PrimitiveValue.hh"


//-----------------------------------------------------------------------
// BooleanValue

#ifndef BooleanValue_CLASS_ID
#define BooleanValue_CLASS_ID 13
#endif



class BooleanValue : public PrimitiveValue {
public:
    static BooleanValue* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface
    Boolean value(void); // get
    void value(Boolean data); // set


protected:
    // Constructors
    BooleanValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    BooleanValue(ClassIdentity classIdentity, DbResultCode& result);

    static BooleanValue* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static BooleanValue* open(DbTitle* title,
	DbResultCode& result,
	BooleanValue* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    BooleanAttribute value_;

    friend PrimitiveValue* PrimitiveValue::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend PrimitiveValue* PrimitiveValue::open(DbTitle*, DbResultCode&, PrimitiveValue*);
    friend Value* Value::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend Value* Value::open(DbTitle*, DbResultCode&, Value*);
}; // BooleanValue

#endif
//-- EoF ------------------------------------------------------------
//============ Class.hh
//=======================================================================

#ifndef _Class_hh
#define _Class_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "DbObject.hh"


//-----------------------------------------------------------------------
// Class

#ifndef Class_CLASS_ID
#define Class_CLASS_ID 3
#endif

class ClassIterator {
public:
    void reset();
    Class* updateNext(DbResultCode& result, LocalTransaction* trId);
    Class* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    Class* openNext(DbResultCode& result, Class* dol = NULL);
protected:
    friend Class;
    ClassIterator();
    ClassIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    char searchValue[1];
    ObjectIndex index; 
};


class Class : public DbObject {
public:
    static Class* create(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Class* update(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Class* remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Class* openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Class* open(Name key,
	DbResultCode& result,
	Class* dol = NULL);

    int getClassNo();

    static ClassIterator* getIterator();

    // Attribute interface
    keySpecifikation* updateprimaryKey(DbResultCode& result, LocalTransaction* trId);
    keySpecifikation* removeprimaryKey(DbResultCode& result, LocalTransaction* trId);
    keySpecifikation* openrlockprimaryKey(DbResultCode& result, LocalTransaction* trId);
    keySpecifikation* openprimaryKey(DbResultCode& result, keySpecifikation* dol = NULL);
    void primaryKey(keySpecifikation* data); // set

    Boolean allocate(void); // get
    void allocate(Boolean data); // set
    static ClassIterator* searchallocate(Boolean);

    Class* updatebase(DbResultCode& result, LocalTransaction* trId);
    Class* removebase(DbResultCode& result, LocalTransaction* trId);
    Class* openrlockbase(DbResultCode& result, LocalTransaction* trId);
    Class* openbase(DbResultCode& result, Class* dol = NULL);
    void base(Class* data); // set

    ClassAttributes* createattributes(DbResultCode& result);
    ClassAttributes* openattributes(DbResultCode& result);


protected:
    friend ClassIterator;
    // Constructors
    Class(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static Class* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static Class* open(DbTitle* title,
	DbResultCode& result,
	Class* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DbTitleRef* primaryKey_;
    BooleanAttribute allocate_;
    DbTitleRef* base_;
    ClassAttributes* attributes_;

    friend Class;
    friend Relation;
    friend DbObject* DbObject::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend DbObject* DbObject::open(DbTitle*, DbResultCode&, DbObject*);
    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DbEntity*);
}; // Class

#endif
//-- EoF ------------------------------------------------------------
//============ ClassAttributes.hh
//=======================================================================

#ifndef _ClassAttributes_hh
#define _ClassAttributes_hh

#include "Attribute.hh"


//-----------------------------------------------------------------------
// ClassAttributes

#ifndef ClassAttributes_CLASS_ID
#define ClassAttributes_CLASS_ID 26
#endif

class ClassAttributes : public DbSetAbstractObject {
public:

    void add(Attribute*);
    void sub(Attribute*);
    Attribute* updateNext(DbResultCode& result, LocalTransaction* trId);
    Attribute* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    Attribute* openNext(DbResultCode& result, Attribute* dol = NULL);
    Boolean isMember(Attribute* dol);

protected:
    // Constructors
    ClassAttributes(DbTitle*, DBOperation, Class* mainObject, DbResultCode&);
    ClassAttributes(ClassIdentity classIdentity, Class* mainObject, DbResultCode&);
    // Transaction handling
    DbResultCode prepare();
    void rollbackSubObject();

    friend Class;

private:
    Class* main_Object;
}; // ClassAttributes

#endif
//-- EoF ------------------------------------------------------------
//============ DOL declarations =========================================
//=======================================================================

#ifndef _DOL_H_
#define _DOL_H_

#include "DBH.h"
#include <string.h>

#define Integer int
#define Integer_8 char
#define Integer_16 short
#define Integer_32 int

#define Natural unsigned int
#define Natural_8 unsigned char
#define Natural_16 unsigned short
#define Natural_32 unsigned int

#define Real double
#define Real_32 float
#define Real_64 double

#define Boolean char
#define Boolean_8 char
#define Boolean_32 char

#define Character char
#define Character_8 char


#define TRUE 1
#define FALSE 0

extern void error(char*);
extern void DB_init(void);

#define DbEntity_CLASS_ID 1
#define DbObject_CLASS_ID 2
#define Class_CLASS_ID 3
#define keySpecifikation_CLASS_ID 4
#define Attribute_CLASS_ID 5
#define AttributeType_CLASS_ID 6
#define ArrayAttributeType_CLASS_ID 7
#define AttributeProperty_CLASS_ID 8
#define Value_CLASS_ID 9
#define PrimitiveValue_CLASS_ID 10
#define IntegerValue_CLASS_ID 11
#define FloatValue_CLASS_ID 12
#define BooleanValue_CLASS_ID 13
#define StringValue_CLASS_ID 14
#define NilValue_CLASS_ID 15
#define StructureValue_CLASS_ID 16
#define Relation_CLASS_ID 17
#define Structure_CLASS_ID 18
#define PersistentStructure_CLASS_ID 19
#define DynamicStructure_CLASS_ID 20
#define Element_CLASS_ID 21
#define PersistentElement_CLASS_ID 22
#define PredefinedType_CLASS_ID 23
#define VolatileElement_CLASS_ID 24
#define DynamicString_CLASS_ID 25
#define ClassAttributes_CLASS_ID 26

#endif
//-- EoF ------------------------------------------------------------
//============ DbEntity.hh
//=======================================================================

#ifndef _DbEntity_hh
#define _DbEntity_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;



//-----------------------------------------------------------------------
// DbEntity

#ifndef DbEntity_CLASS_ID
#define DbEntity_CLASS_ID 1
#endif

class DbEntityIterator {
public:
    void reset();
    DbEntity* updateNext(DbResultCode& result, LocalTransaction* trId);
    DbEntity* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    DbEntity* openNext(DbResultCode& result, DbEntity* dol = NULL);
protected:
    friend DbEntity;
    DbEntityIterator();
    DbEntityIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    char searchValue[32];
    ObjectIndex index; 
};

class DbEntity : public DbAbstractObject {
public:
    static DbEntity* create(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DbEntity* update(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DbEntity* remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DbEntity* openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DbEntity* open(Name key,
	DbResultCode& result,
	DbEntity* dol = NULL);

    int getClassNo();

    static DbEntityIterator* getIterator();

    // Attribute interface
    Name name(void); // get
    static DbEntityIterator* searchname(Name);

    DynamicString* updateversion(DbResultCode& result, LocalTransaction* trId);
    DynamicString* removeversion(DbResultCode& result, LocalTransaction* trId);
    DynamicString* openrlockversion(DbResultCode& result, LocalTransaction* trId);
    DynamicString* openversion(DbResultCode& result, DynamicString* dol = NULL);
    void version(DynamicString* data); // set


protected:
    friend DbEntityIterator;
    // Constructors
    DbEntity(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static DbEntity* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static DbEntity* open(DbTitle* title,
	DbResultCode& result,
	DbEntity* dol);

    void init(DBOperation);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    NameAttribute name_;
    DbTitleRef* version_;

    friend AttributeType;
}; // DbEntity

#endif
//-- EoF ------------------------------------------------------------
//============ DbObject.hh
//=======================================================================

#ifndef _DbObject_hh
#define _DbObject_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "DbEntity.hh"


//-----------------------------------------------------------------------
// DbObject

#ifndef DbObject_CLASS_ID
#define DbObject_CLASS_ID 2
#endif

class DbObjectIterator {
public:
    void reset();
    DbObject* updateNext(DbResultCode& result, LocalTransaction* trId);
    DbObject* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    DbObject* openNext(DbResultCode& result, DbObject* dol = NULL);
protected:
    friend DbObject;
    DbObjectIterator();
    DbObjectIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    ObjectIndex index; 
};


class DbObject : public DbEntity {
public:
    static DbObject* create(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DbObject* update(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DbObject* remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DbObject* openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DbObject* open(Name key,
	DbResultCode& result,
	DbObject* dol = NULL);

    int getClassNo();

    static DbObjectIterator* getIterator();

    // Attribute interface

protected:
    friend DbObjectIterator;
    // Constructors
    DbObject(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static DbObject* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static DbObject* open(DbTitle* title,
	DbResultCode& result,
	DbObject* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:

    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DbEntity*);
}; // DbObject

#endif
//-- EoF ------------------------------------------------------------
//============ DynString.hh
//=======================================================================

#ifndef _DynString_hh
#define _DynString_hh


//-----------------------------------------------------------------------
// DynString

class DynString {
public:
    // Persistent elements
    Boolean full;
    Integer_16 length;
    char buffer[200];

    // Constructor
    DynString(Boolean,Integer_16,char *);   
    DynString();   

    // Ranking operators
    Boolean operator==(DynString);
    Boolean operator<(DynString);
}; // DynString

class DynStringAttribute {
public:
    DbResultCode get(DbBaseObject*, AttributeIndex, DynString&);
    DbResultCode get(DbBaseObject*, AttributeIndex, DynString&, int index);
    DbResultCode set(DbBaseObject*, AttributeIndex, DynString);
    DbResultCode set(DbBaseObject*, AttributeIndex, DynString, int index);

}; // DynStringAttribute

#endif
//-- EoF ------------------------------------------------------------
//============ DynamicString.hh
//=======================================================================

#ifndef _DynamicString_hh
#define _DynamicString_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;



//-----------------------------------------------------------------------
// DynamicString

#ifndef DynamicString_CLASS_ID
#define DynamicString_CLASS_ID 25
#endif


class DynamicString : public DbAbstractObject {
public:
    static DynamicString* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface
    DynString string(void); // get
    void string(DynString data); // set

    DynamicString* updatenext(DbResultCode& result, LocalTransaction* trId);
    DynamicString* removenext(DbResultCode& result, LocalTransaction* trId);
    DynamicString* openrlocknext(DbResultCode& result, LocalTransaction* trId);
    DynamicString* opennext(DbResultCode& result, DynamicString* dol = NULL);
    void next(DynamicString* data); // set


protected:
    // Constructors
    DynamicString(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    DynamicString(ClassIdentity classIdentity, DbResultCode& result);

    static DynamicString* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static DynamicString* open(DbTitle* title,
	DbResultCode& result,
	DynamicString* dol);

    void init(DBOperation);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DynStringAttribute string_;
    DbTitleRef* next_;

    friend DbEntity;
    friend StringValue;
    friend DynamicString;
}; // DynamicString

#endif
//-- EoF ------------------------------------------------------------

//============ DynamicStructure.hh
//=======================================================================

#ifndef _DynamicStructure_hh
#define _DynamicStructure_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "Structure.hh"


//-----------------------------------------------------------------------
// DynamicStructure

#ifndef DynamicStructure_CLASS_ID
#define DynamicStructure_CLASS_ID 20
#endif

class DynamicStructureIterator {
public:
    void reset();
    DynamicStructure* updateNext(DbResultCode& result, LocalTransaction* trId);
    DynamicStructure* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    DynamicStructure* openNext(DbResultCode& result, DynamicStructure* dol = NULL);
protected:
    friend DynamicStructure;
    DynamicStructureIterator();
    DynamicStructureIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    ObjectIndex index; 
};


class DynamicStructure : public Structure {
public:
    static DynamicStructure* create(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DynamicStructure* update(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DynamicStructure* remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DynamicStructure* openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static DynamicStructure* open(Name key,
	DbResultCode& result,
	DynamicStructure* dol = NULL);

    int getClassNo();

    static DynamicStructureIterator* getIterator();

    // Attribute interface
    PersistentElement* updatedynamic(DbResultCode& result, LocalTransaction* trId);
    PersistentElement* removedynamic(DbResultCode& result, LocalTransaction* trId);
    PersistentElement* openrlockdynamic(DbResultCode& result, LocalTransaction* trId);
    PersistentElement* opendynamic(DbResultCode& result, PersistentElement* dol = NULL);
    void dynamic(PersistentElement* data); // set


protected:
    friend DynamicStructureIterator;
    // Constructors
    DynamicStructure(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static DynamicStructure* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static DynamicStructure* open(DbTitle* title,
	DbResultCode& result,
	DynamicStructure* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DbTitleRef* dynamic_;

    friend Structure* Structure::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend Structure* Structure::open(DbTitle*, DbResultCode&, Structure*);
    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DbEntity*);
}; // DynamicStructure

#endif
//-- EoF ------------------------------------------------------------
//============ Element.hh
//=======================================================================

#ifndef _Element_hh
#define _Element_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;



//-----------------------------------------------------------------------
// Element

#ifndef Element_CLASS_ID
#define Element_CLASS_ID 21
#endif

class ElementIterator {
public:
    void reset();
    Element* updateNext(DbResultCode& result, LocalTransaction* trId);
    Element* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    Element* openNext(DbResultCode& result, Element* dol = NULL);
protected:
    friend Element;
    ElementIterator();
    ElementIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    char searchValue[64];
    ObjectIndex index; 
};

class Element : public DbAbstractObject {
public:
    static Element* create(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Element* update(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Element* remove(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Element* openrlock(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Element* open(UniqueName key,
	DbResultCode& result,
	Element* dol = NULL);

    int getClassNo();

    static ElementIterator* getIterator();

    // Attribute interface
    UniqueName name(void); // get
    static ElementIterator* searchname(UniqueName);

    Element* updatenext(DbResultCode& result, LocalTransaction* trId);
    Element* removenext(DbResultCode& result, LocalTransaction* trId);
    Element* openrlocknext(DbResultCode& result, LocalTransaction* trId);
    Element* opennext(DbResultCode& result, Element* dol = NULL);
    void next(Element* data); // set


protected:
    friend ElementIterator;
    // Constructors
    Element(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static Element* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static Element* open(DbTitle* title,
	DbResultCode& result,
	Element* dol);

    void init(DBOperation);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    UniqueNameAttribute name_;
    DbTitleRef* next_;

    friend Element;
}; // Element

#endif
//-- EoF ------------------------------------------------------------
//============ Float.hh
//=======================================================================

#ifndef _Float_hh
#define _Float_hh


//-----------------------------------------------------------------------
// Float

class Float {
public:
    // Persistent elements
    Real_64 value;

    // Constructor
    Float(Real_64);   
    Float();   

    // Ranking operators
    Boolean operator==(Float);
    Boolean operator<(Float);
}; // Float

class FloatAttribute {
public:
    DbResultCode get(DbBaseObject*, AttributeIndex, Float&);
    DbResultCode get(DbBaseObject*, AttributeIndex, Float&, int index);
    DbResultCode set(DbBaseObject*, AttributeIndex, Float);
    DbResultCode set(DbBaseObject*, AttributeIndex, Float, int index);

}; // FloatAttribute

#endif
//-- EoF ------------------------------------------------------------
//============ FloatValue.hh
//=======================================================================

#ifndef _FloatValue_hh
#define _FloatValue_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "PrimitiveValue.hh"


//-----------------------------------------------------------------------
// FloatValue

#ifndef FloatValue_CLASS_ID
#define FloatValue_CLASS_ID 12
#endif



class FloatValue : public PrimitiveValue {
public:
    static FloatValue* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface
    Float value(void); // get
    void value(Float data); // set


protected:
    // Constructors
    FloatValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    FloatValue(ClassIdentity classIdentity, DbResultCode& result);

    static FloatValue* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static FloatValue* open(DbTitle* title,
	DbResultCode& result,
	FloatValue* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    FloatAttribute value_;

    friend PrimitiveValue* PrimitiveValue::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend PrimitiveValue* PrimitiveValue::open(DbTitle*, DbResultCode&, PrimitiveValue*);
    friend Value* Value::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend Value* Value::open(DbTitle*, DbResultCode&, Value*);
}; // FloatValue

#endif
//-- EoF ------------------------------------------------------------
//============ Integer.hh
//=======================================================================

#ifndef _Integer_hh
#define _Integer_hh


//-----------------------------------------------------------------------
// Integer

class Integer {
public:
    // Persistent elements
    Integer_32 value;

    // Constructor
    Integer(Integer_32);   
    Integer();   

    // Ranking operators
    Boolean operator==(Integer);
    Boolean operator<(Integer);
}; // Integer

class IntegerAttribute {
public:
    DbResultCode get(DbBaseObject*, AttributeIndex, Integer&);
    DbResultCode get(DbBaseObject*, AttributeIndex, Integer&, int index);
    DbResultCode set(DbBaseObject*, AttributeIndex, Integer);
    DbResultCode set(DbBaseObject*, AttributeIndex, Integer, int index);

}; // IntegerAttribute

#endif
//-- EoF ------------------------------------------------------------
//============ IntegerValue.hh
//=======================================================================

#ifndef _IntegerValue_hh
#define _IntegerValue_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "PrimitiveValue.hh"


//-----------------------------------------------------------------------
// IntegerValue

#ifndef IntegerValue_CLASS_ID
#define IntegerValue_CLASS_ID 11
#endif



class IntegerValue : public PrimitiveValue {
public:
    static IntegerValue* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface
    Integer value(void); // get
    void value(Integer data); // set


protected:
    // Constructors
    IntegerValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    IntegerValue(ClassIdentity classIdentity, DbResultCode& result);

    static IntegerValue* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static IntegerValue* open(DbTitle* title,
	DbResultCode& result,
	IntegerValue* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    IntegerAttribute value_;

    friend PrimitiveValue* PrimitiveValue::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend PrimitiveValue* PrimitiveValue::open(DbTitle*, DbResultCode&, PrimitiveValue*);
    friend Value* Value::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend Value* Value::open(DbTitle*, DbResultCode&, Value*);
}; // IntegerValue

#endif
//-- EoF ------------------------------------------------------------
//============ Name.hh
//=======================================================================

#ifndef _Name_hh
#define _Name_hh


//-----------------------------------------------------------------------
// Name

class Name {
public:
    // Persistent elements
    char value[32];

    // Constructor
    Name(char *);   
    Name();   

    // Ranking operators
    Boolean operator==(Name);
    Boolean operator<(Name);
}; // Name

class NameAttribute {
public:
    DbResultCode get(DbBaseObject*, AttributeIndex, Name&);
    DbResultCode get(DbBaseObject*, AttributeIndex, Name&, int index);
    DbResultCode set(DbBaseObject*, AttributeIndex, Name);
    DbResultCode set(DbBaseObject*, AttributeIndex, Name, int index);

}; // NameAttribute

#endif
//-- EoF ------------------------------------------------------------
//============ NilValue.hh
//=======================================================================

#ifndef _NilValue_hh
#define _NilValue_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "PrimitiveValue.hh"


//-----------------------------------------------------------------------
// NilValue

#ifndef NilValue_CLASS_ID
#define NilValue_CLASS_ID 15
#endif



class NilValue : public PrimitiveValue {
public:
    static NilValue* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface

protected:
    // Constructors
    NilValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    NilValue(ClassIdentity classIdentity, DbResultCode& result);

    static NilValue* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static NilValue* open(DbTitle* title,
	DbResultCode& result,
	NilValue* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:

    friend PrimitiveValue* PrimitiveValue::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend PrimitiveValue* PrimitiveValue::open(DbTitle*, DbResultCode&, PrimitiveValue*);
    friend Value* Value::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend Value* Value::open(DbTitle*, DbResultCode&, Value*);
}; // NilValue

#endif
//-- EoF ------------------------------------------------------------
//============ PersistentElement.hh
//=======================================================================

#ifndef _PersistentElement_hh
#define _PersistentElement_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "Element.hh"


//-----------------------------------------------------------------------
// PersistentElement

#ifndef PersistentElement_CLASS_ID
#define PersistentElement_CLASS_ID 22
#endif

class PersistentElementIterator {
public:
    void reset();
    PersistentElement* updateNext(DbResultCode& result, LocalTransaction* trId);
    PersistentElement* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    PersistentElement* openNext(DbResultCode& result, PersistentElement* dol = NULL);
protected:
    friend PersistentElement;
    PersistentElementIterator();
    PersistentElementIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    char searchValue[4];
    ObjectIndex index; 
};


class PersistentElement : public Element {
public:
    static PersistentElement* create(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PersistentElement* update(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PersistentElement* remove(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PersistentElement* openrlock(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PersistentElement* open(UniqueName key,
	DbResultCode& result,
	PersistentElement* dol = NULL);

    int getClassNo();

    static PersistentElementIterator* getIterator();

    // Attribute interface
    PredefinedType* updatetype(DbResultCode& result, LocalTransaction* trId);
    PredefinedType* removetype(DbResultCode& result, LocalTransaction* trId);
    PredefinedType* openrlocktype(DbResultCode& result, LocalTransaction* trId);
    PredefinedType* opentype(DbResultCode& result, PredefinedType* dol = NULL);
    void type(PredefinedType* data); // set

    Integer size(void); // get
    void size(Integer data); // set
    static PersistentElementIterator* searchsize(Integer);


protected:
    friend PersistentElementIterator;
    // Constructors
    PersistentElement(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static PersistentElement* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static PersistentElement* open(DbTitle* title,
	DbResultCode& result,
	PersistentElement* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DbTitleRef* type_;
    IntegerAttribute size_;

    friend PersistentStructure;
    friend DynamicStructure;
    friend Element* Element::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend Element* Element::open(DbTitle*, DbResultCode&, Element*);
}; // PersistentElement

#endif
//-- EoF ------------------------------------------------------------
//============ PersistentStructure.hh
//=======================================================================

#ifndef _PersistentStructure_hh
#define _PersistentStructure_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "Structure.hh"


//-----------------------------------------------------------------------
// PersistentStructure

#ifndef PersistentStructure_CLASS_ID
#define PersistentStructure_CLASS_ID 19
#endif

class PersistentStructureIterator {
public:
    void reset();
    PersistentStructure* updateNext(DbResultCode& result, LocalTransaction* trId);
    PersistentStructure* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    PersistentStructure* openNext(DbResultCode& result, PersistentStructure* dol = NULL);
protected:
    friend PersistentStructure;
    PersistentStructureIterator();
    PersistentStructureIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    ObjectIndex index; 
};


class PersistentStructure : public Structure {
public:
    static PersistentStructure* create(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PersistentStructure* update(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PersistentStructure* remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PersistentStructure* openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PersistentStructure* open(Name key,
	DbResultCode& result,
	PersistentStructure* dol = NULL);

    int getClassNo();

    static PersistentStructureIterator* getIterator();

    // Attribute interface
    PersistentElement* updatepersistent(DbResultCode& result, LocalTransaction* trId);
    PersistentElement* removepersistent(DbResultCode& result, LocalTransaction* trId);
    PersistentElement* openrlockpersistent(DbResultCode& result, LocalTransaction* trId);
    PersistentElement* openpersistent(DbResultCode& result, PersistentElement* dol = NULL);
    void persistent(PersistentElement* data); // set


protected:
    friend PersistentStructureIterator;
    // Constructors
    PersistentStructure(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static PersistentStructure* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static PersistentStructure* open(DbTitle* title,
	DbResultCode& result,
	PersistentStructure* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DbTitleRef* persistent_;

    friend Structure* Structure::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend Structure* Structure::open(DbTitle*, DbResultCode&, Structure*);
    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DbEntity*);
}; // PersistentStructure

#endif
//-- EoF ------------------------------------------------------------
//============ PredefinedType.hh
//=======================================================================

#ifndef _PredefinedType_hh
#define _PredefinedType_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;



//-----------------------------------------------------------------------
// PredefinedType

#ifndef PredefinedType_CLASS_ID
#define PredefinedType_CLASS_ID 23
#endif

class PredefinedTypeIterator {
public:
    void reset();
    PredefinedType* updateNext(DbResultCode& result, LocalTransaction* trId);
    PredefinedType* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    PredefinedType* openNext(DbResultCode& result, PredefinedType* dol = NULL);
protected:
    friend PredefinedType;
    PredefinedTypeIterator();
    PredefinedTypeIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    char searchValue[32];
    ObjectIndex index; 
};

class PredefinedType : public DbAbstractObject {
public:
    static PredefinedType* create(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PredefinedType* update(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PredefinedType* remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PredefinedType* openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static PredefinedType* open(Name key,
	DbResultCode& result,
	PredefinedType* dol = NULL);

    int getClassNo();

    static PredefinedTypeIterator* getIterator();

    // Attribute interface
    Name name(void); // get
    static PredefinedTypeIterator* searchname(Name);


protected:
    friend PredefinedTypeIterator;
    // Constructors
    PredefinedType(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static PredefinedType* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static PredefinedType* open(DbTitle* title,
	DbResultCode& result,
	PredefinedType* dol);

    void init(DBOperation);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    NameAttribute name_;

    friend PersistentElement;
}; // PredefinedType

#endif
//-- EoF ------------------------------------------------------------
//============ PrimitiveValue.hh
//=======================================================================

#ifndef _PrimitiveValue_hh
#define _PrimitiveValue_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "Value.hh"


//-----------------------------------------------------------------------
// PrimitiveValue

#ifndef PrimitiveValue_CLASS_ID
#define PrimitiveValue_CLASS_ID 10
#endif



class PrimitiveValue : public Value {
public:
    static PrimitiveValue* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface

protected:
    // Constructors
    PrimitiveValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    PrimitiveValue(ClassIdentity classIdentity, DbResultCode& result);

    static PrimitiveValue* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static PrimitiveValue* open(DbTitle* title,
	DbResultCode& result,
	PrimitiveValue* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:

    friend StructureValue;
    friend Value* Value::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend Value* Value::open(DbTitle*, DbResultCode&, Value*);
}; // PrimitiveValue

#endif
//-- EoF ------------------------------------------------------------
//============ Relation.hh
//=======================================================================

#ifndef _Relation_hh
#define _Relation_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "DbObject.hh"


//-----------------------------------------------------------------------
// Relation

#ifndef Relation_CLASS_ID
#define Relation_CLASS_ID 17
#endif

class RelationIterator {
public:
    void reset();
    Relation* updateNext(DbResultCode& result, LocalTransaction* trId);
    Relation* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    Relation* openNext(DbResultCode& result, Relation* dol = NULL);
protected:
    friend Relation;
    RelationIterator();
    RelationIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    ObjectIndex index; 
};


class Relation : public DbObject {
public:
    static Relation* create(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Relation* update(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Relation* remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Relation* openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Relation* open(Name key,
	DbResultCode& result,
	Relation* dol = NULL);

    int getClassNo();

    static RelationIterator* getIterator();

    // Attribute interface
    Class* updatefrom(DbResultCode& result, LocalTransaction* trId);
    Class* removefrom(DbResultCode& result, LocalTransaction* trId);
    Class* openrlockfrom(DbResultCode& result, LocalTransaction* trId);
    Class* openfrom(DbResultCode& result, Class* dol = NULL);
    void from(Class* data); // set

    Class* updateto(DbResultCode& result, LocalTransaction* trId);
    Class* removeto(DbResultCode& result, LocalTransaction* trId);
    Class* openrlockto(DbResultCode& result, LocalTransaction* trId);
    Class* opento(DbResultCode& result, Class* dol = NULL);
    void to(Class* data); // set


protected:
    friend RelationIterator;
    // Constructors
    Relation(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static Relation* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static Relation* open(DbTitle* title,
	DbResultCode& result,
	Relation* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DbTitleRef* from_;
    DbTitleRef* to_;

    friend DbObject* DbObject::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend DbObject* DbObject::open(DbTitle*, DbResultCode&, DbObject*);
    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DbEntity*);
}; // Relation

#endif
//-- EoF ------------------------------------------------------------
//============ StringValue.hh
//=======================================================================

#ifndef _StringValue_hh
#define _StringValue_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "PrimitiveValue.hh"


//-----------------------------------------------------------------------
// StringValue

#ifndef StringValue_CLASS_ID
#define StringValue_CLASS_ID 14
#endif



class StringValue : public PrimitiveValue {
public:
    static StringValue* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface
    DynamicString* updatevalue(DbResultCode& result, LocalTransaction* trId);
    DynamicString* removevalue(DbResultCode& result, LocalTransaction* trId);
    DynamicString* openrlockvalue(DbResultCode& result, LocalTransaction* trId);
    DynamicString* openvalue(DbResultCode& result, DynamicString* dol = NULL);
    void value(DynamicString* data); // set


protected:
    // Constructors
    StringValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    StringValue(ClassIdentity classIdentity, DbResultCode& result);

    static StringValue* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static StringValue* open(DbTitle* title,
	DbResultCode& result,
	StringValue* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DbTitleRef* value_;

    friend PrimitiveValue* PrimitiveValue::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend PrimitiveValue* PrimitiveValue::open(DbTitle*, DbResultCode&, PrimitiveValue*);
    friend Value* Value::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend Value* Value::open(DbTitle*, DbResultCode&, Value*);
}; // StringValue

#endif
//-- EoF ------------------------------------------------------------
//============ Structure.hh
//=======================================================================

#ifndef _Structure_hh
#define _Structure_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "DbEntity.hh"


//-----------------------------------------------------------------------
// Structure

#ifndef Structure_CLASS_ID
#define Structure_CLASS_ID 18
#endif

class StructureIterator {
public:
    void reset();
    Structure* updateNext(DbResultCode& result, LocalTransaction* trId);
    Structure* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    Structure* openNext(DbResultCode& result, Structure* dol = NULL);
protected:
    friend Structure;
    StructureIterator();
    StructureIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    ObjectIndex index; 
};


class Structure : public DbEntity {
public:
    static Structure* create(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Structure* update(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Structure* remove(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Structure* openrlock(Name key,
	DbResultCode& result,
	LocalTransaction* trId);

    static Structure* open(Name key,
	DbResultCode& result,
	Structure* dol = NULL);

    int getClassNo();

    static StructureIterator* getIterator();

    // Attribute interface
    VolatileElement* updatevolatile(DbResultCode& result, LocalTransaction* trId);
    VolatileElement* removevolatile(DbResultCode& result, LocalTransaction* trId);
    VolatileElement* openrlockvolatile(DbResultCode& result, LocalTransaction* trId);
    VolatileElement* openvolatile(DbResultCode& result, VolatileElement* dol = NULL);
    void volatile(VolatileElement* data); // set


protected:
    friend StructureIterator;
    // Constructors
    Structure(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static Structure* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static Structure* open(DbTitle* title,
	DbResultCode& result,
	Structure* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DbTitleRef* volatile_;

    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend DbEntity* DbEntity::open(DbTitle*, DbResultCode&, DbEntity*);
}; // Structure

#endif
//-- EoF ------------------------------------------------------------
//============ StructureValue.hh
//=======================================================================

#ifndef _StructureValue_hh
#define _StructureValue_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "Value.hh"


//-----------------------------------------------------------------------
// StructureValue

#ifndef StructureValue_CLASS_ID
#define StructureValue_CLASS_ID 16
#endif



class StructureValue : public Value {
public:
    static StructureValue* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface
    PrimitiveValue* updatevalues(DbResultCode& result, LocalTransaction* trId);
    PrimitiveValue* removevalues(DbResultCode& result, LocalTransaction* trId);
    PrimitiveValue* openrlockvalues(DbResultCode& result, LocalTransaction* trId);
    PrimitiveValue* openvalues(DbResultCode& result, PrimitiveValue* dol = NULL);
    void values(PrimitiveValue* data); // set


protected:
    // Constructors
    StructureValue(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    StructureValue(ClassIdentity classIdentity, DbResultCode& result);

    static StructureValue* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static StructureValue* open(DbTitle* title,
	DbResultCode& result,
	StructureValue* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DbTitleRef* values_;

    friend Value* Value::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend Value* Value::open(DbTitle*, DbResultCode&, Value*);
}; // StructureValue

#endif
//-- EoF ------------------------------------------------------------
//============ UniqueName.hh
//=======================================================================

#ifndef _UniqueName_hh
#define _UniqueName_hh


//-----------------------------------------------------------------------
// UniqueName

class UniqueName {
public:
    // Persistent elements
    char base[32];
    char name[32];

    // Constructor
    UniqueName(char *,char *);   
    UniqueName();   

    // Ranking operators
    Boolean operator==(UniqueName);
    Boolean operator<(UniqueName);
}; // UniqueName

class UniqueNameAttribute {
public:
    DbResultCode get(DbBaseObject*, AttributeIndex, UniqueName&);
    DbResultCode get(DbBaseObject*, AttributeIndex, UniqueName&, int index);
    DbResultCode set(DbBaseObject*, AttributeIndex, UniqueName);
    DbResultCode set(DbBaseObject*, AttributeIndex, UniqueName, int index);

}; // UniqueNameAttribute

#endif
//-- EoF ------------------------------------------------------------
//============ Value.hh
//=======================================================================

#ifndef _Value_hh
#define _Value_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;



//-----------------------------------------------------------------------
// Value

#ifndef Value_CLASS_ID
#define Value_CLASS_ID 9
#endif


class Value : public DbAbstractObject {
public:
    static Value* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface
    Value* updatenext(DbResultCode& result, LocalTransaction* trId);
    Value* removenext(DbResultCode& result, LocalTransaction* trId);
    Value* openrlocknext(DbResultCode& result, LocalTransaction* trId);
    Value* opennext(DbResultCode& result, Value* dol = NULL);
    void next(Value* data); // set


protected:
    // Constructors
    Value(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    Value(ClassIdentity classIdentity, DbResultCode& result);

    static Value* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static Value* open(DbTitle* title,
	DbResultCode& result,
	Value* dol);

    void init(DBOperation);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DbTitleRef* next_;

    friend AttributeProperty;
    friend Value;
}; // Value

#endif
//-- EoF ------------------------------------------------------------
//============ VolatileElement.hh
//=======================================================================

#ifndef _VolatileElement_hh
#define _VolatileElement_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;

// Include superclass:
#include "Element.hh"


//-----------------------------------------------------------------------
// VolatileElement

#ifndef VolatileElement_CLASS_ID
#define VolatileElement_CLASS_ID 24
#endif

class VolatileElementIterator {
public:
    void reset();
    VolatileElement* updateNext(DbResultCode& result, LocalTransaction* trId);
    VolatileElement* openrlockNext(DbResultCode& result, LocalTransaction* trId);
    VolatileElement* openNext(DbResultCode& result, VolatileElement* dol = NULL);
protected:
    friend VolatileElement;
    VolatileElementIterator();
    VolatileElementIterator(AttributeIndex attr, void* value, int length);
    AttributeIndex attrNumber;
    char searchValue[32];
    ObjectIndex index; 
};


class VolatileElement : public Element {
public:
    static VolatileElement* create(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static VolatileElement* update(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static VolatileElement* remove(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static VolatileElement* openrlock(UniqueName key,
	DbResultCode& result,
	LocalTransaction* trId);

    static VolatileElement* open(UniqueName key,
	DbResultCode& result,
	VolatileElement* dol = NULL);

    int getClassNo();

    static VolatileElementIterator* getIterator();

    // Attribute interface
    Name type(void); // get
    void type(Name data); // set
    static VolatileElementIterator* searchtype(Name);


protected:
    friend VolatileElementIterator;
    // Constructors
    VolatileElement(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    static VolatileElement* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static VolatileElement* open(DbTitle* title,
	DbResultCode& result,
	VolatileElement* dol);

    void init(DBOperation, Boolean initBase = FALSE);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    NameAttribute type_;

    friend Structure;
    friend Element* Element::open(DbTitle*, DbResultCode&, DBOperation, LocalTransaction*);
    friend Element* Element::open(DbTitle*, DbResultCode&, Element*);
}; // VolatileElement

#endif
//-- EoF ------------------------------------------------------------
//============ keySpecifikation.hh
//=======================================================================

#ifndef _keySpecifikation_hh
#define _keySpecifikation_hh

#include "DynString.hh"
#include "Boolean.hh"
#include "Integer.hh"
#include "Float.hh"
#include "UniqueName.hh"
#include "Name.hh"
//=======================================================================
// Forward declarations of relations
class ClassAttributes;
//=======================================================================
// Forward declarations of classes
class DbEntity;
class DbObject;
class Class;
class keySpecifikation;
class Attribute;
class AttributeType;
class ArrayAttributeType;
class AttributeProperty;
class Value;
class PrimitiveValue;
class IntegerValue;
class FloatValue;
class BooleanValue;
class StringValue;
class NilValue;
class StructureValue;
class Relation;
class Structure;
class PersistentStructure;
class DynamicStructure;
class Element;
class PersistentElement;
class PredefinedType;
class VolatileElement;
class DynamicString;



//-----------------------------------------------------------------------
// keySpecifikation

#ifndef keySpecifikation_CLASS_ID
#define keySpecifikation_CLASS_ID 4
#endif


class keySpecifikation : public DbAbstractObject {
public:
    static keySpecifikation* create(DbResultCode& result, LocalTransaction* trId);

    int getClassNo();


    // Attribute interface
    Attribute* updatename(DbResultCode& result, LocalTransaction* trId);
    Attribute* removename(DbResultCode& result, LocalTransaction* trId);
    Attribute* openrlockname(DbResultCode& result, LocalTransaction* trId);
    Attribute* openname(DbResultCode& result, Attribute* dol = NULL);
    void name(Attribute* data); // set

    Name indexStructure(void); // get
    void indexStructure(Name data); // set


protected:
    // Constructors
    keySpecifikation(DbBaseObject* object,
	DbBaseObject* tempObject,
	DBOperation op,
	LocalTransaction* trId,
        DbTitle* title);

    keySpecifikation(ClassIdentity classIdentity, DbResultCode& result);

    static keySpecifikation* open(DbTitle* title,
	DbResultCode& result,
	DBOperation op,
	LocalTransaction* trId);

    static keySpecifikation* open(DbTitle* title,
	DbResultCode& result,
	keySpecifikation* dol);

    void init(DBOperation);

    // Transaction handling
    DbResultCode prepare();
    void commit();
    void rollback();

private:
    DbTitleRef* name_;
    NameAttribute indexStructure_;

    friend Class;
}; // keySpecifikation

#endif
//-- EoF ------------------------------------------------------------
4
1
6
1
0
0

1
2
_GEN_KEY_
0


2
1
32
1
item
0

3
0
4
0
lowIndex
0

4
0
4
0
highIndex
0
4
1
0
1
0
0

1
64
name
0


2
1
2
1
type
0

3
1
2
1
properties
0

4
0
4
0
attributeIdentity
0
4
1
0
1
0
0

1
2
_GEN_KEY_
0


2
0
1
0
null
0

3
1
2
1
initial
0

4
1
2
1
reset
0
2
1
0
1
0
0

1
2
_GEN_KEY_
0


2
1
32
1
item
0
3
1
10
1
0
0

1
2
_GEN_KEY_
0


2
1
2
1
next
0

3
0
1
0
value
0
6
1
2
0
0
0

1
32
name
0


2
1
2
1
version
0

3
1
2
1
primaryKey
0

4
0
1
0
allocate
0

5
1
32
1
base
0

6
2
0
2
attributes
0
0
0
0
0
0
1
2
1
0
1
0
0

1
32
name
0


2
1
2
1
version
0
2
1
1
0
0
0

1
32
name
0


2
1
2
1
version
0
3
1
0
1
0
0

1
2
_GEN_KEY_
0


2
0
203
0
string
0

3
1
2
1
next
0
4
1
18
0
0
0

1
32
name
0


2
1
2
1
version
0

3
1
64
1
volatile
0

4
1
64
1
dynamic
0
2
1
0
1
0
0

1
64
name
0


2
1
64
1
next
0
3
1
10
1
0
0

1
2
_GEN_KEY_
0


2
1
2
1
next
0

3
0
8
0
value
0
3
1
10
1
0
0

1
2
_GEN_KEY_
0


2
1
2
1
next
0

3
0
4
0
value
0
2
1
10
1
0
0

1
2
_GEN_KEY_
0


2
1
2
1
next
0
4
1
21
0
0
0

1
64
name
0


2
1
64
1
next
0

3
1
32
1
type
0

4
0
4
0
size
0
4
1
18
0
0
0

1
32
name
0


2
1
2
1
version
0

3
1
64
1
volatile
0

4
1
64
1
persistent
0
1
1
0
1
0
0

1
32
name
0

2
1
9
1
0
0

1
2
_GEN_KEY_
0


2
1
2
1
next
0
4
1
2
0
0
0

1
32
name
0


2
1
2
1
version
0

3
1
32
1
from
0

4
1
32
1
to
0
3
1
10
1
0
0

1
2
_GEN_KEY_
0


2
1
2
1
next
0

3
1
2
1
value
0
3
1
1
0
0
0

1
32
name
0


2
1
2
1
version
0

3
1
64
1
volatile
0
3
1
9
1
0
0

1
2
_GEN_KEY_
0


2
1
2
1
next
0

3
1
2
1
values
0
2
1
0
1
0
0

1
2
_GEN_KEY_
0


2
1
2
1
next
0
3
1
21
0
0
0

1
64
name
0


2
1
64
1
next
0

3
0
32
0
type
0
3
1
0
1
0
0

1
2
_GEN_KEY_
0


2
1
64
1
name
0

3
0
32
0
indexStructure
0
