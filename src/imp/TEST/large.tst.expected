########## large ##########
DOCUMENT DBDDH;

DECLARE;

!BEGIN SQL COMMON 0!

%%SET pzVersion("1.02 ")

%%SET tables()

%%SET tabNos()

%%SET remTables()

%%SET remTabNos()

%%SET tableOwner()

%%SET tableUser()

!END SQL!


!*****************************************************************************!
!*                                                                           *! 
!*             G L O B A L   S Y M B O L S                                   *!
!*                                                                           *!
!*****************************************************************************!


 ! GLOBAL NSYMB ZTOWFUCODE = 162  !
 
 
 
 
 
 
 
 
 
!*****************************************************************************!
!*                                                                           *! 
!*             L O C A L   S Y M B O L S                                     *!
!*                                                                           *!
!*****************************************************************************! 
 



! TEMPORARILY DECLARED PLEX SQL SYMBOL VALUES !


NSYMB ZTOWFUCODE = 162;



!  NSYMB TABLESSTATEBLOCKED=0
NSYMB TABLESSTATEWORKING=1  
NSYMB TABLESLOCATESINGLE=0
NSYMB TABLESLOCATEMULTI=1

NSYMB FIELDSVISIBILINVIS=0
NSYMB FIELDSVISIBILREADO=1
NSYMB FIELDSVISIBILREADWR=2

NSYMB FIELDSNULLPERFALSE=1
NSYMB FIELDSNULLPERTRUE=0

NSYMB FIELDSDATATYPBITS = 0
NSYMB FIELDSDATATYPSTRING = 1
NSYMB FIELDSDATATYPNUMSTR = 2
NSYMB FIELDSDATATYPPNUMSTR = 3
NSYMB FIELDSDATATYPSYMBOL = 4
NSYMB FIELDSDATATYPROWNUM = 5
NSYMB FIELDSDATATYPDBNUM = 6

NSYMB FIELDSCLEARYES = 0
NSYMB FIELDSCLEARNO = 1
NSYMB FIELDSRELOADYES = 0
NSYMB FIELDSRELOADNO = 1
NSYMB FIELDSDUMPYES = 0
NSYMB FIELDSDUMPNO = 1
NSYMB FIELDSSTATICYES = 0
NSYMB FIELDSSTATICNO = 1
NSYMB FIELDSVOLATILYES = 0
NSYMB FIELDSVOLATILNO = 1

NSYMB KEYSKEYTYPEPRIMKEY = 0
NSYMB KEYSKEYTYPEALTERN = 1
NSYMB KEYSKEYTYPEINDKEY = 2

NSYMB FOREIGNKEYSCONDRESTR = 0
NSYMB FOREIGNKEYSCONDCASCAD = 1
NSYMB FOREIGNKEYSCONDSETNULL = 2
NSYMB FOREIGNKEYSCONDSETDEF = 3     !



             
 
STRING ZFIELDS= "FIELDS";          ! USED IN PROGERROR !
STRING ZFOREIGNKEYS= "FOREIGNKEYS";! USED IN PROGERROR !
STRING ZTABLES= "TABLES";         ! USED IN PROGERROR !


                                        
                                        
NSYMB ZBITS=0;                              ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZBLOCKCAT = 2;                        ! BLOCK CATEGORY. USED IN STTOR    !
NSYMB ZCONGESTION=4;                        ! CONGESTION IN KEED.              !
NSYMB ZDBNUMBER=6;                          ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZDBSINTERNALPHASE1 = 1;
NSYMB ZDBSINTERNALPHASE2 = 2;
NSYMB ZDBSINTERNALPHASE3 = 3;
NSYMB ZDBSINTERNALPHASE4 = 4;
NSYMB ZDDFCSTA=0;                           ! CURRENT SIGNAL = DDFCSTA         !
NSYMB ZDDRESPART=1;                         ! CURRENT SIGNAL = DDRESPART       !
NSYMB ZDONOTLOG=1;                          ! DO NOT LOG THE TRANSACTION       !
NSYMB ZDONOTPARTICIPATE=1;                  ! BLOCK IS NOT INVOLVED IN RESTART !
NSYMB ZERROR=3;                             ! SQLCODE.VALUE FAULT RESOLUTION   !
NSYMB ZFIRSTFK=0;                           ! FIRST FOREIGN KEY OF TRANSACTION !
NSYMB ZFIRSTORDNO = 0;                      ! ORDINAL NUMBER OF FIRST FK TO TAB!
NSYMB ZFKFOUND = 0;                         ! A FOREIGN KEY IS FOUND           !
NSYMB ZFKNOTFOUND = 1;                      ! A FOREIGN KEY IS NOT FOUND       !
NSYMB ZFUNCTIONCHANGE=2;                    ! EVENT = FUNCTION CHANGE          !
NSYMB ZINFOONLEVELC=#1000;                  ! INFORMATION ON LEVEL C           !
NSYMB ZLARGERELOAD=2;                       ! LARGE RESTART WITH RELOAD        !
NSYMB ZLARGERESTART=1;                      ! LARGE RESTART WITHOUT RELOAD     !
NSYMB ZMAXNOFBLOCKS=65535;                  ! DETERMINES THE MAXIMUM NUMBER OF !
                                            ! BLOCKS THAT MAY BE AFFECTED BY A !
                                            ! FUNCTION CHANGE FOLLOWED BY A    !
                                      ! SPECIFY. SMALL RESTART.                !
NSYMB ZMAXNOFROWS = 65531;
NSYMB ZMAXORDNO = 255;                      ! MAXIMUM FOREIGN KEY ORDINAL NUMB.!
NSYMB ZMAXSYMVAL = 65535;
NSYMB ZNAMEALREADYEXISTS=0;                 ! TABLENAME ALREADY DEFINED        !
NSYMB ZNOMOREPHASES=255;                    ! LAST RESTART PHASE INDICATOR     !
NSYMB ZNOMORETABLES = 2;
NSYMB ZNOTABFOUNDFLAG=1;                    ! WHEN ANSWERING DDTABREF !
NSYMB ZNUMSTR=2;                         ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZOK=0;                   
NSYMB ZONEEVENT=1;                          ! INFO. ON ONE EVENT REQUESTED     !
NSYMB ZPACKEDNUMSTR=3;                      ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZPARTICIPATE=0;                       ! BLOCK IS INVOLVED IN THE RESTART !
NSYMB ZPROGERRORCODE1=0;             ! SPECIFY. FAULT CODE. DBDDH TABLE FULL     !
NSYMB ZPROGERRORCODE2=0;             ! SPECIFY. FAULT CODE. DUPLICATE TABLENAMES !
NSYMB ZPROGERRORCODE3=0;           ! SPECIFY. FAULT CODE.REFERRED TAB UNDEFINED!
NSYMB ZPROGERRORCODE4=0;           ! SPECIFY. FAULT CODE. CONGESTION IN TRH    !
NSYMB ZREQUESTACKN=0;
NSYMB ZROWINSERTED=0;                       ! A ROW IS SUCCESSFULLY INSERTED   !
NSYMB ZROWNOTALLOCATED = 6;                 ! INSERT FAILED. ROW NOT ALLOCATED !
NSYMB ZROWNUMBER=5;                         ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZSEARCHFAIL=2;                        ! SQLCODE.VALUE FAULT RESOLUTION   !
NSYMB ZSMALLRESTART=0;                      ! SMALL RESTART                    !
NSYMB ZSPH1DBDDH=2;                         ! FIRST RESTARTPHASE IN THIS BLOCK !
NSYMB ZSPH2DBDDH=3;                    ! SPECIFY. SECOND RESTART PHASE         !
NSYMB ZSPH3DBDDH=4;                    ! SPECIFY. THIRD  RESTART PHASE         !
NSYMB ZSPH4DBDDH=5;                    ! SPECIFY. FOURTH RESTART PHASE         !
NSYMB ZSPH5DBDDH=6;                    ! SPECIFY. FIFTH  RESTART PHASE         !
NSYMB ZSPH6DBDDH=7;                    ! SPECIFY. SIXTH  RESTART PHASE         !
NSYMB ZSTR=1;                            ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZSTTORRYVERSION=2;                    ! VERSION OF SIGNAL STTORRY        !
NSYMB ZSYMBOL=4;                            ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZSYMBOLFOUND=0;                       ! A SYMBOL VALUE IS RETURNED       !
NSYMB ZSYSTEMRESTART=36;                    ! EVENT = SYSTEM RESTART           !
NSYMB ZSYSTEMSTART=3;                       ! SYSTEM RESTART                   !
NSYMB ZSYSRESTFLAGCHANGED=#1024;            ! SYSTEM RESTART FLAG CHANGED      !
NSYMB ZTABCONGESTION = 8;                   ! NO WORK ROW FREE IN TABLE        !
NSYMB ZTABFULL=9;                           ! A TABLE IS FULL                  !
NSYMB ZTABLEFOUND = 0;
NSYMB ZTRHCONG=10;                          ! CONGESTION IN TRANSACTION HANDLER!
NSYMB ZTRHSAEID1= 0;              ! SPECIFY. CONGESTION IN TRH CAUSES PROGERROR!
NSYMB ZTRHSAEID2= 0;              ! SPECIFY. CONGESTION IN TRH CAUSES PROGERROR!

 
 
 
 
 
 
 
 
 




!*****************************************************************************!
!*                                                                           *! 
!*             R E C O R D S   A N D   F I L E S I Z E S                     *!
!*                                                                           *!
!*****************************************************************************! 
 

!BEGIN SQL INCLUDE 41!
!******************************************************************************!

!EXEC SQL INCLUDE PROTECTION WITH "
   VARIABLE BLKNUM 16 DS
   VARIABLE BLKREF 16 DS
   VARIABLE CONDITION 16 DS
   VARIABLE COUNTER 16 DS
   VARIABLE DELETEACTION 16 DS             FOREIGN KEY DELETE ACTION        
   VARIABLE FBLKREF 16 DS                  BLOCK REFERENCE OF REFERRING TAB 
   VARIABLE FKNUMBER 16 DS                 FOREIGN KEY NUMBER               
   VARIABLE FLDDATATYPE 16 DS              DATA TYPE OF COLUMN VARIABLE     
   VARIABLE FLDNUMBER 16 DS                FIELD NUMBER                     
   VARIABLE FLDPROTECTION 16 DS            FIELD PROTECTION/VISIBILITY      
   VARIABLE FLDSIZE 16 DS                  FIELD SIZE                       
   VARIABLE FROWNO 16 DS                   ROWNUMBER IN FIELDS TABLE        
   VARIABLE FTABREF 16 DS                  TABLE REFERENCE OF REFERRING TAB 
   VARIABLE KEYNO 16 DS                    ORDINAL KEY NUMBER               
   VARIABLE LOCATION 16 DS                 TABLE LOCATION (SINGLE/MULTIPLE) 
   VARIABLE MAXSYMLENGTH 16 DS             LONGEST SYMBOL VALUE NAME        
   VARIABLE NAMELENGTH 8 DS                LENGTH OF SYMBOL VALUE NAME      
   VARIABLE NEXTTOBEDELETED 16 DS          ROWNUMBER OF ROW TO BE DELETED   
   VARIABLE ORDNO 16 DS                    ORDINAL NUMBER                   
   VARIABLE PRWIDTH 16 DS                  PRINTOUT WIDTH OF COLUMN         
   VARIABLE RAUTHCAT 16 DS                 TABLE READ AUTHORITY CATEGORY    
   VARIABLE REF 16 DS                      RETURN SIGNAL REFERENCE          
   VARIABLE REFERREDTROWNO 16 DS           TABLE ROW NUMBER OF REFERRED TAB 
   VARIABLE SAMENAME 16 DS                 ROWNUMBER OF TABLE WITH SAME NAME
   VARIABLE SYMBOLVALUE 16 DS              NUMERICAL SYMBOL VALUE           
   VARIABLE TABREF 16 DS
   VARIABLE TOWBLKREF 16 DS                TABLE OWNER BLOCK REFERENCE      
   VARIABLE TOWTABREF 16 DS                TABLE OWNER TABLE REFERENCE      
   VARIABLE TRANSID 16 DS                  TRANSACTION IDENTITY             
   VARIABLE TROWNO 16 DS                   ROWNUMBER IN TABLES TABLE        
   VARIABLE USERP 16 DS                    USER'S POINTER                   
   VARIABLE VOLATIL 16 DS                  VARIABLE PROPERTY VOLATILE       
   VARIABLE WAUTHCAT 16 DS                 TABLE WRITE AUTHORITY CATEGORY   

   STRING VARIABLE FLDNAME 7 DS            COLUMN NAME                      
   STRING VARIABLE REFERREDTABNAME 15 DS   NAME OF REFERRED TABLE           
   STRING VARIABLE TABNAME 15 DS           TABLE NAME                       
                              
   SYMBOL VARIABLE SYMBOLFOUND=(FALSE, TRUE) DS
                                             NEW SYMBOL VALUE NAME FOUND?     
   "!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!






!BEGIN SQL INCLUDE 0!
!******************************************************************************!

!EXEC SQL INCLUDE TEST!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!












!*****************************************************************************!
!*                                                                           *! 
!*             C O M M O N   S T O R E D   V A R I A B L E S                 *!
!*                                                                           *!
!*****************************************************************************! 
 

VARIABLE CBLOCK ( 32768 ) 16 DS;    ! BLOCK NUMBERS/REFERENCES OF      !
                                            ! BLOCKS INVOLVED IN SMALL RESTART !
                                            ! SIZE = ZMAXNOFBLOCKS             !
VARIABLE CBLOCKCOUNT 16 DS;                 ! INDEX TO CBLOCK                  !
VARIABLE CK 16 DS;                          ! INDEX USED IN DIFFERENT LOOPS    !
VARIABLE CLOCALRESTARTPHASE 16 DS;
VARIABLE CMESSAGE 16 DS;                    ! MESSAGE CODE. SEE STRUCTURE      !
VARIABLE CNEXTFROWNO 16 DS;                 ! REMEMBERS NEXT AVAILABLE FROWNO  !
VARIABLE CNEXTTROWNO 16 DS;                 ! REMEMBERS NEXT AVAILABLE TROWNO  !
VARIABLE CNOFBLOCKS 16 DS;                  ! NUMBER OF BLOCKS INVOLVED IN FC  !
VARIABLE CNOFREQ 16 DS;                     ! NUMBER OF REQUESTS WITH FCHBNOOLD!
VARIABLE COWNREF 16 DS;                     ! OWN BLOCK REFERENCE              !
VARIABLE CPARTICIPATE 16 DS;                ! PARTICIPATE IN FUNCTION CHANGE?  !
VARIABLE CPHASE 8 DS;                       ! CURRENT RESTART PHASE            !
VARIABLE CREFERRINGFKORDNO 16 DS;           ! ORDINAL NUMBER OF REFERRING FK   !
VARIABLE CRESTCASE 4 DS;                    ! RESTART CASE                     !
VARIABLE CSIGKEY 16 DS;                     ! SIGNAL KEY                       !
VARIABLE CTEMPBLOCK (16) 16 DS;
VARIABLE CUSERBLKREF 16 DS;                 ! BLOCK REFERENCE OF DBDDH USER    !
VARIABLE CUSERP ( 2 ) 16 DS;                ! USERS POINTER                    !

!VARIABLE SQLCODE 16 DS !           ! ONLY FOR TEMP USE ! 

STRING VARIABLE CFLDNAME 7 DS;              ! NAME OF COLUMN/FIELD             !
STRING VARIABLE CREFERREDTABNAME 15 DS;     ! NAME OF REFERRED TABLE           !
STRING VARIABLE CSYMBOLNAME 7 DS;           ! SYMBOL VALUE NAME                !
STRING VARIABLE CTABNAME 15 DS;             ! TABLE NAME                       !

SYMBOL VARIABLE CALLTABSCLEARED = (FALSE, TRUE) DS;

SYMBOL VARIABLE CALLTABSRECEIVED = (FALSE, TRUE) DS;
                                           
SYMBOL VARIABLE CFC = (FALSE, TRUE) DS;
                                            ! REPORTS RECENT FUNCTION CHANGE   !

SYMBOL VARIABLE CMORETABSTODELETE = (FALSE, TRUE) DS;
SYMBOL VARIABLE CONLYSOMEBLOCKS = (FALSE, TRUE) DS;


SYMBOL VARIABLE CRETURNFROMCHECKSYMVALNAMELENGTH = (SYMDDINITFIELD10);
SYMBOL VARIABLE CRETURNFROMCLEARALLTABS = ( SYMWHICHRESTCASE10 );
SYMBOL VARIABLE CRETURNFROMCLEARSOMETABS = ( SYMWHICHRESTCASE10 );
SYMBOL VARIABLE CRETURNFROMTRIGTOWINITIATION = (SYMSTTOR10) DS;
SYMBOL VARIABLE CRETURNFROMTRHSTATRANSR = (SYMCLEARALLTABS30,
                                           SYMCLEARSOMETABS80,
                                           SYMDDINITTABLE20,
                                           SYMDDINITFIELD20,
                                           SYMDDINITFK10);
             
SYMBOL VARIABLE CRETURNFROMWHICHRESTCASE = (SYMSTTOR10) DS;
                                            ! RETURN ADDRESS FROM WHICHRESTCASE!
                               
SYMBOL VARIABLE CSIGNAL = (DDFCSTA, BLKREMST) DS;
                                            ! WHICH SIGNAL WILL BE ANSWERED    !
                               
SYMBOL VARIABLE CSMALLREST = (FALSE, TRUE) DS;
                                            ! IS THE CURRENT RESTART SMALL?    !






















!*****************************************************************************!
!*                                                                           *! 
!*             T E M P O R A R Y   V A R I A B L E S                         *!
!*                                                                           *!
!*****************************************************************************! 
 

VARIABLE TANSWER 16; 
VARIABLE TBLKNUM 16;                        ! BLOCK NUMBER                     !
VARIABLE TBLKREF 16;                        ! BLOCK REFERENCE                  !
VARIABLE TCOUNTER 16;
VARIABLE TDELETEACTION 16;                  ! FOREIGN KEY DELETE ACTION        !
VARIABLE TFCIND 16;                         ! FUNCTION CHANGE INDICATOR        !
VARIABLE TFKNUMBER 16;                      ! FOREIGN KEY NUMBER               !
VARIABLE TFLDDATATYPE 16;                   ! DATA TYPE OF CURRENT FIELD       !
VARIABLE TFLDNUMBER 16;                     ! FIELD NUMBER                     !
VARIABLE TFLDPROTECTION 16;                 ! FIELD PROTECTION/VISIBILITY      !
VARIABLE TFLDSIZE 16;                       ! FIELD SIZE                       !
VARIABLE TLOCATION 16;                      ! TABLE LOCATION (SINGLE/MULTIPLE) !
VARIABLE TNAMELENGTH 16;
VARIABLE TNOFRECEIVEDDATA 16;
VARIABLE TOWNREF 16;                        ! OWN BLOCK REFERENCE              !
VARIABLE TREADAUTHCAT 16 ;                  ! READ AUTHORITY CATEGORY OF TABLE !
VARIABLE TRETURNCODE 16;                    ! RETURN CODE                      !
VARIABLE TSAEID 16;                         ! SIZE ALTERNATION EVENT IDENTITY  !
VARIABLE TSTATEID 16;                       ! STATE IDENTITY                   !
VARIABLE TSYMLENGTH 8;                      ! SYMBOL VALUE NAME LENGTH         !
VARIABLE TTABREF 16;                        ! TABLE REFERENCE OF FULL TABLE    !
VARIABLE TTOWBLKREF 16;                     ! TABLE OWNER BLOCK REFERENCE      !
VARIABLE TTOWTABREF 16;                     ! TABLE OWNER TABLE REFERENCE      !
VARIABLE TTRID 16;                          ! TRANSACTION IDENTITY             !
VARIABLE TUSERP 16;                         ! USER'S POINTER                   !
VARIABLE TVOLATILE 16;                      ! VARIABLE PROPERTY VOLATILE       !
VARIABLE TWRITEAUTHCAT 16;                  ! WRITE AUTHORITY CATEGORY OF TABLE!























!*****************************************************************************!
!*                                                                           *! 
!*             S T R U C T U R E S                                           *!
!*                                                                           *!
!*****************************************************************************! 
 



STRUCTURE CMESSAGE =
   1 VALUE 8,
   1 SUBCODE 8;

!STRUCTURE SQLCODE =!       ! TO BE DELETED !
!   1 VALUE 8,
   1 SUBCODE 8     !























!*****************************************************************************!
!*                                                                           *! 
!*             S T A T E S   A N D   S Y M B O L S                           *!
!*                                                                           *!
!*****************************************************************************! 
 


!
BLKREMST            BLKREMSTRPY WILL BE RETURNED WHEN TRHSTOPTRANSR COMES
DDFCSTA             DDFCSTAR WILL BE RETURNED WHEN TRHSTOPTRANSR COMES 
FALSE               SYMBOL VARIABLE NAME STATEMENT IS FALSE
SYMCLEARALLTABS30   SYMBOL FOR A RETURN ADDRESS LABEL
SYMCLEARSOMETABS30  SYMBOL FOR A RETURN ADDRESS LABEL
SYMDDINITFIELD10    SYMBOL FOR A RETURN ADDRESS LABEL
SYMSTTOR10          SYMBOL FOR A RETURN ADDRESS LABEL
SYMSYSINITFK        RETURN TO SYSTEMTABLES VIA SIGNAL SYSRETURNTOFK
SYMSYSINITFLD       RETURN TO SYSTEMTABLES VIA SIGNAL SYSRETURNTOFLD
SYMSYSINITTAB       RETURN TO SYSTEMTABLES VIA SIGNAL SYSRETURNTOTAB
SYMWHICHRESTCASE10  SYMBOL FOR A RETURN ADDRESS LABEL
TRUE                SYMBOL VARIABLE NAME STATEMENT IS TRUE                  !

























!*****************************************************************************!
!*                                                                           *! 
!*             I N C L U D E D   T A B L E S                                 *!
!*                                                                           *!
!*****************************************************************************! 
                         

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE PROGRAMS 
   CREATE!

!------------------------------------------------------------------------------!

%%SET tables(,PROGRAMS)
%%SET tabNos(,0)
%%SET tabSlogans(,"""PROGRAM REFERENCES""")
%%SET tabSaes(,"21")
%%SET tabMinSizes(,30)
%%SET tabMaxSizes(,65000)
%%SET tabDivDirs(,1)
%%SET tabRelDivs(,1)
%%SET tabDivConsts(,0)
%%SET workSaes(,"22")
%%SET workMinSizes(,0)
%%SET workMaxSizes(,500)
%%SET workDivDirs(,1)
%%SET workRelDivs(,1)
%%SET workDivConsts(,0)
%%SET tabRAuths(,0)
%%SET tabWAuths(,0)
%%SET tabChecks(,1)
%%SET cols0("DBNUM", "NAME", "BLKREF")
%%SET rnCols0()
%%SET bitsCols0(3)
%%SET symCols0()
%%SET strCols0(2)
%%SET numCols0()
%%SET packNumCols0()
%%SET normCols0(1, 2)
%%SET colTypes0("DBNUMBER", "STRING", "BITS")
%%SET colSizes0(32, 7, 16)
%%SET colProps0("", "RELOAD", "RELOAD")
%%SET colNull0(0, 0, 0)
%%SET colLen0(2, 4, 1)
%%SET colSlogans0("""""", """BLOCK NAME""", """""")
%%SET colVis0("READWRITE", "READONLY", "READONLY")
%%SET colNonVol0(1, 1, 1)
%%SET defCols0()
%%SET bTrees0(2)
%%SET bTreeCols0_2(3)
%%SET aks0()
%%SET fks0()
%%SET schConst0_2(7)
%%SET scanPred0_1("", "SQLC_PROGRAMS_BLKREF_Data", "", "SQLM_PROGRAMS_OperRow", "1", "", "", ">=", "True", "False", "False")
%%SET scanCols0_1(3)
%%SET scanNulls0_1()
%%SET scanNullPtrs0_1()
%%SET colMin0_3(1)
%%SET colMax0_3(65535)


!******************************************************************************!
!END SQL!



!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE TABLES 
   CREATE!

!------------------------------------------------------------------------------!

%%SET tables(,TABLES)
%%SET tabNos(,1)
%%SET tabSlogans(,"""TABLE DEFINITIONS""")
%%SET tabSaes(,"21")
%%SET tabMinSizes(,30)
%%SET tabMaxSizes(,65000)
%%SET tabDivDirs(,1)
%%SET tabRelDivs(,1)
%%SET tabDivConsts(,0)
%%SET workSaes(,"22")
%%SET workMinSizes(,0)
%%SET workMaxSizes(,500)
%%SET workDivDirs(,1)
%%SET workRelDivs(,1)
%%SET workDivConsts(,0)
%%SET tabRAuths(,0)
%%SET tabWAuths(,0)
%%SET tabChecks(,17)
%%SET cols1("DBNUM", "NAME", "BLKREF", "TABREF", "DESCR", "SAEIDT", "ESTEPT", "MAXST", "ALLOCST", "USEDST", "SAEIDW", "ESTEPW", "MAXSW", "ALLOCSW", "USEDSW", "STATE", "RAUCAT", "WAUCAT", "LOCATE", "NOFLTCO")
%%SET rnCols1(TROWNO)
%%SET bitsCols1(3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 20)
%%SET symCols1(16, 19)
%%SET strCols1(2, 5)
%%SET numCols1()
%%SET packNumCols1()
%%SET normCols1(1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
%%SET colTypes1("DBNUMBER", "STRING", "BITS", "BITS", "STRING", "BITS", "BITS", "BITS", "BITS", "BITS", "BITS", "BITS", "BITS", "BITS", "BITS", "SYMBOL", "BITS", "BITS", "SYMBOL", "BITS")
%%SET colSizes1(32, 15, 16, 16, 31, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 1, 8, 8, 1, 8)
%%SET colProps1("", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD")
%%SET colNull1(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0)
%%SET colLen1(2, 8, 1, 1, 16, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
%%SET colSlogans1("""""", """TABLE NAME""", """""", """""", """TABLE DESCRIPTION""", """""", """""", """""", """""", """""", """""", """""", """""", """""", """""", """""", """READ AUTHORITY CATEGORY""", """WRITE AUTHORITY CATEGORY""", """TABLE LOCATION""", """NUMBER OF FAULT CODES""")
%%SET colVis1("READWRITE", "READONLY", "READONLY", "INVISIBLE", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READWRITE", "READWRITE", "READONLY", "READONLY")
%%SET colNonVol1(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
%%SET defCols1(5, 6, 7, 8, 11, 12, 13, 16, 19)
%%SET defVal1_5("""  """)
%%SET defVal1_6("NULL")
%%SET defVal1_7("1")
%%SET defVal1_8("65531")
%%SET defVal1_11("NULL")
%%SET defVal1_12("1")
%%SET defVal1_13("65531")
%%SET defVal1_16("TABLESSTATEWORKING")
%%SET defVal1_19("TABLESLOCATESINGLE")
%%SET symVals1_16(BLOCKED, WORKING)
%%SET symVals1_19(SINGLE, MULTI)
%%SET symLits1_16(0, 1)
%%SET symLits1_19(0, 1)
%%SET bTrees1(3, 4)
%%SET bTreeCols1_3(2, 3)
%%SET bTreeCols1_4(3)
%%SET aks1(3)
%%SET fks1(4)
%%SET fkTab1_4(PROGRAMS)
%%SET fkAct1_4("RESTRICT")
%%SET schConst1_3(24)
%%SET schConst1_4(7)
%%SET scanPred1_1("", "SQLC_TABLES_WAUCAT_Data", "", "SQLM_TABLES_OperRow", "63", "", "", ">", "False", "", "False")
%%SET scanPred1_2("", "SQLC_TABLES_USEDSW_Data", "", "SQLM_TABLES_OperRow", "65531", "", "", ">", "False", "", "False")
%%SET scanPred1_3("", "SQLC_TABLES_USEDST_Data", "", "SQLM_TABLES_OperRow", "65531", "", "", ">", "False", "", "False")
%%SET scanPred1_4("", "SQLC_TABLES_SAEIDW_Data", "", "SQLM_TABLES_OperRow", "999", "", "", ">", "False", "", "False")
%%SET scanPred1_5("", "SQLC_TABLES_NOFLTCO_Data", "", "SQLM_TABLES_OperRow", "64", "", "", ">", "False", "", "False")
%%SET scanPred1_6("", "SQLC_TABLES_RAUCAT_Data", "", "SQLM_TABLES_OperRow", "63", "", "", ">", "False", "", "False")
%%SET scanPred1_7("", "SQLC_TABLES_SAEIDT_Data", "", "SQLM_TABLES_OperRow", "999", "", "", ">", "False", "", "False")
%%SET scanPred1_8("", "SQLC_TABLES_TABREF_Data", "", "SQLM_TABLES_OperRow", "4095", "", "", ">", "False", "", "False")
%%SET scanPred1_9("", "SQLC_TABLES_MAXSW_Data", "", "SQLM_TABLES_OperRow", "65531", "", "", ">", "False", "", "False")
%%SET scanPred1_10("", "SQLC_TABLES_ESTEPW_Data", "", "SQLM_TABLES_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred1_11("", "SQLC_TABLES_ESTEPW_Data", "", "SQLM_TABLES_OperRow", "65531", "", "", ">", "False", "", "False")
%%SET scanPred1_12("", "SQLC_TABLES_MAXST_Data", "", "SQLM_TABLES_OperRow", "65531", "", "", ">", "False", "", "False")
%%SET scanPred1_13("", "SQLC_TABLES_ESTEPT_Data", "", "SQLM_TABLES_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred1_14("", "SQLC_TABLES_ESTEPT_Data", "", "SQLM_TABLES_OperRow", "65531", "", "", ">", "False", "", "False")
%%SET scanPred1_15("", "SQLC_TABLES_ALLOCSW_Data", "", "SQLM_TABLES_OperRow", "65531", "", "", ">", "False", "", "False")
%%SET scanPred1_16("", "SQLC_TABLES_ALLOCST_Data", "", "SQLM_TABLES_OperRow", "65531", "", "", ">", "False", "", "False")
%%SET scanPred1_17("", "SQLC_TABLES_BLKREF_Data", "", "SQLM_TABLES_OperRow", "1", "", "", "<", "False", "True", "False")
%%SET scanCols1_1(18)
%%SET scanCols1_2(15)
%%SET scanCols1_3(10)
%%SET scanCols1_4(11)
%%SET scanCols1_5(20)
%%SET scanCols1_6(17)
%%SET scanCols1_7(6)
%%SET scanCols1_8(4)
%%SET scanCols1_9(13)
%%SET scanCols1_10(12)
%%SET scanCols1_11(12)
%%SET scanCols1_12(8)
%%SET scanCols1_13(7)
%%SET scanCols1_14(7)
%%SET scanCols1_15(14)
%%SET scanCols1_16(9)
%%SET scanCols1_17(3)
%%SET scanNulls1_1()
%%SET scanNulls1_2()
%%SET scanNulls1_3()
%%SET scanNulls1_4()
%%SET scanNulls1_5()
%%SET scanNulls1_6()
%%SET scanNulls1_7()
%%SET scanNulls1_8()
%%SET scanNulls1_9()
%%SET scanNulls1_10()
%%SET scanNulls1_11()
%%SET scanNulls1_12()
%%SET scanNulls1_13()
%%SET scanNulls1_14()
%%SET scanNulls1_15()
%%SET scanNulls1_16()
%%SET scanNulls1_17()
%%SET scanNullPtrs1_1()
%%SET scanNullPtrs1_2()
%%SET scanNullPtrs1_3()
%%SET scanNullPtrs1_4()
%%SET scanNullPtrs1_5()
%%SET scanNullPtrs1_6()
%%SET scanNullPtrs1_7()
%%SET scanNullPtrs1_8()
%%SET scanNullPtrs1_9()
%%SET scanNullPtrs1_10()
%%SET scanNullPtrs1_11()
%%SET scanNullPtrs1_12()
%%SET scanNullPtrs1_13()
%%SET scanNullPtrs1_14()
%%SET scanNullPtrs1_15()
%%SET scanNullPtrs1_16()
%%SET scanNullPtrs1_17()
%%SET colMin1_3(1)
%%SET colMin1_4(0)
%%SET colMin1_6(0)
%%SET colMin1_7(1)
%%SET colMin1_8(0)
%%SET colMin1_9(0)
%%SET colMin1_10(0)
%%SET colMin1_11(0)
%%SET colMin1_12(1)
%%SET colMin1_13(0)
%%SET colMin1_14(0)
%%SET colMin1_15(0)
%%SET colMin1_17(0)
%%SET colMin1_18(0)
%%SET colMin1_20(0)
%%SET colMax1_3(65535)
%%SET colMax1_4(4095)
%%SET colMax1_6(999)
%%SET colMax1_7(65531)
%%SET colMax1_8(65531)
%%SET colMax1_9(65531)
%%SET colMax1_10(65531)
%%SET colMax1_11(999)
%%SET colMax1_12(65531)
%%SET colMax1_13(65531)
%%SET colMax1_14(65531)
%%SET colMax1_15(65531)
%%SET colMax1_17(63)
%%SET colMax1_18(63)
%%SET colMax1_20(64)


!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE FIELDS 
   CREATE!

!------------------------------------------------------------------------------!

%%SET tables(,FIELDS)
%%SET tabNos(,2)
%%SET tabSlogans(,"""FIELD DEFINITIONS""")
%%SET tabSaes(,"1")
%%SET tabMinSizes(,200)
%%SET tabMaxSizes(,65000)
%%SET tabDivDirs(,1)
%%SET tabRelDivs(,1)
%%SET tabDivConsts(,0)
%%SET workSaes(,"2")
%%SET workMinSizes(,0)
%%SET workMaxSizes(,500)
%%SET workDivDirs(,1)
%%SET workRelDivs(,1)
%%SET workDivConsts(,0)
%%SET tabRAuths(,0)
%%SET tabWAuths(,0)
%%SET tabChecks(,9)
%%SET cols2("DBNUM", "NAME", "TABREF", "BLKREF", "FIELDNO", "DESCR", "VISIBIL", "PRWIDTH", "NULLPER", "DATATYP", "BADDRES", "MIN", "MAX", "SIZE", "DIDNR", "DIDPOS", "PCLEAR", "PRELOAD", "PDUMP", "PSTATIC", "VOLATIL", "DEFBITS", "DEFSTR", "DEFNSTR", "DEFPNS", "DEFSYMB", "TROWNO")
%%SET rnCols2(FROWNO)
%%SET bitsCols2(3, 4, 5, 8, 11, 12, 13, 14, 15, 16, 22, 27)
%%SET symCols2(7, 9, 10, 17, 18, 19, 20, 21, 26)
%%SET strCols2(2, 6, 23)
%%SET numCols2(24)
%%SET packNumCols2(25)
%%SET normCols2(1, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26)
%%SET colTypes2("DBNUMBER", "STRING", "BITS", "BITS", "BITS", "STRING", "SYMBOL", "BITS", "SYMBOL", "SYMBOL", "BITS", "BITS", "BITS", "BITS", "BITS", "BITS", "SYMBOL", "SYMBOL", "SYMBOL", "SYMBOL", "SYMBOL", "BITS", "STRING", "NUMSTRING", "PACKED NUMSTRING", "SYMBOL", "BITS")
%%SET colSizes2(32, 7, 16, 16, 16, 31, 2, 8, 1, 4, 16, 16, 16, 16, 16, 16, 1, 1, 1, 1, 1, 16, 31, 31, 28, 2, 16)
%%SET colProps2("", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD")
%%SET colNull2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
%%SET colLen2(2, 4, 1, 1, 1, 16, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 16, 8, 1, 1)
%%SET colSlogans2("""""", """FIELD NAME""", """""", """""", """""", """FIELD DESCRIPTION""", """""", """""", """NULL PERMITTED""", """""", """BASE ADDRESS""", """""", """""", """""", """""", """""", """""", """""", """""", """""", """""", """""", """""", """""", """""", """""", """""")
%%SET colVis2("READWRITE", "READONLY", "INVISIBLE", "INVISIBLE", "INVISIBLE", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY")
%%SET colNonVol2(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
%%SET defCols2(6, 7, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27)
%%SET defVal2_6("""  """)
%%SET defVal2_7("FIELDSVISIBILREADWR")
%%SET defVal2_12("NULL")
%%SET defVal2_13("NULL")
%%SET defVal2_15("NULL")
%%SET defVal2_16("NULL")
%%SET defVal2_17("FIELDSPCLEARNO")
%%SET defVal2_18("FIELDSPRELOADYES")
%%SET defVal2_19("FIELDSPDUMPNO")
%%SET defVal2_20("FIELDSPSTATICNO")
%%SET defVal2_21("FIELDSVOLATILNO")
%%SET defVal2_22("NULL")
%%SET defVal2_23("NULL")
%%SET defVal2_24("NULL")
%%SET defVal2_25("NULL")
%%SET defVal2_26("NULL")
%%SET defVal2_27("NULL")
%%SET symVals2_7(INVIS, READO, READWR)
%%SET symVals2_9(TRUE, FALSE)
%%SET symVals2_10(BITS, STRING, NUMSTR, PNUMSTR, SYMBOL, ROWNUM, DBNUM)
%%SET symVals2_17(YES, NO)
%%SET symVals2_18(YES, NO)
%%SET symVals2_19(YES, NO)
%%SET symVals2_20(YES, NO)
%%SET symVals2_21(YES, NO)
%%SET symVals2_26(SYMBOL1, SYMBOL2, SYMBOL3)
%%SET symLits2_7(0, 1, 2)
%%SET symLits2_9(0, 1)
%%SET symLits2_10(0, 1, 2, 3, 4, 5, 6)
%%SET symLits2_17(0, 1)
%%SET symLits2_18(0, 1)
%%SET symLits2_19(0, 1)
%%SET symLits2_20(0, 1)
%%SET symLits2_21(0, 1)
%%SET symLits2_26(0, 1, 2)
%%SET bTrees2(3, 4, 5)
%%SET bTreeCols2_3(2, 3, 4)
%%SET bTreeCols2_4(3, 4, 5)
%%SET bTreeCols2_5(27)
%%SET aks2(3, 4)
%%SET fks2(5)
%%SET fkTab2_5(TABLES)
%%SET fkAct2_5("SET NULL")
%%SET schConst2_3(24)
%%SET schConst2_4(17)
%%SET schConst2_5(11)
%%SET scanPred2_1("", "SQLC_FIELDS_TROWNO_Data", "", "SQLM_FIELDS_OperRow", "65531", "", "", ">", "False", "", "False")
%%SET scanPred2_2("", "SQLC_FIELDS_PRWIDTH_Data", "", "SQLM_FIELDS_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred2_3("", "SQLC_FIELDS_PRWIDTH_Data", "", "SQLM_FIELDS_OperRow", "63", "", "", ">", "False", "", "False")
%%SET scanPred2_4("", "SQLC_FIELDS_TABREF_Data", "", "SQLM_FIELDS_OperRow", "4095", "", "", ">", "False", "", "False")
%%SET scanPred2_5("", "SQLC_FIELDS_FIELDNO_Data", "", "SQLM_FIELDS_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred2_6("", "SQLC_FIELDS_FIELDNO_Data", "", "SQLM_FIELDS_OperRow", "4096", "", "", ">", "False", "", "False")
%%SET scanPred2_7("", "SQLC_FIELDS_BADDRES_Data", "", "SQLM_FIELDS_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred2_8("", "SQLC_FIELDS_BADDRES_Data", "", "SQLM_FIELDS_OperRow", "4095", "", "", ">", "False", "", "False")
%%SET scanPred2_9("", "SQLC_FIELDS_BLKREF_Data", "", "SQLM_FIELDS_OperRow", "1", "", "", "<", "False", "True", "False")
%%SET scanCols2_1(27)
%%SET scanCols2_2(8)
%%SET scanCols2_3(8)
%%SET scanCols2_4(3)
%%SET scanCols2_5(5)
%%SET scanCols2_6(5)
%%SET scanCols2_7(11)
%%SET scanCols2_8(11)
%%SET scanCols2_9(4)
%%SET scanNulls2_1()
%%SET scanNulls2_2()
%%SET scanNulls2_3()
%%SET scanNulls2_4()
%%SET scanNulls2_5()
%%SET scanNulls2_6()
%%SET scanNulls2_7()
%%SET scanNulls2_8()
%%SET scanNulls2_9()
%%SET scanNullPtrs2_1()
%%SET scanNullPtrs2_2()
%%SET scanNullPtrs2_3()
%%SET scanNullPtrs2_4()
%%SET scanNullPtrs2_5()
%%SET scanNullPtrs2_6()
%%SET scanNullPtrs2_7()
%%SET scanNullPtrs2_8()
%%SET scanNullPtrs2_9()
%%SET colMin2_3(0)
%%SET colMin2_4(1)
%%SET colMin2_5(1)
%%SET colMin2_8(1)
%%SET colMin2_11(1)
%%SET colMin2_12(0)
%%SET colMin2_13(0)
%%SET colMin2_14(0)
%%SET colMin2_15(0)
%%SET colMin2_16(0)
%%SET colMin2_22(0)
%%SET colMin2_27(0)
%%SET colMax2_3(4095)
%%SET colMax2_4(65535)
%%SET colMax2_5(4096)
%%SET colMax2_8(63)
%%SET colMax2_11(4095)
%%SET colMax2_12(65535)
%%SET colMax2_13(65535)
%%SET colMax2_14(65535)
%%SET colMax2_15(65535)
%%SET colMax2_16(65535)
%%SET colMax2_22(65535)
%%SET colMax2_27(65531)


!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE KEYS 
   CREATE!

!------------------------------------------------------------------------------!

%%SET tables(,KEYS)
%%SET tabNos(,3)
%%SET tabSlogans(,"""KEY DEFINITIONS""")
%%SET tabSaes(,"3")
%%SET tabMinSizes(,0)
%%SET tabMaxSizes(,30)
%%SET tabDivDirs(,1)
%%SET tabRelDivs(,1)
%%SET tabDivConsts(,0)
%%SET workSaes(,"4")
%%SET workMinSizes(,0)
%%SET workMaxSizes(,500)
%%SET workDivDirs(,1)
%%SET workRelDivs(,1)
%%SET workDivConsts(,0)
%%SET tabRAuths(,0)
%%SET tabWAuths(,0)
%%SET tabChecks(,3)
%%SET cols3("DBNUM", "TROWNO", "KEYNO", "TABREF", "BLKREF", "KEYTYPE")
%%SET rnCols3()
%%SET bitsCols3(2, 3, 4, 5)
%%SET symCols3(6)
%%SET strCols3()
%%SET numCols3()
%%SET packNumCols3()
%%SET normCols3(1, 6)
%%SET colTypes3("DBNUMBER", "BITS", "BITS", "BITS", "BITS", "SYMBOL")
%%SET colSizes3(32, 16, 8, 16, 16, 2)
%%SET colProps3("", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD")
%%SET colNull3(0, 0, 0, 0, 0, 0)
%%SET colLen3(2, 1, 1, 1, 1, 1)
%%SET colSlogans3("""""", """""", """""", """""", """""", """""")
%%SET colVis3("READWRITE", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY")
%%SET colNonVol3(1, 1, 1, 1, 1, 1)
%%SET defCols3(2)
%%SET defVal3_2("1")
%%SET symVals3_6(PRIMKEY, ALTERN, INDKEY)
%%SET symLits3_6(0, 1, 2)
%%SET bTrees3(2, 3, 4)
%%SET bTreeCols3_2(2, 3)
%%SET bTreeCols3_3(5, 4, 3)
%%SET bTreeCols3_4(2)
%%SET aks3(3)
%%SET fks3(4)
%%SET fkTab3_4(TABLES)
%%SET fkAct3_4("SET DEFAULT")
%%SET schConst3_2(12)
%%SET schConst3_3(17)
%%SET schConst3_4(7)
%%SET scanPred3_1("", "SQLC_KEYS_TABREF_Data", "", "SQLM_KEYS_OperRow", "4095", "", "", ">", "False", "", "False")
%%SET scanPred3_2("", "SQLC_KEYS_BLKREF_Data", "", "SQLM_KEYS_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred3_3("", "SQLC_KEYS_TROWNO_Data", "", "SQLM_KEYS_OperRow", "65531", "", "", ">", "False", "True", "False")
%%SET scanCols3_1(4)
%%SET scanCols3_2(5)
%%SET scanCols3_3(2)
%%SET scanNulls3_1()
%%SET scanNulls3_2()
%%SET scanNulls3_3()
%%SET scanNullPtrs3_1()
%%SET scanNullPtrs3_2()
%%SET scanNullPtrs3_3()
%%SET colMin3_2(0)
%%SET colMin3_3(0)
%%SET colMin3_4(0)
%%SET colMin3_5(1)
%%SET colMax3_2(65531)
%%SET colMax3_3(255)
%%SET colMax3_4(4095)
%%SET colMax3_5(65535)


!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE KEYFIELDS
   CREATE!

!------------------------------------------------------------------------------!

%%SET tables(,KEYFIELDS)
%%SET tabNos(,4)
%%SET tabSlogans(,"""KEYFIELD DEFINITIONS""")
%%SET tabSaes(,"5")
%%SET tabMinSizes(,0)
%%SET tabMaxSizes(,30)
%%SET tabDivDirs(,1)
%%SET tabRelDivs(,1)
%%SET tabDivConsts(,0)
%%SET workSaes(,"6")
%%SET workMinSizes(,0)
%%SET workMaxSizes(,500)
%%SET workDivDirs(,1)
%%SET workRelDivs(,1)
%%SET workDivConsts(,0)
%%SET tabRAuths(,0)
%%SET tabWAuths(,0)
%%SET tabChecks(,6)
%%SET cols4("DBNUM", "TROWNO", "KEYNO", "TABREF", "BLKREF", "COMPNO", "FROWNO")
%%SET rnCols4()
%%SET bitsCols4(2, 3, 4, 5, 6, 7)
%%SET symCols4()
%%SET strCols4()
%%SET numCols4()
%%SET packNumCols4()
%%SET normCols4(1, 7)
%%SET colTypes4("DBNUMBER", "BITS", "BITS", "BITS", "BITS", "BITS", "BITS")
%%SET colSizes4(32, 16, 8, 16, 16, 8, 16)
%%SET colProps4("", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD")
%%SET colNull4(0, 0, 0, 0, 0, 0, 0)
%%SET colLen4(2, 1, 1, 1, 1, 1, 1)
%%SET colSlogans4("""""", """""", """""", """""", """""", """""", """""")
%%SET colVis4("READWRITE", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY")
%%SET colNonVol4(1, 1, 1, 1, 1, 1, 1)
%%SET defCols4()
%%SET bTrees4(2, 3)
%%SET bTreeCols4_2(2, 3, 6)
%%SET bTreeCols4_3(5, 4, 3, 6)
%%SET aks4(3)
%%SET fks4()
%%SET schConst4_2(17)
%%SET schConst4_3(23)
%%SET scanPred4_1("", "SQLC_KEYFIELDS_TABREF_Data", "", "SQLM_KEYFIELDS_OperRow", "4095", "", "", ">", "False", "", "False")
%%SET scanPred4_2("", "SQLC_KEYFIELDS_FROWNO_Data", "", "SQLM_KEYFIELDS_OperRow", "65531", "", "", ">", "False", "", "False")
%%SET scanPred4_3("", "SQLC_KEYFIELDS_COMPNO_Data", "", "SQLM_KEYFIELDS_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred4_4("", "SQLC_KEYFIELDS_COMPNO_Data", "", "SQLM_KEYFIELDS_OperRow", "16", "", "", ">", "False", "", "False")
%%SET scanPred4_5("", "SQLC_KEYFIELDS_BLKREF_Data", "", "SQLM_KEYFIELDS_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred4_6("", "SQLC_KEYFIELDS_TROWNO_Data", "", "SQLM_KEYFIELDS_OperRow", "65531", "", "", ">", "False", "True", "False")
%%SET scanCols4_1(4)
%%SET scanCols4_2(7)
%%SET scanCols4_3(6)
%%SET scanCols4_4(6)
%%SET scanCols4_5(5)
%%SET scanCols4_6(2)
%%SET scanNulls4_1()
%%SET scanNulls4_2()
%%SET scanNulls4_3()
%%SET scanNulls4_4()
%%SET scanNulls4_5()
%%SET scanNulls4_6()
%%SET scanNullPtrs4_1()
%%SET scanNullPtrs4_2()
%%SET scanNullPtrs4_3()
%%SET scanNullPtrs4_4()
%%SET scanNullPtrs4_5()
%%SET scanNullPtrs4_6()
%%SET colMin4_2(0)
%%SET colMin4_3(0)
%%SET colMin4_4(0)
%%SET colMin4_5(1)
%%SET colMin4_6(1)
%%SET colMin4_7(0)
%%SET colMax4_2(65531)
%%SET colMax4_3(255)
%%SET colMax4_4(4095)
%%SET colMax4_5(65535)
%%SET colMax4_6(16)
%%SET colMax4_7(65531)


!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE FOREIGNKEYS
   CREATE!

!------------------------------------------------------------------------------!

%%SET tables(,FOREIGNKEYS)
%%SET tabNos(,5)
%%SET tabSlogans(,"""FOREIGN KEY DEFINITIONS""")
%%SET tabSaes(,"7")
%%SET tabMinSizes(,30)
%%SET tabMaxSizes(,65000)
%%SET tabDivDirs(,1)
%%SET tabRelDivs(,1)
%%SET tabDivConsts(,0)
%%SET workSaes(,"8")
%%SET workMinSizes(,0)
%%SET workMaxSizes(,500)
%%SET workDivDirs(,1)
%%SET workRelDivs(,1)
%%SET workDivConsts(,0)
%%SET tabRAuths(,0)
%%SET tabWAuths(,0)
%%SET tabChecks(,6)
%%SET cols5("DBNUM", "TROWNO", "ORDNO", "BLKREF", "TABREF", "KEYNO", "FTROWNO", "FTABREF", "FBLKREF", "COND")
%%SET rnCols5()
%%SET bitsCols5(2, 3, 4, 5, 6, 7, 8, 9)
%%SET symCols5(10)
%%SET strCols5()
%%SET numCols5()
%%SET packNumCols5()
%%SET normCols5(1, 6, 8, 9, 10)
%%SET colTypes5("DBNUMBER", "BITS", "BITS", "BITS", "BITS", "BITS", "BITS", "BITS", "BITS", "SYMBOL")
%%SET colSizes5(32, 16, 8, 16, 16, 8, 16, 16, 16, 4)
%%SET colProps5("", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD", "RELOAD")
%%SET colNull5(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
%%SET colLen5(2, 1, 1, 1, 1, 1, 1, 1, 1, 1)
%%SET colSlogans5("""""", """""", """""", """""", """""", """""", """""", """""", """""", """""")
%%SET colVis5("READWRITE", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY", "READONLY")
%%SET colNonVol5(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
%%SET defCols5()
%%SET symVals5_10(RESTR, CASCAD, SETNULL, SETDEF)
%%SET symLits5_10(0, 1, 2, 3)
%%SET bTrees5(2, 3, 4, 5)
%%SET bTreeCols5_2(2, 3)
%%SET bTreeCols5_3(3, 4, 5)
%%SET bTreeCols5_4(2)
%%SET bTreeCols5_5(7)
%%SET aks5(3)
%%SET fks5(4, 5)
%%SET fkTab5_4(TABLES)
%%SET fkTab5_5(TABLES)
%%SET fkAct5_4("CASCADE")
%%SET fkAct5_5("CASCADE")
%%SET schConst5_2(12)
%%SET schConst5_3(17)
%%SET schConst5_4(7)
%%SET schConst5_5(7)
%%SET scanPred5_1("", "SQLC_FOREIGNKEYS_TABREF_Data", "", "SQLM_FOREIGNKEYS_OperRow", "4095", "", "", ">", "False", "", "False")
%%SET scanPred5_2("", "SQLC_FOREIGNKEYS_FBLKREF_Data", "", "SQLM_FOREIGNKEYS_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred5_3("", "SQLC_FOREIGNKEYS_FTABREF_Data", "", "SQLM_FOREIGNKEYS_OperRow", "4095", "", "", ">", "False", "", "False")
%%SET scanPred5_4("", "SQLC_FOREIGNKEYS_FTROWNO_Data", "", "SQLM_FOREIGNKEYS_OperRow", "65531", "", "", ">", "False", "", "False")
%%SET scanPred5_5("", "SQLC_FOREIGNKEYS_BLKREF_Data", "", "SQLM_FOREIGNKEYS_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred5_6("", "SQLC_FOREIGNKEYS_TROWNO_Data", "", "SQLM_FOREIGNKEYS_OperRow", "65531", "", "", ">", "False", "True", "False")
%%SET scanCols5_1(5)
%%SET scanCols5_2(9)
%%SET scanCols5_3(8)
%%SET scanCols5_4(7)
%%SET scanCols5_5(4)
%%SET scanCols5_6(2)
%%SET scanNulls5_1()
%%SET scanNulls5_2()
%%SET scanNulls5_3()
%%SET scanNulls5_4()
%%SET scanNulls5_5()
%%SET scanNulls5_6()
%%SET scanNullPtrs5_1()
%%SET scanNullPtrs5_2()
%%SET scanNullPtrs5_3()
%%SET scanNullPtrs5_4()
%%SET scanNullPtrs5_5()
%%SET scanNullPtrs5_6()
%%SET colMin5_2(0)
%%SET colMin5_3(0)
%%SET colMin5_4(1)
%%SET colMin5_5(0)
%%SET colMin5_6(0)
%%SET colMin5_7(0)
%%SET colMin5_8(0)
%%SET colMin5_9(1)
%%SET colMax5_2(65531)
%%SET colMax5_3(255)
%%SET colMax5_4(65535)
%%SET colMax5_5(4095)
%%SET colMax5_6(255)
%%SET colMax5_7(65531)
%%SET colMax5_8(4095)
%%SET colMax5_9(65535)


!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE SYMBOLS 
   CREATE!

!------------------------------------------------------------------------------!

%%SET tables(,SYMBOLS)
%%SET tabNos(,6)
%%SET tabSlogans(,"""SYMBOL VALUES""")
%%SET tabSaes(,"9")
%%SET tabMinSizes(,0)
%%SET tabMaxSizes(,30)
%%SET tabDivDirs(,1)
%%SET tabRelDivs(,1)
%%SET tabDivConsts(,0)
%%SET workSaes(,"10")
%%SET workMinSizes(,0)
%%SET workMaxSizes(,500)
%%SET workDivDirs(,1)
%%SET workRelDivs(,1)
%%SET workDivConsts(,0)
%%SET tabRAuths(,0)
%%SET tabWAuths(,0)
%%SET tabChecks(,1)
%%SET cols6("DBNUM", "FROWNO", "SYMBOL", "SYMVAL")
%%SET rnCols6()
%%SET bitsCols6(2, 4)
%%SET symCols6()
%%SET strCols6(3)
%%SET numCols6()
%%SET packNumCols6()
%%SET normCols6(1)
%%SET colTypes6("DBNUMBER", "BITS", "STRING", "BITS")
%%SET colSizes6(32, 16, 7, 16)
%%SET colProps6("", "RELOAD", "RELOAD", "RELOAD")
%%SET colNull6(0, 0, 0, 0)
%%SET colLen6(2, 1, 4, 1)
%%SET colSlogans6("""""", """""", """SYMBOL NAME""", """SYMBOL VALUE""")
%%SET colVis6("READWRITE", "READONLY", "READONLY", "READONLY")
%%SET colNonVol6(1, 1, 1, 1)
%%SET defCols6()
%%SET bTrees6(2, 3)
%%SET bTreeCols6_2(2, 3)
%%SET bTreeCols6_3(2, 4)
%%SET aks6(3)
%%SET fks6()
%%SET schConst6_2(19)
%%SET schConst6_3(12)
%%SET scanPred6_1("", "SQLC_SYMBOLS_FROWNO_Data", "", "SQLM_SYMBOLS_OperRow", "65531", "", "", "=<", "True", "False", "False")
%%SET scanCols6_1(2)
%%SET scanNulls6_1()
%%SET scanNullPtrs6_1()
%%SET colMin6_2(0)
%%SET colMin6_4(0)
%%SET colMax6_2(65531)
%%SET colMax6_4(65535)


!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE TOWFAULTCODES 
   CREATE!

!------------------------------------------------------------------------------!

%%SET tables(,TOWFAULTCODES)
%%SET tabNos(,7)
%%SET tabSlogans(,"""TABLE OWNER FAULT CODES""")
%%SET tabSaes(,"13")
%%SET tabMinSizes(,0)
%%SET tabMaxSizes(,30)
%%SET tabDivDirs(,1)
%%SET tabRelDivs(,1)
%%SET tabDivConsts(,0)
%%SET workSaes(,"14")
%%SET workMinSizes(,0)
%%SET workMaxSizes(,500)
%%SET workDivDirs(,1)
%%SET workRelDivs(,1)
%%SET workDivConsts(,0)
%%SET tabRAuths(,0)
%%SET tabWAuths(,0)
%%SET tabChecks(,2)
%%SET cols7("DBNUM", "TROWNO", "FAULTNO", "FLTTEXT")
%%SET rnCols7()
%%SET bitsCols7(2, 3)
%%SET symCols7()
%%SET strCols7(4)
%%SET numCols7()
%%SET packNumCols7()
%%SET normCols7(1, 4)
%%SET colTypes7("DBNUMBER", "BITS", "BITS", "STRING")
%%SET colSizes7(32, 16, 8, 31)
%%SET colProps7("", "RELOAD", "RELOAD", "RELOAD")
%%SET colNull7(0, 0, 0, 0)
%%SET colLen7(2, 1, 1, 16)
%%SET colSlogans7("""""", """""", """""", """""")
%%SET colVis7("READWRITE", "READONLY", "READONLY", "READONLY")
%%SET colNonVol7(1, 1, 1, 1)
%%SET defCols7()
%%SET bTrees7(2)
%%SET bTreeCols7_2(2, 3)
%%SET aks7()
%%SET fks7()
%%SET schConst7_2(12)
%%SET scanPred7_1("", "SQLC_TOWFAULTCODES_FAULTNO_Data", "", "SQLM_TOWFAULTCODES_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred7_2("", "SQLC_TOWFAULTCODES_TROWNO_Data", "", "SQLM_TOWFAULTCODES_OperRow", "65531", "", "", ">", "False", "True", "False")
%%SET scanCols7_1(3)
%%SET scanCols7_2(2)
%%SET scanNulls7_1()
%%SET scanNulls7_2()
%%SET scanNullPtrs7_1()
%%SET scanNullPtrs7_2()
%%SET colMin7_2(0)
%%SET colMin7_3(1)
%%SET colMax7_2(65531)
%%SET colMax7_3(255)


!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE SYSFAULTCODES
   CREATE!

!------------------------------------------------------------------------------!

%%SET tables(,SYSFAULTCODES)
%%SET tabNos(,8)
%%SET tabSlogans(,"""""")
%%SET tabSaes(,"15")
%%SET tabMinSizes(,0)
%%SET tabMaxSizes(,65000)
%%SET tabDivDirs(,1)
%%SET tabRelDivs(,1)
%%SET tabDivConsts(,0)
%%SET workSaes(,"16")
%%SET workMinSizes(,0)
%%SET workMaxSizes(,500)
%%SET workDivDirs(,1)
%%SET workRelDivs(,1)
%%SET workDivConsts(,0)
%%SET tabRAuths(,0)
%%SET tabWAuths(,0)
%%SET tabChecks(,2)
%%SET cols8("DBNUM", "FAULTNO", "FLTTEXT")
%%SET rnCols8()
%%SET bitsCols8(2)
%%SET symCols8()
%%SET strCols8(3)
%%SET numCols8()
%%SET packNumCols8()
%%SET normCols8(1, 3)
%%SET colTypes8("DBNUMBER", "BITS", "STRING")
%%SET colSizes8(32, 16, 15)
%%SET colProps8("", "RELOAD", "RELOAD")
%%SET colNull8(0, 0, 0)
%%SET colLen8(2, 1, 8)
%%SET colSlogans8("""""", """""", """""")
%%SET colVis8("READWRITE", "READWRITE", "READWRITE")
%%SET colNonVol8(1, 1, 1)
%%SET defCols8()
%%SET bTrees8(2)
%%SET bTreeCols8_2(2)
%%SET aks8()
%%SET fks8()
%%SET schConst8_2(7)
%%SET scanPred8_1("", "SQLC_SYSFAULTCODES_FAULTNO_Data", "", "SQLM_SYSFAULTCODES_OperRow", "256", "", "", "<", "False", "", "False")
%%SET scanPred8_2("", "SQLC_SYSFAULTCODES_FAULTNO_Data", "", "SQLM_SYSFAULTCODES_OperRow", "511", "", "", ">", "False", "True", "False")
%%SET scanCols8_1(2)
%%SET scanCols8_2(2)
%%SET scanNulls8_1()
%%SET scanNulls8_2()
%%SET scanNullPtrs8_1()
%%SET scanNullPtrs8_2()
%%SET colMin8_2(256)
%%SET colMax8_2(511)


!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE SYSTEMFIELDS 
   CREATE!

!------------------------------------------------------------------------------!

%%SET tables(,SYSTEMFIELDS)
%%SET tabNos(,9)
%%SET tabSlogans(,"""""")
%%SET tabSaes(,"19")
%%SET tabMinSizes(,0)
%%SET tabMaxSizes(,65000)
%%SET tabDivDirs(,1)
%%SET tabRelDivs(,1)
%%SET tabDivConsts(,0)
%%SET workSaes(,"20")
%%SET workMinSizes(,0)
%%SET workMaxSizes(,500)
%%SET workDivDirs(,1)
%%SET workRelDivs(,1)
%%SET workDivConsts(,0)
%%SET tabRAuths(,0)
%%SET tabWAuths(,0)
%%SET tabChecks(,5)
%%SET cols9("DBNUM", "TROWNO", "ROWGEN", "LOCK")
%%SET rnCols9()
%%SET bitsCols9(2, 3, 4)
%%SET symCols9()
%%SET strCols9()
%%SET numCols9()
%%SET packNumCols9()
%%SET normCols9(1, 3, 4)
%%SET colTypes9("DBNUMBER", "BITS", "BITS", "BITS")
%%SET colSizes9(32, 16, 16, 16)
%%SET colProps9("", "RELOAD", "RELOAD", "RELOAD")
%%SET colNull9(0, 0, 0, 0)
%%SET colLen9(2, 1, 1, 1)
%%SET colSlogans9("""""", """""", """""", """""")
%%SET colVis9("READWRITE", "READONLY", "READONLY", "READONLY")
%%SET colNonVol9(1, 1, 1, 1)
%%SET defCols9()
%%SET bTrees9(2, 3)
%%SET bTreeCols9_2(2)
%%SET bTreeCols9_3(2)
%%SET aks9()
%%SET fks9(3)
%%SET fkTab9_3(TABLES)
%%SET fkAct9_3("RESTRICT")
%%SET schConst9_2(7)
%%SET schConst9_3(7)
%%SET scanPred9_1("", "SQLC_SYSTEMFIELDS_LOCK_Data", "", "SQLM_SYSTEMFIELDS_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred9_2("", "SQLC_SYSTEMFIELDS_LOCK_Data", "", "SQLM_SYSTEMFIELDS_OperRow", "4095", "", "", ">", "False", "", "False")
%%SET scanPred9_3("", "SQLC_SYSTEMFIELDS_ROWGEN_Data", "", "SQLM_SYSTEMFIELDS_OperRow", "1", "", "", "<", "False", "", "False")
%%SET scanPred9_4("", "SQLC_SYSTEMFIELDS_ROWGEN_Data", "", "SQLM_SYSTEMFIELDS_OperRow", "4095", "", "", ">", "False", "", "False")
%%SET scanPred9_5("", "SQLC_SYSTEMFIELDS_TROWNO_Data", "", "SQLM_SYSTEMFIELDS_OperRow", "65531", "", "", ">", "False", "True", "False")
%%SET scanCols9_1(4)
%%SET scanCols9_2(4)
%%SET scanCols9_3(3)
%%SET scanCols9_4(3)
%%SET scanCols9_5(2)
%%SET scanNulls9_1()
%%SET scanNulls9_2()
%%SET scanNulls9_3()
%%SET scanNulls9_4()
%%SET scanNulls9_5()
%%SET scanNullPtrs9_1()
%%SET scanNullPtrs9_2()
%%SET scanNullPtrs9_3()
%%SET scanNullPtrs9_4()
%%SET scanNullPtrs9_5()
%%SET colMin9_2(0)
%%SET colMin9_3(1)
%%SET colMin9_4(1)
%%SET colMax9_2(65531)
%%SET colMax9_3(4095)
%%SET colMax9_4(4095)


!******************************************************************************!
!END SQL!



! The includes below are only stated to make sure that all the
  grammar rules are used !


!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE TEST1
   CREATE!

!------------------------------------------------------------------------------!

%%SET tables(,TEST1)
%%SET tabNos(,10)
%%SET tabSlogans(,"""test table no 1""")
%%SET tabSaes(,"10")
%%SET tabMinSizes(,0)
%%SET tabMaxSizes(,65000)
%%SET tabDivDirs(,1)
%%SET tabRelDivs(,1)
%%SET tabDivConsts(,0)
%%SET workSaes(,"20")
%%SET workMinSizes(,0)
%%SET workMaxSizes(,500)
%%SET workDivDirs(,1)
%%SET workRelDivs(,1)
%%SET workDivConsts(,0)
%%SET tabRAuths(,0)
%%SET tabWAuths(,0)
%%SET tabChecks(,6)
%%SET cols10("COL10", "COL1", "COL2", "COL3", "COL4", "COL5", "COL6", "COL7", "COL8")
%%SET rnCols10(COL9)
%%SET bitsCols10(3, 4)
%%SET symCols10(8)
%%SET strCols10(2, 5, 7)
%%SET numCols10(6)
%%SET packNumCols10(9)
%%SET normCols10(1, 4, 5, 7, 8, 9)
%%SET colTypes10("DBNUMBER", "STRING", "BITS", "BITS", "STRING", "NUMSTRING", "STRING", "SYMBOL", "PACKED NUMSTRING")
%%SET colSizes10(0, 15, 16, 16, 15, 7, 31, 1, 28)
%%SET colProps10("", "RELOAD", "RELOAD", "RELOAD", "", "RELOAD", "RELOAD", "RELOAD", "RELOAD")
%%SET colNull10(0, 0, 0, 1, 0, 1, 1, 1, 1)
%%SET colLen10(2, 8, 1, 1, 8, 4, 16, 1, 8)
%%SET colSlogans10("""""", """column 1""", """column 2""", """column 3""", """column 4""", """""", """""", """""", """""")
%%SET colVis10("READWRITE", "READWRITE", "READWRITE", "READWRITE", "READWRITE", "READWRITE", "READWRITE", "READWRITE", "READWRITE")
%%SET colNonVol10(1, 1, 1, 1, 0, 1, 1, 1, 1)
%%SET defCols10(4, 5, 6, 7, 8, 9)
%%SET defVal10_4("NULL")
%%SET defVal10_5("""xxx""")
%%SET defVal10_6("NULL")
%%SET defVal10_7("NULL")
%%SET defVal10_8("NULL")
%%SET defVal10_9("NULL")
%%SET symVals10_8(FALSE, TRUE)
%%SET symLits10_8(0, 1)
%%SET bTrees10(2, 3)
%%SET bTreeCols10_2(2, 3)
%%SET bTreeCols10_3(6)
%%SET aks10()
%%SET fks10()
%%SET schConst10_2(24)
%%SET schConst10_3(17)
%%SET prepLabel10(XX)
%%SET commLabel10(YY)
%%SET rollLabel10(ZZ)
%%SET scanPred10_1("", "SQLC_TEST1_COL2_Data", "", "SQLM_TEST1_OperRow", "4", "", "", ">", "0", "", "2")
%%SET scanPred10_2("2", "SQLC_TEST1_COL1_Data", "", "SQLM_TEST1_OperRow", "(A * B) / C", "", "", "<", "2", "", "1")
%%SET scanPred10_3("", "D", "", "", "- 4", "", "", "/=", "2", "0", "")
%%SET scanPred10_4("1", "SQLC_TEST1_COL1_Data", "", "SQLM_TEST1_OperRow", "2", "", "", ">=", "False", "", "False")
%%SET scanPred10_5("0", "SQLC_TEST1_COL3_Data", "", "SQLM_TEST1_OperRow", "0", "", "", "<", "False", "", "False")
%%SET scanPred10_6("", "SQLC_TEST1_COL2_Data", "", "SQLM_TEST1_OperRow", "0", "", "", "<", "False", "True", "False")
%%SET scanCols10_1(3)
%%SET scanCols10_2(2)
%%SET scanCols10_3()
%%SET scanCols10_4(2)
%%SET scanCols10_5(4)
%%SET scanCols10_6(3)
%%SET scanNulls10_1()
%%SET scanNulls10_2()
%%SET scanNulls10_3()
%%SET scanNulls10_4()
%%SET scanNulls10_5()
%%SET scanNulls10_6()
%%SET scanNullPtrs10_1()
%%SET scanNullPtrs10_2()
%%SET scanNullPtrs10_3()
%%SET scanNullPtrs10_4()
%%SET scanNullPtrs10_5()
%%SET scanNullPtrs10_6()
%%SET colMin10_3(0)
%%SET colMin10_4(0)
%%SET colMax10_3(65535)
%%SET colMax10_4(65535)


!******************************************************************************!
!END SQL!



!BEGIN SQL INCLUDE_TABLE 0!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE TEST2!

!------------------------------------------------------------------------------!

%%SET remTables(,TEST2)
%%SET remTabNos(,256)
%%SET cols256("COL10", "COL1", "COL2", "COL3", "COL4", "COL5", "COL6", "COL7", "COL8")
%%SET colLen256(2, 8, 1, 1, 8, 4, 16, 1, 8)
%%SET colNull256(0, 0, 0, 1, 0, 1, 1, 1, 1)
%%SET colTypes256("DBNUMBER", "STRING", "BITS", "BITS", "STRING", "NUMSTRING", "STRING", "SYMBOL", "PACKED NUMSTRING")
%%SET colSizes256(0, 15, 16, 16, 15, 7, 31, 1, 28)
%%SET bTrees256(2, 3)
%%SET bTreeCols256_2(2, 3)
%%SET bTreeCols256_3(6)
%%SET symCols256(8)
%%SET symVals256_8(FALSE, TRUE)
%%SET symLits256_8(0, 1)


!******************************************************************************!
!END SQL!



!BEGIN SQL INCLUDE_TABLE 0!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE TEST3!

!------------------------------------------------------------------------------!

%%SET remTables(,TEST3)
%%SET remTabNos(,257)
%%SET cols257("COL10", "COL1", "COL2", "COL3", "COL4", "COL5", "COL6", "COL7", "COL8")
%%SET colLen257(2, 8, 1, 1, 8, 4, 16, 1, 8)
%%SET colNull257(0, 0, 0, 1, 0, 1, 1, 1, 1)
%%SET colTypes257("DBNUMBER", "STRING", "BITS", "BITS", "STRING", "NUMSTRING", "STRING", "SYMBOL", "PACKED NUMSTRING")
%%SET colSizes257(0, 15, 16, 16, 15, 7, 31, 1, 28)
%%SET bTrees257(2, 3, 4)
%%SET bTreeCols257_2(2, 3)
%%SET bTreeCols257_3(4)
%%SET bTreeCols257_4(6)
%%SET symCols257(8)
%%SET symVals257_8(FALSE, TRUE)
%%SET symLits257_8(0, 1)
%%SET multiNo257(5)


!******************************************************************************!
!END SQL!














!*****************************************************************************!
!*                                                                           *! 
!*             C U R S O R   D E C L A R A T I O N S                         *!
!*                                                                           *!
!*****************************************************************************! 
 



!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE EXTENSIVETABS CURSOR FOR
   SELECT TROWNO
   FROM TABLES
   WHERE NAME=`%PROTECTEDP:TABNAME!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!
 
      

!BEGIN SQL DECLARE_CURSOR 5!
!******************************************************************************!

!EXEC SQL DECLARE FINDFK CURSOR FOR
   SELECT ORDNO, FBLKREF, FTABREF, KEYNO, COND 
   FROM FOREIGNKEYS
   WHERE  BLKREF = `%PROTECTEDP:TOWBLKREF AND 
       TABREF = `%PROTECTEDP:TOWTABREF
      AND  ORDNO = `%CREFERRINGFKORDNO!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

 

!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE FINDNEWTABLE CURSOR FOR
   SELECT TROWNO
   FROM TABLES
   WHERE TROWNO =< `%ZMAXNOFROWS!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!



!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE FINDNEXTTABLE CURSOR FOR
   SELECT TROWNO
   FROM TABLES
   WHERE BLKREF = `%CBLOCK(`%CK)!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

         

!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE FINDORDNO CURSOR FOR
   SELECT ORDNO
   FROM FOREIGNKEYS
   WHERE TROWNO = `%PROTECTEDP:REFERREDTROWNO AND ORDNO =< `%ZMAXORDNO!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

         

!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE FINDTROWNO CURSOR FOR
   SELECT TROWNO
   FROM TABLES
   WHERE  NAME = `%PROTECTEDP:REFERREDTABNAME!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!



!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE GETBLOCKANDTABREF CURSOR FOR
   SELECT BLKREF, TABREF
   FROM TABLES
   WHERE NAME = `%PROTECTEDP:TABNAME!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

         

!BEGIN SQL DECLARE_CURSOR 4!
!******************************************************************************!

!EXEC SQL DECLARE GETTROWNO CURSOR FOR
   SELECT TROWNO
   FROM TABLES
   WHERE BLKREF=`%PROTECTEDP:TOWBLKREF
   AND TABREF=`%PROTECTEDP:TOWTABREF!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

   
   
     
   

!BEGIN SQL COMMON 0!

%%PROCESS ("CCL")

%%SET protInitSize(100)
%%SET tempSizes(3, 3)
%%SET tempUse1("STR")
%%SET tempUse2("STR")
%%BEGIN(userProtection)

   VARIABLE BLKNUM 16 DS;
   VARIABLE BLKREF 16 DS;
   VARIABLE CONDITION 16 DS;
   VARIABLE COUNTER 16 DS;
   VARIABLE DELETEACTION 16 DS;            ! FOREIGN KEY DELETE ACTION        !
   VARIABLE FBLKREF 16 DS;                 ! BLOCK REFERENCE OF REFERRING TAB !
   VARIABLE FKNUMBER 16 DS;                ! FOREIGN KEY NUMBER               !
   VARIABLE FLDDATATYPE 16 DS;             ! DATA TYPE OF COLUMN VARIABLE     !
   VARIABLE FLDNUMBER 16 DS;               ! FIELD NUMBER                     !
   VARIABLE FLDPROTECTION 16 DS;           ! FIELD PROTECTION/VISIBILITY      !
   VARIABLE FLDSIZE 16 DS;                 ! FIELD SIZE                       !
   VARIABLE FROWNO 16 DS;                  ! ROWNUMBER IN FIELDS TABLE        !
   VARIABLE FTABREF 16 DS;                 ! TABLE REFERENCE OF REFERRING TAB !
   VARIABLE KEYNO 16 DS;                   ! ORDINAL KEY NUMBER               !
   VARIABLE LOCATION 16 DS;                ! TABLE LOCATION (SINGLE/MULTIPLE) !
   VARIABLE MAXSYMLENGTH 16 DS;            ! LONGEST SYMBOL VALUE NAME        !
   VARIABLE NAMELENGTH 8 DS;               ! LENGTH OF SYMBOL VALUE NAME      !
   VARIABLE NEXTTOBEDELETED 16 DS;         ! ROWNUMBER OF ROW TO BE DELETED   !
   VARIABLE ORDNO 16 DS;                   ! ORDINAL NUMBER                   !
   VARIABLE PRWIDTH 16 DS;                 ! PRINTOUT WIDTH OF COLUMN         !
   VARIABLE RAUTHCAT 16 DS;                ! TABLE READ AUTHORITY CATEGORY    !
   VARIABLE REF 16 DS;                     ! RETURN SIGNAL REFERENCE          !
   VARIABLE REFERREDTROWNO 16 DS;          ! TABLE ROW NUMBER OF REFERRED TAB !
   VARIABLE SAMENAME 16 DS;                ! ROWNUMBER OF TABLE WITH SAME NAME!
   VARIABLE SYMBOLVALUE 16 DS;             ! NUMERICAL SYMBOL VALUE           !
   VARIABLE TABREF 16 DS;
   VARIABLE TOWBLKREF 16 DS;               ! TABLE OWNER BLOCK REFERENCE      !
   VARIABLE TOWTABREF 16 DS;               ! TABLE OWNER TABLE REFERENCE      !
   VARIABLE TRANSID 16 DS;                 ! TRANSACTION IDENTITY             !
   VARIABLE TROWNO 16 DS;                  ! ROWNUMBER IN TABLES TABLE        !
   VARIABLE USERP 16 DS;                   ! USER'S POINTER                   !
   VARIABLE VOLATIL 16 DS;                 ! VARIABLE PROPERTY VOLATILE       !
   VARIABLE WAUTHCAT 16 DS;                ! TABLE WRITE AUTHORITY CATEGORY   !

   STRING VARIABLE FLDNAME 7 DS;           ! COLUMN NAME                      !
   STRING VARIABLE REFERREDTABNAME 15 DS;  ! NAME OF REFERRED TABLE           !
   STRING VARIABLE TABNAME 15 DS;          ! TABLE NAME                       !
                              
   SYMBOL VARIABLE SYMBOLFOUND=(FALSE, TRUE) DS;
                                            ! NEW SYMBOL VALUE NAME FOUND?     !
   
%%END(userProtection)

%%BEGIN(towSymbols)
NSYMB TABLESEAID = 10;
NSYMB WORKSAEID = 20;
STRING SLOG = ""test table no 1"";

%%END(towSymbols)

%%SET curNames(EXTENSIVETABS, FINDFK, FINDNEWTABLE, FINDNEXTTABLE, FINDORDNO, FINDTROWNO, GETBLOCKANDTABREF, GETTROWNO)
%%SET curLocal(1, 1, 1, 1, 1, 1, 1, 1)
%%SET curTabNos(1, 5, 1, 1, 5, 1, 1, 1)
%%SET curTabNames(TABLES, FOREIGNKEYS, TABLES, TABLES, FOREIGNKEYS, TABLES, TABLES, TABLES)

%%SET curBlockRefs("", "", "", "", "", "", "", "")

%%INCLUDE (towDeclarations)

%%INCLUDE (tuDeclarations)

!END SQL!
END DECLARE;

PROGRAM; PLEX;

!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!
!*                                                                           *! 
!*              D A T A   D I C T I O N A R Y   I N T E R F A C E            *!
!*                                                                           *!
!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!




!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!
!*                                                                           *! 
!*              S I G N A L   E N T R I E S                                  *!
!*                                                                           *!
!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!




!*****************************************************************************!
!*                                                                           *! 
!*             T R H S T A T R A N S R                                       *!
!*                                                                           *!
!*****************************************************************************!



   ENTER TRHSTATRANSR WITH
      PROTECTEDP,
      CMESSAGE,
      PROTECTEDP:SQL_SQLTID; 
      
   CASE CRETURNFROMTRHSTATRANSR IS
      WHEN SYMCLEARSOMETABS80 DO
         GOTO CLEARSOMETABS80;
         
      WHEN SYMCLEARALLTABS30 DO
         GOTO CLEARALLTABS30;
         
      WHEN SYMDDINITTABLE20 DO
         GOTO DDINITTABLE20;
         
      WHEN SYMDDINITFIELD20 DO
         GOTO DDINITFIELD20;
         
      WHEN SYMDDINITFK10 DO
         GOTO DDINITFK10;
         
      OTHERWISE DO;
   ESAC;
      






!*****************************************************************************!
!*                                                                           *! 
!*             T R H S T O P T R A N S R                                     *!
!*                                                                           *!
!*****************************************************************************!




! THIS ROUTINE ENTERS THE RETURN SIGNAL TO TRHSTOPTRANS. TRHSTOP- !
! TRANS MAY HAVE BEEN INITIATED BY EITHER DDFCSTA OR BLKREMST,    !
! AND CSIGNAL KNOWS WHICH ONE IT WAS.                             !

! INDATA:        CSIGNAL                                          !

! OUTDATA:       NONE                                             ! 

   ENTER TRHSTOPTRANSR;
   
   CASE CSIGNAL IS
      WHEN DDFCSTA DO
         SEND DDFCSTAR WITH
            CUSERP(ZDDFCSTA);
      WHEN BLKREMST DO
         SEND BLKREMSTRPY;
      OTHERWISE DO;
   ESAC;
   
   EXIT;               














!*****************************************************************************!
!*                                                                           *! 
!*             B L K R E M S T ,    D D F C S T A                            *!
!*                                                                           *!
!*****************************************************************************!




! THE OBJECTIVE OF THIS ROUTINE IS TO SEND THE SIGNAL TRHSTOP-    !
! TRANS, WHICH WILL STOP AND ROLL BACK ALL TRANSACTIONS THAT ARE  !
! CURRENTLY PERFORMED, AND WHICH WILL BLOCK RECEPTION OF NEW      !
! TRANSACTIONS. THE ROUTINE IS INITIATED EITHER BY RECEPTION OF   !
! THE SIGNAL DDFCSTA OR BY RECEPTION OF THE SIGNAL BLKREMST.      !

! INSIGNALS:         DDFCSTA OR BLKREMST                          !

! OUTSIGNAL:         TRHSTOPTRANS                                 !

! INDATA:            NONE                                         !

! OUTDATA:           CSIGNAL                                      !

  
   ENTER BLKREMST WITH
      +,
      +;
      
   CSIGNAL=BLKREMST;
   SEND TRHSTOPTRANS;
   EXIT;
   
   
   ENTER DDFCSTA WITH
      CUSERP(ZDDFCSTA),
      +,
      +;
      
   CSIGNAL=DDFCSTA;
   SEND TRHSTOPTRANS;
   EXIT;



   
   
      

!*****************************************************************************!
!*                                                                           *! 
!*             D D I N I T F I E L D                                         *!
!*                                                                           *!
!*****************************************************************************!




! A TABLE OWNER ASKS DD TO INITIATE A SPECIFIC FIELD I.E. TO      !
! INSERT THE FIELD DEFINITION IN THE FIELDS TABLE. DDINTERFACE    !
! RECEIVES THE SIGNAL DDINITFIELD, CALCULATES THE PRINTOUT WIDTH  !
! AS THE MAXIMUM WIDTH OF THE FIELD NAME AND THE FIELD VALUE,     !
! ASKS THE TABLES TABLE FOR THE CURRENT ROW NUMBER IN TABLES AND  !
! FORWARDS THE INFORMATION TO SYSTEMTABLES BY SENDING THE SIGNAL  !
! SYSINITFLD. !

! INDATA:        NONE                                             !

! OUTDATA:       NONE                                             !


   ENTER DDINITFIELD WITH
      TUSERP,
      TTOWBLKREF,
      TTOWTABREF,
      CFLDNAME,
      TFLDNUMBER,
      TFLDPROTECTION,
      TFLDDATATYPE,
      TFLDSIZE,
      TVOLATILE;
   
   
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (beginStat)


!******************************************************************************!
!END SQL!


   
   PROTECTEDP:REF=TTOWBLKREF;
   PROTECTEDP:TOWBLKREF=TTOWBLKREF;
   PROTECTEDP:USERP=TUSERP;
   PROTECTEDP:TOWTABREF=TTOWTABREF;
   PROTECTEDP:FLDNAME=CFLDNAME;
   PROTECTEDP:FLDNUMBER=TFLDNUMBER;
   PROTECTEDP:FLDPROTECTION=TFLDPROTECTION;
   PROTECTEDP:FLDDATATYPE=TFLDDATATYPE;
   PROTECTEDP:FLDSIZE=TFLDSIZE;
   PROTECTEDP:VOLATIL=TVOLATILE;
   
   

   CHAR VX:CFLDNAME(N:0) TO VT:TNAMELENGTH;
   PROTECTEDP:NAMELENGTH=TNAMELENGTH;

   CASE PROTECTEDP:FLDDATATYPE IS
      WHEN ZBITS DO  
         CASE PROTECTEDP:FLDSIZE IS
            WHEN 1,2 DO
               PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
            WHEN 4 DO
               IF PROTECTEDP:NAMELENGTH > 2 THEN
                  PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
               ELSE
                  PROTECTEDP:PRWIDTH=2;
               FI; 
            WHEN 8 DO
               IF PROTECTEDP:NAMELENGTH > 3 THEN
                  PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
               ELSE
                  PROTECTEDP:PRWIDTH=3;
               FI;
            WHEN 16 DO
               IF PROTECTEDP:NAMELENGTH > 5 THEN
                  PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
               ELSE
                  PROTECTEDP:PRWIDTH=5;
               FI; 
            OTHERWISE DO;         
         ESAC;
   
      WHEN ZSTR, ZNUMSTR DO 
         CASE PROTECTEDP:FLDSIZE IS
            WHEN 1 DO
               PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
            WHEN 3 DO
               IF PROTECTEDP:NAMELENGTH > 3 THEN 
                  PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
               ELSE
                  PROTECTEDP:PRWIDTH=3;
               FI;
            OTHERWISE DO
               PROTECTEDP:PRWIDTH = PROTECTEDP:FLDSIZE;
         ESAC;
   
      WHEN ZPACKEDNUMSTR DO 
         PROTECTEDP:PRWIDTH=PROTECTEDP:FLDSIZE;
   
      WHEN ZSYMBOL DO 
         CRETURNFROMCHECKSYMVALNAMELENGTH = SYMDDINITFIELD10;
         GOTO CHECKSYMVALNAMELENGTH;         
                         
   
      WHEN ZROWNUMBER DO
         CASE PROTECTEDP:FLDSIZE IS
            WHEN 16 DO
               IF PROTECTEDP:NAMELENGTH > 5 THEN  
                  PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
               ELSE
                  PROTECTEDP:PRWIDTH=5;
               FI;
            WHEN 20 DO                  ! ROWNUMBER WILL BE EXPANDED !
               PROTECTEDP:PRWIDTH=7;    ! TO 20 BITS IN THE FUTURE   !
            OTHERWISE DO;
         ESAC; 
   
      WHEN ZDBNUMBER DO
         PROTECTEDP:PRWIDTH=10;         ! THE PRINTOUT WIDTH IS !
      OTHERWISE DO;
   ESAC;                                ! DETERMINED !

DDINITFIELD10)
              

   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN GETTROWNO!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(4)
%%SET keyExprs("TOWBLKREF")
%%SET keyPtrs("PROTECTEDP")
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(8)
%%INCLUDE (locOpenStat)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH GETTROWNO INTO `%PROTECTEDP:TROWNO!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(4)
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(8)
%%SET cols(0)
%%SET vars("TROWNO")
%%SET ptrs("PROTECTEDP")
%%SET nulls("")
%%SET nullPtrs("")
%%SET preds(1)
%%SET scanPred1("", "SQLC_TABLES_TABREF_Data", "", "SQLM_TABLES_OperRow", "TOWTABREF", "", "PROTECTEDP", "=", "True", "False", "False")
%%SET scanCols1(4)
%%SET scanNulls1()
%%SET scanNullPtrs1()
%%INCLUDE (locFetchStat)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE GETTROWNO!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET curNo(8)
%%INCLUDE (locCloseStat)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!






     
! THIS ROUTINE ENTERS THE SIGNAL SYSINITFLD FROM THE DD INTERFACE !
! MODULE. THE OBJECTIVE IS TO INSERT A NEW ROW INTO THE FIELDS    !
! TABLE, AND THUS TO DEFINE A NEW USER FIELD. THE ROUTINE WILL    !
! SEND THE SIGNAL SYSINITFLDR TO DD INTERFACE AS AN ACKNOW-       !
! LEGDEMENT ONCE ALL ACTION IS TAKEN.                             !

! IF IT TURNS OUT THAT THE FIELDS TABLE IS FULL WHEN THE INSERT IS!
! ATTEMPTED, THE SIGNAL PROGERROR WILL BE SENT. THIS SIGNAL WILL  !
! CAUSE A NEW RESTART, MAKING THE OLD SYSTEM EXECUTIVE.           !

! INDATA:       CNEXTFROWNO          NEXT AVAILABLE PRIMARY KEY  !

! OUTDATA:      CNEXTFROWNO          NEXT AVAILABLE PRIMARY KEY  !                

 
                      




   PROTECTEDP:FROWNO=CNEXTFROWNO;
   CNEXTFROWNO=CNEXTFROWNO+1;
   

                


   CRETURNFROMTRHSTATRANSR = SYMDDINITFIELD20;        
   SEND TRHSTATRANS WITH
      PROTECTEDP,            ! OWN POINTER !
      COWNREF,
      ZDONOTLOG,
      +;     
   EXIT;

DDINITFIELD20)

   
!BEGIN SQL INSERT 27!
!******************************************************************************!

!EXEC SQL INSERT INTO FIELDS
     (FROWNO,
      NAME,
      TABREF,
      BLKREF,
      FIELDNO,
      VISIBIL,
      PRWIDTH,
      NULLPER,
      DATATYP,
      BADDRES,
      SIZE,
      VOLATIL,
      TROWNO)
   VALUES
     (`%PROTECTEDP:FROWNO,
      `%PROTECTEDP:FLDNAME,
      `%PROTECTEDP:TOWTABREF,
      `%PROTECTEDP:TOWBLKREF,
      `%PROTECTEDP:FLDNUMBER,
      `%PROTECTEDP:FLDPROTECTION,
      `%PROTECTEDP:PRWIDTH,
      TRUE,
      `%PROTECTEDP:FLDDATATYPE,
      1,
      `%PROTECTEDP:FLDSIZE,
      `%PROTECTEDP:VOLATIL,
      `%PROTECTEDP:TROWNO)!

!------------------------------------------------------------------------------!

%%SET tabNo(2)
%%SET tabName(FIELDS)
%%SET keyNo(2)
%%SET keyExprs("FROWNO")
%%SET keyPtrs("PROTECTEDP")
%%SET keyPrefix(1)
%%SET sigCount(1)
%%SET sigAssVars0()
%%SET sigAssVars1()
%%SET sigAssPtrs0()
%%SET sigAssPtrs1()
%%SET sigAssExprs0()
%%SET sigAssExprs1()
%%SET sigCols0(2, 3, 4, 5, 7)
%%SET sigCols1(8, 9, 10, 11, 14, 21, 27)
%%SET sigExprs0("FLDNAME", "TOWTABREF", "TOWBLKREF", "FLDNUMBER", "FLDPROTECTION")
%%SET sigExprs1("PRWIDTH", "0", "FLDDATATYPE", "1", "FLDSIZE", "VOLATIL", "TROWNO")
%%SET sigPtrs0("PROTECTEDP", "PROTECTEDP", "PROTECTEDP", "PROTECTEDP", "PROTECTEDP")
%%SET sigPtrs1("PROTECTEDP", "", "PROTECTEDP", "", "PROTECTEDP", "PROTECTEDP", "PROTECTEDP")
%%SET sigNulls0("", "", "", "", "")
%%SET sigNulls1("", "", "", "", "", "", "")
%%SET sigNullPtrs0("", "", "", "", "")
%%SET sigNullPtrs1("", "", "", "", "", "", "")
%%INCLUDE (insertStat)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL COMMIT 0!
!******************************************************************************!

!EXEC SQL COMMIT TRANSACTION!

!------------------------------------------------------------------------------!

%%INCLUDE (commitStat)


!******************************************************************************!
!END SQL!
      


   CASE SQLCODE.VALUE IS
      WHEN ZROWINSERTED DO;
      
      WHEN ZSEARCHFAIL DO
         IF SQLCODE.SUBCODE = ZROWNOTALLOCATED THEN
            
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
               INTO `%TTABREF, `%TSAEID
               FROM TABLES
               WHERE NAME = `%ZFIELDS AND BLKREF = `%COWNREF!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyExprs("ZFIELDS", "COWNREF")
%%SET keyPtrs("", "")
%%SET keyPrefix(2)
%%SET cols(4, 6)
%%SET vars("TTABREF", "TSAEID")
%%SET ptrs("", "")
%%SET nulls("", "")
%%SET nullPtrs("", "")
%%INCLUDE (locSelectStat)


!******************************************************************************!
!END SQL!

                  
            SEND PROGERROR WITH
               ZPROGERRORCODE1,
               COWNREF,
               TTABREF,
               TSAEID;
            EXIT;
         FI;
         
      WHEN ZERROR DO
         CASE SQLCODE.SUBCODE IS
            WHEN ZTABFULL DO
               
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
                  INTO `%TTABREF, `%TSAEID
                  FROM TABLES
                  WHERE NAME = `%ZFIELDS AND BLKREF = `%COWNREF!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyExprs("ZFIELDS", "COWNREF")
%%SET keyPtrs("", "")
%%SET keyPrefix(2)
%%SET cols(4, 6)
%%SET vars("TTABREF", "TSAEID")
%%SET ptrs("", "")
%%SET nulls("", "")
%%SET nullPtrs("", "")
%%INCLUDE (locSelectStat)


!******************************************************************************!
!END SQL!

                  
               SEND PROGERROR WITH
                  ZPROGERRORCODE1,
                  COWNREF,
                  TTABREF,
                  TSAEID;
               EXIT;
               
            WHEN ZTRHCONG DO
               SEND PROGERROR WITH
                  ZPROGERRORCODE4,
                  ZTRHSAEID2;
               EXIT;

            OTHERWISE DO;
         ESAC;
         
      OTHERWISE DO;
   ESAC;
   
   SEND DDINITFIELDR REFERENCE PROTECTEDP:REF WITH
      PROTECTEDP:USERP;
   

   
!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (endStat)


!******************************************************************************!
!END SQL!

   EXIT;

         

                  
       










      

!*****************************************************************************!
!*                                                                           *! 
!*             D D I N I T F K                                               *!
!*                                                                           *!
!*****************************************************************************!




! A TABLE OWNER ASKS DD TO INITIATE A SPECIFIC FOREIGN KEY I.E.   !
! TO INSERT THE FOREIGN KEY DEFINITION IN THE FOREIGNKEYS TABLE.  !
! DDINTERFACE RECEIVES THE SIGNAL DDINITFK, TRANSLATES THE TABLE  !
! NAME OF THE REFERRED TABLE TO ITS ROWNUMBER IN THE TABLES TABLE !
! AND FORWARDS THE INFORMATION TO SYSTEMTABLES BY SENDING THE     !
! SIGNAL SYSINITFK.                                               !

! IF THE REFERRED TABLE IS NOT DEFINED IN THE TABLES TABLE, THE   !
! SIGNAL PROGERROR IS SENT. THIS SIGNAL WILL INITIATE A NEW       !
! RESTART, WHICH IMPLIES THAT THE OLD SYSTEM WILL BECOME          !
! EXECUTIVE.                                                      !

! INDATA:        NONE                                             !

! OUTDATA:       NONE                                             !


ENTER DDINITFK WITH
   TUSERP,
   TTOWBLKREF,
   TTOWTABREF,
   TFKNUMBER,
   CREFERREDTABNAME,
   TDELETEACTION;


!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (beginStat)


!******************************************************************************!
!END SQL!


PROTECTEDP:USERP=TUSERP;
PROTECTEDP:REF=TTOWBLKREF;
PROTECTEDP:TOWBLKREF=TTOWBLKREF;  
PROTECTEDP:TOWTABREF=TTOWTABREF;
PROTECTEDP:FKNUMBER=TFKNUMBER;
PROTECTEDP:REFERREDTABNAME=CREFERREDTABNAME;
PROTECTEDP:DELETEACTION=TDELETEACTION;
      

   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN FINDTROWNO!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyExprs("REFERREDTABNAME")
%%SET keyPtrs("PROTECTEDP")
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(6)
%%INCLUDE (locOpenStat)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH FINDTROWNO INTO `%PROTECTEDP:REFERREDTROWNO!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(6)
%%SET cols(0)
%%SET vars("REFERREDTROWNO")
%%SET ptrs("PROTECTEDP")
%%SET nulls("")
%%SET nullPtrs("")
%%SET preds(0)
%%INCLUDE (locFetchStat)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!
   CASE SQLCODE.VALUE IS
      WHEN ZOK DO;
      WHEN ZSEARCHFAIL DO

         SEND PROGERROR WITH
            ZPROGERRORCODE3,
            PROTECTEDP:TOWBLKREF,
            PROTECTEDP:TOWTABREF;
         EXIT;
      OTHERWISE DO;                  ! DISCUSSIONS NEEDED !
   ESAC;                                
            
   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE FINDTROWNO!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET curNo(6)
%%INCLUDE (locCloseStat)


!******************************************************************************!
!END SQL!
       
                  
   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN GETTROWNO!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(4)
%%SET keyExprs("TOWBLKREF")
%%SET keyPtrs("PROTECTEDP")
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(8)
%%INCLUDE (locOpenStat)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH GETTROWNO INTO `%PROTECTEDP:TROWNO!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(4)
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(8)
%%SET cols(0)
%%SET vars("TROWNO")
%%SET ptrs("PROTECTEDP")
%%SET nulls("")
%%SET nullPtrs("")
%%SET preds(1)
%%SET scanPred1("", "SQLC_TABLES_TABREF_Data", "", "SQLM_TABLES_OperRow", "TOWTABREF", "", "PROTECTEDP", "=", "True", "False", "False")
%%SET scanCols1(4)
%%SET scanNulls1()
%%SET scanNullPtrs1()
%%INCLUDE (locFetchStat)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE GETTROWNO!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET curNo(8)
%%INCLUDE (locCloseStat)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!
            

   
! THIS ROUTINE ENTERS THE SIGNAL SYSINITFK FROM THE DD INTERFACE  !
! MODULE. THE OBJECTIVE IS TO INSERT A NEW ROW IN THE FOREIGNKEYS !
! TABLE, AND THUS DEFINE A NEW FOREIGN KEY RELATIONSHIP. THE ROU- !
! TINE WILL FIND THE NEXT AVAILABLE                               !
! ORDINAL NUMBER OF THE FOREIGN KEY AMONG THE FOREIGN KEYS THAT   !
! REFER TO THE REFERRED TABLE BY USING THE CURSOR FINDORDNO. ONCE !
! ALL DATA IS INSERTED INTO FOREIGNKEY, THE SIGNAL SYSINITFKR     !
! WILL BE SENT AS AN ACKNOWLEDGEMENT TO THE DD INTERFACE MODULE.  !

! IF THE INSERT FAILS BECASE THE FOREIGNKEYS TABLE IS UNDER-      !
! DIMENSIONED, THE SIGNAL PROGERROR WILL BE SENT. THIS SIGNAL     !
! WILL INITIATE A RESTART, WHICH IMPLIES THAT THE OLD SYSTEM WILL !
! BECOME EXECUTIVE.                                               !

      
   
   

   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN FINDORDNO!

!------------------------------------------------------------------------------!

%%SET tabNo(5)
%%SET tabName(FOREIGNKEYS)
%%SET keyNo(4)
%%SET keyExprs("REFERREDTROWNO")
%%SET keyPtrs("PROTECTEDP")
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(5)
%%INCLUDE (locOpenStat)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH FINDORDNO INTO `%PROTECTEDP:ORDNO !

!------------------------------------------------------------------------------!

%%SET tabNo(5)
%%SET tabName(FOREIGNKEYS)
%%SET keyNo(4)
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(5)
%%SET cols(3)
%%SET vars("ORDNO")
%%SET ptrs("PROTECTEDP")
%%SET nulls("")
%%SET nullPtrs("")
%%SET preds(1)
%%SET scanPred1("", "SQLC_FOREIGNKEYS_ORDNO_Data", "", "SQLM_FOREIGNKEYS_OperRow", "ZMAXORDNO", "", "", "=<", "True", "False", "False")
%%SET scanCols1(3)
%%SET scanNulls1()
%%SET scanNullPtrs1()
%%INCLUDE (locFetchStat)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!
   
   CASE SQLCODE.VALUE IS
      WHEN ZOK DO
         PROTECTEDP:ORDNO=PROTECTEDP:ORDNO+1;
      WHEN ZSEARCHFAIL DO
         PROTECTEDP:ORDNO=ZFIRSTORDNO;
      OTHERWISE DO;
   ESAC;      
  
   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE FINDORDNO!

!------------------------------------------------------------------------------!

%%SET tabNo(5)
%%SET tabName(FOREIGNKEYS)
%%SET curNo(5)
%%INCLUDE (locCloseStat)


!******************************************************************************!
!END SQL!

   
   
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT BLKREF, TABREF
      INTO `%PROTECTEDP:TOWBLKREF, `%PROTECTEDP:TOWTABREF
      FROM TABLES
      WHERE TROWNO = `%PROTECTEDP:REFERREDTROWNO!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(0)
%%SET keyExprs("REFERREDTROWNO")
%%SET keyPtrs("PROTECTEDP")
%%SET keyPrefix(1)
%%SET cols(3, 4)
%%SET vars("TOWBLKREF", "TOWTABREF")
%%SET ptrs("PROTECTEDP", "PROTECTEDP")
%%SET nulls("", "")
%%SET nullPtrs("", "")
%%INCLUDE (locSelectStat)


!******************************************************************************!
!END SQL!



   CRETURNFROMTRHSTATRANSR = SYMDDINITFK10;        
   SEND TRHSTATRANS WITH
      PROTECTEDP, 
      COWNREF,
      ZDONOTLOG,
      +;     
   EXIT;

DDINITFK10)

   
   
!BEGIN SQL INSERT 19!
!******************************************************************************!

!EXEC SQL INSERT INTO FOREIGNKEYS
     (TROWNO,
      ORDNO,
      BLKREF,
      TABREF,
      KEYNO,
      FTROWNO,
      FTABREF,
      FBLKREF,
      COND)
   VALUES
     (`%PROTECTEDP:REFERREDTROWNO,
      `%PROTECTEDP:ORDNO,
      `%PROTECTEDP:BLKREF,
      `%PROTECTEDP:TABREF,
      `%PROTECTEDP:FKNUMBER,
      `%PROTECTEDP:TROWNO,
      1,
      1,
      `%PROTECTEDP:DELETEACTION)!

!------------------------------------------------------------------------------!

%%SET tabNo(5)
%%SET tabName(FOREIGNKEYS)
%%SET keyNo(2)
%%SET keyExprs("REFERREDTROWNO", "ORDNO")
%%SET keyPtrs("PROTECTEDP", "PROTECTEDP")
%%SET keyPrefix(2)
%%SET sigCount(0)
%%SET sigAssVars0()
%%SET sigAssPtrs0()
%%SET sigAssExprs0()
%%SET sigCols0(4, 5, 6, 7, 8, 9, 10)
%%SET sigExprs0("BLKREF", "TABREF", "FKNUMBER", "TROWNO", "1", "1", "DELETEACTION")
%%SET sigPtrs0("PROTECTEDP", "PROTECTEDP", "PROTECTEDP", "PROTECTEDP", "", "", "PROTECTEDP")
%%SET sigNulls0("", "", "", "", "", "", "")
%%SET sigNullPtrs0("", "", "", "", "", "", "")
%%INCLUDE (insertStat)


!******************************************************************************!
!END SQL!
            
   
!BEGIN SQL COMMIT 0!
!******************************************************************************!

!EXEC SQL COMMIT TRANSACTION!

!------------------------------------------------------------------------------!

%%INCLUDE (commitStat)


!******************************************************************************!
!END SQL!
 


   CASE SQLCODE.VALUE IS
      WHEN ZROWINSERTED DO;
      
      WHEN ZSEARCHFAIL DO
         IF SQLCODE.SUBCODE = ZROWNOTALLOCATED THEN
            
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
               INTO `%TTABREF, `%TSAEID
               FROM TABLES
               WHERE NAME = `%ZFOREIGNKEYS AND BLKREF = `%COWNREF!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyExprs("ZFOREIGNKEYS", "COWNREF")
%%SET keyPtrs("", "")
%%SET keyPrefix(2)
%%SET cols(4, 6)
%%SET vars("TTABREF", "TSAEID")
%%SET ptrs("", "")
%%SET nulls("", "")
%%SET nullPtrs("", "")
%%INCLUDE (locSelectStat)


!******************************************************************************!
!END SQL!

                  
            SEND PROGERROR WITH
               ZPROGERRORCODE1,
               COWNREF,
               TTABREF,
               TSAEID;
            EXIT;
         FI;
         
      WHEN ZERROR DO
         CASE SQLCODE.SUBCODE IS
            WHEN ZTABFULL DO
               
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
                  INTO `%TTABREF, `%TSAEID
                  FROM TABLES
                  WHERE NAME = `%ZFOREIGNKEYS AND BLKREF = `%COWNREF!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyExprs("ZFOREIGNKEYS", "COWNREF")
%%SET keyPtrs("", "")
%%SET keyPrefix(2)
%%SET cols(4, 6)
%%SET vars("TTABREF", "TSAEID")
%%SET ptrs("", "")
%%SET nulls("", "")
%%SET nullPtrs("", "")
%%INCLUDE (locSelectStat)


!******************************************************************************!
!END SQL!

                  
               SEND PROGERROR WITH
                  ZPROGERRORCODE1,
                  COWNREF,
                  TTABREF,
                  TSAEID;
               EXIT;
               
            WHEN ZTRHCONG DO
               SEND PROGERROR WITH
                  ZPROGERRORCODE4,
                  ZTRHSAEID2;
               EXIT;

            OTHERWISE DO;
         ESAC;
         
      OTHERWISE DO;
   ESAC;

   
SEND DDINITFKR REFERENCE PROTECTEDP:REF WITH
   PROTECTEDP:USERP;
   

!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (endStat)


!******************************************************************************!
!END SQL!


EXIT;










!*****************************************************************************!
!*                                                                           *! 
!*             D D I N I T T A B L E                                         *!
!*                                                                           *!
!*****************************************************************************!




! A TABLE OWNER ASKS DD TO INITIATE A SPECIFIC TABLE I.E. TO      !
! INSERT THE TABLE DEFINITION IN THE TABLES TABLE. DDINTERFACE    !
! RECEIVES THE SIGNAL DDINITTABLE, STORES THE DATA IN THE         !
! PROTECTION FILE, AND SIMPLY FORWARDS THE PROTECTEDP POINTER TO   !
! SYSTEMTABLES BY SENDING THE SIGNAL SYSINITTAB.                  !

! INDATA:           NONE                                          !

! OUTDATA:          NONE                                          !


ENTER DDINITTABLE WITH
   TUSERP,
   TTOWBLKREF,
   TTOWTABREF,
   CTABNAME,
   TREADAUTHCAT,
   TWRITEAUTHCAT,
   TLOCATION;


!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (beginStat)


!******************************************************************************!
!END SQL!


PROTECTEDP:USERP=TUSERP;
PROTECTEDP:REF=TTOWBLKREF;
PROTECTEDP:TOWBLKREF=TTOWBLKREF;
PROTECTEDP:TOWTABREF=TTOWTABREF;
PROTECTEDP:TABNAME=CTABNAME;
PROTECTEDP:RAUTHCAT=TREADAUTHCAT;
PROTECTEDP:WAUTHCAT=TWRITEAUTHCAT;
PROTECTEDP:LOCATION=TLOCATION;


! THIS ROUTINE RECEIVES THE SIGNAL SYSINITTAB FROM THE DD INTER-  !
! FACE MODULE. THE OBJECTIVE IS TO INSERT A NEW ROW INTO THE      !
! TABLES TABLE, AND THUS TO DEFINE A NEW USER TABLE. HOWEVER      !
! PROBLEMS MAY ARISE AND THE SIGNAL PROGERROR MAY BE SENT IN THE  !
! FOLLOWING SITUATIONS:                                           !
! A. THE NAME OF THE TABLE WHICH REQUESTS TO BE DEFINED MAY       !
!    ALREADY BE OCCUPIED. IF THE LOCATION OF THE TABLE IS SINGLE, !
!    THE NAME MAY NOT OCCUR IN ANY OTHER BLOCK. IF THE LOCATION   !
!    OF THE TABLE IS MULTIPLE, A TABLE WITH THE SAME NAME MAY NOT !
!    APPEAR IN THE SAME BLOCK. HOWEVER, SUCH A FAULT WILL NOT     !
!    PASS THE PLEX-SQL PREPROCESSOR, AND THEREFORE NO CHECKS ARE  !
!    MADE ON MULTIPLE TABLES.                                     !
! B. IF THE ENTIRE ALLOCATED SIZE OF THE TABLE ALREADY IS USED,   !
!    THAT IS, THE TABLES TABLE IS ALREADY FULL, THE NEW TABLE     !
!    DEFINITION WILL NOT BE INCLUDED AND PROGERROR WILL BE SENT.  !
! THE SIGNAL PROGERROR WILL, IF IT IS SENT, CAUSE A RESTART,      !
! WHICH IMPLIES THAT THE OLD SYSTEM WILL BECOME EXECUTIVE.        ! 


! THE ROUTINE WILL ALWAYS END BY RETURNING THE SIGNAL SYSINITTABR !
! TO THE DD INTERFACE MODULE.                                     !

! INDATA:       CNEXTTROWNO          NEXT AVAILABLE ROWNUMBER IN !
!                                    TABLES.                     !

! OUTDATA:      CNEXTTROWNO          NEXT AVAILABLE ROWNUMBER IN !
!                                    TABLES (UPDATED).           !

! NORMAL ACTION: INSERT INDATA INTO THE TABLES TABLE.             !

! ALTERNATIVE ACTION: CAUSE A NEW RESTART BY SENDING PROGERROR.   !







   PROTECTEDP:TROWNO=CNEXTTROWNO;
   CNEXTTROWNO=CNEXTTROWNO+1;
      
          
   IF PROTECTEDP:LOCATION = TABLESLOCATEMULTI THEN      
      GOTO DDINITTABLE10;
   FI;
 
 
   
                                            ! BEGIN CHECK OF CASE A  !

   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN EXTENSIVETABS!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyExprs("TABNAME")
%%SET keyPtrs("PROTECTEDP")
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(1)
%%INCLUDE (locOpenStat)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH EXTENSIVETABS INTO `%PROTECTEDP:SAMENAME!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(1)
%%SET cols(0)
%%SET vars("SAMENAME")
%%SET ptrs("PROTECTEDP")
%%SET nulls("")
%%SET nullPtrs("")
%%SET preds(0)
%%INCLUDE (locFetchStat)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!   
      
   CASE SQLCODE.VALUE IS
      WHEN ZNAMEALREADYEXISTS DO
            
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT BLKREF
               INTO `%TBLKREF
               FROM TABLES
               WHERE TROWNO = `%PROTECTEDP.SAMENAME!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(0)
%%SET keyExprs("PROTECTEDP.SAMENAME")
%%SET keyPtrs("")
%%SET keyPrefix(1)
%%SET cols(3)
%%SET vars("TBLKREF")
%%SET ptrs("")
%%SET nulls("")
%%SET nullPtrs("")
%%INCLUDE (locSelectStat)


!******************************************************************************!
!END SQL!

            
            SEND PROGERROR WITH
               ZPROGERRORCODE2,
               PROTECTEDP:TOWBLKREF,
               PROTECTEDP:TOWTABREF,
               TBLKREF;
               
            EXIT;
            
      WHEN ZSEARCHFAIL DO;
      
      OTHERWISE DO;
   ESAC;
  
   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE EXTENSIVETABS!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET curNo(1)
%%INCLUDE (locCloseStat)


!******************************************************************************!
!END SQL!

                                         ! END CHECK OF CASE A    !







DDINITTABLE10)
                                
   CRETURNFROMTRHSTATRANSR = SYMDDINITTABLE20;        
   SEND TRHSTATRANS WITH
      PROTECTEDP,            ! OWN POINTER !
      COWNREF,
      ZDONOTLOG,
      +;     
   EXIT;

DDINITTABLE20)

   
!BEGIN SQL INSERT 25!
!******************************************************************************!

!EXEC SQL INSERT INTO TABLES
        (TROWNO,
         BLKREF,
         TABREF,
         NAME,
         ALLOCST,
         USEDST,
	 ALLOCSW,
	 USEDSW,
         RAUCAT,
         WAUCAT,
         LOCATE,
	 NOFLTCO)
      VALUES   
        (`%PROTECTEDP:TROWNO,
         `%PROTECTEDP:TOWBLKREF,
         `%PROTECTEDP:TOWTABREF,
         `%PROTECTEDP:TABNAME,
	 1,
	 1,
	 1,
	 1,
         `%PROTECTEDP:RAUTHCAT,
         `%PROTECTEDP:WAUTHCAT,
         `%PROTECTEDP:LOCATION,
	 1)!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(2)
%%SET keyExprs("TROWNO")
%%SET keyPtrs("PROTECTEDP")
%%SET keyPrefix(1)
%%SET sigCount(1)
%%SET sigAssVars0()
%%SET sigAssVars1()
%%SET sigAssPtrs0()
%%SET sigAssPtrs1()
%%SET sigAssExprs0()
%%SET sigAssExprs1()
%%SET sigCols0(2, 3, 4)
%%SET sigCols1(9, 10, 14, 15, 17, 18, 19, 20)
%%SET sigExprs0("TABNAME", "TOWBLKREF", "TOWTABREF")
%%SET sigExprs1("1", "1", "1", "1", "RAUTHCAT", "WAUTHCAT", "LOCATION", "1")
%%SET sigPtrs0("PROTECTEDP", "PROTECTEDP", "PROTECTEDP")
%%SET sigPtrs1("", "", "", "", "PROTECTEDP", "PROTECTEDP", "PROTECTEDP", "")
%%SET sigNulls0("", "", "")
%%SET sigNulls1("", "", "", "", "", "", "", "")
%%SET sigNullPtrs0("", "", "")
%%SET sigNullPtrs1("", "", "", "", "", "", "", "")
%%INCLUDE (insertStat)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL COMMIT 0!
!******************************************************************************!

!EXEC SQL COMMIT TRANSACTION!

!------------------------------------------------------------------------------!

%%INCLUDE (commitStat)


!******************************************************************************!
!END SQL!



                                         ! BEGIN CHECK OF CASE B  !
   
   CASE SQLCODE.VALUE IS
      WHEN ZROWINSERTED DO;
      
      WHEN ZSEARCHFAIL DO
         IF SQLCODE.SUBCODE = ZROWNOTALLOCATED THEN
            
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
                INTO `%TTABREF, `%TSAEID
                FROM TABLES
               WHERE NAME = `%ZTABLES AND BLKREF = `%COWNREF!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyExprs("ZTABLES", "COWNREF")
%%SET keyPtrs("", "")
%%SET keyPrefix(2)
%%SET cols(4, 6)
%%SET vars("TTABREF", "TSAEID")
%%SET ptrs("", "")
%%SET nulls("", "")
%%SET nullPtrs("", "")
%%INCLUDE (locSelectStat)


!******************************************************************************!
!END SQL!

                  
            SEND PROGERROR WITH
               ZPROGERRORCODE1,
               COWNREF,
               TTABREF,
               TSAEID;
            EXIT;
         FI;
         
      WHEN ZERROR DO
         CASE SQLCODE.SUBCODE IS
            WHEN ZTABFULL DO
               
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
                  INTO `%TTABREF, `%TSAEID
                  FROM TABLES
                  WHERE NAME = `%ZTABLES AND BLKREF = `%COWNREF!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyExprs("ZTABLES", "COWNREF")
%%SET keyPtrs("", "")
%%SET keyPrefix(2)
%%SET cols(4, 6)
%%SET vars("TTABREF", "TSAEID")
%%SET ptrs("", "")
%%SET nulls("", "")
%%SET nullPtrs("", "")
%%INCLUDE (locSelectStat)


!******************************************************************************!
!END SQL!

                  
               SEND PROGERROR WITH
                  ZPROGERRORCODE1,
                  COWNREF,
                  TTABREF,
                  TSAEID;
               EXIT;
               
            WHEN ZTRHCONG DO
               SEND PROGERROR WITH
                  ZPROGERRORCODE4,
                  ZTRHSAEID2;
               EXIT;

            OTHERWISE DO;
         ESAC;
         
      OTHERWISE DO;
   ESAC;
                                         ! END CHECK OF CASE B    !

   
   
SEND DDINITTABLER REFERENCE PROTECTEDP:REF WITH
   PROTECTEDP:USERP;
   

!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (endStat)


!******************************************************************************!
!END SQL!

   
EXIT;














!*****************************************************************************!
!*                                                                           *! 
!*             D D H G E T N X T F K                                         *!
!*                                                                           *!
!*****************************************************************************!





! THE SIGNAL DDHGETNEXTFK IS A REQUEST FROM THE DBS TRANSACTION   !
! HANDLER TO SUPPLY IT WITH THE NEXT FOREIGN KEY, THAT REFERS TO  !
! A SPECIFIC TABLE. IF IT IS THE FIRST REQUEST FOR A FOREIGN KEY  !
! TO A SPECIFIC TABLE, THE CURSOR FINDFK IS OPENED. IT IS KEPT    !
! OPEN UNTIL NO MORE FK'S REFERRING TO THE CURRENT TABLE IS FOUND.!
! BETWEEN REQUESTS FOR FOREIGN KEYS TO THE SAME TABLE, THE OPEN   !
! CURSOR IS STORED IN THE PROTECTION FILE.                        !

! INSIGNAL:        DDHGETNEXTFK                                   !
! OUTSIGNAL:       DDHGETNEXTFKR                                  !

   ENTER DDHGETNXTFK WITH
      TTRID,
      PROTECTEDP,
      TTOWBLKREF,
      TTOWTABREF,
      CREFERRINGFKORDNO;
   



   IF CREFERRINGFKORDNO=ZFIRSTFK THEN
      
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (beginStat)


!******************************************************************************!
!END SQL!

      PROTECTEDP:TRANSID=TTRID;
      PROTECTEDP:TOWBLKREF=TTOWBLKREF;
      PROTECTEDP:TOWTABREF=TTOWTABREF;
      
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN FINDFK!

!------------------------------------------------------------------------------!

%%SET tabNo(5)
%%SET tabName(FOREIGNKEYS)
%%SET keyNo(3)
%%SET keyExprs("CREFERRINGFKORDNO", "TOWBLKREF", "TOWTABREF")
%%SET keyPtrs("", "PROTECTEDP", "PROTECTEDP")
%%SET keyPrefix(3)
%%SET keyOp(0)
%%SET curNo(2)
%%INCLUDE (locOpenStat)


!******************************************************************************!
!END SQL!

   FI;         


DDHGETNXTFK10)
   
   
!BEGIN SQL FETCH 5!
!******************************************************************************!

!EXEC SQL FETCH FINDFK INTO
      `%PROTECTEDP:ORDNO,
      `%PROTECTEDP:FBLKREF,
      `%PROTECTEDP:FTABREF,
      `%PROTECTEDP:KEYNO,
      `%PROTECTEDP:CONDITION!

!------------------------------------------------------------------------------!

%%SET tabNo(5)
%%SET tabName(FOREIGNKEYS)
%%SET keyNo(3)
%%SET keyPrefix(3)
%%SET keyOp(0)
%%SET curNo(2)
%%SET cols(3, 9, 8, 6, 10)
%%SET vars("ORDNO", "FBLKREF", "FTABREF", "KEYNO", "CONDITION")
%%SET ptrs("PROTECTEDP", "PROTECTEDP", "PROTECTEDP", "PROTECTEDP", "PROTECTEDP")
%%SET nulls("", "", "", "", "")
%%SET nullPtrs("", "", "", "", "")
%%SET preds(0)
%%INCLUDE (locFetchStat)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!   

   CASE SQLCODE.VALUE IS
      WHEN ZOK DO
         SEND DDHGETNXTFKR WITH
            PROTECTEDP:TRANSID,
            ZFKFOUND,
            PROTECTEDP,
            PROTECTEDP:ORDNO,
            PROTECTEDP:FBLKREF,
            PROTECTEDP:FTABREF,
            PROTECTEDP:KEYNO,
            PROTECTEDP:CONDITION;
            
      WHEN ZSEARCHFAIL DO
         SEND DDHGETNXTFKR WITH
            PROTECTEDP:TRANSID,
            ZFKNOTFOUND,
            +,
            +,
            +,
            +,
            +;
         
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE FINDFK!

!------------------------------------------------------------------------------!

%%SET tabNo(5)
%%SET tabName(FOREIGNKEYS)
%%SET curNo(2)
%%INCLUDE (locCloseStat)


!******************************************************************************!
!END SQL!

         
!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (endStat)


!******************************************************************************!
!END SQL!

      
      WHEN ZERROR DO
         IF SQLCODE.SUBCODE = ZTABCONGESTION THEN
!            EXEC SQL DELAY 100 MS!
            GOTO DDHGETNXTFK10;
         FI;
            
      OTHERWISE DO;
   ESAC;
       
EXIT;                         
   










!*****************************************************************************!
!*                                                                           *! 
!*             D D H G E T R E F                                             *!
!*                                                                           *!
!*****************************************************************************!


! THE DBS TRANSACTION HANDLER ASKS FOR THE BLOCK REFERENCE TO     !
! THIS BLOCK.                                                     !
 
 
   RECEIVE DDHGETREF;
   
   LOADREF TOWNREF;
   
   RETURN DDHGETREFACK WITH
      TOWNREF;
 
   
















 



         
















!*****************************************************************************!
!*                                                                           *! 
!*             D D T A B R E F                                               *!
!*                                                                           *!
!*****************************************************************************!



   ENTER DDTABREF WITH
      TUSERP,
      TBLKREF,
      CTABNAME;
      
   
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (beginStat)


!******************************************************************************!
!END SQL!

   
   PROTECTEDP:USERP=TUSERP;
   PROTECTEDP:REF=TBLKREF;
   PROTECTEDP:TABNAME=CTABNAME;
   
   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN GETBLOCKANDTABREF!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyExprs("TABNAME")
%%SET keyPtrs("PROTECTEDP")
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(7)
%%INCLUDE (locOpenStat)


!******************************************************************************!
!END SQL!


DDTABREF10)

   
!BEGIN SQL FETCH 1!
!******************************************************************************!

!EXEC SQL FETCH GETBLOCKANDTABREF 
      INTO `%PROTECTEDP:BLKREF, `%PROTECTEDP:TABREF!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(3)
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(7)
%%SET cols(3, 4)
%%SET vars("BLKREF", "TABREF")
%%SET ptrs("PROTECTEDP", "PROTECTEDP")
%%SET nulls("", "")
%%SET nullPtrs("", "")
%%SET preds(0)
%%INCLUDE (locFetchStat)


!******************************************************************************!
!END SQL!

      
   CASE SQLCODE.VALUE IS
      WHEN ZTABLEFOUND DO
         SEND DDTABREFR REFERENCE PROTECTEDP:REF WITH
            PROTECTEDP:USERP,
            ZOK,
            PROTECTEDP:BLKREF,
            PROTECTEDP:TABREF;
            
      WHEN ZSEARCHFAIL DO
         SEND DDTABREFR REFERENCE PROTECTEDP:REF WITH
            PROTECTEDP:USERP,
            ZNOTABFOUNDFLAG,
            +,
            +;
            
      WHEN ZERROR DO
         IF SQLCODE.SUBCODE = ZTABCONGESTION THEN
!            EXEC SQL DELAY 100 MS!
            GOTO DDTABREF10;
         FI;
         
      OTHERWISE DO;
   ESAC;
   
   
!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (endStat)


!******************************************************************************!
!END SQL!

   EXIT;

      


!*****************************************************************************!
!*                                                                           *! 
!*             E V E N T M E S S A G E C                                     *!
!*                                                                           *!
!*****************************************************************************!




! EVENTMESSAGEC TELLS WHETHER OR NOT THE RECENT SYSTEM RESTART IS !
! DUE TO A FUNCTION CHANGE (FC) OR NOT. IN CASE OF A SMALL        !
! RESTART, THIS SIGNAL HAS TO BE ENTERED BEFORE ZSPH2DBDDH.       !

! OUTDATA:       CFC             INDICATES IF FC HAS OCCURRED     !

ENTER EVENTMESSAGEC WITH  
   TSTATEID,
   +,                                           
   +,
   +, 
   +,
   +,
   TFCIND;
   

IF TSTATEID = ZSYSTEMRESTART THEN
   IF TFCIND = ZFUNCTIONCHANGE THEN
      CFC=TRUE;
   FI;
FI;                      

EXIT;








!*****************************************************************************!
!*                                                                           *! 
!*             S T T O R                                                     *!
!*                                                                           *!
!*****************************************************************************!





! THIS ROUTINE WILL BE RUN ONCE IN EACH RESTART PHASE. THE SIGNAL !
! STTOR, WHICH INFORMS ABOUT THE CURRENT RESTART PHASE NUMBER, IS !
! ENTERED, THE APPROPRIATE ACTION IS PERFORMED, AND THE SIGNAL    !
! STTORRY IS RETURNED AS A RECEIPT THAT THE CURRENT RESTART PHASE !
! IS TAKEN CARE OF BY THIS BLOCK.                                 !

! OUTDATA:       CRESTCASE                      RESTART CASE      !
!                CRETURNFROMWHICHRESTCASE                         !

! POSSIBLE SUBROUTINECALLS:    EVENTREQ                           !
!                              WHICHRESTCASE                      !

   ENTER STTOR WITH 
      CRESTCASE,
      CPHASE,
      +,
      +,
      +,
      +,                      ! RESTART RANK !
      CSIGKEY;
!BEGIN SQL ENTER 0!
!******************************************************************************!


%%INCLUDE (comSttor("CRESTCASE", "CPHASE", "+", "+", "+", "+", "CSIGKEY"))


!******************************************************************************!
!END SQL!

             
   CASE CPHASE IS
      WHEN ZSPH1DBDDH DO DO EVENTREQ;
      WHEN ZSPH2DBDDH DO 
         CRETURNFROMWHICHRESTCASE=SYMSTTOR10;
         GOTO WHICHRESTCASE;
      WHEN ZSPH3DBDDH DO
         CRETURNFROMTRIGTOWINITIATION=SYMSTTOR10;
         CLOCALRESTARTPHASE = ZDBSINTERNALPHASE1;
         GOTO TRIGTOWINITIATION;
      WHEN ZSPH4DBDDH DO
         CRETURNFROMTRIGTOWINITIATION=SYMSTTOR10;
         CLOCALRESTARTPHASE = ZDBSINTERNALPHASE2;
         GOTO TRIGTOWINITIATION;
      WHEN ZSPH5DBDDH DO
         CRETURNFROMTRIGTOWINITIATION=SYMSTTOR10;
         CLOCALRESTARTPHASE = ZDBSINTERNALPHASE3;
         GOTO TRIGTOWINITIATION;
      WHEN ZSPH6DBDDH DO
         CRETURNFROMTRIGTOWINITIATION=SYMSTTOR10;
         CLOCALRESTARTPHASE = ZDBSINTERNALPHASE4;
         GOTO TRIGTOWINITIATION;
      OTHERWISE DO;
   ESAC;
          
STTOR10)
   SEND STTORRY WITH
      CSIGKEY,                ! RETURN DATA !
      ZBLOCKCAT, 
      ZSTTORRYVERSION,
      ZSPH1DBDDH,             ! WANTED RESTARTPHASE 1 !
      ZSPH2DBDDH,             ! WANTED RESTARTPHASE 2 !
      ZSPH3DBDDH,
      ZSPH4DBDDH,
      ZSPH5DBDDH,
      ZSPH6DBDDH,
      ZNOMOREPHASES;
             
   EXIT; 









!*****************************************************************************!
!*                                                                           *! 
!*             T O W R E S P A R T R                                         *!
!*                                                                           *!
!*****************************************************************************!



   ENTER TOWRESPARTR WITH
      PROTECTEDP,
      +;
      
   GOTO TRIGTOWINITIATIONS10;
   


   
   
   



!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!
!*                                                                           *! 
!*             S U B R O U T I N E S   I N   P L E X                         *!
!*                                                                           *!
!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!






!*****************************************************************************!
!*                                                                           *! 
!*             C H E C K S Y M V A L N A M E L E N G T H                     *!
!*                                                                           *!
!*****************************************************************************!




CHECKSYMVALNAMELENGTH)

   PROTECTEDP:MAXSYMLENGTH=0;
   PROTECTEDP:SYMBOLVALUE=ZMAXSYMVAL;
   PROTECTEDP:SYMBOLFOUND=TRUE; 
   
   IF PROTECTEDP:NAMELENGTH = 7 THEN
      PROTECTEDP:PRWIDTH= PROTECTEDP:NAMELENGTH;
      GOTO CHECKSYMVALNAMELENGTH30;
   FI;        
      
CHECKSYMVALNAMELENGTH10)                                   ! BEGIN LOOP !

   IF PROTECTEDP:SYMBOLFOUND = FALSE THEN
      IF PROTECTEDP:MAXSYMLENGTH  > PROTECTEDP:NAMELENGTH THEN
         PROTECTEDP:PRWIDTH=PROTECTEDP:MAXSYMLENGTH;
      ELSE
         PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
      FI;      
      GOTO CHECKSYMVALNAMELENGTH30;
   FI;
      
   SEND TOWPRESYMBOL REFERENCE PROTECTEDP:REF WITH
      PROTECTEDP,
      PROTECTEDP:TOWTABREF,
      PROTECTEDP:FLDNUMBER, 
      PROTECTEDP:SYMBOLVALUE,
   WAIT FOR TOWPRESYMBOLACK IN CHECKSYMVALNAMELENGTH20;   
         
CHECKSYMVALNAMELENGTH20)
   RETRIEVE TOWPRESYMBOLACK WITH
      PROTECTEDP,
      TRETURNCODE,
      PROTECTEDP:SYMBOLVALUE,
      CSYMBOLNAME;
   
   
         
   IF TRETURNCODE = ZSYMBOLFOUND THEN
      CHAR VX:CSYMBOLNAME(N:0) TO VT:TSYMLENGTH;
      IF TSYMLENGTH > PROTECTEDP:MAXSYMLENGTH THEN
         PROTECTEDP:MAXSYMLENGTH=TSYMLENGTH;
      FI;
      PROTECTEDP:SYMBOLVALUE=PROTECTEDP:SYMBOLVALUE-1;
   ELSE
      PROTECTEDP:SYMBOLFOUND=FALSE;   
   FI;
      
   GOTO CHECKSYMVALNAMELENGTH10;                       ! END LOOP !

       
CHECKSYMVALNAMELENGTH30)

   BRANCH ON CRETURNFROMCHECKSYMVALNAMELENGTH
      TO DDINITFIELD10 IF SYMDDINITFIELD10
      ELSE TO DDINITFIELD10;       



















!*****************************************************************************!
!*                                                                           *! 
!*             C L E A R A L L T A B S                                       *!
!*                                                                           *!
!*****************************************************************************!




! THIS ROUTINE TAKES CARE OF THE CASES 'SYSTEM START', 'LARGE     !
! RESTART' AND 'LARGE RESTART WITH RELOAD'. THE OBJECTIVE IS TO   !
! DELETE ALL ROWS IN ALL TABLES IN DATA DICTIONARY. BY DELETING   !
! THE ENTIRE TABLES TABLE, ALL OTHERTABLES WILL BE DELETED DUE TO !
! THE FOREIGN KEY CONDITIONS.                                     !

! THE ROUTINE WORKS AS FOLLOWS. THE CURSOR FINDNEWTABLE IS OPENED !
! AND FETCHED. IF THE TABLES TABLE IS EMPTY, THE FLAG CALLTABS-   !
! CLEARED WILL BE SET TO TRUE AND VIA JUMPS TO CLEARALLTABS10 AND !
! -40 THE ROUTINE WILL BE ENDED.                                  !

! HOWEVER, IF THERE ARE MORE ROWS IN TABLES TO DELETE, A TRANS-   !
! ACTION WILL BE STARTED BY THE SIGNAL TRHSTATRANS. THE REASON    !
! FOR USING THE SIGNAL AND NOT THE START TRANSACTION INSTRUCTION  !
! IS THAT THE TRANSACTION SHOULD NOT BE LOGGED. THE DELETE IS     !
! PERFORMED AND THE PROGRAM EXECUTION CONTINUES AT CLEARALLTABS20 !

! IN THE CASE 'LARGE RESTART', PROBLEMS MAY OCCUR IN THE TRANS-   !
! ACTION HANDLER. THERE MAY BE A LINE OF TRANSACTIONS IN THE      !
! COMMIT PHASE STEMMING FROM BEFORE THE RESTART, WHICH ARE WAITING!
! TO BE COMMITTED. IF THESE TRANSACTIONS OCCUPY ALL TRANSACTION   !
! INDIVIDUALS, SQLCODE WILL REPORT TRH CONGESTION AND THE SIGNAL  !
! PROGERROR WILL BE SENT BECAUSE THE SYSTEM WILL NOT BE ABLE TO   !
! ADVANCE ANY FURTHER IN THE RESTART PROCEDURE.                   !

! INDATA:        NONE                                             !

! OUTDATA:       NONE                                             !

! RESULT:        ALL TABLES THAT ARE PHYSICALLY STORED IN DD ARE  !
!                DELETED.                                         !

CLEARALLTABS)

   
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (beginStat)


!******************************************************************************!
!END SQL!
         
   CALLTABSCLEARED = FALSE;
   
CLEARALLTABS10)

   IF CALLTABSCLEARED = TRUE THEN          ! BEGIN LOOP !
      GOTO CLEARALLTABS40;
   FI;
   
   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN FINDNEWTABLE!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(0)
%%SET keyExprs("ZMAXNOFROWS")
%%SET keyPtrs("")
%%SET keyPrefix(1)
%%SET keyOp(2)
%%SET curNo(3)
%%INCLUDE (locOpenStat)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH FINDNEWTABLE INTO `%PROTECTEDP:NEXTTOBEDELETED!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(0)
%%SET keyPrefix(1)
%%SET keyOp(2)
%%SET curNo(3)
%%SET cols(0)
%%SET vars("NEXTTOBEDELETED")
%%SET ptrs("PROTECTEDP")
%%SET nulls("")
%%SET nullPtrs("")
%%SET preds(0)
%%INCLUDE (locFetchStat)


!******************************************************************************!
!END SQL!



   CASE SQLCODE.VALUE IS
   
      WHEN ZTABLEFOUND DO
         
         CRETURNFROMTRHSTATRANSR=SYMCLEARALLTABS30;
         SEND TRHSTATRANS WITH
            PROTECTEDP,            ! OWN POINTER !
            COWNREF,
            ZDONOTLOG,
            +;     
         EXIT;
         
!        ACTION CONTINUES AT CLEARALLTABS30 BELOW                              !
         
      WHEN ZNOMORETABLES DO
         CALLTABSCLEARED = TRUE;
         
      OTHERWISE DO;
   ESAC;

CLEARALLTABS20)
   
   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE FINDNEWTABLE!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET curNo(3)
%%INCLUDE (locCloseStat)


!******************************************************************************!
!END SQL!

      
   GOTO CLEARALLTABS10;                     ! END LOOP !






!     CONTINUE EXECUTION OF 'CASE SQLCODE.VALUE IS WHEN ZTABLEFOUND DO'        !


CLEARALLTABS30)
            
   CASE CMESSAGE.VALUE IS
      WHEN ZOK DO;
      
      WHEN ZERROR DO
         IF CMESSAGE.SUBCODE = ZTRHCONG THEN
            SEND PROGERROR WITH
               ZPROGERRORCODE4,
               ZTRHSAEID1;
         FI;
         EXIT;
         
      OTHERWISE DO;
   ESAC;
   
   
!BEGIN SQL DELETE 2!
!******************************************************************************!

!EXEC SQL DELETE
      FROM TABLES
      WHERE TROWNO = `%PROTECTEDP:NEXTTOBEDELETED!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(0)
%%SET keyExprs("NEXTTOBEDELETED")
%%SET keyPtrs("PROTECTEDP")
%%SET keyPrefix(1)
%%SET sigAssVars0()
%%SET sigAssPtrs0()
%%SET sigAssExprs0()
%%INCLUDE (deleteStat)


!******************************************************************************!
!END SQL!


   CASE SQLCODE.VALUE IS
      WHEN ZOK DO;
      
      WHEN ZERROR DO
         IF SQLCODE.SUBCODE = ZTRHCONG THEN
            SEND PROGERROR WITH
               ZPROGERRORCODE4,
               ZTRHSAEID1;
         FI;
         EXIT;
         
      OTHERWISE DO;
   ESAC;
      
   
!BEGIN SQL PREPARE 0!
!******************************************************************************!

!EXEC SQL PREPARE TRANSACTION!

!------------------------------------------------------------------------------!

%%INCLUDE (prepareStat)


!******************************************************************************!
!END SQL!

   
   CASE SQLCODE.VALUE IS
      WHEN ZOK DO;
      
      WHEN ZERROR DO
         IF SQLCODE.SUBCODE = ZTRHCONG THEN
            SEND PROGERROR WITH
               ZPROGERRORCODE4,
               ZTRHSAEID1;
         FI;
         EXIT;
         
      OTHERWISE DO;
   ESAC;

   
!BEGIN SQL COMMIT 0!
!******************************************************************************!

!EXEC SQL COMMIT TRANSACTION!

!------------------------------------------------------------------------------!

%%INCLUDE (commitStat)


!******************************************************************************!
!END SQL!
            

   GOTO CLEARALLTABS20;


CLEARALLTABS40)

   
!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (endStat)


!******************************************************************************!
!END SQL!


   BRANCH ON CRETURNFROMCLEARALLTABS
      TO WHICHRESTCASE10 IF SYMWHICHRESTCASE10
      ELSE TO WHICHRESTCASE10;
      
!     END OF ROUTINE CLEARALLTABS                                              !














!*****************************************************************************!
!*                                                                           *! 
!*             C L E A R S O M E T A B S                                     *!
!*                                                                           *!
!*****************************************************************************!






! THIS ROUTINE TAKES CARE OF THE CASE 'SMALL RESTART DUE TO A     !
! FUNCTION CHANGE'. BY SENDING FCHBNOOLD2 AND RECEIVING FCHBNO-   !
! OLD2RPY, THE ROUTINE GETS ALL THE BLOCKNUMBERS TO THE BLOCKS    !
! THAT PARTICIPATE IN THE FUNCTION CHANGE. IT TRANSFORMS ALL THE  !
! BLOCK NUMBERS TO BLOCK REFERENCES AND IT DELETES ALL ROWS,      !
! WHICH ARE ASSOCIATED WITH THE CURRENT BLOCKS, FROM ALL DATA     !
! DICTIONARY TABLES.                                              !

! OUTDATA:          CNOFBLOCKS                                    !
!                   CBLOCK              ARRAY OF BLOCK REFERENCES !

CLEARSOMETABS)

   CNOFREQ=0;
   CBLOCKCOUNT = 0;
   CK=0;
   CALLTABSRECEIVED=FALSE;







CLEARSOMETABS10)                      ! BEGIN LOOP FOR EACH SIGNAL FCH.. !

   IF CALLTABSRECEIVED = TRUE THEN
      GOTO CLEARSOMETABS60;
   FI;   

   SEND FCHBNOOLD2 WITH
      CK,
      COWNREF,
      CNOFREQ;
   EXIT;
          
   ENTER FCHBNOOLD2RPY WITH
      CK,
      CNOFREQ,
      CNOFBLOCKS,
      CTEMPBLOCK( 0),
      CTEMPBLOCK( 1),
      CTEMPBLOCK( 2),
      CTEMPBLOCK( 3),
      CTEMPBLOCK( 4),
      CTEMPBLOCK( 5),
      CTEMPBLOCK( 6),
      CTEMPBLOCK( 7),
      CTEMPBLOCK( 8),
      CTEMPBLOCK( 9),
      CTEMPBLOCK( 10),
      CTEMPBLOCK( 11),
      CTEMPBLOCK( 12),
      CTEMPBLOCK( 13),
      CTEMPBLOCK( 14),
      CTEMPBLOCK( 15);
             

   TCOUNTER = 0;
   
CLEARSOMETABS20)          ! BEGIN LOOP FOR EACH BLOCK IN THE SIGNAL !

   IF TCOUNTER = 16 THEN
      GOTO CLEARSOMETABS50;
   FI;

   TNOFRECEIVEDDATA=CNOFREQ*16 + TCOUNTER + 1;
   
   IF TNOFRECEIVEDDATA =< CNOFBLOCKS  THEN
   
      TBLKNUM = CTEMPBLOCK(TCOUNTER) - 1;
      SEND NOFORFUCODE WITH
         TCOUNTER,
         ZTOWFUCODE,
         TBLKNUM,
      WAIT FOR NOFORFUCODEACK IN CLEARSOMETABS30;
      
   ELSE
   
      CALLTABSRECEIVED=TRUE;
      GOTO CLEARSOMETABS50;
      
   FI;
   
 
CLEARSOMETABS30)

   RETRIEVE NOFORFUCODEACK WITH
      TCOUNTER,
      TBLKNUM,
      TANSWER;
      
   CASE TANSWER IS
      WHEN ZOK DO
      
         IF TBLKNUM = CTEMPBLOCK(TCOUNTER) THEN
         
            TRANSFORM BLOCKNUMBER IN TEMP TBLKNUM
               TO BLOCKREF IN TEMP TBLKREF;
               
            CBLOCK(CBLOCKCOUNT) = TBLKREF;
            CBLOCKCOUNT = CBLOCKCOUNT+1;
         FI;
            
      OTHERWISE DO;
   ESAC; 
  
   TCOUNTER = TCOUNTER + 1;
   GOTO CLEARSOMETABS20;           ! END LOOP FOR EACH BLOCK IN THE SIGNAL !
 
 
 
 
CLEARSOMETABS50)
  
   CK=CK+16;
   CNOFREQ=CNOFREQ+1;   
   GOTO CLEARSOMETABS10;                 ! END LOOP FOR EACH SIGNAL FCH.. !






! ALL BLOCK REFERENCES OF ALL TABLE-OWNING BLOCKS THAT PARTICIPATE IN THE !
! FUNCTION CHANGE ARE STORED IN THE ARRAY CBLOCK. THE NUMBER OF BLOCKS    !
! THAT ARE STORED IN CBLOCK WILL BE GIVEN BY CNOFBLOCKS.                  !


CLEARSOMETABS60)

   CNOFBLOCKS = CBLOCKCOUNT;
   CK=0;
   
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (beginStat)


!******************************************************************************!
!END SQL!










CLEARSOMETABS70)
          
   IF CK=CNOFBLOCKS THEN                 ! BEGIN LOOP FOR EACH BLOCK !
      GOTO CLEARSOMETABS110;
   FI;
                

   CRETURNFROMTRHSTATRANSR=SYMCLEARSOMETABS80;

   
   SEND TRHSTATRANS WITH
      PROTECTEDP,            ! OWN POINTER !
      COWNREF,
      ZDONOTLOG,
      +;
   EXIT;

CLEARSOMETABS80)

   CMORETABSTODELETE = TRUE;
   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN FINDNEXTTABLE!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(4)
%%SET keyExprs("CBLOCK(CK)")
%%SET keyPtrs("")
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(4)
%%INCLUDE (locOpenStat)


!******************************************************************************!
!END SQL!







CLEARSOMETABS90)                          ! BEGIN LOOP FOR EACH TABLE !

   IF CMORETABSTODELETE = FALSE THEN
      GOTO CLEARSOMETABS100;
   FI;

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH FINDNEXTTABLE INTO `%PROTECTEDP:NEXTTOBEDELETED!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(4)
%%SET keyPrefix(1)
%%SET keyOp(0)
%%SET curNo(4)
%%SET cols(0)
%%SET vars("NEXTTOBEDELETED")
%%SET ptrs("PROTECTEDP")
%%SET nulls("")
%%SET nullPtrs("")
%%SET preds(0)
%%INCLUDE (locFetchStat)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!
   
   CASE SQLCODE.VALUE IS
      WHEN ZTABLEFOUND DO
         
!BEGIN SQL DELETE 1!
!******************************************************************************!

!EXEC SQL DELETE FROM TABLES
            WHERE TROWNO=`%PROTECTEDP:NEXTTOBEDELETED!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET keyNo(0)
%%SET keyExprs("NEXTTOBEDELETED")
%%SET keyPtrs("PROTECTEDP")
%%SET keyPrefix(1)
%%SET sigAssVars0()
%%SET sigAssPtrs0()
%%SET sigAssExprs0()
%%INCLUDE (deleteStat)


!******************************************************************************!
!END SQL!

     
      WHEN ZSEARCHFAIL DO
         CMORETABSTODELETE = FALSE;
         
      OTHERWISE DO;
   ESAC;
  
   GOTO CLEARSOMETABS90;                  ! END LOOP FOR EACH TABLE !





CLEARSOMETABS100)
   
   
!BEGIN SQL COMMIT 0!
!******************************************************************************!

!EXEC SQL COMMIT TRANSACTION!

!------------------------------------------------------------------------------!

%%INCLUDE (commitStat)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE FINDNEXTTABLE!

!------------------------------------------------------------------------------!

%%SET tabNo(1)
%%SET tabName(TABLES)
%%SET curNo(4)
%%INCLUDE (locCloseStat)


!******************************************************************************!
!END SQL!

            

   CK=CK+1;
   GOTO CLEARSOMETABS70;                 ! END LOOP FOR EACH BLOCK !
 
 
 
 
 
 
 
 
   
CLEARSOMETABS110)                       
   
!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (endStat)


!******************************************************************************!
!END SQL!

          
BRANCH ON CRETURNFROMCLEARSOMETABS
   TO WHICHRESTCASE10 IF SYMWHICHRESTCASE10
   ELSE TO WHICHRESTCASE10;



















!*****************************************************************************!
!*                                                                           *! 
!*             E V E N T R E Q                                               *!
!*                                                                           *!
!*****************************************************************************!





! THIS ROUTINE SENDS THE SIGNAL EVENTMSGREQ IN ORDER TO TELL KEED !
! THAT THIS BLOCK WANTS TO SUBSCRIBE ON THE SIGNAL EVENTMESSAGEC  !
! IN THE SPECIFIC CASE THAT THE RECENT SYSTEM RESTART FLAG HAS    !
! CHANGED STATES. THE OBJECTIVE IS TO FIND OUT WHETHER OR NOT A   !
! SYSTEM RESTART IS CAUSED BY A FUNCTION CHANGE.                  !

! INDATA:        NONE                                             !

! OUTDATA:       COWNREF                                          !
!                CFC=FALSE          VALUE MAY BE CHANGED LATER BY !
!                                   SIGNAL EVENTMESSAGEC.         !

          
BEGIN EVENTREQ;

   LOADREF TOWNREF;
   COWNREF=TOWNREF;   

   CFC=FALSE;


EVENTREQ10)
         
   SEND EVENTMSGREQ WITH
      +,                       ! OWN POINTER !
      COWNREF,
      ZINFOONLEVELC,
      ZONEEVENT,
      ZSYSRESTFLAGCHANGED,
   WAIT FOR EVENTMSGREQACK IN EVENTREQ20;
          
EVENTREQ20)
   RETRIEVE EVENTMSGREQACK WITH 
      +,                       ! OWN POINTER !
      TRETURNCODE;
          
             
   CASE TRETURNCODE IS
      WHEN ZREQUESTACKN DO;
      WHEN ZCONGESTION DO
!         EXEC SQL DELAY 100 MS!
         GOTO EVENTREQ10;          ! CONGESTION IN KEED. TRY AGAIN !
      OTHERWISE DO;  
   ESAC;
          
END EVENTREQ;

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 












!*****************************************************************************!
!*                                                                           *! 
!*             T R I G T O W I N I T I A T I O N S                           *!
!*                                                                           *!
!*****************************************************************************!



TRIGTOWINITIATION)

   
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

%%INCLUDE (beginStat)


!******************************************************************************!
!END SQL!


   PROTECTEDP:BLKNUM = 0;
   PROTECTEDP:COUNTER = 0;
   

TRIGTOWINITIATIONS10)

   IF CONLYSOMEBLOCKS = TRUE THEN
   
      IF PROTECTEDP:COUNTER = CNOFBLOCKS THEN
         GOTO TRIGTOWINITIATIONS30;
      FI;
      
      SEND TOWRESPART REFERENCE CBLOCK(PROTECTEDP:COUNTER) WITH
         COWNREF,
         PROTECTEDP,
         CLOCALRESTARTPHASE;
         
      PROTECTEDP:COUNTER = PROTECTEDP:COUNTER+1;
      EXIT;
                     
   ELSE
      
      SEND NOFORFUCODE WITH
         PROTECTEDP,
         ZTOWFUCODE,
         PROTECTEDP:BLKNUM,
      WAIT FOR NOFORFUCODEACK IN TRIGTOWINITIATIONS20;
         
   FI;
   
TRIGTOWINITIATIONS20)

   RETRIEVE NOFORFUCODEACK WITH
      PROTECTEDP,
      PROTECTEDP:BLKNUM,
      TANSWER;
      
   CASE TANSWER IS
   
      WHEN ZOK DO
      
         TBLKNUM = PROTECTEDP:BLKNUM;
         TRANSFORM BLOCKNUMBER IN TEMP TBLKNUM
            TO BLOCKREF IN TEMP TBLKREF;

         SEND TOWRESPART REFERENCE TBLKREF WITH
            COWNREF,
            PROTECTEDP,
            CLOCALRESTARTPHASE;
            
         EXIT;
         
      OTHERWISE DO

         GOTO TRIGTOWINITIATIONS30;
            
   ESAC;



TRIGTOWINITIATIONS30)


   BRANCH ON CRETURNFROMTRIGTOWINITIATION
      TO STTOR10 IF SYMSTTOR10
      ELSE TO STTOR10;







!*****************************************************************************!
!*                                                                           *! 
!*             W H I C H R E S T C A S E                                     *!
!*                                                                           *!
!*****************************************************************************!






! THIS ROUTINE DIFFERS BETWEEN THE TWO ALTERNATIVE RESTART CASES  !
! THAT MAY OCCUR. IF A SYSTEM START OR ANY KIND OF LARGE RESTART  !
! OCCURS, THEN THE ENTIRE DATA DICTIONARY WILL BE (RE-)INITIATED  !
! AND THIS HAS TO BE PREPARED BY CLEARING ALL DATA DICTIONARY     !
! TABLES. A SMALL RESTART IMPLIES NO ACTION FROM DATA DICTIONARY  !
! EXCEPT WHEN THE RESTART IS CAUSED BY A FUNCTION CHANGE. IN THIS !
! CASE, ONLY THE BLOCKS THAT PARTICIPATE IN THE FUNCTION CHANGE   !
! WILL BE REINITIATED IN DATA DICTIONARY.                         !

! INDATA:        CRESTCASE        RESTART CASE                    !
!                CFC              HAS AN FC OCCURRED?             !

! OUTDATA:       CSMALLREST       BOOLEAN                         !
!                CONLYSOMEBLOCKS  BOOLEAN                         !

! ACTIONS:       CALL SUBROUTINE CLEARSOMETABS, CLEARALLTABS OR   !
!                DO NOTHING                                       !

WHICHRESTCASE)

   CONLYSOMEBLOCKS = FALSE;
   CSMALLREST=FALSE;
   
   CASE CRESTCASE IS

      WHEN ZSMALLRESTART DO
         CSMALLREST=TRUE;
         IF  CFC=TRUE THEN
            CONLYSOMEBLOCKS = TRUE;
            CRETURNFROMCLEARSOMETABS=SYMWHICHRESTCASE10;          
            GOTO CLEARSOMETABS;       
         FI;

      WHEN ZLARGERELOAD, ZLARGERESTART, ZSYSTEMSTART DO
         CRETURNFROMCLEARALLTABS = SYMWHICHRESTCASE10;
         CNEXTTROWNO = 0;
         CNEXTFROWNO = 0;  
         GOTO CLEARALLTABS;
         
      OTHERWISE DO;   
   ESAC;
   


WHICHRESTCASE10) 
  
   BRANCH ON CRETURNFROMWHICHRESTCASE
      TO STTOR10 IF SYMSTTOR10
      ELSE TO STTOR10;


! Additional SQL statments are stated to make sure that all the grammar 
  rules are used at least one time !


!BEGIN SQL CONTINUE 0!
!******************************************************************************!

!EXEC SQL CONTINUE AT LEVEL B DELAY 5 MS!

!------------------------------------------------------------------------------!

%%SET level("B")
%%SET exprs("5")
%%SET timeUnit("MS")
%%INCLUDE (continueStat)


!******************************************************************************!
!END SQL!



!BEGIN SQL CONTINUE 0!
!******************************************************************************!

!EXEC SQL CONTINUE B!

!------------------------------------------------------------------------------!

%%SET level("B")
%%SET exprs("")
%%SET timeUnit("")
%%INCLUDE (continueStat)


!******************************************************************************!
!END SQL!



!BEGIN SQL GET_DB_NUMBER 0!
!******************************************************************************!

!EXEC SQL GET DBNUMBER INTO `%a!

!------------------------------------------------------------------------------!

%%SET vars("A")
%%SET ptrs("")
%%INCLUDE (getDbnumberStat)


!******************************************************************************!
!END SQL!



!BEGIN SQL UPDATE 0!
!******************************************************************************!

!EXEC SQL UPDATE test1 AS tt SET col3=`%a`%b, col6=`%b WHERE col2 = "bb" AND col1 = "aa"!

!------------------------------------------------------------------------------!

%%SET tabNo(10)
%%SET tabName(TEST1)
%%SET keyNo(2)
%%SET keyExprs("SQLM_1", "SQLM_2")
%%SET keyPtrs("PROTECTEDP", "PROTECTEDP")
%%SET keyPrefix(2)
%%SET sigCount(1)
%%SET sigAssVars0("SQLM_2", "SQLM_1")
%%SET sigAssVars1()
%%SET sigAssPtrs0("PROTECTEDP", "PROTECTEDP")
%%SET sigAssPtrs1()
%%SET sigAssExprs0("""bb""", """aa""")
%%SET sigAssExprs1()
%%SET sigCols0(4)
%%SET sigCols1(7)
%%SET sigColOps0("=")
%%SET sigColOps1("=")
%%SET sigExprs0("A")
%%SET sigExprs1("B")
%%SET sigPtrs0("")
%%SET sigPtrs1("")
%%SET sigNulls0("B")
%%SET sigNulls1("")
%%SET sigNullPtrs0("")
%%SET sigNullPtrs1("")
%%INCLUDE (updateStat)


!******************************************************************************!
!END SQL!



!BEGIN SQL UPDATE 0!
!******************************************************************************!

!EXEC SQL UPDATE test1 AS tt SET col3=`%a:b`%c:d, col6=`%b WHERE CURRENT OF WORK!

!------------------------------------------------------------------------------!

%%SET tabNo(10)
%%SET tabName(TEST1)
%%SET cols(4, 7)
%%SET exprs("B", "B")
%%SET ptrs("A", "")
%%SET nulls("D", "")
%%SET nullsPtrs("C", "")
%%INCLUDE (workUpdateStat)


!******************************************************************************!
!END SQL!



!BEGIN SQL UPDATE_VOLATILE 1!
!******************************************************************************!

!EXEC SQL UPDATE test3 AT (`%xx) tt VOLATILE col4=`%a 
         WHERE test3.col9 = 4!

!------------------------------------------------------------------------------!

%%SET tabNo(257)
%%SET tabName(TEST3)
%%SET blockRef("XX")
%%SET keyExprs("4")
%%SET sigCount(0)
%%SET sigAssVars0()
%%SET sigAssPtrs0()
%%SET sigAssExprs0()
%%SET sigCols0(5)
%%SET sigColOps0("=")
%%SET sigExprs0("A")
%%SET sigPtrs0("")
%%SET sigNulls0("")
%%SET sigNullPtrs0("")
%%INCLUDE (remUpdateVolatileStat)


!******************************************************************************!
!END SQL!



!BEGIN SQL SELECT 0!
!******************************************************************************!

!EXEC SQL SELECT col3 INTO `%a`%b FROM test1 WHERE CURRENT OF WORK!

!------------------------------------------------------------------------------!

%%SET tabNo(10)
%%SET tabName(TEST1)
%%SET keyNo(1)
%%SET keyExprs("WORK")
%%SET keyPtrs("")
%%SET keyPrefix(0)
%%SET cols(4)
%%SET vars("A")
%%SET ptrs("")
%%SET nulls("B")
%%SET nullPtrs("")
%%INCLUDE (locSelectStat)


!******************************************************************************!
!END SQL!
  


!BEGIN SQL SELECT 0!
!******************************************************************************!

!EXEC SQL SELECT col3 INTO `%a`%b FROM test1 WHERE CURRENT OF ORIGINAL!

!------------------------------------------------------------------------------!

%%SET tabNo(10)
%%SET tabName(TEST1)
%%SET keyNo(1)
%%SET keyExprs("ORIGINAL")
%%SET keyPtrs("")
%%SET keyPrefix(0)
%%SET cols(4)
%%SET vars("A")
%%SET ptrs("")
%%SET nulls("B")
%%SET nullPtrs("")
%%INCLUDE (locSelectStat)


!******************************************************************************!
!END SQL!
  


!BEGIN SQL START 0!
!******************************************************************************!

!EXEC SQL START WORK "abc"!

!------------------------------------------------------------------------------!

%%SET transId("""abc""")
%%INCLUDE (startStat)


!******************************************************************************!
!END SQL!



!BEGIN SQL START 0!
!******************************************************************************!

!EXEC SQL START WORK!

!------------------------------------------------------------------------------!

%%SET transId("""""")
%%INCLUDE (startStat)


!******************************************************************************!
!END SQL!



!BEGIN SQL ROLLBACK 0!
!******************************************************************************!

!EXEC SQL ROLLBACK TRANSACTION!

!------------------------------------------------------------------------------!

%%INCLUDE (rollbackStat)


!******************************************************************************!
!END SQL!




! Comment test !
! EXEC SQL START WORK "abc""def`%ghi``jkl`%`%mno````pqr" !

   

! String test !

!BEGIN SQL START 0!
!******************************************************************************!

!EXEC SQL START WORK "abc""def`%ghi``jkl`%`%mno````pqr"!

!------------------------------------------------------------------------------!

%%SET transId("""abc""def`%ghi``jkl`%`%mno````pqr""")
%%INCLUDE (startStat)


!******************************************************************************!
!END SQL!

   

      


!BEGIN SQL COMMON 0!
%%INCLUDE (comGiveFs())

%%INCLUDE (comContFs())

%%INCLUDE (comSetFs())

%%INCLUDE (towPlexCode)

%%INCLUDE (tuPlexCode)
!END SQL!
END PROGRAM;
!BEGIN SQL COMMON 0!
%%INCLUDE (towAsaCode)

%%INCLUDE (tuAsaCode)

%%INCLUDE (towData())

%%INCLUDE (tuData())

!END SQL!



END DOCUMENT;
########## ../imp large.tst >large.tst.tmp; cat large.tst.tmp; rm large.tst.tmp ##########
Disable logging
Fixes bug in register allocation
Fixes bug in WSII


CCL

12543.1     SQLM_%%(tabName)_WorkRow:%%(SQLC_%%(tabName)_LastRow)=%%(keyExprs[
        i])+1;
=====>                                                                        
        1

  *1*   209 E : Index value "9" out of range.



1 error(s) detected.
No warnings issued.

DOCUMENT DBDDH;

DECLARE;

!BEGIN SQL COMMON 0!








!END SQL!


!*****************************************************************************!
!*                                                                           *! 
!*             G L O B A L   S Y M B O L S                                   *!
!*                                                                           *!
!*****************************************************************************!


 ! GLOBAL NSYMB ZTOWFUCODE = 162  !
 
 
 
 
 
 
 
 
 
!*****************************************************************************!
!*                                                                           *! 
!*             L O C A L   S Y M B O L S                                     *!
!*                                                                           *!
!*****************************************************************************! 
 



! TEMPORARILY DECLARED PLEX SQL SYMBOL VALUES !


NSYMB ZTOWFUCODE = 162;



!  NSYMB TABLESSTATEBLOCKED=0
NSYMB TABLESSTATEWORKING=1  
NSYMB TABLESLOCATESINGLE=0
NSYMB TABLESLOCATEMULTI=1

NSYMB FIELDSVISIBILINVIS=0
NSYMB FIELDSVISIBILREADO=1
NSYMB FIELDSVISIBILREADWR=2

NSYMB FIELDSNULLPERFALSE=1
NSYMB FIELDSNULLPERTRUE=0

NSYMB FIELDSDATATYPBITS = 0
NSYMB FIELDSDATATYPSTRING = 1
NSYMB FIELDSDATATYPNUMSTR = 2
NSYMB FIELDSDATATYPPNUMSTR = 3
NSYMB FIELDSDATATYPSYMBOL = 4
NSYMB FIELDSDATATYPROWNUM = 5
NSYMB FIELDSDATATYPDBNUM = 6

NSYMB FIELDSCLEARYES = 0
NSYMB FIELDSCLEARNO = 1
NSYMB FIELDSRELOADYES = 0
NSYMB FIELDSRELOADNO = 1
NSYMB FIELDSDUMPYES = 0
NSYMB FIELDSDUMPNO = 1
NSYMB FIELDSSTATICYES = 0
NSYMB FIELDSSTATICNO = 1
NSYMB FIELDSVOLATILYES = 0
NSYMB FIELDSVOLATILNO = 1

NSYMB KEYSKEYTYPEPRIMKEY = 0
NSYMB KEYSKEYTYPEALTERN = 1
NSYMB KEYSKEYTYPEINDKEY = 2

NSYMB FOREIGNKEYSCONDRESTR = 0
NSYMB FOREIGNKEYSCONDCASCAD = 1
NSYMB FOREIGNKEYSCONDSETNULL = 2
NSYMB FOREIGNKEYSCONDSETDEF = 3     !



             
 
STRING ZFIELDS= "FIELDS";          ! USED IN PROGERROR !
STRING ZFOREIGNKEYS= "FOREIGNKEYS";! USED IN PROGERROR !
STRING ZTABLES= "TABLES";         ! USED IN PROGERROR !


                                        
                                        
NSYMB ZBITS=0;                              ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZBLOCKCAT = 2;                        ! BLOCK CATEGORY. USED IN STTOR    !
NSYMB ZCONGESTION=4;                        ! CONGESTION IN KEED.              !
NSYMB ZDBNUMBER=6;                          ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZDBSINTERNALPHASE1 = 1;
NSYMB ZDBSINTERNALPHASE2 = 2;
NSYMB ZDBSINTERNALPHASE3 = 3;
NSYMB ZDBSINTERNALPHASE4 = 4;
NSYMB ZDDFCSTA=0;                           ! CURRENT SIGNAL = DDFCSTA         !
NSYMB ZDDRESPART=1;                         ! CURRENT SIGNAL = DDRESPART       !
NSYMB ZDONOTLOG=1;                          ! DO NOT LOG THE TRANSACTION       !
NSYMB ZDONOTPARTICIPATE=1;                  ! BLOCK IS NOT INVOLVED IN RESTART !
NSYMB ZERROR=3;                             ! SQLCODE.VALUE FAULT RESOLUTION   !
NSYMB ZFIRSTFK=0;                           ! FIRST FOREIGN KEY OF TRANSACTION !
NSYMB ZFIRSTORDNO = 0;                      ! ORDINAL NUMBER OF FIRST FK TO TAB!
NSYMB ZFKFOUND = 0;                         ! A FOREIGN KEY IS FOUND           !
NSYMB ZFKNOTFOUND = 1;                      ! A FOREIGN KEY IS NOT FOUND       !
NSYMB ZFUNCTIONCHANGE=2;                    ! EVENT = FUNCTION CHANGE          !
NSYMB ZINFOONLEVELC=#1000;                  ! INFORMATION ON LEVEL C           !
NSYMB ZLARGERELOAD=2;                       ! LARGE RESTART WITH RELOAD        !
NSYMB ZLARGERESTART=1;                      ! LARGE RESTART WITHOUT RELOAD     !
NSYMB ZMAXNOFBLOCKS=65535;                  ! DETERMINES THE MAXIMUM NUMBER OF !
                                            ! BLOCKS THAT MAY BE AFFECTED BY A !
                                            ! FUNCTION CHANGE FOLLOWED BY A    !
                                      ! SPECIFY. SMALL RESTART.                !
NSYMB ZMAXNOFROWS = 65531;
NSYMB ZMAXORDNO = 255;                      ! MAXIMUM FOREIGN KEY ORDINAL NUMB.!
NSYMB ZMAXSYMVAL = 65535;
NSYMB ZNAMEALREADYEXISTS=0;                 ! TABLENAME ALREADY DEFINED        !
NSYMB ZNOMOREPHASES=255;                    ! LAST RESTART PHASE INDICATOR     !
NSYMB ZNOMORETABLES = 2;
NSYMB ZNOTABFOUNDFLAG=1;                    ! WHEN ANSWERING DDTABREF !
NSYMB ZNUMSTR=2;                         ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZOK=0;                   
NSYMB ZONEEVENT=1;                          ! INFO. ON ONE EVENT REQUESTED     !
NSYMB ZPACKEDNUMSTR=3;                      ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZPARTICIPATE=0;                       ! BLOCK IS INVOLVED IN THE RESTART !
NSYMB ZPROGERRORCODE1=0;             ! SPECIFY. FAULT CODE. DBDDH TABLE FULL     !
NSYMB ZPROGERRORCODE2=0;             ! SPECIFY. FAULT CODE. DUPLICATE TABLENAMES !
NSYMB ZPROGERRORCODE3=0;           ! SPECIFY. FAULT CODE.REFERRED TAB UNDEFINED!
NSYMB ZPROGERRORCODE4=0;           ! SPECIFY. FAULT CODE. CONGESTION IN TRH    !
NSYMB ZREQUESTACKN=0;
NSYMB ZROWINSERTED=0;                       ! A ROW IS SUCCESSFULLY INSERTED   !
NSYMB ZROWNOTALLOCATED = 6;                 ! INSERT FAILED. ROW NOT ALLOCATED !
NSYMB ZROWNUMBER=5;                         ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZSEARCHFAIL=2;                        ! SQLCODE.VALUE FAULT RESOLUTION   !
NSYMB ZSMALLRESTART=0;                      ! SMALL RESTART                    !
NSYMB ZSPH1DBDDH=2;                         ! FIRST RESTARTPHASE IN THIS BLOCK !
NSYMB ZSPH2DBDDH=3;                    ! SPECIFY. SECOND RESTART PHASE         !
NSYMB ZSPH3DBDDH=4;                    ! SPECIFY. THIRD  RESTART PHASE         !
NSYMB ZSPH4DBDDH=5;                    ! SPECIFY. FOURTH RESTART PHASE         !
NSYMB ZSPH5DBDDH=6;                    ! SPECIFY. FIFTH  RESTART PHASE         !
NSYMB ZSPH6DBDDH=7;                    ! SPECIFY. SIXTH  RESTART PHASE         !
NSYMB ZSTR=1;                            ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZSTTORRYVERSION=2;                    ! VERSION OF SIGNAL STTORRY        !
NSYMB ZSYMBOL=4;                            ! SYMBOL VALUE ACC. TO DDINITFLD   !
NSYMB ZSYMBOLFOUND=0;                       ! A SYMBOL VALUE IS RETURNED       !
NSYMB ZSYSTEMRESTART=36;                    ! EVENT = SYSTEM RESTART           !
NSYMB ZSYSTEMSTART=3;                       ! SYSTEM RESTART                   !
NSYMB ZSYSRESTFLAGCHANGED=#1024;            ! SYSTEM RESTART FLAG CHANGED      !
NSYMB ZTABCONGESTION = 8;                   ! NO WORK ROW FREE IN TABLE        !
NSYMB ZTABFULL=9;                           ! A TABLE IS FULL                  !
NSYMB ZTABLEFOUND = 0;
NSYMB ZTRHCONG=10;                          ! CONGESTION IN TRANSACTION HANDLER!
NSYMB ZTRHSAEID1= 0;              ! SPECIFY. CONGESTION IN TRH CAUSES PROGERROR!
NSYMB ZTRHSAEID2= 0;              ! SPECIFY. CONGESTION IN TRH CAUSES PROGERROR!

 
 
 
 
 
 
 
 
 




!*****************************************************************************!
!*                                                                           *! 
!*             R E C O R D S   A N D   F I L E S I Z E S                     *!
!*                                                                           *!
!*****************************************************************************! 
 

!BEGIN SQL INCLUDE 41!
!******************************************************************************!

!EXEC SQL INCLUDE PROTECTION WITH "
   VARIABLE BLKNUM 16 DS
   VARIABLE BLKREF 16 DS
   VARIABLE CONDITION 16 DS
   VARIABLE COUNTER 16 DS
   VARIABLE DELETEACTION 16 DS             FOREIGN KEY DELETE ACTION        
   VARIABLE FBLKREF 16 DS                  BLOCK REFERENCE OF REFERRING TAB 
   VARIABLE FKNUMBER 16 DS                 FOREIGN KEY NUMBER               
   VARIABLE FLDDATATYPE 16 DS              DATA TYPE OF COLUMN VARIABLE     
   VARIABLE FLDNUMBER 16 DS                FIELD NUMBER                     
   VARIABLE FLDPROTECTION 16 DS            FIELD PROTECTION/VISIBILITY      
   VARIABLE FLDSIZE 16 DS                  FIELD SIZE                       
   VARIABLE FROWNO 16 DS                   ROWNUMBER IN FIELDS TABLE        
   VARIABLE FTABREF 16 DS                  TABLE REFERENCE OF REFERRING TAB 
   VARIABLE KEYNO 16 DS                    ORDINAL KEY NUMBER               
   VARIABLE LOCATION 16 DS                 TABLE LOCATION (SINGLE/MULTIPLE) 
   VARIABLE MAXSYMLENGTH 16 DS             LONGEST SYMBOL VALUE NAME        
   VARIABLE NAMELENGTH 8 DS                LENGTH OF SYMBOL VALUE NAME      
   VARIABLE NEXTTOBEDELETED 16 DS          ROWNUMBER OF ROW TO BE DELETED   
   VARIABLE ORDNO 16 DS                    ORDINAL NUMBER                   
   VARIABLE PRWIDTH 16 DS                  PRINTOUT WIDTH OF COLUMN         
   VARIABLE RAUTHCAT 16 DS                 TABLE READ AUTHORITY CATEGORY    
   VARIABLE REF 16 DS                      RETURN SIGNAL REFERENCE          
   VARIABLE REFERREDTROWNO 16 DS           TABLE ROW NUMBER OF REFERRED TAB 
   VARIABLE SAMENAME 16 DS                 ROWNUMBER OF TABLE WITH SAME NAME
   VARIABLE SYMBOLVALUE 16 DS              NUMERICAL SYMBOL VALUE           
   VARIABLE TABREF 16 DS
   VARIABLE TOWBLKREF 16 DS                TABLE OWNER BLOCK REFERENCE      
   VARIABLE TOWTABREF 16 DS                TABLE OWNER TABLE REFERENCE      
   VARIABLE TRANSID 16 DS                  TRANSACTION IDENTITY             
   VARIABLE TROWNO 16 DS                   ROWNUMBER IN TABLES TABLE        
   VARIABLE USERP 16 DS                    USER'S POINTER                   
   VARIABLE VOLATIL 16 DS                  VARIABLE PROPERTY VOLATILE       
   VARIABLE WAUTHCAT 16 DS                 TABLE WRITE AUTHORITY CATEGORY   

   STRING VARIABLE FLDNAME 7 DS            COLUMN NAME                      
   STRING VARIABLE REFERREDTABNAME 15 DS   NAME OF REFERRED TABLE           
   STRING VARIABLE TABNAME 15 DS           TABLE NAME                       
                              
   SYMBOL VARIABLE SYMBOLFOUND=(FALSE, TRUE) DS
                                             NEW SYMBOL VALUE NAME FOUND?     
   "!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!






!BEGIN SQL INCLUDE 0!
!******************************************************************************!

!EXEC SQL INCLUDE TEST!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!












!*****************************************************************************!
!*                                                                           *! 
!*             C O M M O N   S T O R E D   V A R I A B L E S                 *!
!*                                                                           *!
!*****************************************************************************! 
 

VARIABLE CBLOCK ( 32768 ) 16 DS;    ! BLOCK NUMBERS/REFERENCES OF      !
                                            ! BLOCKS INVOLVED IN SMALL RESTART !
                                            ! SIZE = ZMAXNOFBLOCKS             !
VARIABLE CBLOCKCOUNT 16 DS;                 ! INDEX TO CBLOCK                  !
VARIABLE CK 16 DS;                          ! INDEX USED IN DIFFERENT LOOPS    !
VARIABLE CLOCALRESTARTPHASE 16 DS;
VARIABLE CMESSAGE 16 DS;                    ! MESSAGE CODE. SEE STRUCTURE      !
VARIABLE CNEXTFROWNO 16 DS;                 ! REMEMBERS NEXT AVAILABLE FROWNO  !
VARIABLE CNEXTTROWNO 16 DS;                 ! REMEMBERS NEXT AVAILABLE TROWNO  !
VARIABLE CNOFBLOCKS 16 DS;                  ! NUMBER OF BLOCKS INVOLVED IN FC  !
VARIABLE CNOFREQ 16 DS;                     ! NUMBER OF REQUESTS WITH FCHBNOOLD!
VARIABLE COWNREF 16 DS;                     ! OWN BLOCK REFERENCE              !
VARIABLE CPARTICIPATE 16 DS;                ! PARTICIPATE IN FUNCTION CHANGE?  !
VARIABLE CPHASE 8 DS;                       ! CURRENT RESTART PHASE            !
VARIABLE CREFERRINGFKORDNO 16 DS;           ! ORDINAL NUMBER OF REFERRING FK   !
VARIABLE CRESTCASE 4 DS;                    ! RESTART CASE                     !
VARIABLE CSIGKEY 16 DS;                     ! SIGNAL KEY                       !
VARIABLE CTEMPBLOCK (16) 16 DS;
VARIABLE CUSERBLKREF 16 DS;                 ! BLOCK REFERENCE OF DBDDH USER    !
VARIABLE CUSERP ( 2 ) 16 DS;                ! USERS POINTER                    !

!VARIABLE SQLCODE 16 DS !           ! ONLY FOR TEMP USE ! 

STRING VARIABLE CFLDNAME 7 DS;              ! NAME OF COLUMN/FIELD             !
STRING VARIABLE CREFERREDTABNAME 15 DS;     ! NAME OF REFERRED TABLE           !
STRING VARIABLE CSYMBOLNAME 7 DS;           ! SYMBOL VALUE NAME                !
STRING VARIABLE CTABNAME 15 DS;             ! TABLE NAME                       !

SYMBOL VARIABLE CALLTABSCLEARED = (FALSE, TRUE) DS;

SYMBOL VARIABLE CALLTABSRECEIVED = (FALSE, TRUE) DS;
                                           
SYMBOL VARIABLE CFC = (FALSE, TRUE) DS;
                                            ! REPORTS RECENT FUNCTION CHANGE   !

SYMBOL VARIABLE CMORETABSTODELETE = (FALSE, TRUE) DS;
SYMBOL VARIABLE CONLYSOMEBLOCKS = (FALSE, TRUE) DS;


SYMBOL VARIABLE CRETURNFROMCHECKSYMVALNAMELENGTH = (SYMDDINITFIELD10);
SYMBOL VARIABLE CRETURNFROMCLEARALLTABS = ( SYMWHICHRESTCASE10 );
SYMBOL VARIABLE CRETURNFROMCLEARSOMETABS = ( SYMWHICHRESTCASE10 );
SYMBOL VARIABLE CRETURNFROMTRIGTOWINITIATION = (SYMSTTOR10) DS;
SYMBOL VARIABLE CRETURNFROMTRHSTATRANSR = (SYMCLEARALLTABS30,
                                           SYMCLEARSOMETABS80,
                                           SYMDDINITTABLE20,
                                           SYMDDINITFIELD20,
                                           SYMDDINITFK10);
             
SYMBOL VARIABLE CRETURNFROMWHICHRESTCASE = (SYMSTTOR10) DS;
                                            ! RETURN ADDRESS FROM WHICHRESTCASE!
                               
SYMBOL VARIABLE CSIGNAL = (DDFCSTA, BLKREMST) DS;
                                            ! WHICH SIGNAL WILL BE ANSWERED    !
                               
SYMBOL VARIABLE CSMALLREST = (FALSE, TRUE) DS;
                                            ! IS THE CURRENT RESTART SMALL?    !






















!*****************************************************************************!
!*                                                                           *! 
!*             T E M P O R A R Y   V A R I A B L E S                         *!
!*                                                                           *!
!*****************************************************************************! 
 

VARIABLE TANSWER 16; 
VARIABLE TBLKNUM 16;                        ! BLOCK NUMBER                     !
VARIABLE TBLKREF 16;                        ! BLOCK REFERENCE                  !
VARIABLE TCOUNTER 16;
VARIABLE TDELETEACTION 16;                  ! FOREIGN KEY DELETE ACTION        !
VARIABLE TFCIND 16;                         ! FUNCTION CHANGE INDICATOR        !
VARIABLE TFKNUMBER 16;                      ! FOREIGN KEY NUMBER               !
VARIABLE TFLDDATATYPE 16;                   ! DATA TYPE OF CURRENT FIELD       !
VARIABLE TFLDNUMBER 16;                     ! FIELD NUMBER                     !
VARIABLE TFLDPROTECTION 16;                 ! FIELD PROTECTION/VISIBILITY      !
VARIABLE TFLDSIZE 16;                       ! FIELD SIZE                       !
VARIABLE TLOCATION 16;                      ! TABLE LOCATION (SINGLE/MULTIPLE) !
VARIABLE TNAMELENGTH 16;
VARIABLE TNOFRECEIVEDDATA 16;
VARIABLE TOWNREF 16;                        ! OWN BLOCK REFERENCE              !
VARIABLE TREADAUTHCAT 16 ;                  ! READ AUTHORITY CATEGORY OF TABLE !
VARIABLE TRETURNCODE 16;                    ! RETURN CODE                      !
VARIABLE TSAEID 16;                         ! SIZE ALTERNATION EVENT IDENTITY  !
VARIABLE TSTATEID 16;                       ! STATE IDENTITY                   !
VARIABLE TSYMLENGTH 8;                      ! SYMBOL VALUE NAME LENGTH         !
VARIABLE TTABREF 16;                        ! TABLE REFERENCE OF FULL TABLE    !
VARIABLE TTOWBLKREF 16;                     ! TABLE OWNER BLOCK REFERENCE      !
VARIABLE TTOWTABREF 16;                     ! TABLE OWNER TABLE REFERENCE      !
VARIABLE TTRID 16;                          ! TRANSACTION IDENTITY             !
VARIABLE TUSERP 16;                         ! USER'S POINTER                   !
VARIABLE TVOLATILE 16;                      ! VARIABLE PROPERTY VOLATILE       !
VARIABLE TWRITEAUTHCAT 16;                  ! WRITE AUTHORITY CATEGORY OF TABLE!























!*****************************************************************************!
!*                                                                           *! 
!*             S T R U C T U R E S                                           *!
!*                                                                           *!
!*****************************************************************************! 
 



STRUCTURE CMESSAGE =
   1 VALUE 8,
   1 SUBCODE 8;

!STRUCTURE SQLCODE =!       ! TO BE DELETED !
!   1 VALUE 8,
   1 SUBCODE 8     !























!*****************************************************************************!
!*                                                                           *! 
!*             S T A T E S   A N D   S Y M B O L S                           *!
!*                                                                           *!
!*****************************************************************************! 
 


!
BLKREMST            BLKREMSTRPY WILL BE RETURNED WHEN TRHSTOPTRANSR COMES
DDFCSTA             DDFCSTAR WILL BE RETURNED WHEN TRHSTOPTRANSR COMES 
FALSE               SYMBOL VARIABLE NAME STATEMENT IS FALSE
SYMCLEARALLTABS30   SYMBOL FOR A RETURN ADDRESS LABEL
SYMCLEARSOMETABS30  SYMBOL FOR A RETURN ADDRESS LABEL
SYMDDINITFIELD10    SYMBOL FOR A RETURN ADDRESS LABEL
SYMSTTOR10          SYMBOL FOR A RETURN ADDRESS LABEL
SYMSYSINITFK        RETURN TO SYSTEMTABLES VIA SIGNAL SYSRETURNTOFK
SYMSYSINITFLD       RETURN TO SYSTEMTABLES VIA SIGNAL SYSRETURNTOFLD
SYMSYSINITTAB       RETURN TO SYSTEMTABLES VIA SIGNAL SYSRETURNTOTAB
SYMWHICHRESTCASE10  SYMBOL FOR A RETURN ADDRESS LABEL
TRUE                SYMBOL VARIABLE NAME STATEMENT IS TRUE                  !

























!*****************************************************************************!
!*                                                                           *! 
!*             I N C L U D E D   T A B L E S                                 *!
!*                                                                           *!
!*****************************************************************************! 
                         

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE PROGRAMS 
   CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!



!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE TABLES 
   CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE FIELDS 
   CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE KEYS 
   CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE KEYFIELDS
   CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE FOREIGNKEYS
   CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE SYMBOLS 
   CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE TOWFAULTCODES 
   CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE SYSFAULTCODES
   CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

   

!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE SYSTEMFIELDS 
   CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!



! The includes below are only stated to make sure that all the
  grammar rules are used !


!BEGIN SQL INCLUDE_TABLE 1!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE TEST1
   CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!



!BEGIN SQL INCLUDE_TABLE 0!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE TEST2!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!



!BEGIN SQL INCLUDE_TABLE 0!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE TEST3!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!














!*****************************************************************************!
!*                                                                           *! 
!*             C U R S O R   D E C L A R A T I O N S                         *!
!*                                                                           *!
!*****************************************************************************! 
 



!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE EXTENSIVETABS CURSOR FOR
   SELECT TROWNO
   FROM TABLES
   WHERE NAME=%PROTECTEDP:TABNAME!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!
 
      

!BEGIN SQL DECLARE_CURSOR 5!
!******************************************************************************!

!EXEC SQL DECLARE FINDFK CURSOR FOR
   SELECT ORDNO, FBLKREF, FTABREF, KEYNO, COND 
   FROM FOREIGNKEYS
   WHERE  BLKREF = %PROTECTEDP:TOWBLKREF AND 
       TABREF = %PROTECTEDP:TOWTABREF
      AND  ORDNO = %CREFERRINGFKORDNO!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

 

!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE FINDNEWTABLE CURSOR FOR
   SELECT TROWNO
   FROM TABLES
   WHERE TROWNO =< %ZMAXNOFROWS!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!



!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE FINDNEXTTABLE CURSOR FOR
   SELECT TROWNO
   FROM TABLES
   WHERE BLKREF = %CBLOCK(%CK)!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

         

!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE FINDORDNO CURSOR FOR
   SELECT ORDNO
   FROM FOREIGNKEYS
   WHERE TROWNO = %PROTECTEDP:REFERREDTROWNO AND ORDNO =< %ZMAXORDNO!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

         

!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE FINDTROWNO CURSOR FOR
   SELECT TROWNO
   FROM TABLES
   WHERE  NAME = %PROTECTEDP:REFERREDTABNAME!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!



!BEGIN SQL DECLARE_CURSOR 3!
!******************************************************************************!

!EXEC SQL DECLARE GETBLOCKANDTABREF CURSOR FOR
   SELECT BLKREF, TABREF
   FROM TABLES
   WHERE NAME = %PROTECTEDP:TABNAME!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

         

!BEGIN SQL DECLARE_CURSOR 4!
!******************************************************************************!

!EXEC SQL DECLARE GETTROWNO CURSOR FOR
   SELECT TROWNO
   FROM TABLES
   WHERE BLKREF=%PROTECTEDP:TOWBLKREF
   AND TABREF=%PROTECTEDP:TOWTABREF!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!

   
   
     
   

!BEGIN SQL COMMON 0!






!------------------------------------------------!
!       towDeclarations !
!------------------------------------------------!








































































































!------------------------------------------------!
!       comDeclarations !
!------------------------------------------------!
!------------------------------------------------!
!       comDeclProtection !
!------------------------------------------------!
RECORD PROTECTION;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLM_Allocated          1   DS CLEAR;
! Return label reference !
    VARIABLE    SQLX_SQLRETURN          16  DS;
! Cursor references !
    VARIABLE    SQLM_EXTENSIVETABS_Cursor          !R! 16 DS CLEAR;
    VARIABLE    SQLM_FINDFK_Cursor          !R! 16 DS CLEAR;
    VARIABLE    SQLM_FINDNEWTABLE_Cursor          !R! 16 DS CLEAR;
    VARIABLE    SQLM_FINDNEXTTABLE_Cursor          !R! 16 DS CLEAR;
    VARIABLE    SQLM_FINDORDNO_Cursor          !R! 16 DS CLEAR;
    VARIABLE    SQLM_FINDTROWNO_Cursor          !R! 16 DS CLEAR;
    VARIABLE    SQLM_GETBLOCKANDTABREF_Cursor          !R! 16 DS CLEAR;
    VARIABLE    SQLM_GETTROWNO_Cursor          !R! 16 DS CLEAR;
! The block reference to the table user in the current transaction. !
    VARIABLE    SQLBLOCK            16  DS;
! The table reference of a table issuing a local status code. !
    VARIABLE    SQLTABLE            16  DS;
! This variable could be set by the user in user defined code. !
    VARIABLE    SQLLOCALCODE        8  DS;
! The current operation which should be PREPARED, POSTCOMMITED or ROLLBACKED:
$ 0 = insert, 1 = update, 2 = delete !
    VARIABLE    SQLOPERATION        2  DS;
! The current operating row while user defined code are executed. !
    VARIABLE    SQLX_SQLOPERROW         16  DS;
! The current working row while user defined code are executed. !
    VARIABLE    SQLX_SQLWORKROW         16  DS CLEAR;
! The current transaction identity while user defined code are executed. !
    VARIABLE    SQLX_SQLPROTECTED       16  DS;
! The current table reference while userdefined code are executed. !
    VARIABLE    SQLX_SQLTABLEREFERENCE  16  DS;
! Set by unPackX (table user) if there is no null indicator variable for
$ a column which is null. !
    VARIABLE    SQLX_SQLCODE            16  DS;
! This variable holds the current transaction identity. !
    VARIABLE    SQLTRANSID              16  DS CLEAR;
! User defined protected variable. !

   VARIABLE BLKNUM 16 DS;
   VARIABLE BLKREF 16 DS;
   VARIABLE CONDITION 16 DS;
   VARIABLE COUNTER 16 DS;
   VARIABLE DELETEACTION 16 DS;            ! FOREIGN KEY DELETE ACTION        !
   VARIABLE FBLKREF 16 DS;                 ! BLOCK REFERENCE OF REFERRING TAB !
   VARIABLE FKNUMBER 16 DS;                ! FOREIGN KEY NUMBER               !
   VARIABLE FLDDATATYPE 16 DS;             ! DATA TYPE OF COLUMN VARIABLE     !
   VARIABLE FLDNUMBER 16 DS;               ! FIELD NUMBER                     !
   VARIABLE FLDPROTECTION 16 DS;           ! FIELD PROTECTION/VISIBILITY      !
   VARIABLE FLDSIZE 16 DS;                 ! FIELD SIZE                       !
   VARIABLE FROWNO 16 DS;                  ! ROWNUMBER IN FIELDS TABLE        !
   VARIABLE FTABREF 16 DS;                 ! TABLE REFERENCE OF REFERRING TAB !
   VARIABLE KEYNO 16 DS;                   ! ORDINAL KEY NUMBER               !
   VARIABLE LOCATION 16 DS;                ! TABLE LOCATION (SINGLE/MULTIPLE) !
   VARIABLE MAXSYMLENGTH 16 DS;            ! LONGEST SYMBOL VALUE NAME        !
   VARIABLE NAMELENGTH 8 DS;               ! LENGTH OF SYMBOL VALUE NAME      !
   VARIABLE NEXTTOBEDELETED 16 DS;         ! ROWNUMBER OF ROW TO BE DELETED   !
   VARIABLE ORDNO 16 DS;                   ! ORDINAL NUMBER                   !
   VARIABLE PRWIDTH 16 DS;                 ! PRINTOUT WIDTH OF COLUMN         !
   VARIABLE RAUTHCAT 16 DS;                ! TABLE READ AUTHORITY CATEGORY    !
   VARIABLE REF 16 DS;                     ! RETURN SIGNAL REFERENCE          !
   VARIABLE REFERREDTROWNO 16 DS;          ! TABLE ROW NUMBER OF REFERRED TAB !
   VARIABLE SAMENAME 16 DS;                ! ROWNUMBER OF TABLE WITH SAME NAME!
   VARIABLE SYMBOLVALUE 16 DS;             ! NUMERICAL SYMBOL VALUE           !
   VARIABLE TABREF 16 DS;
   VARIABLE TOWBLKREF 16 DS;               ! TABLE OWNER BLOCK REFERENCE      !
   VARIABLE TOWTABREF 16 DS;               ! TABLE OWNER TABLE REFERENCE      !
   VARIABLE TRANSID 16 DS;                 ! TRANSACTION IDENTITY             !
   VARIABLE TROWNO 16 DS;                  ! ROWNUMBER IN TABLES TABLE        !
   VARIABLE USERP 16 DS;                   ! USER'S POINTER                   !
   VARIABLE VOLATIL 16 DS;                 ! VARIABLE PROPERTY VOLATILE       !
   VARIABLE WAUTHCAT 16 DS;                ! TABLE WRITE AUTHORITY CATEGORY   !

   STRING VARIABLE FLDNAME 7 DS;           ! COLUMN NAME                      !
   STRING VARIABLE REFERREDTABNAME 15 DS;  ! NAME OF REFERRED TABLE           !
   STRING VARIABLE TABNAME 15 DS;          ! TABLE NAME                       !
                              
   SYMBOL VARIABLE SYMBOLFOUND=(FALSE, TRUE) DS;
                                            ! NEW SYMBOL VALUE NAME FOUND?     !
   
! Used to protect pointers from time gaps in table user statements. !
    VARIABLE    SQLM_P(4)               !R! 16  DS;
! Variables generated by the preprocessor. !
!------------------------------------------------!
!       comDeclTempVars !
!------------------------------------------------!
    STRING VARIABLE SQLM_1 3 DS;
    STRING VARIABLE SQLM_2 3 DS;
END RECORD;
! Pointer to protected !
    POINTER     PROTECTEDP   (PROTECTION);
! The size of the protected area. !
    VARIABLE    SQLM_ProtectedAllocated 16  DS RELOAD;
! The last allocated row in the protected area. !
    VARIABLE    SQLM_ProtectedLast      16  DS CLEAR;
! The number of allocated rows in the protected area. !
    VARIABLE    SQLM_ProtectedUsed      16  DS CLEAR;
! Used to lock the protected area for size alteration. !
    VARIABLE    SQLM_ProtectedLock       1  DS CLEAR;

!------------------------------------------------!
!       comDeclSqlCode !
!------------------------------------------------!
! This variable is used to check the result of a SQL statement. !
    VARIABLE    SQLCODE         16 DS;
    STRUCTURE   SQLCODE =
                1   VALUE       8,
                1   SUBCODE     8;
!------------------------------------------------!
!       comDeclPlexTemp !
!------------------------------------------------!
! The data base number !
    VARIABLE    SQLX_DBnumber1      16;
    VARIABLE    SQLX_DBnumber2      16;
! The reference to the current operating row. !
    VARIABLE    SQLX_OperRow        16;
! The return label when a schedule or look up was performed !
    VARIABLE    SQLX_ReturnLabel    16;
! Temporary row reference !
    VARIABLE    SQLX_TempRow        16;
! The result of a key test operation !
    VARIABLE    SQLX_KeyTest        16;
! Reference to this block. Used mainly when scheduling. !
    VARIABLE    cOwnRef      16 DS;
! The file number when the user has not defined a size alteration event !
    VARIABLE    SQLX_FileNumber     16;
! The new table size when the user has not defined a size alteration event !
    VARIABLE    SQLX_NewIndNum      16;
! The restart phase when the user has not defined restart code !
    VARIABLE    SQLX_RestartPhase   16;
! The signal key in a restart phase when no user defined code is present !
    VARIABLE    SQLX_SignalKey      16;
! The size alteration event number when no user defined code is present !
    VARIABLE    SQLX_SizeEvent      16;
! The reference of the calling block. !
    VARIABLE    SQLX_OtherBlock     16;
! A pointer to the PROTECTED area or the transaction id !
    VARIABLE    SQLX_OtherProtected 16;
! The stored reference of the calling block. !
    VARIABLE    CSQLX_OtherBlock     16 DS;
! A stored pointer to the PROTECTED area or the transaction id !
    VARIABLE    CSQLX_OtherProtected 16 DS;
! The return code !
    VARIABLE    SQLX_ReturnCode     16;
! Signal data for use in the assembler functions. !
    VARIABLE    SQLX_DR0     16;
    VARIABLE    SQLX_DR1     16;
    VARIABLE    SQLX_DR2     16;
    VARIABLE    SQLX_DR3     16;
    VARIABLE    SQLX_DR4     16;
    VARIABLE    SQLX_DR5     16;
    VARIABLE    SQLX_DR6     16;
    VARIABLE    SQLX_DR7     16;
    VARIABLE    SQLX_DR8     16;
    VARIABLE    SQLX_DR9     16;
    VARIABLE    SQLX_DR10     16;
    VARIABLE    SQLX_DR11     16;
    VARIABLE    SQLX_DR12     16;
    VARIABLE    SQLX_DR13     16;
    VARIABLE    SQLX_DR14     16;
    VARIABLE    SQLX_DR15     16;
    VARIABLE    SQLX_DR16     16;
    VARIABLE    SQLX_DR17     16;
    VARIABLE    SQLX_DR18     16;
    VARIABLE    SQLX_DR19     16;
    VARIABLE    SQLX_DR20     16;
    VARIABLE    SQLX_DR21     16;
    VARIABLE    SQLX_DR22     16;
    VARIABLE    SQLX_DR23     16;
! A remote table reference !
    VARIABLE    SQLX_TableReference 16;
! The base address of a variable !
    VARIABLE    SQLX_BaseAddress1   16;
    VARIABLE    SQLX_BaseAddress2   16;
! Column reference. !
    VARIABLE    SQLX_ColumnReference    16;
! This index variable is used to temporary store information about
$ columns to pack or unpack (see sPack, sUnPack). !
    VARIABLE    SQLX_Columns(32)    16 DS;
! Key component reference. !
    VARIABLE    SQLX_ComponentReference 16;
! Used when scheduling key insertion/deletion !
    VARIABLE    SQLX_Father              16;
    VARIABLE    SQLX_GrandFather              16;
    VARIABLE    SQLX_GrandGrandFather             16;
! The fault code sought !
    VARIABLE    SQLX_FaultCode      16;
! The key operation. !
    VARIABLE    SQLX_KeyOperation   16;
! The number of key components which is used in key comparisons !
    VARIABLE    SQLX_KeyPrefix      16;
! The number of untested key components in the key prefix !
    VARIABLE    SQLX_KeySuffix      16;
! The key number. !
    VARIABLE    SQLX_KeyNumber        16;
! The new lock of a row !
    VARIABLE    SQLX_Lock           16;
! The old (expected) lock of a row !
    VARIABLE    SQLX_OldLock        16;
! The last right turn in a btree in a search operation !
    VARIABLE    SQLX_RightTurn      16;
! This variable is used to determine when a schedule is necessary !
    VARIABLE    SQLX_Schedule       16;
! The symbol name and value !
    STRING VARIABLE SQLX_Symbol 7 DS;
    VARIABLE    SQLX_SymbolValue    16;
! Delete key variables !
    VARIABLE    SQLX_Delete              16;
    VARIABLE    SQLX_DeleteFather             16;
! Temporary data !
    VARIABLE    SQLX_TempData       16 DS;
! Reference to the current work row. !
    VARIABLE    SQLX_WorkRow        16;
! Reference to the current row !
    VARIABLE    SQLX_Current              16;
! The local error code after user defined code is executed !
    VARIABLE     SQLX_Code           16;
NSYMB TABLESEAID = 10;
NSYMB WORKSAEID = 20;
STRING SLOG = ""test table no 1"";

!------------------------------------------------!
!       towTables !
!------------------------------------------------!
RECORD SQLT_PROGRAMS_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_PROGRAMS_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_PROGRAMS_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_PROGRAMS_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    STRING VARIABLE SQLC_PROGRAMS_NAME_Data 7 DS RELOAD;

    VARIABLE SQLC_PROGRAMS_BLKREF_Data 16 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_PROGRAMS_Color         2   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_PROGRAMS_Left2         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_PROGRAMS_Right2        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_PROGRAMS_DBnumber =
    1       SQLC_PROGRAMS_DBnumber1      16,
    1       SQLC_PROGRAMS_DBnumber2      16;

! Structure of the packed numstring columns. !

! This variable indicates the current color of the node !
STRUCTURE SQLC_PROGRAMS_Color =
    1 SQLC_PROGRAMS_Color2 1
    ;

! The symbol values. !

! Pointers !
    POINTER SQLM_PROGRAMS_OperRow (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_WorkRow (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_GuardRow (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_NilRow (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_RootRow (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_TempRow (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_GrandGrandFather (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_GrandFather (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_Father (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_Brother (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_Nephew (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_Delete (SQLT_PROGRAMS_Table);
    POINTER SQLM_PROGRAMS_DeleteFather (SQLT_PROGRAMS_Table);
RECORD SQLT_TABLES_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_TABLES_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_TABLES_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_TABLES_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    STRING VARIABLE SQLC_TABLES_NAME_Data 15 DS RELOAD;

    VARIABLE SQLC_TABLES_BLKREF_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLES_TABREF_Data 16 DS RELOAD;

    STRING VARIABLE SQLC_TABLES_DESCR_Data 31 DS RELOAD;

    VARIABLE SQLC_TABLES_SAEIDT_Null 1 DS RELOAD;
    VARIABLE SQLC_TABLES_SAEIDT_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLES_ESTEPT_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLES_MAXST_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLES_ALLOCST_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLES_USEDST_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLES_SAEIDW_Null 1 DS RELOAD;
    VARIABLE SQLC_TABLES_SAEIDW_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLES_ESTEPW_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLES_MAXSW_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLES_ALLOCSW_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLES_USEDSW_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLES_STATE_Data 1 DS RELOAD;

    VARIABLE SQLC_TABLES_RAUCAT_Data 8 DS RELOAD;

    VARIABLE SQLC_TABLES_WAUCAT_Data 8 DS RELOAD;

    VARIABLE SQLC_TABLES_LOCATE_Data 1 DS RELOAD;

    VARIABLE SQLC_TABLES_NOFLTCO_Data 8 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_TABLES_Color         2   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_TABLES_Left3         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_TABLES_Right3        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_TABLES_Left4         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_TABLES_Right4        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_TABLES_DBnumber =
    1       SQLC_TABLES_DBnumber1      16,
    1       SQLC_TABLES_DBnumber2      16;

! Structure of the packed numstring columns. !

! This variable indicates the current color of the node !
STRUCTURE SQLC_TABLES_Color =
    1 SQLC_TABLES_Color3 1
    , 1 SQLC_TABLES_Color4 1
    ;

! The symbol values. !
NSYMB TABLESSTATEBLOCKED = 0;
NSYMB TABLESSTATEWORKING = 1;
NSYMB TABLESLOCATESINGLE = 0;
NSYMB TABLESLOCATEMULTI = 1;

! Pointers !
    POINTER SQLM_TABLES_OperRow (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_WorkRow (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_GuardRow (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_NilRow (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_RootRow (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_TempRow (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_GrandGrandFather (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_GrandFather (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_Father (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_Brother (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_Nephew (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_Delete (SQLT_TABLES_Table);
    POINTER SQLM_TABLES_DeleteFather (SQLT_TABLES_Table);
RECORD SQLT_FIELDS_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_FIELDS_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_FIELDS_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_FIELDS_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    STRING VARIABLE SQLC_FIELDS_NAME_Data 7 DS RELOAD;

    VARIABLE SQLC_FIELDS_TABREF_Data 16 DS RELOAD;

    VARIABLE SQLC_FIELDS_BLKREF_Data 16 DS RELOAD;

    VARIABLE SQLC_FIELDS_FIELDNO_Data 16 DS RELOAD;

    STRING VARIABLE SQLC_FIELDS_DESCR_Data 31 DS RELOAD;

    VARIABLE SQLC_FIELDS_VISIBIL_Data 2 DS RELOAD;

    VARIABLE SQLC_FIELDS_PRWIDTH_Data 8 DS RELOAD;

    VARIABLE SQLC_FIELDS_NULLPER_Data 1 DS RELOAD;

    VARIABLE SQLC_FIELDS_DATATYP_Data 4 DS RELOAD;

    VARIABLE SQLC_FIELDS_BADDRES_Data 16 DS RELOAD;

    VARIABLE SQLC_FIELDS_MIN_Null 1 DS RELOAD;
    VARIABLE SQLC_FIELDS_MIN_Data 16 DS RELOAD;

    VARIABLE SQLC_FIELDS_MAX_Null 1 DS RELOAD;
    VARIABLE SQLC_FIELDS_MAX_Data 16 DS RELOAD;

    VARIABLE SQLC_FIELDS_SIZE_Data 16 DS RELOAD;

    VARIABLE SQLC_FIELDS_DIDNR_Null 1 DS RELOAD;
    VARIABLE SQLC_FIELDS_DIDNR_Data 16 DS RELOAD;

    VARIABLE SQLC_FIELDS_DIDPOS_Null 1 DS RELOAD;
    VARIABLE SQLC_FIELDS_DIDPOS_Data 16 DS RELOAD;

    VARIABLE SQLC_FIELDS_PCLEAR_Data 1 DS RELOAD;

    VARIABLE SQLC_FIELDS_PRELOAD_Data 1 DS RELOAD;

    VARIABLE SQLC_FIELDS_PDUMP_Data 1 DS RELOAD;

    VARIABLE SQLC_FIELDS_PSTATIC_Data 1 DS RELOAD;

    VARIABLE SQLC_FIELDS_VOLATIL_Data 1 DS RELOAD;

    VARIABLE SQLC_FIELDS_DEFBITS_Null 1 DS RELOAD;
    VARIABLE SQLC_FIELDS_DEFBITS_Data 16 DS RELOAD;

    VARIABLE SQLC_FIELDS_DEFSTR_Null 1 DS RELOAD;
    STRING VARIABLE SQLC_FIELDS_DEFSTR_Data 31 DS RELOAD;

    VARIABLE SQLC_FIELDS_DEFNSTR_Null 1 DS RELOAD;
    STRING VARIABLE SQLC_FIELDS_DEFNSTR_Data 31 DS RELOAD;

    VARIABLE SQLC_FIELDS_DEFPNS_Null 1 DS RELOAD;
    VARIABLE SQLC_FIELDS_DEFPNS_Data 128 DS RELOAD;

    VARIABLE SQLC_FIELDS_DEFSYMB_Null 1 DS RELOAD;
    VARIABLE SQLC_FIELDS_DEFSYMB_Data 2 DS RELOAD;

    VARIABLE SQLC_FIELDS_TROWNO_Null 1 DS RELOAD;
    VARIABLE SQLC_FIELDS_TROWNO_Data 16 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_FIELDS_Color         4   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_FIELDS_Left3         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_FIELDS_Right3        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_FIELDS_Left4         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_FIELDS_Right4        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_FIELDS_Left5         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_FIELDS_Right5        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_FIELDS_DBnumber =
    1       SQLC_FIELDS_DBnumber1      16,
    1       SQLC_FIELDS_DBnumber2      16;

! Structure of the packed numstring columns. !
STRUCTURE SQLC_FIELDS_DEFPNS_Data =
    1 LENGTH 16,
    1 W1 16,
    1 W2 16,
    1 W3 16,
    1 W4 16,
    1 W5 16,
    1 W6 16,
    1 W7 16;

! This variable indicates the current color of the node !
STRUCTURE SQLC_FIELDS_Color =
    1 SQLC_FIELDS_Color3 1
    , 1 SQLC_FIELDS_Color4 1
    , 1 SQLC_FIELDS_Color5 1
    ;

! The symbol values. !
NSYMB FIELDSVISIBILINVIS = 0;
NSYMB FIELDSVISIBILREADO = 1;
NSYMB FIELDSVISIBILREADWR = 2;
NSYMB FIELDSNULLPERTRUE = 0;
NSYMB FIELDSNULLPERFALSE = 1;
NSYMB FIELDSDATATYPBITS = 0;
NSYMB FIELDSDATATYPSTRING = 1;
NSYMB FIELDSDATATYPNUMSTR = 2;
NSYMB FIELDSDATATYPPNUMSTR = 3;
NSYMB FIELDSDATATYPSYMBOL = 4;
NSYMB FIELDSDATATYPROWNUM = 5;
NSYMB FIELDSDATATYPDBNUM = 6;
NSYMB FIELDSPCLEARYES = 0;
NSYMB FIELDSPCLEARNO = 1;
NSYMB FIELDSPRELOADYES = 0;
NSYMB FIELDSPRELOADNO = 1;
NSYMB FIELDSPDUMPYES = 0;
NSYMB FIELDSPDUMPNO = 1;
NSYMB FIELDSPSTATICYES = 0;
NSYMB FIELDSPSTATICNO = 1;
NSYMB FIELDSVOLATILYES = 0;
NSYMB FIELDSVOLATILNO = 1;
NSYMB FIELDSDEFSYMBSYMBOL1 = 0;
NSYMB FIELDSDEFSYMBSYMBOL2 = 1;
NSYMB FIELDSDEFSYMBSYMBOL3 = 2;

! Pointers !
    POINTER SQLM_FIELDS_OperRow (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_WorkRow (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_GuardRow (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_NilRow (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_RootRow (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_TempRow (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_GrandGrandFather (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_GrandFather (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_Father (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_Brother (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_Nephew (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_Delete (SQLT_FIELDS_Table);
    POINTER SQLM_FIELDS_DeleteFather (SQLT_FIELDS_Table);
RECORD SQLT_KEYS_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_KEYS_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_KEYS_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_KEYS_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    VARIABLE SQLC_KEYS_TROWNO_Data 16 DS RELOAD;

    VARIABLE SQLC_KEYS_KEYNO_Data 8 DS RELOAD;

    VARIABLE SQLC_KEYS_TABREF_Data 16 DS RELOAD;

    VARIABLE SQLC_KEYS_BLKREF_Data 16 DS RELOAD;

    VARIABLE SQLC_KEYS_KEYTYPE_Data 2 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_KEYS_Color         4   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_KEYS_Left2         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_KEYS_Right2        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_KEYS_Left3         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_KEYS_Right3        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_KEYS_Left4         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_KEYS_Right4        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_KEYS_DBnumber =
    1       SQLC_KEYS_DBnumber1      16,
    1       SQLC_KEYS_DBnumber2      16;

! Structure of the packed numstring columns. !

! This variable indicates the current color of the node !
STRUCTURE SQLC_KEYS_Color =
    1 SQLC_KEYS_Color2 1
    , 1 SQLC_KEYS_Color3 1
    , 1 SQLC_KEYS_Color4 1
    ;

! The symbol values. !
NSYMB KEYSKEYTYPEPRIMKEY = 0;
NSYMB KEYSKEYTYPEALTERN = 1;
NSYMB KEYSKEYTYPEINDKEY = 2;

! Pointers !
    POINTER SQLM_KEYS_OperRow (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_WorkRow (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_GuardRow (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_NilRow (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_RootRow (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_TempRow (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_GrandGrandFather (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_GrandFather (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_Father (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_Brother (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_Nephew (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_Delete (SQLT_KEYS_Table);
    POINTER SQLM_KEYS_DeleteFather (SQLT_KEYS_Table);
RECORD SQLT_KEYFIELDS_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_KEYFIELDS_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_KEYFIELDS_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_KEYFIELDS_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    VARIABLE SQLC_KEYFIELDS_TROWNO_Data 16 DS RELOAD;

    VARIABLE SQLC_KEYFIELDS_KEYNO_Data 8 DS RELOAD;

    VARIABLE SQLC_KEYFIELDS_TABREF_Data 16 DS RELOAD;

    VARIABLE SQLC_KEYFIELDS_BLKREF_Data 16 DS RELOAD;

    VARIABLE SQLC_KEYFIELDS_COMPNO_Data 8 DS RELOAD;

    VARIABLE SQLC_KEYFIELDS_FROWNO_Data 16 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_KEYFIELDS_Color         2   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_KEYFIELDS_Left2         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_KEYFIELDS_Right2        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_KEYFIELDS_Left3         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_KEYFIELDS_Right3        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_KEYFIELDS_DBnumber =
    1       SQLC_KEYFIELDS_DBnumber1      16,
    1       SQLC_KEYFIELDS_DBnumber2      16;

! Structure of the packed numstring columns. !

! This variable indicates the current color of the node !
STRUCTURE SQLC_KEYFIELDS_Color =
    1 SQLC_KEYFIELDS_Color2 1
    , 1 SQLC_KEYFIELDS_Color3 1
    ;

! The symbol values. !

! Pointers !
    POINTER SQLM_KEYFIELDS_OperRow (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_WorkRow (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_GuardRow (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_NilRow (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_RootRow (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_TempRow (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_GrandGrandFather (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_GrandFather (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_Father (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_Brother (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_Nephew (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_Delete (SQLT_KEYFIELDS_Table);
    POINTER SQLM_KEYFIELDS_DeleteFather (SQLT_KEYFIELDS_Table);
RECORD SQLT_FOREIGNKEYS_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_FOREIGNKEYS_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_FOREIGNKEYS_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_FOREIGNKEYS_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    VARIABLE SQLC_FOREIGNKEYS_TROWNO_Data 16 DS RELOAD;

    VARIABLE SQLC_FOREIGNKEYS_ORDNO_Data 8 DS RELOAD;

    VARIABLE SQLC_FOREIGNKEYS_BLKREF_Data 16 DS RELOAD;

    VARIABLE SQLC_FOREIGNKEYS_TABREF_Data 16 DS RELOAD;

    VARIABLE SQLC_FOREIGNKEYS_KEYNO_Data 8 DS RELOAD;

    VARIABLE SQLC_FOREIGNKEYS_FTROWNO_Data 16 DS RELOAD;

    VARIABLE SQLC_FOREIGNKEYS_FTABREF_Data 16 DS RELOAD;

    VARIABLE SQLC_FOREIGNKEYS_FBLKREF_Data 16 DS RELOAD;

    VARIABLE SQLC_FOREIGNKEYS_COND_Data 4 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_FOREIGNKEYS_Color         4   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_FOREIGNKEYS_Left2         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_FOREIGNKEYS_Right2        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_FOREIGNKEYS_Left3         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_FOREIGNKEYS_Right3        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_FOREIGNKEYS_Left4         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_FOREIGNKEYS_Right4        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_FOREIGNKEYS_Left5         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_FOREIGNKEYS_Right5        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_FOREIGNKEYS_DBnumber =
    1       SQLC_FOREIGNKEYS_DBnumber1      16,
    1       SQLC_FOREIGNKEYS_DBnumber2      16;

! Structure of the packed numstring columns. !

! This variable indicates the current color of the node !
STRUCTURE SQLC_FOREIGNKEYS_Color =
    1 SQLC_FOREIGNKEYS_Color2 1
    , 1 SQLC_FOREIGNKEYS_Color3 1
    , 1 SQLC_FOREIGNKEYS_Color4 1
    , 1 SQLC_FOREIGNKEYS_Color5 1
    ;

! The symbol values. !
NSYMB FOREIGNKEYSCONDRESTR = 0;
NSYMB FOREIGNKEYSCONDCASCAD = 1;
NSYMB FOREIGNKEYSCONDSETNULL = 2;
NSYMB FOREIGNKEYSCONDSETDEF = 3;

! Pointers !
    POINTER SQLM_FOREIGNKEYS_OperRow (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_WorkRow (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_GuardRow (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_NilRow (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_RootRow (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_TempRow (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_GrandGrandFather (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_GrandFather (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_Father (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_Brother (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_Nephew (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_Delete (SQLT_FOREIGNKEYS_Table);
    POINTER SQLM_FOREIGNKEYS_DeleteFather (SQLT_FOREIGNKEYS_Table);
RECORD SQLT_SYMBOLS_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_SYMBOLS_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_SYMBOLS_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_SYMBOLS_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    VARIABLE SQLC_SYMBOLS_FROWNO_Data 16 DS RELOAD;

    STRING VARIABLE SQLC_SYMBOLS_SYMBOL_Data 7 DS RELOAD;

    VARIABLE SQLC_SYMBOLS_SYMVAL_Data 16 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_SYMBOLS_Color         2   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_SYMBOLS_Left2         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_SYMBOLS_Right2        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_SYMBOLS_Left3         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_SYMBOLS_Right3        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_SYMBOLS_DBnumber =
    1       SQLC_SYMBOLS_DBnumber1      16,
    1       SQLC_SYMBOLS_DBnumber2      16;

! Structure of the packed numstring columns. !

! This variable indicates the current color of the node !
STRUCTURE SQLC_SYMBOLS_Color =
    1 SQLC_SYMBOLS_Color2 1
    , 1 SQLC_SYMBOLS_Color3 1
    ;

! The symbol values. !

! Pointers !
    POINTER SQLM_SYMBOLS_OperRow (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_WorkRow (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_GuardRow (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_NilRow (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_RootRow (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_TempRow (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_GrandGrandFather (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_GrandFather (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_Father (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_Brother (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_Nephew (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_Delete (SQLT_SYMBOLS_Table);
    POINTER SQLM_SYMBOLS_DeleteFather (SQLT_SYMBOLS_Table);
RECORD SQLT_TOWFAULTCODES_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_TOWFAULTCODES_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_TOWFAULTCODES_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_TOWFAULTCODES_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    VARIABLE SQLC_TOWFAULTCODES_TROWNO_Data 16 DS RELOAD;

    VARIABLE SQLC_TOWFAULTCODES_FAULTNO_Data 8 DS RELOAD;

    STRING VARIABLE SQLC_TOWFAULTCODES_FLTTEXT_Data 31 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_TOWFAULTCODES_Color         2   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_TOWFAULTCODES_Left2         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_TOWFAULTCODES_Right2        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_TOWFAULTCODES_DBnumber =
    1       SQLC_TOWFAULTCODES_DBnumber1      16,
    1       SQLC_TOWFAULTCODES_DBnumber2      16;

! Structure of the packed numstring columns. !

! This variable indicates the current color of the node !
STRUCTURE SQLC_TOWFAULTCODES_Color =
    1 SQLC_TOWFAULTCODES_Color2 1
    ;

! The symbol values. !

! Pointers !
    POINTER SQLM_TOWFAULTCODES_OperRow (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_WorkRow (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_GuardRow (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_NilRow (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_RootRow (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_TempRow (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_GrandGrandFather (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_GrandFather (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_Father (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_Brother (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_Nephew (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_Delete (SQLT_TOWFAULTCODES_Table);
    POINTER SQLM_TOWFAULTCODES_DeleteFather (SQLT_TOWFAULTCODES_Table);
RECORD SQLT_SYSFAULTCODES_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_SYSFAULTCODES_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_SYSFAULTCODES_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_SYSFAULTCODES_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    VARIABLE SQLC_SYSFAULTCODES_FAULTNO_Data 16 DS RELOAD;

    STRING VARIABLE SQLC_SYSFAULTCODES_FLTTEXT_Data 15 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_SYSFAULTCODES_Color         2   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_SYSFAULTCODES_Left2         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_SYSFAULTCODES_Right2        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_SYSFAULTCODES_DBnumber =
    1       SQLC_SYSFAULTCODES_DBnumber1      16,
    1       SQLC_SYSFAULTCODES_DBnumber2      16;

! Structure of the packed numstring columns. !

! This variable indicates the current color of the node !
STRUCTURE SQLC_SYSFAULTCODES_Color =
    1 SQLC_SYSFAULTCODES_Color2 1
    ;

! The symbol values. !

! Pointers !
    POINTER SQLM_SYSFAULTCODES_OperRow (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_WorkRow (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_GuardRow (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_NilRow (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_RootRow (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_TempRow (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_GrandGrandFather (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_GrandFather (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_Father (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_Brother (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_Nephew (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_Delete (SQLT_SYSFAULTCODES_Table);
    POINTER SQLM_SYSFAULTCODES_DeleteFather (SQLT_SYSFAULTCODES_Table);
RECORD SQLT_SYSTEMFIELDS_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_SYSTEMFIELDS_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_SYSTEMFIELDS_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_SYSTEMFIELDS_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    VARIABLE SQLC_SYSTEMFIELDS_TROWNO_Data 16 DS RELOAD;

    VARIABLE SQLC_SYSTEMFIELDS_ROWGEN_Data 16 DS RELOAD;

    VARIABLE SQLC_SYSTEMFIELDS_LOCK_Data 16 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_SYSTEMFIELDS_Color         2   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_SYSTEMFIELDS_Left2         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_SYSTEMFIELDS_Right2        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_SYSTEMFIELDS_Left3         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_SYSTEMFIELDS_Right3        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_SYSTEMFIELDS_DBnumber =
    1       SQLC_SYSTEMFIELDS_DBnumber1      16,
    1       SQLC_SYSTEMFIELDS_DBnumber2      16;

! Structure of the packed numstring columns. !

! This variable indicates the current color of the node !
STRUCTURE SQLC_SYSTEMFIELDS_Color =
    1 SQLC_SYSTEMFIELDS_Color2 1
    , 1 SQLC_SYSTEMFIELDS_Color3 1
    ;

! The symbol values. !

! Pointers !
    POINTER SQLM_SYSTEMFIELDS_OperRow (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_WorkRow (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_GuardRow (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_NilRow (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_RootRow (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_TempRow (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_GrandGrandFather (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_GrandFather (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_Father (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_Brother (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_Nephew (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_Delete (SQLT_SYSTEMFIELDS_Table);
    POINTER SQLM_SYSTEMFIELDS_DeleteFather (SQLT_SYSTEMFIELDS_Table);
RECORD SQLT_TEST1_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_TEST1_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_TEST1_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_TEST1_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    STRING VARIABLE SQLC_TEST1_COL1_Data 15 DS RELOAD;

    VARIABLE SQLC_TEST1_COL2_Data 16 DS RELOAD;

    VARIABLE SQLC_TEST1_COL3_Null 1 DS RELOAD;
    VARIABLE SQLC_TEST1_COL3_Data 16 DS RELOAD;

    STRING VARIABLE SQLC_TEST1_COL4_Data 15 DS ;

    VARIABLE SQLC_TEST1_COL5_Null 1 DS RELOAD;
    STRING VARIABLE SQLC_TEST1_COL5_Data 7 DS RELOAD;

    VARIABLE SQLC_TEST1_COL6_Null 1 DS RELOAD;
    STRING VARIABLE SQLC_TEST1_COL6_Data 31 DS RELOAD;

    VARIABLE SQLC_TEST1_COL7_Null 1 DS RELOAD;
    VARIABLE SQLC_TEST1_COL7_Data 1 DS RELOAD;

    VARIABLE SQLC_TEST1_COL8_Null 1 DS RELOAD;
    VARIABLE SQLC_TEST1_COL8_Data 128 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_TEST1_Color         2   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_TEST1_Left2         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_TEST1_Right2        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_TEST1_Left3         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_TEST1_Right3        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_TEST1_DBnumber =
    1       SQLC_TEST1_DBnumber1      16,
    1       SQLC_TEST1_DBnumber2      16;

! Structure of the packed numstring columns. !
STRUCTURE SQLC_TEST1_COL8_Data =
    1 LENGTH 16,
    1 W1 16,
    1 W2 16,
    1 W3 16,
    1 W4 16,
    1 W5 16,
    1 W6 16,
    1 W7 16;

! This variable indicates the current color of the node !
STRUCTURE SQLC_TEST1_Color =
    1 SQLC_TEST1_Color2 1
    , 1 SQLC_TEST1_Color3 1
    ;

! The symbol values. !
NSYMB TEST1COL7FALSE = 0;
NSYMB TEST1COL7TRUE = 1;

! Pointers !
    POINTER SQLM_TEST1_OperRow (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_WorkRow (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_GuardRow (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_NilRow (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_RootRow (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_TempRow (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_GrandGrandFather (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_GrandFather (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_Father (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_Brother (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_Nephew (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_Delete (SQLT_TEST1_Table);
    POINTER SQLM_TEST1_DeleteFather (SQLT_TEST1_Table);
!------------------------------------------------!
!       towTabInfo !
!------------------------------------------------!
RECORD SQLT_TableInfo;
! The location of the first system row. !
    VARIABLE    SQLM_System    !R! 16 DS RELOAD;
! The number of rows in the table area, allocated or not. !
    VARIABLE    SQLM_TableAllocated !R! 16 DS RELOAD;
! The location of the last row which is allocated in the table area. !
    VARIABLE    SQLM_TableLast !R! 16 DS RELOAD;
! The number of allocated rows in the table area. !
    VARIABLE    SQLM_TableUsed !R! 16 DS RELOAD;
! The number of rows in the work area, allocated or not. !
    VARIABLE    SQLM_WorkAllocated  !R! 16 DS RELOAD;
! The location of the last row which is allocated in the work area. !
    VARIABLE    SQLM_WorkLast !R! 16 DS RELOAD;
! The number of allocated rows in the work area. !
    VARIABLE    SQLM_WorkUsed !R! 16 DS RELOAD;
! This variable locks the work area of a table. !
    VARIABLE    SQLM_WorkLock   1   DS CLEAR;
END RECORD;
! This variable holds the current table number. !
    POINTER     SQLM_TableReference (SQLT_TableInfo);


!------------------------------------------------!
!       tuDeclarations !
!------------------------------------------------!
!------------------------------------------------!
!       comDeclarations !
!------------------------------------------------!
!------------------------------------------------!
!       tuDeclRemTab !
!------------------------------------------------!


    VARIABLE SQLM_Remote(2) 32 DS RELOAD;
    STRUCTURE SQLM_Remote =
! This variable holds the block reference of a remote single table. !
        1 block 16,
! This variable holds the table reference of a remote single table. !
        1 table 16;
! The symbol values for all remote tables. !
NSYMB TEST2COL7FALSE = 0;
NSYMB TEST2COL7TRUE = 1;
NSYMB TEST3COL7FALSE = 0;
NSYMB TEST3COL7TRUE = 1;



!END SQL!
END DECLARE;

PROGRAM; PLEX;

!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!
!*                                                                           *! 
!*              D A T A   D I C T I O N A R Y   I N T E R F A C E            *!
!*                                                                           *!
!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!




!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!
!*                                                                           *! 
!*              S I G N A L   E N T R I E S                                  *!
!*                                                                           *!
!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!




!*****************************************************************************!
!*                                                                           *! 
!*             T R H S T A T R A N S R                                       *!
!*                                                                           *!
!*****************************************************************************!



   ENTER TRHSTATRANSR WITH
      PROTECTEDP,
      CMESSAGE,
      PROTECTEDP:SQL_SQLTID; 
      
   CASE CRETURNFROMTRHSTATRANSR IS
      WHEN SYMCLEARSOMETABS80 DO
         GOTO CLEARSOMETABS80;
         
      WHEN SYMCLEARALLTABS30 DO
         GOTO CLEARALLTABS30;
         
      WHEN SYMDDINITTABLE20 DO
         GOTO DDINITTABLE20;
         
      WHEN SYMDDINITFIELD20 DO
         GOTO DDINITFIELD20;
         
      WHEN SYMDDINITFK10 DO
         GOTO DDINITFK10;
         
      OTHERWISE DO;
   ESAC;
      






!*****************************************************************************!
!*                                                                           *! 
!*             T R H S T O P T R A N S R                                     *!
!*                                                                           *!
!*****************************************************************************!




! THIS ROUTINE ENTERS THE RETURN SIGNAL TO TRHSTOPTRANS. TRHSTOP- !
! TRANS MAY HAVE BEEN INITIATED BY EITHER DDFCSTA OR BLKREMST,    !
! AND CSIGNAL KNOWS WHICH ONE IT WAS.                             !

! INDATA:        CSIGNAL                                          !

! OUTDATA:       NONE                                             ! 

   ENTER TRHSTOPTRANSR;
   
   CASE CSIGNAL IS
      WHEN DDFCSTA DO
         SEND DDFCSTAR WITH
            CUSERP(ZDDFCSTA);
      WHEN BLKREMST DO
         SEND BLKREMSTRPY;
      OTHERWISE DO;
   ESAC;
   
   EXIT;               














!*****************************************************************************!
!*                                                                           *! 
!*             B L K R E M S T ,    D D F C S T A                            *!
!*                                                                           *!
!*****************************************************************************!




! THE OBJECTIVE OF THIS ROUTINE IS TO SEND THE SIGNAL TRHSTOP-    !
! TRANS, WHICH WILL STOP AND ROLL BACK ALL TRANSACTIONS THAT ARE  !
! CURRENTLY PERFORMED, AND WHICH WILL BLOCK RECEPTION OF NEW      !
! TRANSACTIONS. THE ROUTINE IS INITIATED EITHER BY RECEPTION OF   !
! THE SIGNAL DDFCSTA OR BY RECEPTION OF THE SIGNAL BLKREMST.      !

! INSIGNALS:         DDFCSTA OR BLKREMST                          !

! OUTSIGNAL:         TRHSTOPTRANS                                 !

! INDATA:            NONE                                         !

! OUTDATA:           CSIGNAL                                      !

  
   ENTER BLKREMST WITH
      +,
      +;
      
   CSIGNAL=BLKREMST;
   SEND TRHSTOPTRANS;
   EXIT;
   
   
   ENTER DDFCSTA WITH
      CUSERP(ZDDFCSTA),
      +,
      +;
      
   CSIGNAL=DDFCSTA;
   SEND TRHSTOPTRANS;
   EXIT;



   
   
      

!*****************************************************************************!
!*                                                                           *! 
!*             D D I N I T F I E L D                                         *!
!*                                                                           *!
!*****************************************************************************!




! A TABLE OWNER ASKS DD TO INITIATE A SPECIFIC FIELD I.E. TO      !
! INSERT THE FIELD DEFINITION IN THE FIELDS TABLE. DDINTERFACE    !
! RECEIVES THE SIGNAL DDINITFIELD, CALCULATES THE PRINTOUT WIDTH  !
! AS THE MAXIMUM WIDTH OF THE FIELD NAME AND THE FIELD VALUE,     !
! ASKS THE TABLES TABLE FOR THE CURRENT ROW NUMBER IN TABLES AND  !
! FORWARDS THE INFORMATION TO SYSTEMTABLES BY SENDING THE SIGNAL  !
! SYSINITFLD. !

! INDATA:        NONE                                             !

! OUTDATA:       NONE                                             !


   ENTER DDINITFIELD WITH
      TUSERP,
      TTOWBLKREF,
      TTOWTABREF,
      CFLDNAME,
      TFLDNUMBER,
      TFLDPROTECTION,
      TFLDDATATYPE,
      TFLDSIZE,
      TVOLATILE;
   
   
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat1;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat1;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat1;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat1;
PROTECTEDALLOCATEDbeginStat1)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat1)
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!


   
   PROTECTEDP:REF=TTOWBLKREF;
   PROTECTEDP:TOWBLKREF=TTOWBLKREF;
   PROTECTEDP:USERP=TUSERP;
   PROTECTEDP:TOWTABREF=TTOWTABREF;
   PROTECTEDP:FLDNAME=CFLDNAME;
   PROTECTEDP:FLDNUMBER=TFLDNUMBER;
   PROTECTEDP:FLDPROTECTION=TFLDPROTECTION;
   PROTECTEDP:FLDDATATYPE=TFLDDATATYPE;
   PROTECTEDP:FLDSIZE=TFLDSIZE;
   PROTECTEDP:VOLATIL=TVOLATILE;
   
   

   CHAR VX:CFLDNAME(N:0) TO VT:TNAMELENGTH;
   PROTECTEDP:NAMELENGTH=TNAMELENGTH;

   CASE PROTECTEDP:FLDDATATYPE IS
      WHEN ZBITS DO  
         CASE PROTECTEDP:FLDSIZE IS
            WHEN 1,2 DO
               PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
            WHEN 4 DO
               IF PROTECTEDP:NAMELENGTH > 2 THEN
                  PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
               ELSE
                  PROTECTEDP:PRWIDTH=2;
               FI; 
            WHEN 8 DO
               IF PROTECTEDP:NAMELENGTH > 3 THEN
                  PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
               ELSE
                  PROTECTEDP:PRWIDTH=3;
               FI;
            WHEN 16 DO
               IF PROTECTEDP:NAMELENGTH > 5 THEN
                  PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
               ELSE
                  PROTECTEDP:PRWIDTH=5;
               FI; 
            OTHERWISE DO;         
         ESAC;
   
      WHEN ZSTR, ZNUMSTR DO 
         CASE PROTECTEDP:FLDSIZE IS
            WHEN 1 DO
               PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
            WHEN 3 DO
               IF PROTECTEDP:NAMELENGTH > 3 THEN 
                  PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
               ELSE
                  PROTECTEDP:PRWIDTH=3;
               FI;
            OTHERWISE DO
               PROTECTEDP:PRWIDTH = PROTECTEDP:FLDSIZE;
         ESAC;
   
      WHEN ZPACKEDNUMSTR DO 
         PROTECTEDP:PRWIDTH=PROTECTEDP:FLDSIZE;
   
      WHEN ZSYMBOL DO 
         CRETURNFROMCHECKSYMVALNAMELENGTH = SYMDDINITFIELD10;
         GOTO CHECKSYMVALNAMELENGTH;         
                         
   
      WHEN ZROWNUMBER DO
         CASE PROTECTEDP:FLDSIZE IS
            WHEN 16 DO
               IF PROTECTEDP:NAMELENGTH > 5 THEN  
                  PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
               ELSE
                  PROTECTEDP:PRWIDTH=5;
               FI;
            WHEN 20 DO                  ! ROWNUMBER WILL BE EXPANDED !
               PROTECTEDP:PRWIDTH=7;    ! TO 20 BITS IN THE FUTURE   !
            OTHERWISE DO;
         ESAC; 
   
      WHEN ZDBNUMBER DO
         PROTECTEDP:PRWIDTH=10;         ! THE PRINTOUT WIDTH IS !
      OTHERWISE DO;
   ESAC;                                ! DETERMINED !

DDINITFIELD10)
              

   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN GETTROWNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locOpenStat     !
!--------------------------------------!
! Check if cursor already is opened, if so report failure. !
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITlocOpenStat2;
    FI;
! Check that the work area is locked, if so report failure !
    SQLM_TableReference=1;
    IF SQLM_TableReference:SQLM_WorkLock /= 0 THEN
        SQLCODE=3+18 <= 8;
        GOTO EXITlocOpenStat2;
    FI;
! Allocate work row, report if the allocate fails. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocOpenStat2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocOpenStat2;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow1;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow1;
!
$ We should never get here
!
    GOTO WORKFULLlocOpenStat2;
WORKALLOCATEallocateWorkRow1)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data=TOWBLKREF;
! If the cursor is a btree store 0 in cLastRow if the key operation is
  PREVIOUS otherwise the highest row number (65535 if 16 bit address)
  is stored in cLastRow (key operation THIS or THIS OR PREVIOUS). !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=65535;
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_GETTROWNO_Cursor=SQLM_TABLES_WorkRow;
    SQLCODE=0;
    GOTO EXITlocOpenStat2;
WORKLOCKlocOpenStat2)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocOpenStat2;
WORKFULLlocOpenStat2)
    SQLCODE=3+8 <= 8;
EXITlocOpenStat2)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH GETTROWNO INTO %PROTECTEDP:TROWNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locFetchStat!
!--------------------------------------!
! Check if cursor is open, if not report failure !
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITlocFetchStat3;
    FI;
! Find an operating row !
NEXTlocFetchStat3)
    SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        4,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right4,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
,
        0,
        1,
        SQLM_TableReference:SQLM_System+1,   ! pNilRow !
        11;
    EXIT;
towGetSchLab11)
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! check if row is not found, if so report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat3;
    FI;
! check if row is locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+3 <= 8;
        GOTO EXITlocFetchStat3;
    FI;
! update cursor !
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data=
        SQLM_TABLES_OperRow:SQLC_TABLES_BLKREF_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=
        SQLM_TABLES_OperRow;
    SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2=
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2;
! Do additional tests, if the fails try another row. !
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!








    IF SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data = PROTECTEDP:TOWTABREF
        GOTO SUCCESSlocFetchStat3;


    GOTO NEXTlocFetchStat3;
SUCCESSlocFetchStat3)
! Everything is allright, copy columns into variables. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    PROTECTEDP:TROWNO = SQLM_TABLES_OperRow;
! Set cursor to indicate that a row was found and return success !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=0;
    SQLCODE=0;
EXITlocFetchStat3)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE GETTROWNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locCloseStat    !
!--------------------------------------!
    IF  PROTECTEDP:SQLM_GETTROWNO_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
    ELSE
! Close cursor. !
      SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
      SQLCODE=0;
    FI;


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!






     
! THIS ROUTINE ENTERS THE SIGNAL SYSINITFLD FROM THE DD INTERFACE !
! MODULE. THE OBJECTIVE IS TO INSERT A NEW ROW INTO THE FIELDS    !
! TABLE, AND THUS TO DEFINE A NEW USER FIELD. THE ROUTINE WILL    !
! SEND THE SIGNAL SYSINITFLDR TO DD INTERFACE AS AN ACKNOW-       !
! LEGDEMENT ONCE ALL ACTION IS TAKEN.                             !

! IF IT TURNS OUT THAT THE FIELDS TABLE IS FULL WHEN THE INSERT IS!
! ATTEMPTED, THE SIGNAL PROGERROR WILL BE SENT. THIS SIGNAL WILL  !
! CAUSE A NEW RESTART, MAKING THE OLD SYSTEM EXECUTIVE.           !

! INDATA:       CNEXTFROWNO          NEXT AVAILABLE PRIMARY KEY  !

! OUTDATA:      CNEXTFROWNO          NEXT AVAILABLE PRIMARY KEY  !                

 
                      




   PROTECTEDP:FROWNO=CNEXTFROWNO;
   CNEXTFROWNO=CNEXTFROWNO+1;
   

                


   CRETURNFROMTRHSTATRANSR = SYMDDINITFIELD20;        
   SEND TRHSTATRANS WITH
      PROTECTEDP,            ! OWN POINTER !
      COWNREF,
      ZDONOTLOG,
      +;     
   EXIT;

DDINITFIELD20)

   
!BEGIN SQL INSERT 27!
!******************************************************************************!

!EXEC SQL INSERT INTO FIELDS
     (FROWNO,
      NAME,
      TABREF,
      BLKREF,
      FIELDNO,
      VISIBIL,
      PRWIDTH,
      NULLPER,
      DATATYP,
      BADDRES,
      SIZE,
      VOLATIL,
      TROWNO)
   VALUES
     (%PROTECTEDP:FROWNO,
      %PROTECTEDP:FLDNAME,
      %PROTECTEDP:TOWTABREF,
      %PROTECTEDP:TOWBLKREF,
      %PROTECTEDP:FLDNUMBER,
      %PROTECTEDP:FLDPROTECTION,
      %PROTECTEDP:PRWIDTH,
      TRUE,
      %PROTECTEDP:FLDDATATYPE,
      1,
      %PROTECTEDP:FLDSIZE,
      %PROTECTEDP:VOLATIL,
      %PROTECTEDP:TROWNO)!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       insertStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITinsertStat5;
    FI;
! Pack signal with required data and primary key. Then send insert
  signal to transaction handler. !
    PROTECTEDP:SQLX_SQLRETURN=1;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!









!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!
    SQLX_DR23 = FROWNO;
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 5;
    SQLX_DR6 = 7;
    SQLX_DR7 = 5;
    SQLX_DR8 = 4;
    SQLX_DR9 = 3;
    SQLX_DR10 = 2;

    DO SQLS_Pack1;  ! pack string into signal registers !

    SQLX_DR15 = PROTECTEDP:TOWTABREF;

    SQLX_DR16 = PROTECTEDP:TOWBLKREF;

    SQLX_DR17 = PROTECTEDP:FLDNUMBER;

    SQLX_DR18 = PROTECTEDP:FLDPROTECTION;
    SEND trhInsRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref,
        cOwnRef,
        2,
        2                 ! primary key !
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR23
        ;
    EXIT;
trhInsRowLab1)
    IF SQLCODE /= 0 GOTO EXITinsertStat5;
! Send let field signal to transaction handler until all data is
  transferred to the table. Abort the command if any signal fails. !
    PROTECTEDP:SQLX_SQLRETURN=1;
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 7;
    SQLX_DR6 = 27;
    SQLX_DR7 = 21;
    SQLX_DR8 = 14;
    SQLX_DR9 = 11;
    SQLX_DR10 = 10;
    SQLX_DR11 = 9;
    SQLX_DR12 = 8;

    SQLX_DR13 = PROTECTEDP:PRWIDTH;

    SQLX_DR14 = 0;

    SQLX_DR15 = PROTECTEDP:FLDDATATYPE;

    SQLX_DR16 = 1;

    SQLX_DR17 = PROTECTEDP:FLDSIZE;

    SQLX_DR18 = PROTECTEDP:VOLATIL;
    SQLX_DR19 = 0;

    SQLX_DR20 = PROTECTEDP:TROWNO;
    SEND trhLetFld WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref,
        +,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,+
        ,+
        ,+
        ;
    EXIT;
trhLetFldLab1)
    IF SQLCODE /= 0 GOTO EXITinsertStat5;
! Exit !
EXITinsertStat5)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL COMMIT 0!
!******************************************************************************!

!EXEC SQL COMMIT TRANSACTION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       commitStat      !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhComTransLab1;
    FI;
! Request to commit a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=1;
    SEND trhComTrans WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhComTransLab1)
! Close transaction !
    PROTECTEDP:SQLTRANSID=0;


!******************************************************************************!
!END SQL!
      


   CASE SQLCODE.VALUE IS
      WHEN ZROWINSERTED DO;
      
      WHEN ZSEARCHFAIL DO
         IF SQLCODE.SUBCODE = ZROWNOTALLOCATED THEN
            
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
               INTO %TTABREF, %TSAEID
               FROM TABLES
               WHERE NAME = %ZFIELDS AND BLKREF = %COWNREF!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TableReference = 1;
! Allocate a work area, if none is found report failure. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocSelectStat7;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocSelectStat7;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow2;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow2;
!
$ We should never get here
!
    GOTO WORKFULLlocSelectStat7;
WORKALLOCATEallocateWorkRow2)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
! Save the primary key in work area. !
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data =
        ZFIELDS;
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data =
        COWNREF;
! Find row which have the primary key as stored in the work row.!
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnref WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        3,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLM_TABLES_WorkRow,
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        2,
        +,
        12;
    EXIT;
towGetSchLab12)
! Restore some data !
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    SQLCODE=2+1 <= 8;
! check if row is found, if not report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1
        GOTO EXITlocSelectStat7;
! check if row is not read locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock>1 THEN
        SQLCODE=2+3 <= 8;
        GOTO EXITlocSelectStat7;
    FI;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    TTABREF = SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data;

    IF SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    TSAEID = SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Data;
    GOTO EXITlocSelectStat7;
WORKLOCKlocSelectStat7)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocSelectStat7;
WORKFULLlocSelectStat7)
    SQLCODE=3+8 <= 8;
EXITlocSelectStat7)


!******************************************************************************!
!END SQL!

                  
            SEND PROGERROR WITH
               ZPROGERRORCODE1,
               COWNREF,
               TTABREF,
               TSAEID;
            EXIT;
         FI;
         
      WHEN ZERROR DO
         CASE SQLCODE.SUBCODE IS
            WHEN ZTABFULL DO
               
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
                  INTO %TTABREF, %TSAEID
                  FROM TABLES
                  WHERE NAME = %ZFIELDS AND BLKREF = %COWNREF!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TableReference = 1;
! Allocate a work area, if none is found report failure. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocSelectStat8;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocSelectStat8;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow3;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow3;
!
$ We should never get here
!
    GOTO WORKFULLlocSelectStat8;
WORKALLOCATEallocateWorkRow3)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
! Save the primary key in work area. !
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data =
        ZFIELDS;
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data =
        COWNREF;
! Find row which have the primary key as stored in the work row.!
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnref WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        3,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLM_TABLES_WorkRow,
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        2,
        +,
        13;
    EXIT;
towGetSchLab13)
! Restore some data !
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    SQLCODE=2+1 <= 8;
! check if row is found, if not report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1
        GOTO EXITlocSelectStat8;
! check if row is not read locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock>1 THEN
        SQLCODE=2+3 <= 8;
        GOTO EXITlocSelectStat8;
    FI;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    TTABREF = SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data;

    IF SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    TSAEID = SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Data;
    GOTO EXITlocSelectStat8;
WORKLOCKlocSelectStat8)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocSelectStat8;
WORKFULLlocSelectStat8)
    SQLCODE=3+8 <= 8;
EXITlocSelectStat8)


!******************************************************************************!
!END SQL!

                  
               SEND PROGERROR WITH
                  ZPROGERRORCODE1,
                  COWNREF,
                  TTABREF,
                  TSAEID;
               EXIT;
               
            WHEN ZTRHCONG DO
               SEND PROGERROR WITH
                  ZPROGERRORCODE4,
                  ZTRHSAEID2;
               EXIT;

            OTHERWISE DO;
         ESAC;
         
      OTHERWISE DO;
   ESAC;
   
   SEND DDINITFIELDR REFERENCE PROTECTEDP:REF WITH
      PROTECTEDP:USERP;
   

   
!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_EXTENSIVETABS_Cursor=0;
    IF PROTECTEDP:SQLM_FINDFK_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDFK_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEWTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDORDNO_Cursor=0;
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDTROWNO_Cursor=0;
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor=0;
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETTROWNO_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=1;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab1)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!

   EXIT;

         

                  
       










      

!*****************************************************************************!
!*                                                                           *! 
!*             D D I N I T F K                                               *!
!*                                                                           *!
!*****************************************************************************!




! A TABLE OWNER ASKS DD TO INITIATE A SPECIFIC FOREIGN KEY I.E.   !
! TO INSERT THE FOREIGN KEY DEFINITION IN THE FOREIGNKEYS TABLE.  !
! DDINTERFACE RECEIVES THE SIGNAL DDINITFK, TRANSLATES THE TABLE  !
! NAME OF THE REFERRED TABLE TO ITS ROWNUMBER IN THE TABLES TABLE !
! AND FORWARDS THE INFORMATION TO SYSTEMTABLES BY SENDING THE     !
! SIGNAL SYSINITFK.                                               !

! IF THE REFERRED TABLE IS NOT DEFINED IN THE TABLES TABLE, THE   !
! SIGNAL PROGERROR IS SENT. THIS SIGNAL WILL INITIATE A NEW       !
! RESTART, WHICH IMPLIES THAT THE OLD SYSTEM WILL BECOME          !
! EXECUTIVE.                                                      !

! INDATA:        NONE                                             !

! OUTDATA:       NONE                                             !


ENTER DDINITFK WITH
   TUSERP,
   TTOWBLKREF,
   TTOWTABREF,
   TFKNUMBER,
   CREFERREDTABNAME,
   TDELETEACTION;


!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat10;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat10;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat10;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat10;
PROTECTEDALLOCATEDbeginStat10)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat10)
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!


PROTECTEDP:USERP=TUSERP;
PROTECTEDP:REF=TTOWBLKREF;
PROTECTEDP:TOWBLKREF=TTOWBLKREF;  
PROTECTEDP:TOWTABREF=TTOWTABREF;
PROTECTEDP:FKNUMBER=TFKNUMBER;
PROTECTEDP:REFERREDTABNAME=CREFERREDTABNAME;
PROTECTEDP:DELETEACTION=TDELETEACTION;
      

   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN FINDTROWNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locOpenStat     !
!--------------------------------------!
! Check if cursor already is opened, if so report failure. !
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITlocOpenStat11;
    FI;
! Check that the work area is locked, if so report failure !
    SQLM_TableReference=1;
    IF SQLM_TableReference:SQLM_WorkLock /= 0 THEN
        SQLCODE=3+18 <= 8;
        GOTO EXITlocOpenStat11;
    FI;
! Allocate work row, report if the allocate fails. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocOpenStat11;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocOpenStat11;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow4;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow4;
!
$ We should never get here
!
    GOTO WORKFULLlocOpenStat11;
WORKALLOCATEallocateWorkRow4)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data=REFERREDTABNAME;
! If the cursor is a btree store 0 in cLastRow if the key operation is
  PREVIOUS otherwise the highest row number (65535 if 16 bit address)
  is stored in cLastRow (key operation THIS or THIS OR PREVIOUS). !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=65535;
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_FINDTROWNO_Cursor=SQLM_TABLES_WorkRow;
    SQLCODE=0;
    GOTO EXITlocOpenStat11;
WORKLOCKlocOpenStat11)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocOpenStat11;
WORKFULLlocOpenStat11)
    SQLCODE=3+8 <= 8;
EXITlocOpenStat11)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH FINDTROWNO INTO %PROTECTEDP:REFERREDTROWNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locFetchStat!
!--------------------------------------!
! Check if cursor is open, if not report failure !
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITlocFetchStat12;
    FI;
! Find an operating row !
    SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDTROWNO_Cursor;
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        3,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
,
        0,
        1,
        SQLM_TableReference:SQLM_System+1,   ! pNilRow !
        14;
    EXIT;
towGetSchLab14)
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! check if row is not found, if so report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat12;
    FI;
! check if row is locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+3 <= 8;
        GOTO EXITlocFetchStat12;
    FI;
! update cursor !
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data=
        SQLM_TABLES_OperRow:SQLC_TABLES_NAME_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=
        SQLM_TABLES_OperRow;
    SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2=
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2;
! Do additional tests, if the fails try another row. !
! Everything is allright, copy columns into variables. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    PROTECTEDP:REFERREDTROWNO = SQLM_TABLES_OperRow;
! Set cursor to indicate that a row was found and return success !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=0;
    SQLCODE=0;
EXITlocFetchStat12)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!
   CASE SQLCODE.VALUE IS
      WHEN ZOK DO;
      WHEN ZSEARCHFAIL DO

         SEND PROGERROR WITH
            ZPROGERRORCODE3,
            PROTECTEDP:TOWBLKREF,
            PROTECTEDP:TOWTABREF;
         EXIT;
      OTHERWISE DO;                  ! DISCUSSIONS NEEDED !
   ESAC;                                
            
   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE FINDTROWNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locCloseStat    !
!--------------------------------------!
    IF  PROTECTEDP:SQLM_FINDTROWNO_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
    ELSE
! Close cursor. !
      SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDTROWNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
      SQLCODE=0;
    FI;


!******************************************************************************!
!END SQL!
       
                  
   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN GETTROWNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locOpenStat     !
!--------------------------------------!
! Check if cursor already is opened, if so report failure. !
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITlocOpenStat14;
    FI;
! Check that the work area is locked, if so report failure !
    SQLM_TableReference=1;
    IF SQLM_TableReference:SQLM_WorkLock /= 0 THEN
        SQLCODE=3+18 <= 8;
        GOTO EXITlocOpenStat14;
    FI;
! Allocate work row, report if the allocate fails. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocOpenStat14;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocOpenStat14;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow5;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow5;
!
$ We should never get here
!
    GOTO WORKFULLlocOpenStat14;
WORKALLOCATEallocateWorkRow5)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data=TOWBLKREF;
! If the cursor is a btree store 0 in cLastRow if the key operation is
  PREVIOUS otherwise the highest row number (65535 if 16 bit address)
  is stored in cLastRow (key operation THIS or THIS OR PREVIOUS). !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=65535;
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_GETTROWNO_Cursor=SQLM_TABLES_WorkRow;
    SQLCODE=0;
    GOTO EXITlocOpenStat14;
WORKLOCKlocOpenStat14)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocOpenStat14;
WORKFULLlocOpenStat14)
    SQLCODE=3+8 <= 8;
EXITlocOpenStat14)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH GETTROWNO INTO %PROTECTEDP:TROWNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locFetchStat!
!--------------------------------------!
! Check if cursor is open, if not report failure !
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITlocFetchStat15;
    FI;
! Find an operating row !
NEXTlocFetchStat15)
    SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        4,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right4,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
,
        0,
        1,
        SQLM_TableReference:SQLM_System+1,   ! pNilRow !
        15;
    EXIT;
towGetSchLab15)
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! check if row is not found, if so report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat15;
    FI;
! check if row is locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+3 <= 8;
        GOTO EXITlocFetchStat15;
    FI;
! update cursor !
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data=
        SQLM_TABLES_OperRow:SQLC_TABLES_BLKREF_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=
        SQLM_TABLES_OperRow;
    SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2=
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2;
! Do additional tests, if the fails try another row. !
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!








    IF SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data = PROTECTEDP:TOWTABREF
        GOTO SUCCESSlocFetchStat15;


    GOTO NEXTlocFetchStat15;
SUCCESSlocFetchStat15)
! Everything is allright, copy columns into variables. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    PROTECTEDP:TROWNO = SQLM_TABLES_OperRow;
! Set cursor to indicate that a row was found and return success !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=0;
    SQLCODE=0;
EXITlocFetchStat15)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE GETTROWNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locCloseStat    !
!--------------------------------------!
    IF  PROTECTEDP:SQLM_GETTROWNO_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
    ELSE
! Close cursor. !
      SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETTROWNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
      SQLCODE=0;
    FI;


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!
            

   
! THIS ROUTINE ENTERS THE SIGNAL SYSINITFK FROM THE DD INTERFACE  !
! MODULE. THE OBJECTIVE IS TO INSERT A NEW ROW IN THE FOREIGNKEYS !
! TABLE, AND THUS DEFINE A NEW FOREIGN KEY RELATIONSHIP. THE ROU- !
! TINE WILL FIND THE NEXT AVAILABLE                               !
! ORDINAL NUMBER OF THE FOREIGN KEY AMONG THE FOREIGN KEYS THAT   !
! REFER TO THE REFERRED TABLE BY USING THE CURSOR FINDORDNO. ONCE !
! ALL DATA IS INSERTED INTO FOREIGNKEY, THE SIGNAL SYSINITFKR     !
! WILL BE SENT AS AN ACKNOWLEDGEMENT TO THE DD INTERFACE MODULE.  !

! IF THE INSERT FAILS BECASE THE FOREIGNKEYS TABLE IS UNDER-      !
! DIMENSIONED, THE SIGNAL PROGERROR WILL BE SENT. THIS SIGNAL     !
! WILL INITIATE A RESTART, WHICH IMPLIES THAT THE OLD SYSTEM WILL !
! BECOME EXECUTIVE.                                               !

      
   
   

   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN FINDORDNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locOpenStat     !
!--------------------------------------!
! Check if cursor already is opened, if so report failure. !
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITlocOpenStat17;
    FI;
! Check that the work area is locked, if so report failure !
    SQLM_TableReference=5;
    IF SQLM_TableReference:SQLM_WorkLock /= 0 THEN
        SQLCODE=3+18 <= 8;
        GOTO EXITlocOpenStat17;
    FI;
! Allocate work row, report if the allocate fails. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocOpenStat17;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocOpenStat17;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow6;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow6;
!
$ We should never get here
!
    GOTO WORKFULLlocOpenStat17;
WORKALLOCATEallocateWorkRow6)
    IF SQLM_FOREIGNKEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FOREIGNKEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=2;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_TROWNO_Data=REFERREDTROWNO;
! If the cursor is a btree store 0 in cLastRow if the key operation is
  PREVIOUS otherwise the highest row number (65535 if 16 bit address)
  is stored in cLastRow (key operation THIS or THIS OR PREVIOUS). !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2=65535;
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_FINDORDNO_Cursor=SQLM_FOREIGNKEYS_WorkRow;
    SQLCODE=0;
    GOTO EXITlocOpenStat17;
WORKLOCKlocOpenStat17)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocOpenStat17;
WORKFULLlocOpenStat17)
    SQLCODE=3+8 <= 8;
EXITlocOpenStat17)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH FINDORDNO INTO %PROTECTEDP:ORDNO !

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locFetchStat!
!--------------------------------------!
! Check if cursor is open, if not report failure !
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITlocFetchStat18;
    FI;
! Find an operating row !
NEXTlocFetchStat18)
    SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDORDNO_Cursor;
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        4,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right4,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
,
        0,
        1,
        SQLM_TableReference:SQLM_System+1,   ! pNilRow !
        16;
    EXIT;
towGetSchLab16)
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
! check if row is not found, if so report failure !
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=2;
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat18;
    FI;
! check if row is locked, if so report failure !
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=2;
        SQLCODE=2+3 <= 8;
        GOTO EXITlocFetchStat18;
    FI;
! update cursor !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_TROWNO_Data=
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_TROWNO_Data;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2=
        SQLM_FOREIGNKEYS_OperRow;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_DBnumber2=
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2;
! Do additional tests, if the fails try another row. !
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!








    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_ORDNO_Data =< ZMAXORDNO
        GOTO SUCCESSlocFetchStat18;


    GOTO NEXTlocFetchStat18;
SUCCESSlocFetchStat18)
! Everything is allright, copy columns into variables. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    PROTECTEDP:ORDNO = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_ORDNO_Data;
! Set cursor to indicate that a row was found and return success !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=0;
    SQLCODE=0;
EXITlocFetchStat18)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!
   
   CASE SQLCODE.VALUE IS
      WHEN ZOK DO
         PROTECTEDP:ORDNO=PROTECTEDP:ORDNO+1;
      WHEN ZSEARCHFAIL DO
         PROTECTEDP:ORDNO=ZFIRSTORDNO;
      OTHERWISE DO;
   ESAC;      
  
   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE FINDORDNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locCloseStat    !
!--------------------------------------!
    IF  PROTECTEDP:SQLM_FINDORDNO_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
    ELSE
! Close cursor. !
      SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDORDNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
      SQLCODE=0;
    FI;


!******************************************************************************!
!END SQL!

   
   
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT BLKREF, TABREF
      INTO %PROTECTEDP:TOWBLKREF, %PROTECTEDP:TOWTABREF
      FROM TABLES
      WHERE TROWNO = %PROTECTEDP:REFERREDTROWNO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
      !row access !
    SQLM_TABLES_OperRow=REFERREDTROWNO;
    SQLM_TableReference=1;
    SQLCODE=2+1 <= 8;
    IF NOT SQLM_TABLES_OperRow < SQLM_TableReference:SQLM_TableAllocated
        GOTO EXITlocSelectStat20;
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 0
        GOTO EXITlocSelectStat20;
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLCODE=2+3 <= 8;
        GOTO EXITlocSelectStat20;
    FI;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    PROTECTEDP:TOWBLKREF = SQLM_TABLES_OperRow:SQLC_TABLES_BLKREF_Data;

    PROTECTEDP:TOWTABREF = SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data;
EXITlocSelectStat20)


!******************************************************************************!
!END SQL!



   CRETURNFROMTRHSTATRANSR = SYMDDINITFK10;        
   SEND TRHSTATRANS WITH
      PROTECTEDP, 
      COWNREF,
      ZDONOTLOG,
      +;     
   EXIT;

DDINITFK10)

   
   
!BEGIN SQL INSERT 19!
!******************************************************************************!

!EXEC SQL INSERT INTO FOREIGNKEYS
     (TROWNO,
      ORDNO,
      BLKREF,
      TABREF,
      KEYNO,
      FTROWNO,
      FTABREF,
      FBLKREF,
      COND)
   VALUES
     (%PROTECTEDP:REFERREDTROWNO,
      %PROTECTEDP:ORDNO,
      %PROTECTEDP:BLKREF,
      %PROTECTEDP:TABREF,
      %PROTECTEDP:FKNUMBER,
      %PROTECTEDP:TROWNO,
      1,
      1,
      %PROTECTEDP:DELETEACTION)!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       insertStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITinsertStat21;
    FI;
! Pack signal with required data and primary key. Then send insert
  signal to transaction handler. !
    PROTECTEDP:SQLX_SQLRETURN=2;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!

!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    SQLX_DR23 = PROTECTEDP:REFERREDTROWNO;

    SQLX_DR22 = PROTECTEDP:ORDNO;
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 7;
    SQLX_DR6 = 10;
    SQLX_DR7 = 9;
    SQLX_DR8 = 8;
    SQLX_DR9 = 7;
    SQLX_DR10 = 6;
    SQLX_DR11 = 5;
    SQLX_DR12 = 4;

    SQLX_DR13 = PROTECTEDP:BLKREF;

    SQLX_DR14 = PROTECTEDP:TABREF;

    SQLX_DR15 = PROTECTEDP:FKNUMBER;

    SQLX_DR16 = PROTECTEDP:TROWNO;

    SQLX_DR17 = 1;

    SQLX_DR18 = 1;

    SQLX_DR19 = PROTECTEDP:DELETEACTION;
    SEND trhInsRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref,
        cOwnRef,
        5,
        2                 ! primary key !
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,+
        ,+
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
trhInsRowLab2)
    IF SQLCODE /= 0 GOTO EXITinsertStat21;
! Send let field signal to transaction handler until all data is
  transferred to the table. Abort the command if any signal fails. !
! Exit !
EXITinsertStat21)


!******************************************************************************!
!END SQL!
            
   
!BEGIN SQL COMMIT 0!
!******************************************************************************!

!EXEC SQL COMMIT TRANSACTION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       commitStat      !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhComTransLab2;
    FI;
! Request to commit a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=2;
    SEND trhComTrans WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhComTransLab2)
! Close transaction !
    PROTECTEDP:SQLTRANSID=0;


!******************************************************************************!
!END SQL!
 


   CASE SQLCODE.VALUE IS
      WHEN ZROWINSERTED DO;
      
      WHEN ZSEARCHFAIL DO
         IF SQLCODE.SUBCODE = ZROWNOTALLOCATED THEN
            
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
               INTO %TTABREF, %TSAEID
               FROM TABLES
               WHERE NAME = %ZFOREIGNKEYS AND BLKREF = %COWNREF!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TableReference = 1;
! Allocate a work area, if none is found report failure. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocSelectStat23;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocSelectStat23;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow7;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow7;
!
$ We should never get here
!
    GOTO WORKFULLlocSelectStat23;
WORKALLOCATEallocateWorkRow7)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
! Save the primary key in work area. !
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data =
        ZFOREIGNKEYS;
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data =
        COWNREF;
! Find row which have the primary key as stored in the work row.!
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnref WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        3,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLM_TABLES_WorkRow,
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        2,
        +,
        17;
    EXIT;
towGetSchLab17)
! Restore some data !
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    SQLCODE=2+1 <= 8;
! check if row is found, if not report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1
        GOTO EXITlocSelectStat23;
! check if row is not read locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock>1 THEN
        SQLCODE=2+3 <= 8;
        GOTO EXITlocSelectStat23;
    FI;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    TTABREF = SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data;

    IF SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    TSAEID = SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Data;
    GOTO EXITlocSelectStat23;
WORKLOCKlocSelectStat23)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocSelectStat23;
WORKFULLlocSelectStat23)
    SQLCODE=3+8 <= 8;
EXITlocSelectStat23)


!******************************************************************************!
!END SQL!

                  
            SEND PROGERROR WITH
               ZPROGERRORCODE1,
               COWNREF,
               TTABREF,
               TSAEID;
            EXIT;
         FI;
         
      WHEN ZERROR DO
         CASE SQLCODE.SUBCODE IS
            WHEN ZTABFULL DO
               
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
                  INTO %TTABREF, %TSAEID
                  FROM TABLES
                  WHERE NAME = %ZFOREIGNKEYS AND BLKREF = %COWNREF!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TableReference = 1;
! Allocate a work area, if none is found report failure. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocSelectStat24;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocSelectStat24;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow8;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow8;
!
$ We should never get here
!
    GOTO WORKFULLlocSelectStat24;
WORKALLOCATEallocateWorkRow8)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
! Save the primary key in work area. !
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data =
        ZFOREIGNKEYS;
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data =
        COWNREF;
! Find row which have the primary key as stored in the work row.!
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnref WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        3,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLM_TABLES_WorkRow,
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        2,
        +,
        18;
    EXIT;
towGetSchLab18)
! Restore some data !
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    SQLCODE=2+1 <= 8;
! check if row is found, if not report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1
        GOTO EXITlocSelectStat24;
! check if row is not read locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock>1 THEN
        SQLCODE=2+3 <= 8;
        GOTO EXITlocSelectStat24;
    FI;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    TTABREF = SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data;

    IF SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    TSAEID = SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Data;
    GOTO EXITlocSelectStat24;
WORKLOCKlocSelectStat24)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocSelectStat24;
WORKFULLlocSelectStat24)
    SQLCODE=3+8 <= 8;
EXITlocSelectStat24)


!******************************************************************************!
!END SQL!

                  
               SEND PROGERROR WITH
                  ZPROGERRORCODE1,
                  COWNREF,
                  TTABREF,
                  TSAEID;
               EXIT;
               
            WHEN ZTRHCONG DO
               SEND PROGERROR WITH
                  ZPROGERRORCODE4,
                  ZTRHSAEID2;
               EXIT;

            OTHERWISE DO;
         ESAC;
         
      OTHERWISE DO;
   ESAC;

   
SEND DDINITFKR REFERENCE PROTECTEDP:REF WITH
   PROTECTEDP:USERP;
   

!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDORDNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_EXTENSIVETABS_Cursor=0;
    IF PROTECTEDP:SQLM_FINDFK_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDORDNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDFK_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDORDNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEWTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDORDNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDORDNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDORDNO_Cursor=0;
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDORDNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDTROWNO_Cursor=0;
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDORDNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor=0;
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDORDNO_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETTROWNO_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=2;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab2)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!


EXIT;










!*****************************************************************************!
!*                                                                           *! 
!*             D D I N I T T A B L E                                         *!
!*                                                                           *!
!*****************************************************************************!




! A TABLE OWNER ASKS DD TO INITIATE A SPECIFIC TABLE I.E. TO      !
! INSERT THE TABLE DEFINITION IN THE TABLES TABLE. DDINTERFACE    !
! RECEIVES THE SIGNAL DDINITTABLE, STORES THE DATA IN THE         !
! PROTECTION FILE, AND SIMPLY FORWARDS THE PROTECTEDP POINTER TO   !
! SYSTEMTABLES BY SENDING THE SIGNAL SYSINITTAB.                  !

! INDATA:           NONE                                          !

! OUTDATA:          NONE                                          !


ENTER DDINITTABLE WITH
   TUSERP,
   TTOWBLKREF,
   TTOWTABREF,
   CTABNAME,
   TREADAUTHCAT,
   TWRITEAUTHCAT,
   TLOCATION;


!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat26;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat26;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat26;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat26;
PROTECTEDALLOCATEDbeginStat26)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat26)
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!


PROTECTEDP:USERP=TUSERP;
PROTECTEDP:REF=TTOWBLKREF;
PROTECTEDP:TOWBLKREF=TTOWBLKREF;
PROTECTEDP:TOWTABREF=TTOWTABREF;
PROTECTEDP:TABNAME=CTABNAME;
PROTECTEDP:RAUTHCAT=TREADAUTHCAT;
PROTECTEDP:WAUTHCAT=TWRITEAUTHCAT;
PROTECTEDP:LOCATION=TLOCATION;


! THIS ROUTINE RECEIVES THE SIGNAL SYSINITTAB FROM THE DD INTER-  !
! FACE MODULE. THE OBJECTIVE IS TO INSERT A NEW ROW INTO THE      !
! TABLES TABLE, AND THUS TO DEFINE A NEW USER TABLE. HOWEVER      !
! PROBLEMS MAY ARISE AND THE SIGNAL PROGERROR MAY BE SENT IN THE  !
! FOLLOWING SITUATIONS:                                           !
! A. THE NAME OF THE TABLE WHICH REQUESTS TO BE DEFINED MAY       !
!    ALREADY BE OCCUPIED. IF THE LOCATION OF THE TABLE IS SINGLE, !
!    THE NAME MAY NOT OCCUR IN ANY OTHER BLOCK. IF THE LOCATION   !
!    OF THE TABLE IS MULTIPLE, A TABLE WITH THE SAME NAME MAY NOT !
!    APPEAR IN THE SAME BLOCK. HOWEVER, SUCH A FAULT WILL NOT     !
!    PASS THE PLEX-SQL PREPROCESSOR, AND THEREFORE NO CHECKS ARE  !
!    MADE ON MULTIPLE TABLES.                                     !
! B. IF THE ENTIRE ALLOCATED SIZE OF THE TABLE ALREADY IS USED,   !
!    THAT IS, THE TABLES TABLE IS ALREADY FULL, THE NEW TABLE     !
!    DEFINITION WILL NOT BE INCLUDED AND PROGERROR WILL BE SENT.  !
! THE SIGNAL PROGERROR WILL, IF IT IS SENT, CAUSE A RESTART,      !
! WHICH IMPLIES THAT THE OLD SYSTEM WILL BECOME EXECUTIVE.        ! 


! THE ROUTINE WILL ALWAYS END BY RETURNING THE SIGNAL SYSINITTABR !
! TO THE DD INTERFACE MODULE.                                     !

! INDATA:       CNEXTTROWNO          NEXT AVAILABLE ROWNUMBER IN !
!                                    TABLES.                     !

! OUTDATA:      CNEXTTROWNO          NEXT AVAILABLE ROWNUMBER IN !
!                                    TABLES (UPDATED).           !

! NORMAL ACTION: INSERT INDATA INTO THE TABLES TABLE.             !

! ALTERNATIVE ACTION: CAUSE A NEW RESTART BY SENDING PROGERROR.   !







   PROTECTEDP:TROWNO=CNEXTTROWNO;
   CNEXTTROWNO=CNEXTTROWNO+1;
      
          
   IF PROTECTEDP:LOCATION = TABLESLOCATEMULTI THEN      
      GOTO DDINITTABLE10;
   FI;
 
 
   
                                            ! BEGIN CHECK OF CASE A  !

   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN EXTENSIVETABS!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locOpenStat     !
!--------------------------------------!
! Check if cursor already is opened, if so report failure. !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITlocOpenStat27;
    FI;
! Check that the work area is locked, if so report failure !
    SQLM_TableReference=1;
    IF SQLM_TableReference:SQLM_WorkLock /= 0 THEN
        SQLCODE=3+18 <= 8;
        GOTO EXITlocOpenStat27;
    FI;
! Allocate work row, report if the allocate fails. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocOpenStat27;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocOpenStat27;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow9;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow9;
!
$ We should never get here
!
    GOTO WORKFULLlocOpenStat27;
WORKALLOCATEallocateWorkRow9)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data=TABNAME;
! If the cursor is a btree store 0 in cLastRow if the key operation is
  PREVIOUS otherwise the highest row number (65535 if 16 bit address)
  is stored in cLastRow (key operation THIS or THIS OR PREVIOUS). !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=65535;
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_EXTENSIVETABS_Cursor=SQLM_TABLES_WorkRow;
    SQLCODE=0;
    GOTO EXITlocOpenStat27;
WORKLOCKlocOpenStat27)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocOpenStat27;
WORKFULLlocOpenStat27)
    SQLCODE=3+8 <= 8;
EXITlocOpenStat27)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH EXTENSIVETABS INTO %PROTECTEDP:SAMENAME!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locFetchStat!
!--------------------------------------!
! Check if cursor is open, if not report failure !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITlocFetchStat28;
    FI;
! Find an operating row !
    SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_EXTENSIVETABS_Cursor;
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        3,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
,
        0,
        1,
        SQLM_TableReference:SQLM_System+1,   ! pNilRow !
        19;
    EXIT;
towGetSchLab19)
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! check if row is not found, if so report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat28;
    FI;
! check if row is locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+3 <= 8;
        GOTO EXITlocFetchStat28;
    FI;
! update cursor !
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data=
        SQLM_TABLES_OperRow:SQLC_TABLES_NAME_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=
        SQLM_TABLES_OperRow;
    SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2=
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2;
! Do additional tests, if the fails try another row. !
! Everything is allright, copy columns into variables. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    PROTECTEDP:SAMENAME = SQLM_TABLES_OperRow;
! Set cursor to indicate that a row was found and return success !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=0;
    SQLCODE=0;
EXITlocFetchStat28)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!   
      
   CASE SQLCODE.VALUE IS
      WHEN ZNAMEALREADYEXISTS DO
            
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT BLKREF
               INTO %TBLKREF
               FROM TABLES
               WHERE TROWNO = %PROTECTEDP.SAMENAME!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
      !row access !
    SQLM_TABLES_OperRow=PROTECTEDP.SAMENAME;
    SQLM_TableReference=1;
    SQLCODE=2+1 <= 8;
    IF NOT SQLM_TABLES_OperRow < SQLM_TableReference:SQLM_TableAllocated
        GOTO EXITlocSelectStat29;
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 0
        GOTO EXITlocSelectStat29;
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLCODE=2+3 <= 8;
        GOTO EXITlocSelectStat29;
    FI;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    TBLKREF = SQLM_TABLES_OperRow:SQLC_TABLES_BLKREF_Data;
EXITlocSelectStat29)


!******************************************************************************!
!END SQL!

            
            SEND PROGERROR WITH
               ZPROGERRORCODE2,
               PROTECTEDP:TOWBLKREF,
               PROTECTEDP:TOWTABREF,
               TBLKREF;
               
            EXIT;
            
      WHEN ZSEARCHFAIL DO;
      
      OTHERWISE DO;
   ESAC;
  
   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE EXTENSIVETABS!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locCloseStat    !
!--------------------------------------!
    IF  PROTECTEDP:SQLM_EXTENSIVETABS_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
    ELSE
! Close cursor. !
      SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_EXTENSIVETABS_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
      SQLCODE=0;
    FI;


!******************************************************************************!
!END SQL!

                                         ! END CHECK OF CASE A    !







DDINITTABLE10)
                                
   CRETURNFROMTRHSTATRANSR = SYMDDINITTABLE20;        
   SEND TRHSTATRANS WITH
      PROTECTEDP,            ! OWN POINTER !
      COWNREF,
      ZDONOTLOG,
      +;     
   EXIT;

DDINITTABLE20)

   
!BEGIN SQL INSERT 25!
!******************************************************************************!

!EXEC SQL INSERT INTO TABLES
        (TROWNO,
         BLKREF,
         TABREF,
         NAME,
         ALLOCST,
         USEDST,
	 ALLOCSW,
	 USEDSW,
         RAUCAT,
         WAUCAT,
         LOCATE,
	 NOFLTCO)
      VALUES   
        (%PROTECTEDP:TROWNO,
         %PROTECTEDP:TOWBLKREF,
         %PROTECTEDP:TOWTABREF,
         %PROTECTEDP:TABNAME,
	 1,
	 1,
	 1,
	 1,
         %PROTECTEDP:RAUTHCAT,
         %PROTECTEDP:WAUTHCAT,
         %PROTECTEDP:LOCATION,
	 1)!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       insertStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITinsertStat31;
    FI;
! Pack signal with required data and primary key. Then send insert
  signal to transaction handler. !
    PROTECTEDP:SQLX_SQLRETURN=3;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!










!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!
    SQLX_DR23 = TROWNO;
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 3;
    SQLX_DR6 = 4;
    SQLX_DR7 = 3;
    SQLX_DR8 = 2;

    DO SQLS_Pack2;  ! pack string into signal registers !

    SQLX_DR17 = PROTECTEDP:TOWBLKREF;

    SQLX_DR18 = PROTECTEDP:TOWTABREF;
    SEND trhInsRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref,
        cOwnRef,
        1,
        2                 ! primary key !
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR23
        ;
    EXIT;
trhInsRowLab3)
    IF SQLCODE /= 0 GOTO EXITinsertStat31;
! Send let field signal to transaction handler until all data is
  transferred to the table. Abort the command if any signal fails. !
    PROTECTEDP:SQLX_SQLRETURN=2;
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 8;
    SQLX_DR6 = 20;
    SQLX_DR7 = 19;
    SQLX_DR8 = 18;
    SQLX_DR9 = 17;
    SQLX_DR10 = 15;
    SQLX_DR11 = 14;
    SQLX_DR12 = 10;
    SQLX_DR13 = 9;

    SQLX_DR14 = 1;

    SQLX_DR15 = 1;

    SQLX_DR16 = 1;

    SQLX_DR17 = 1;

    SQLX_DR18 = PROTECTEDP:RAUTHCAT;

    SQLX_DR19 = PROTECTEDP:WAUTHCAT;

    SQLX_DR20 = PROTECTEDP:LOCATION;

    SQLX_DR21 = 1;
    SEND trhLetFld WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref,
        +,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,+
        ,+
        ;
    EXIT;
trhLetFldLab2)
    IF SQLCODE /= 0 GOTO EXITinsertStat31;
! Exit !
EXITinsertStat31)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL COMMIT 0!
!******************************************************************************!

!EXEC SQL COMMIT TRANSACTION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       commitStat      !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhComTransLab3;
    FI;
! Request to commit a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=3;
    SEND trhComTrans WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhComTransLab3)
! Close transaction !
    PROTECTEDP:SQLTRANSID=0;


!******************************************************************************!
!END SQL!



                                         ! BEGIN CHECK OF CASE B  !
   
   CASE SQLCODE.VALUE IS
      WHEN ZROWINSERTED DO;
      
      WHEN ZSEARCHFAIL DO
         IF SQLCODE.SUBCODE = ZROWNOTALLOCATED THEN
            
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
                INTO %TTABREF, %TSAEID
                FROM TABLES
               WHERE NAME = %ZTABLES AND BLKREF = %COWNREF!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TableReference = 1;
! Allocate a work area, if none is found report failure. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocSelectStat33;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocSelectStat33;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow10;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow10;
!
$ We should never get here
!
    GOTO WORKFULLlocSelectStat33;
WORKALLOCATEallocateWorkRow10)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
! Save the primary key in work area. !
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data =
        ZTABLES;
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data =
        COWNREF;
! Find row which have the primary key as stored in the work row.!
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnref WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        3,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLM_TABLES_WorkRow,
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        2,
        +,
        20;
    EXIT;
towGetSchLab20)
! Restore some data !
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    SQLCODE=2+1 <= 8;
! check if row is found, if not report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1
        GOTO EXITlocSelectStat33;
! check if row is not read locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock>1 THEN
        SQLCODE=2+3 <= 8;
        GOTO EXITlocSelectStat33;
    FI;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    TTABREF = SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data;

    IF SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    TSAEID = SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Data;
    GOTO EXITlocSelectStat33;
WORKLOCKlocSelectStat33)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocSelectStat33;
WORKFULLlocSelectStat33)
    SQLCODE=3+8 <= 8;
EXITlocSelectStat33)


!******************************************************************************!
!END SQL!

                  
            SEND PROGERROR WITH
               ZPROGERRORCODE1,
               COWNREF,
               TTABREF,
               TSAEID;
            EXIT;
         FI;
         
      WHEN ZERROR DO
         CASE SQLCODE.SUBCODE IS
            WHEN ZTABFULL DO
               
!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT TABREF, SAEIDT
                  INTO %TTABREF, %TSAEID
                  FROM TABLES
                  WHERE NAME = %ZTABLES AND BLKREF = %COWNREF!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TableReference = 1;
! Allocate a work area, if none is found report failure. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocSelectStat34;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocSelectStat34;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow11;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow11;
!
$ We should never get here
!
    GOTO WORKFULLlocSelectStat34;
WORKALLOCATEallocateWorkRow11)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
! Save the primary key in work area. !
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data =
        ZTABLES;
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data =
        COWNREF;
! Find row which have the primary key as stored in the work row.!
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnref WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        3,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLM_TABLES_WorkRow,
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        2,
        +,
        21;
    EXIT;
towGetSchLab21)
! Restore some data !
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    SQLCODE=2+1 <= 8;
! check if row is found, if not report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1
        GOTO EXITlocSelectStat34;
! check if row is not read locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock>1 THEN
        SQLCODE=2+3 <= 8;
        GOTO EXITlocSelectStat34;
    FI;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    TTABREF = SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data;

    IF SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    TSAEID = SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Data;
    GOTO EXITlocSelectStat34;
WORKLOCKlocSelectStat34)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocSelectStat34;
WORKFULLlocSelectStat34)
    SQLCODE=3+8 <= 8;
EXITlocSelectStat34)


!******************************************************************************!
!END SQL!

                  
               SEND PROGERROR WITH
                  ZPROGERRORCODE1,
                  COWNREF,
                  TTABREF,
                  TSAEID;
               EXIT;
               
            WHEN ZTRHCONG DO
               SEND PROGERROR WITH
                  ZPROGERRORCODE4,
                  ZTRHSAEID2;
               EXIT;

            OTHERWISE DO;
         ESAC;
         
      OTHERWISE DO;
   ESAC;
                                         ! END CHECK OF CASE B    !

   
   
SEND DDINITTABLER REFERENCE PROTECTEDP:REF WITH
   PROTECTEDP:USERP;
   

!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_EXTENSIVETABS_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_EXTENSIVETABS_Cursor=0;
    IF PROTECTEDP:SQLM_FINDFK_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_EXTENSIVETABS_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDFK_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_EXTENSIVETABS_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEWTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_EXTENSIVETABS_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_EXTENSIVETABS_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDORDNO_Cursor=0;
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_EXTENSIVETABS_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDTROWNO_Cursor=0;
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_EXTENSIVETABS_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor=0;
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_EXTENSIVETABS_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETTROWNO_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=3;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab3)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!

   
EXIT;














!*****************************************************************************!
!*                                                                           *! 
!*             D D H G E T N X T F K                                         *!
!*                                                                           *!
!*****************************************************************************!





! THE SIGNAL DDHGETNEXTFK IS A REQUEST FROM THE DBS TRANSACTION   !
! HANDLER TO SUPPLY IT WITH THE NEXT FOREIGN KEY, THAT REFERS TO  !
! A SPECIFIC TABLE. IF IT IS THE FIRST REQUEST FOR A FOREIGN KEY  !
! TO A SPECIFIC TABLE, THE CURSOR FINDFK IS OPENED. IT IS KEPT    !
! OPEN UNTIL NO MORE FK'S REFERRING TO THE CURRENT TABLE IS FOUND.!
! BETWEEN REQUESTS FOR FOREIGN KEYS TO THE SAME TABLE, THE OPEN   !
! CURSOR IS STORED IN THE PROTECTION FILE.                        !

! INSIGNAL:        DDHGETNEXTFK                                   !
! OUTSIGNAL:       DDHGETNEXTFKR                                  !

   ENTER DDHGETNXTFK WITH
      TTRID,
      PROTECTEDP,
      TTOWBLKREF,
      TTOWTABREF,
      CREFERRINGFKORDNO;
   



   IF CREFERRINGFKORDNO=ZFIRSTFK THEN
      
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat36;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat36;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat36;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat36;
PROTECTEDALLOCATEDbeginStat36)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat36)
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!

      PROTECTEDP:TRANSID=TTRID;
      PROTECTEDP:TOWBLKREF=TTOWBLKREF;
      PROTECTEDP:TOWTABREF=TTOWTABREF;
      
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN FINDFK!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locOpenStat     !
!--------------------------------------!
! Check if cursor already is opened, if so report failure. !
    IF PROTECTEDP:SQLM_FINDFK_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITlocOpenStat37;
    FI;
! Check that the work area is locked, if so report failure !
    SQLM_TableReference=5;
    IF SQLM_TableReference:SQLM_WorkLock /= 0 THEN
        SQLCODE=3+18 <= 8;
        GOTO EXITlocOpenStat37;
    FI;
! Allocate work row, report if the allocate fails. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocOpenStat37;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocOpenStat37;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow12;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow12;
!
$ We should never get here
!
    GOTO WORKFULLlocOpenStat37;
WORKALLOCATEallocateWorkRow12)
    IF SQLM_FOREIGNKEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FOREIGNKEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=2;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_ORDNO_Data=CREFERRINGFKORDNO;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_BLKREF_Data=TOWBLKREF;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_TABREF_Data=TOWTABREF;
! If the cursor is a btree store 0 in cLastRow if the key operation is
  PREVIOUS otherwise the highest row number (65535 if 16 bit address)
  is stored in cLastRow (key operation THIS or THIS OR PREVIOUS). !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2=65535;
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_FINDFK_Cursor=SQLM_FOREIGNKEYS_WorkRow;
    SQLCODE=0;
    GOTO EXITlocOpenStat37;
WORKLOCKlocOpenStat37)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocOpenStat37;
WORKFULLlocOpenStat37)
    SQLCODE=3+8 <= 8;
EXITlocOpenStat37)


!******************************************************************************!
!END SQL!

   FI;         


DDHGETNXTFK10)
   
   
!BEGIN SQL FETCH 5!
!******************************************************************************!

!EXEC SQL FETCH FINDFK INTO
      %PROTECTEDP:ORDNO,
      %PROTECTEDP:FBLKREF,
      %PROTECTEDP:FTABREF,
      %PROTECTEDP:KEYNO,
      %PROTECTEDP:CONDITION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locFetchStat!
!--------------------------------------!
! Check if cursor is open, if not report failure !
    IF PROTECTEDP:SQLM_FINDFK_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITlocFetchStat38;
    FI;
! Find an operating row !
    SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDFK_Cursor;
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        3,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right3,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
,
        0,
        3,
        SQLM_TableReference:SQLM_System+1,   ! pNilRow !
        22;
    EXIT;
towGetSchLab22)
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
! check if row is not found, if so report failure !
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=2;
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat38;
    FI;
! check if row is locked, if so report failure !
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=2;
        SQLCODE=2+3 <= 8;
        GOTO EXITlocFetchStat38;
    FI;
! update cursor !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_TABREF_Data=
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_TABREF_Data;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2=
        SQLM_FOREIGNKEYS_OperRow;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_DBnumber2=
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2;
! Do additional tests, if the fails try another row. !
! Everything is allright, copy columns into variables. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    PROTECTEDP:ORDNO = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_ORDNO_Data;

    PROTECTEDP:FBLKREF = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_FBLKREF_Data;

    PROTECTEDP:FTABREF = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_FTABREF_Data;

    PROTECTEDP:KEYNO = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_KEYNO_Data;

    PROTECTEDP:CONDITION = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_COND_Data;
! Set cursor to indicate that a row was found and return success !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=0;
    SQLCODE=0;
EXITlocFetchStat38)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!   

   CASE SQLCODE.VALUE IS
      WHEN ZOK DO
         SEND DDHGETNXTFKR WITH
            PROTECTEDP:TRANSID,
            ZFKFOUND,
            PROTECTEDP,
            PROTECTEDP:ORDNO,
            PROTECTEDP:FBLKREF,
            PROTECTEDP:FTABREF,
            PROTECTEDP:KEYNO,
            PROTECTEDP:CONDITION;
            
      WHEN ZSEARCHFAIL DO
         SEND DDHGETNXTFKR WITH
            PROTECTEDP:TRANSID,
            ZFKNOTFOUND,
            +,
            +,
            +,
            +,
            +;
         
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE FINDFK!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locCloseStat    !
!--------------------------------------!
    IF  PROTECTEDP:SQLM_FINDFK_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
    ELSE
! Close cursor. !
      SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDFK_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
      SQLCODE=0;
    FI;


!******************************************************************************!
!END SQL!

         
!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDFK_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_EXTENSIVETABS_Cursor=0;
    IF PROTECTEDP:SQLM_FINDFK_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDFK_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDFK_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDFK_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEWTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDFK_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDFK_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDORDNO_Cursor=0;
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDFK_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDTROWNO_Cursor=0;
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDFK_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor=0;
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDFK_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETTROWNO_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=4;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab4)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!

      
      WHEN ZERROR DO
         IF SQLCODE.SUBCODE = ZTABCONGESTION THEN
!            EXEC SQL DELAY 100 MS!
            GOTO DDHGETNXTFK10;
         FI;
            
      OTHERWISE DO;
   ESAC;
       
EXIT;                         
   










!*****************************************************************************!
!*                                                                           *! 
!*             D D H G E T R E F                                             *!
!*                                                                           *!
!*****************************************************************************!


! THE DBS TRANSACTION HANDLER ASKS FOR THE BLOCK REFERENCE TO     !
! THIS BLOCK.                                                     !
 
 
   RECEIVE DDHGETREF;
   
   LOADREF TOWNREF;
   
   RETURN DDHGETREFACK WITH
      TOWNREF;
 
   
















 



         
















!*****************************************************************************!
!*                                                                           *! 
!*             D D T A B R E F                                               *!
!*                                                                           *!
!*****************************************************************************!



   ENTER DDTABREF WITH
      TUSERP,
      TBLKREF,
      CTABNAME;
      
   
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat41;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat41;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat41;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat41;
PROTECTEDALLOCATEDbeginStat41)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat41)
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!

   
   PROTECTEDP:USERP=TUSERP;
   PROTECTEDP:REF=TBLKREF;
   PROTECTEDP:TABNAME=CTABNAME;
   
   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN GETBLOCKANDTABREF!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locOpenStat     !
!--------------------------------------!
! Check if cursor already is opened, if so report failure. !
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITlocOpenStat42;
    FI;
! Check that the work area is locked, if so report failure !
    SQLM_TableReference=1;
    IF SQLM_TableReference:SQLM_WorkLock /= 0 THEN
        SQLCODE=3+18 <= 8;
        GOTO EXITlocOpenStat42;
    FI;
! Allocate work row, report if the allocate fails. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocOpenStat42;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocOpenStat42;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow13;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow13;
!
$ We should never get here
!
    GOTO WORKFULLlocOpenStat42;
WORKALLOCATEallocateWorkRow13)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data=TABNAME;
! If the cursor is a btree store 0 in cLastRow if the key operation is
  PREVIOUS otherwise the highest row number (65535 if 16 bit address)
  is stored in cLastRow (key operation THIS or THIS OR PREVIOUS). !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=65535;
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor=SQLM_TABLES_WorkRow;
    SQLCODE=0;
    GOTO EXITlocOpenStat42;
WORKLOCKlocOpenStat42)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocOpenStat42;
WORKFULLlocOpenStat42)
    SQLCODE=3+8 <= 8;
EXITlocOpenStat42)


!******************************************************************************!
!END SQL!


DDTABREF10)

   
!BEGIN SQL FETCH 1!
!******************************************************************************!

!EXEC SQL FETCH GETBLOCKANDTABREF 
      INTO %PROTECTEDP:BLKREF, %PROTECTEDP:TABREF!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locFetchStat!
!--------------------------------------!
! Check if cursor is open, if not report failure !
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITlocFetchStat43;
    FI;
! Find an operating row !
    SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor;
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        3,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
,
        0,
        1,
        SQLM_TableReference:SQLM_System+1,   ! pNilRow !
        23;
    EXIT;
towGetSchLab23)
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! check if row is not found, if so report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat43;
    FI;
! check if row is locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+3 <= 8;
        GOTO EXITlocFetchStat43;
    FI;
! update cursor !
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data=
        SQLM_TABLES_OperRow:SQLC_TABLES_NAME_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=
        SQLM_TABLES_OperRow;
    SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2=
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2;
! Do additional tests, if the fails try another row. !
! Everything is allright, copy columns into variables. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    PROTECTEDP:BLKREF = SQLM_TABLES_OperRow:SQLC_TABLES_BLKREF_Data;

    PROTECTEDP:TABREF = SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data;
! Set cursor to indicate that a row was found and return success !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=0;
    SQLCODE=0;
EXITlocFetchStat43)


!******************************************************************************!
!END SQL!

      
   CASE SQLCODE.VALUE IS
      WHEN ZTABLEFOUND DO
         SEND DDTABREFR REFERENCE PROTECTEDP:REF WITH
            PROTECTEDP:USERP,
            ZOK,
            PROTECTEDP:BLKREF,
            PROTECTEDP:TABREF;
            
      WHEN ZSEARCHFAIL DO
         SEND DDTABREFR REFERENCE PROTECTEDP:REF WITH
            PROTECTEDP:USERP,
            ZNOTABFOUNDFLAG,
            +,
            +;
            
      WHEN ZERROR DO
         IF SQLCODE.SUBCODE = ZTABCONGESTION THEN
!            EXEC SQL DELAY 100 MS!
            GOTO DDTABREF10;
         FI;
         
      OTHERWISE DO;
   ESAC;
   
   
!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_EXTENSIVETABS_Cursor=0;
    IF PROTECTEDP:SQLM_FINDFK_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDFK_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEWTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDORDNO_Cursor=0;
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDTROWNO_Cursor=0;
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor=0;
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETTROWNO_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=5;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab5)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!

   EXIT;

      


!*****************************************************************************!
!*                                                                           *! 
!*             E V E N T M E S S A G E C                                     *!
!*                                                                           *!
!*****************************************************************************!




! EVENTMESSAGEC TELLS WHETHER OR NOT THE RECENT SYSTEM RESTART IS !
! DUE TO A FUNCTION CHANGE (FC) OR NOT. IN CASE OF A SMALL        !
! RESTART, THIS SIGNAL HAS TO BE ENTERED BEFORE ZSPH2DBDDH.       !

! OUTDATA:       CFC             INDICATES IF FC HAS OCCURRED     !

ENTER EVENTMESSAGEC WITH  
   TSTATEID,
   +,                                           
   +,
   +, 
   +,
   +,
   TFCIND;
   

IF TSTATEID = ZSYSTEMRESTART THEN
   IF TFCIND = ZFUNCTIONCHANGE THEN
      CFC=TRUE;
   FI;
FI;                      

EXIT;








!*****************************************************************************!
!*                                                                           *! 
!*             S T T O R                                                     *!
!*                                                                           *!
!*****************************************************************************!





! THIS ROUTINE WILL BE RUN ONCE IN EACH RESTART PHASE. THE SIGNAL !
! STTOR, WHICH INFORMS ABOUT THE CURRENT RESTART PHASE NUMBER, IS !
! ENTERED, THE APPROPRIATE ACTION IS PERFORMED, AND THE SIGNAL    !
! STTORRY IS RETURNED AS A RECEIPT THAT THE CURRENT RESTART PHASE !
! IS TAKEN CARE OF BY THIS BLOCK.                                 !

! OUTDATA:       CRESTCASE                      RESTART CASE      !
!                CRETURNFROMWHICHRESTCASE                         !

! POSSIBLE SUBROUTINECALLS:    EVENTREQ                           !
!                              WHICHRESTCASE                      !

   ENTER STTOR WITH 
      CRESTCASE,
      CPHASE,
      +,
      +,
      +,
      +,                      ! RESTART RANK !
      CSIGKEY;
!BEGIN SQL ENTER 0!
!******************************************************************************!


!------------------------------------------------!
!       comSttor !
!------------------------------------------------!
! Enter restart phase 1 !
    IF CPHASE = 1 THEN
! Load the block reference of the table owning/using block !
        LOADREF SQLX_TempRow;
        cOwnRef = SQLX_TempRow;
        TRANSFORM BLOCKREF IN TEMP SQLX_TempRow TO BLOCKNUMBER IN TEMP SQLX_TempRow;
! Inform the system that the block contains a table owner and/or table user. !
        SEND STOREFUCODE WITH
            +,
            SQLX_TempRow,
            2,
            135,
            162,
        WAIT FOR STOREFUCODEACK IN RESTART;
RESTART)RETRIEVE STOREFUCODEACK;
    FI;


!******************************************************************************!
!END SQL!

             
   CASE CPHASE IS
      WHEN ZSPH1DBDDH DO DO EVENTREQ;
      WHEN ZSPH2DBDDH DO 
         CRETURNFROMWHICHRESTCASE=SYMSTTOR10;
         GOTO WHICHRESTCASE;
      WHEN ZSPH3DBDDH DO
         CRETURNFROMTRIGTOWINITIATION=SYMSTTOR10;
         CLOCALRESTARTPHASE = ZDBSINTERNALPHASE1;
         GOTO TRIGTOWINITIATION;
      WHEN ZSPH4DBDDH DO
         CRETURNFROMTRIGTOWINITIATION=SYMSTTOR10;
         CLOCALRESTARTPHASE = ZDBSINTERNALPHASE2;
         GOTO TRIGTOWINITIATION;
      WHEN ZSPH5DBDDH DO
         CRETURNFROMTRIGTOWINITIATION=SYMSTTOR10;
         CLOCALRESTARTPHASE = ZDBSINTERNALPHASE3;
         GOTO TRIGTOWINITIATION;
      WHEN ZSPH6DBDDH DO
         CRETURNFROMTRIGTOWINITIATION=SYMSTTOR10;
         CLOCALRESTARTPHASE = ZDBSINTERNALPHASE4;
         GOTO TRIGTOWINITIATION;
      OTHERWISE DO;
   ESAC;
          
STTOR10)
   SEND STTORRY WITH
      CSIGKEY,                ! RETURN DATA !
      ZBLOCKCAT, 
      ZSTTORRYVERSION,
      ZSPH1DBDDH,             ! WANTED RESTARTPHASE 1 !
      ZSPH2DBDDH,             ! WANTED RESTARTPHASE 2 !
      ZSPH3DBDDH,
      ZSPH4DBDDH,
      ZSPH5DBDDH,
      ZSPH6DBDDH,
      ZNOMOREPHASES;
             
   EXIT; 









!*****************************************************************************!
!*                                                                           *! 
!*             T O W R E S P A R T R                                         *!
!*                                                                           *!
!*****************************************************************************!



   ENTER TOWRESPARTR WITH
      PROTECTEDP,
      +;
      
   GOTO TRIGTOWINITIATIONS10;
   


   
   
   



!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!
!*                                                                           *! 
!*             S U B R O U T I N E S   I N   P L E X                         *!
!*                                                                           *!
!*****************************************************************************!
!*****************************************************************************!
!*****************************************************************************!






!*****************************************************************************!
!*                                                                           *! 
!*             C H E C K S Y M V A L N A M E L E N G T H                     *!
!*                                                                           *!
!*****************************************************************************!




CHECKSYMVALNAMELENGTH)

   PROTECTEDP:MAXSYMLENGTH=0;
   PROTECTEDP:SYMBOLVALUE=ZMAXSYMVAL;
   PROTECTEDP:SYMBOLFOUND=TRUE; 
   
   IF PROTECTEDP:NAMELENGTH = 7 THEN
      PROTECTEDP:PRWIDTH= PROTECTEDP:NAMELENGTH;
      GOTO CHECKSYMVALNAMELENGTH30;
   FI;        
      
CHECKSYMVALNAMELENGTH10)                                   ! BEGIN LOOP !

   IF PROTECTEDP:SYMBOLFOUND = FALSE THEN
      IF PROTECTEDP:MAXSYMLENGTH  > PROTECTEDP:NAMELENGTH THEN
         PROTECTEDP:PRWIDTH=PROTECTEDP:MAXSYMLENGTH;
      ELSE
         PROTECTEDP:PRWIDTH=PROTECTEDP:NAMELENGTH;
      FI;      
      GOTO CHECKSYMVALNAMELENGTH30;
   FI;
      
   SEND TOWPRESYMBOL REFERENCE PROTECTEDP:REF WITH
      PROTECTEDP,
      PROTECTEDP:TOWTABREF,
      PROTECTEDP:FLDNUMBER, 
      PROTECTEDP:SYMBOLVALUE,
   WAIT FOR TOWPRESYMBOLACK IN CHECKSYMVALNAMELENGTH20;   
         
CHECKSYMVALNAMELENGTH20)
   RETRIEVE TOWPRESYMBOLACK WITH
      PROTECTEDP,
      TRETURNCODE,
      PROTECTEDP:SYMBOLVALUE,
      CSYMBOLNAME;
   
   
         
   IF TRETURNCODE = ZSYMBOLFOUND THEN
      CHAR VX:CSYMBOLNAME(N:0) TO VT:TSYMLENGTH;
      IF TSYMLENGTH > PROTECTEDP:MAXSYMLENGTH THEN
         PROTECTEDP:MAXSYMLENGTH=TSYMLENGTH;
      FI;
      PROTECTEDP:SYMBOLVALUE=PROTECTEDP:SYMBOLVALUE-1;
   ELSE
      PROTECTEDP:SYMBOLFOUND=FALSE;   
   FI;
      
   GOTO CHECKSYMVALNAMELENGTH10;                       ! END LOOP !

       
CHECKSYMVALNAMELENGTH30)

   BRANCH ON CRETURNFROMCHECKSYMVALNAMELENGTH
      TO DDINITFIELD10 IF SYMDDINITFIELD10
      ELSE TO DDINITFIELD10;       



















!*****************************************************************************!
!*                                                                           *! 
!*             C L E A R A L L T A B S                                       *!
!*                                                                           *!
!*****************************************************************************!




! THIS ROUTINE TAKES CARE OF THE CASES 'SYSTEM START', 'LARGE     !
! RESTART' AND 'LARGE RESTART WITH RELOAD'. THE OBJECTIVE IS TO   !
! DELETE ALL ROWS IN ALL TABLES IN DATA DICTIONARY. BY DELETING   !
! THE ENTIRE TABLES TABLE, ALL OTHERTABLES WILL BE DELETED DUE TO !
! THE FOREIGN KEY CONDITIONS.                                     !

! THE ROUTINE WORKS AS FOLLOWS. THE CURSOR FINDNEWTABLE IS OPENED !
! AND FETCHED. IF THE TABLES TABLE IS EMPTY, THE FLAG CALLTABS-   !
! CLEARED WILL BE SET TO TRUE AND VIA JUMPS TO CLEARALLTABS10 AND !
! -40 THE ROUTINE WILL BE ENDED.                                  !

! HOWEVER, IF THERE ARE MORE ROWS IN TABLES TO DELETE, A TRANS-   !
! ACTION WILL BE STARTED BY THE SIGNAL TRHSTATRANS. THE REASON    !
! FOR USING THE SIGNAL AND NOT THE START TRANSACTION INSTRUCTION  !
! IS THAT THE TRANSACTION SHOULD NOT BE LOGGED. THE DELETE IS     !
! PERFORMED AND THE PROGRAM EXECUTION CONTINUES AT CLEARALLTABS20 !

! IN THE CASE 'LARGE RESTART', PROBLEMS MAY OCCUR IN THE TRANS-   !
! ACTION HANDLER. THERE MAY BE A LINE OF TRANSACTIONS IN THE      !
! COMMIT PHASE STEMMING FROM BEFORE THE RESTART, WHICH ARE WAITING!
! TO BE COMMITTED. IF THESE TRANSACTIONS OCCUPY ALL TRANSACTION   !
! INDIVIDUALS, SQLCODE WILL REPORT TRH CONGESTION AND THE SIGNAL  !
! PROGERROR WILL BE SENT BECAUSE THE SYSTEM WILL NOT BE ABLE TO   !
! ADVANCE ANY FURTHER IN THE RESTART PROCEDURE.                   !

! INDATA:        NONE                                             !

! OUTDATA:       NONE                                             !

! RESULT:        ALL TABLES THAT ARE PHYSICALLY STORED IN DD ARE  !
!                DELETED.                                         !

CLEARALLTABS)

   
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat45;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat45;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat45;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat45;
PROTECTEDALLOCATEDbeginStat45)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat45)
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!
         
   CALLTABSCLEARED = FALSE;
   
CLEARALLTABS10)

   IF CALLTABSCLEARED = TRUE THEN          ! BEGIN LOOP !
      GOTO CLEARALLTABS40;
   FI;
   
   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN FINDNEWTABLE!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locOpenStat     !
!--------------------------------------!
! Check if cursor already is opened, if so report failure. !
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITlocOpenStat46;
    FI;
! Check that the work area is locked, if so report failure !
    SQLM_TableReference=1;
    IF SQLM_TableReference:SQLM_WorkLock /= 0 THEN
        SQLCODE=3+18 <= 8;
        GOTO EXITlocOpenStat46;
    FI;
! Allocate work row, report if the allocate fails. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocOpenStat46;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocOpenStat46;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow14;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow14;
!
$ We should never get here
!
    GOTO WORKFULLlocOpenStat46;
WORKALLOCATEallocateWorkRow14)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
! If the cursor is a row number a THIS OR PREVIOUS key operation is
  converted to a PREVIOUS key operation by increasing the row number by
  one. !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=%%(keyExprs[9])+1;
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_FINDNEWTABLE_Cursor=SQLM_TABLES_WorkRow;
    SQLCODE=0;
    GOTO EXITlocOpenStat46;
WORKLOCKlocOpenStat46)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocOpenStat46;
WORKFULLlocOpenStat46)
    SQLCODE=3+8 <= 8;
EXITlocOpenStat46)


!******************************************************************************!
!END SQL!

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH FINDNEWTABLE INTO %PROTECTEDP:NEXTTOBEDELETED!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locFetchStat!
!--------------------------------------!
! Check if cursor is open, if not report failure !
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITlocFetchStat47;
    FI;
! Find an operating row !
    SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEWTABLE_Cursor;
    IF SQLM_TABLES_WorkRow:SQLC_TABLES_Left3 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            +,
            PROTECTEDP,
            SQLM_TableReference,
            0,
            SQLM_TABLES_WorkRow:SQLC_TABLES_Left3,
            SQLM_TABLES_WorkRoW
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            2,
            +,
            +,
            24;
        EXIT;
    FI;
towGetSchLab24)
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! check if row is not found, if so report failure !
    IF SQLM_TABLES_OperRow >= SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
! Search failure: row not found !
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat47;
    FI;
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 0 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
! Search failure: row not found !
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat47;
    FI;
! check if row is locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+3 <= 8;
        GOTO EXITlocFetchStat47;
    FI;
! update cursor !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=
        SQLM_TABLES_OperRow;
    SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2=
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2;
! Do additional tests, if the fails try another row. !
! Everything is allright, copy columns into variables. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    PROTECTEDP:NEXTTOBEDELETED = SQLM_TABLES_OperRow;
! Set cursor to indicate that a row was found and return success !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=0;
    SQLCODE=0;
EXITlocFetchStat47)


!******************************************************************************!
!END SQL!



   CASE SQLCODE.VALUE IS
   
      WHEN ZTABLEFOUND DO
         
         CRETURNFROMTRHSTATRANSR=SYMCLEARALLTABS30;
         SEND TRHSTATRANS WITH
            PROTECTEDP,            ! OWN POINTER !
            COWNREF,
            ZDONOTLOG,
            +;     
         EXIT;
         
!        ACTION CONTINUES AT CLEARALLTABS30 BELOW                              !
         
      WHEN ZNOMORETABLES DO
         CALLTABSCLEARED = TRUE;
         
      OTHERWISE DO;
   ESAC;

CLEARALLTABS20)
   
   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE FINDNEWTABLE!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locCloseStat    !
!--------------------------------------!
    IF  PROTECTEDP:SQLM_FINDNEWTABLE_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
    ELSE
! Close cursor. !
      SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEWTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
      SQLCODE=0;
    FI;


!******************************************************************************!
!END SQL!

      
   GOTO CLEARALLTABS10;                     ! END LOOP !






!     CONTINUE EXECUTION OF 'CASE SQLCODE.VALUE IS WHEN ZTABLEFOUND DO'        !


CLEARALLTABS30)
            
   CASE CMESSAGE.VALUE IS
      WHEN ZOK DO;
      
      WHEN ZERROR DO
         IF CMESSAGE.SUBCODE = ZTRHCONG THEN
            SEND PROGERROR WITH
               ZPROGERRORCODE4,
               ZTRHSAEID1;
         FI;
         EXIT;
         
      OTHERWISE DO;
   ESAC;
   
   
!BEGIN SQL DELETE 2!
!******************************************************************************!

!EXEC SQL DELETE
      FROM TABLES
      WHERE TROWNO = %PROTECTEDP:NEXTTOBEDELETED!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       deleteStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITdeleteStat49;
    FI;
! Pack signal with primary key. Then send delete signal to transaction
  handler. !
    PROTECTEDP:SQLX_SQLRETURN=1;
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!
    SQLX_DR23 = NEXTTOBEDELETED;
    SEND trhDelRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef,
        cOwnRef,
        1,
        0
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR23
        ;
    EXIT;
trhDelRowLab1)
EXITdeleteStat49)


!******************************************************************************!
!END SQL!


   CASE SQLCODE.VALUE IS
      WHEN ZOK DO;
      
      WHEN ZERROR DO
         IF SQLCODE.SUBCODE = ZTRHCONG THEN
            SEND PROGERROR WITH
               ZPROGERRORCODE4,
               ZTRHSAEID1;
         FI;
         EXIT;
         
      OTHERWISE DO;
   ESAC;
      
   
!BEGIN SQL PREPARE 0!
!******************************************************************************!

!EXEC SQL PREPARE TRANSACTION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       prepareStat     !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhVerTransLab1;
    FI;
! Request to prepare a transaction for commit. !
    PROTECTEDP:SQLX_SQLRETURN=1;
    SEND trhVerTrans WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref;
    EXIT;
trhVerTransLab1)


!******************************************************************************!
!END SQL!

   
   CASE SQLCODE.VALUE IS
      WHEN ZOK DO;
      
      WHEN ZERROR DO
         IF SQLCODE.SUBCODE = ZTRHCONG THEN
            SEND PROGERROR WITH
               ZPROGERRORCODE4,
               ZTRHSAEID1;
         FI;
         EXIT;
         
      OTHERWISE DO;
   ESAC;

   
!BEGIN SQL COMMIT 0!
!******************************************************************************!

!EXEC SQL COMMIT TRANSACTION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       commitStat      !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhComTransLab4;
    FI;
! Request to commit a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=4;
    SEND trhComTrans WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhComTransLab4)
! Close transaction !
    PROTECTEDP:SQLTRANSID=0;


!******************************************************************************!
!END SQL!
            

   GOTO CLEARALLTABS20;


CLEARALLTABS40)

   
!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEWTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_EXTENSIVETABS_Cursor=0;
    IF PROTECTEDP:SQLM_FINDFK_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDNEWTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDFK_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEWTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEWTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEWTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDNEWTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDORDNO_Cursor=0;
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEWTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDTROWNO_Cursor=0;
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEWTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor=0;
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEWTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETTROWNO_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=6;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab6)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!


   BRANCH ON CRETURNFROMCLEARALLTABS
      TO WHICHRESTCASE10 IF SYMWHICHRESTCASE10
      ELSE TO WHICHRESTCASE10;
      
!     END OF ROUTINE CLEARALLTABS                                              !














!*****************************************************************************!
!*                                                                           *! 
!*             C L E A R S O M E T A B S                                     *!
!*                                                                           *!
!*****************************************************************************!






! THIS ROUTINE TAKES CARE OF THE CASE 'SMALL RESTART DUE TO A     !
! FUNCTION CHANGE'. BY SENDING FCHBNOOLD2 AND RECEIVING FCHBNO-   !
! OLD2RPY, THE ROUTINE GETS ALL THE BLOCKNUMBERS TO THE BLOCKS    !
! THAT PARTICIPATE IN THE FUNCTION CHANGE. IT TRANSFORMS ALL THE  !
! BLOCK NUMBERS TO BLOCK REFERENCES AND IT DELETES ALL ROWS,      !
! WHICH ARE ASSOCIATED WITH THE CURRENT BLOCKS, FROM ALL DATA     !
! DICTIONARY TABLES.                                              !

! OUTDATA:          CNOFBLOCKS                                    !
!                   CBLOCK              ARRAY OF BLOCK REFERENCES !

CLEARSOMETABS)

   CNOFREQ=0;
   CBLOCKCOUNT = 0;
   CK=0;
   CALLTABSRECEIVED=FALSE;







CLEARSOMETABS10)                      ! BEGIN LOOP FOR EACH SIGNAL FCH.. !

   IF CALLTABSRECEIVED = TRUE THEN
      GOTO CLEARSOMETABS60;
   FI;   

   SEND FCHBNOOLD2 WITH
      CK,
      COWNREF,
      CNOFREQ;
   EXIT;
          
   ENTER FCHBNOOLD2RPY WITH
      CK,
      CNOFREQ,
      CNOFBLOCKS,
      CTEMPBLOCK( 0),
      CTEMPBLOCK( 1),
      CTEMPBLOCK( 2),
      CTEMPBLOCK( 3),
      CTEMPBLOCK( 4),
      CTEMPBLOCK( 5),
      CTEMPBLOCK( 6),
      CTEMPBLOCK( 7),
      CTEMPBLOCK( 8),
      CTEMPBLOCK( 9),
      CTEMPBLOCK( 10),
      CTEMPBLOCK( 11),
      CTEMPBLOCK( 12),
      CTEMPBLOCK( 13),
      CTEMPBLOCK( 14),
      CTEMPBLOCK( 15);
             

   TCOUNTER = 0;
   
CLEARSOMETABS20)          ! BEGIN LOOP FOR EACH BLOCK IN THE SIGNAL !

   IF TCOUNTER = 16 THEN
      GOTO CLEARSOMETABS50;
   FI;

   TNOFRECEIVEDDATA=CNOFREQ*16 + TCOUNTER + 1;
   
   IF TNOFRECEIVEDDATA =< CNOFBLOCKS  THEN
   
      TBLKNUM = CTEMPBLOCK(TCOUNTER) - 1;
      SEND NOFORFUCODE WITH
         TCOUNTER,
         ZTOWFUCODE,
         TBLKNUM,
      WAIT FOR NOFORFUCODEACK IN CLEARSOMETABS30;
      
   ELSE
   
      CALLTABSRECEIVED=TRUE;
      GOTO CLEARSOMETABS50;
      
   FI;
   
 
CLEARSOMETABS30)

   RETRIEVE NOFORFUCODEACK WITH
      TCOUNTER,
      TBLKNUM,
      TANSWER;
      
   CASE TANSWER IS
      WHEN ZOK DO
      
         IF TBLKNUM = CTEMPBLOCK(TCOUNTER) THEN
         
            TRANSFORM BLOCKNUMBER IN TEMP TBLKNUM
               TO BLOCKREF IN TEMP TBLKREF;
               
            CBLOCK(CBLOCKCOUNT) = TBLKREF;
            CBLOCKCOUNT = CBLOCKCOUNT+1;
         FI;
            
      OTHERWISE DO;
   ESAC; 
  
   TCOUNTER = TCOUNTER + 1;
   GOTO CLEARSOMETABS20;           ! END LOOP FOR EACH BLOCK IN THE SIGNAL !
 
 
 
 
CLEARSOMETABS50)
  
   CK=CK+16;
   CNOFREQ=CNOFREQ+1;   
   GOTO CLEARSOMETABS10;                 ! END LOOP FOR EACH SIGNAL FCH.. !






! ALL BLOCK REFERENCES OF ALL TABLE-OWNING BLOCKS THAT PARTICIPATE IN THE !
! FUNCTION CHANGE ARE STORED IN THE ARRAY CBLOCK. THE NUMBER OF BLOCKS    !
! THAT ARE STORED IN CBLOCK WILL BE GIVEN BY CNOFBLOCKS.                  !


CLEARSOMETABS60)

   CNOFBLOCKS = CBLOCKCOUNT;
   CK=0;
   
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat53;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat53;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat53;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat53;
PROTECTEDALLOCATEDbeginStat53)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat53)
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!










CLEARSOMETABS70)
          
   IF CK=CNOFBLOCKS THEN                 ! BEGIN LOOP FOR EACH BLOCK !
      GOTO CLEARSOMETABS110;
   FI;
                

   CRETURNFROMTRHSTATRANSR=SYMCLEARSOMETABS80;

   
   SEND TRHSTATRANS WITH
      PROTECTEDP,            ! OWN POINTER !
      COWNREF,
      ZDONOTLOG,
      +;
   EXIT;

CLEARSOMETABS80)

   CMORETABSTODELETE = TRUE;
   
!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN FINDNEXTTABLE!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locOpenStat     !
!--------------------------------------!
! Check if cursor already is opened, if so report failure. !
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITlocOpenStat54;
    FI;
! Check that the work area is locked, if so report failure !
    SQLM_TableReference=1;
    IF SQLM_TableReference:SQLM_WorkLock /= 0 THEN
        SQLCODE=3+18 <= 8;
        GOTO EXITlocOpenStat54;
    FI;
! Allocate work row, report if the allocate fails. !
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKlocOpenStat54;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLlocOpenStat54;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow15;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow15;
!
$ We should never get here
!
    GOTO WORKFULLlocOpenStat54;
WORKALLOCATEallocateWorkRow15)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data=CBLOCK(CK);
! If the cursor is a btree store 0 in cLastRow if the key operation is
  PREVIOUS otherwise the highest row number (65535 if 16 bit address)
  is stored in cLastRow (key operation THIS or THIS OR PREVIOUS). !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=65535;
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor=SQLM_TABLES_WorkRow;
    SQLCODE=0;
    GOTO EXITlocOpenStat54;
WORKLOCKlocOpenStat54)
    SQLCODE=3+18 <= 8;
    GOTO EXITlocOpenStat54;
WORKFULLlocOpenStat54)
    SQLCODE=3+8 <= 8;
EXITlocOpenStat54)


!******************************************************************************!
!END SQL!







CLEARSOMETABS90)                          ! BEGIN LOOP FOR EACH TABLE !

   IF CMORETABSTODELETE = FALSE THEN
      GOTO CLEARSOMETABS100;
   FI;

   
!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH FINDNEXTTABLE INTO %PROTECTEDP:NEXTTOBEDELETED!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locFetchStat!
!--------------------------------------!
! Check if cursor is open, if not report failure !
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITlocFetchStat55;
    FI;
! Find an operating row !
    SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        4,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right4,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
,
        0,
        1,
        SQLM_TableReference:SQLM_System+1,   ! pNilRow !
        25;
    EXIT;
towGetSchLab25)
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_OperRow;
! check if row is not found, if so report failure !
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat55;
    FI;
! check if row is locked, if so report failure !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SQLCODE=2+3 <= 8;
        GOTO EXITlocFetchStat55;
    FI;
! update cursor !
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data=
        SQLM_TABLES_OperRow:SQLC_TABLES_BLKREF_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3=
        SQLM_TABLES_OperRow;
    SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2=
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2;
! Do additional tests, if the fails try another row. !
! Everything is allright, copy columns into variables. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    PROTECTEDP:NEXTTOBEDELETED = SQLM_TABLES_OperRow;
! Set cursor to indicate that a row was found and return success !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=0;
    SQLCODE=0;
EXITlocFetchStat55)


!******************************************************************************!
!END SQL!

   !$EXEC SQL CONTINUE$!
   
   CASE SQLCODE.VALUE IS
      WHEN ZTABLEFOUND DO
         
!BEGIN SQL DELETE 1!
!******************************************************************************!

!EXEC SQL DELETE FROM TABLES
            WHERE TROWNO=%PROTECTEDP:NEXTTOBEDELETED!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       deleteStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITdeleteStat56;
    FI;
! Pack signal with primary key. Then send delete signal to transaction
  handler. !
    PROTECTEDP:SQLX_SQLRETURN=2;
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!
    SQLX_DR23 = NEXTTOBEDELETED;
    SEND trhDelRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef,
        cOwnRef,
        1,
        0
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR23
        ;
    EXIT;
trhDelRowLab2)
EXITdeleteStat56)


!******************************************************************************!
!END SQL!

     
      WHEN ZSEARCHFAIL DO
         CMORETABSTODELETE = FALSE;
         
      OTHERWISE DO;
   ESAC;
  
   GOTO CLEARSOMETABS90;                  ! END LOOP FOR EACH TABLE !





CLEARSOMETABS100)
   
   
!BEGIN SQL COMMIT 0!
!******************************************************************************!

!EXEC SQL COMMIT TRANSACTION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       commitStat      !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhComTransLab5;
    FI;
! Request to commit a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=5;
    SEND trhComTrans WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhComTransLab5)
! Close transaction !
    PROTECTEDP:SQLTRANSID=0;


!******************************************************************************!
!END SQL!

   
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE FINDNEXTTABLE!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locCloseStat    !
!--------------------------------------!
    IF  PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
    ELSE
! Close cursor. !
      SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
      SQLCODE=0;
    FI;


!******************************************************************************!
!END SQL!

            

   CK=CK+1;
   GOTO CLEARSOMETABS70;                 ! END LOOP FOR EACH BLOCK !
 
 
 
 
 
 
 
 
   
CLEARSOMETABS110)                       
   
!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_EXTENSIVETABS_Cursor=0;
    IF PROTECTEDP:SQLM_FINDFK_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDFK_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEWTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDORDNO_Cursor=0;
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDTROWNO_Cursor=0;
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor=0;
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETTROWNO_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=7;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab7)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!

          
BRANCH ON CRETURNFROMCLEARSOMETABS
   TO WHICHRESTCASE10 IF SYMWHICHRESTCASE10
   ELSE TO WHICHRESTCASE10;



















!*****************************************************************************!
!*                                                                           *! 
!*             E V E N T R E Q                                               *!
!*                                                                           *!
!*****************************************************************************!





! THIS ROUTINE SENDS THE SIGNAL EVENTMSGREQ IN ORDER TO TELL KEED !
! THAT THIS BLOCK WANTS TO SUBSCRIBE ON THE SIGNAL EVENTMESSAGEC  !
! IN THE SPECIFIC CASE THAT THE RECENT SYSTEM RESTART FLAG HAS    !
! CHANGED STATES. THE OBJECTIVE IS TO FIND OUT WHETHER OR NOT A   !
! SYSTEM RESTART IS CAUSED BY A FUNCTION CHANGE.                  !

! INDATA:        NONE                                             !

! OUTDATA:       COWNREF                                          !
!                CFC=FALSE          VALUE MAY BE CHANGED LATER BY !
!                                   SIGNAL EVENTMESSAGEC.         !

          
BEGIN EVENTREQ;

   LOADREF TOWNREF;
   COWNREF=TOWNREF;   

   CFC=FALSE;


EVENTREQ10)
         
   SEND EVENTMSGREQ WITH
      +,                       ! OWN POINTER !
      COWNREF,
      ZINFOONLEVELC,
      ZONEEVENT,
      ZSYSRESTFLAGCHANGED,
   WAIT FOR EVENTMSGREQACK IN EVENTREQ20;
          
EVENTREQ20)
   RETRIEVE EVENTMSGREQACK WITH 
      +,                       ! OWN POINTER !
      TRETURNCODE;
          
             
   CASE TRETURNCODE IS
      WHEN ZREQUESTACKN DO;
      WHEN ZCONGESTION DO
!         EXEC SQL DELAY 100 MS!
         GOTO EVENTREQ10;          ! CONGESTION IN KEED. TRY AGAIN !
      OTHERWISE DO;  
   ESAC;
          
END EVENTREQ;

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 












!*****************************************************************************!
!*                                                                           *! 
!*             T R I G T O W I N I T I A T I O N S                           *!
!*                                                                           *!
!*****************************************************************************!



TRIGTOWINITIATION)

   
!BEGIN SQL BEGIN 0!
!******************************************************************************!

!EXEC SQL BEGIN PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat60;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat60;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat60;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat60;
PROTECTEDALLOCATEDbeginStat60)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat60)
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!


   PROTECTEDP:BLKNUM = 0;
   PROTECTEDP:COUNTER = 0;
   

TRIGTOWINITIATIONS10)

   IF CONLYSOMEBLOCKS = TRUE THEN
   
      IF PROTECTEDP:COUNTER = CNOFBLOCKS THEN
         GOTO TRIGTOWINITIATIONS30;
      FI;
      
      SEND TOWRESPART REFERENCE CBLOCK(PROTECTEDP:COUNTER) WITH
         COWNREF,
         PROTECTEDP,
         CLOCALRESTARTPHASE;
         
      PROTECTEDP:COUNTER = PROTECTEDP:COUNTER+1;
      EXIT;
                     
   ELSE
      
      SEND NOFORFUCODE WITH
         PROTECTEDP,
         ZTOWFUCODE,
         PROTECTEDP:BLKNUM,
      WAIT FOR NOFORFUCODEACK IN TRIGTOWINITIATIONS20;
         
   FI;
   
TRIGTOWINITIATIONS20)

   RETRIEVE NOFORFUCODEACK WITH
      PROTECTEDP,
      PROTECTEDP:BLKNUM,
      TANSWER;
      
   CASE TANSWER IS
   
      WHEN ZOK DO
      
         TBLKNUM = PROTECTEDP:BLKNUM;
         TRANSFORM BLOCKNUMBER IN TEMP TBLKNUM
            TO BLOCKREF IN TEMP TBLKREF;

         SEND TOWRESPART REFERENCE TBLKREF WITH
            COWNREF,
            PROTECTEDP,
            CLOCALRESTARTPHASE;
            
         EXIT;
         
      OTHERWISE DO

         GOTO TRIGTOWINITIATIONS30;
            
   ESAC;



TRIGTOWINITIATIONS30)


   BRANCH ON CRETURNFROMTRIGTOWINITIATION
      TO STTOR10 IF SYMSTTOR10
      ELSE TO STTOR10;







!*****************************************************************************!
!*                                                                           *! 
!*             W H I C H R E S T C A S E                                     *!
!*                                                                           *!
!*****************************************************************************!






! THIS ROUTINE DIFFERS BETWEEN THE TWO ALTERNATIVE RESTART CASES  !
! THAT MAY OCCUR. IF A SYSTEM START OR ANY KIND OF LARGE RESTART  !
! OCCURS, THEN THE ENTIRE DATA DICTIONARY WILL BE (RE-)INITIATED  !
! AND THIS HAS TO BE PREPARED BY CLEARING ALL DATA DICTIONARY     !
! TABLES. A SMALL RESTART IMPLIES NO ACTION FROM DATA DICTIONARY  !
! EXCEPT WHEN THE RESTART IS CAUSED BY A FUNCTION CHANGE. IN THIS !
! CASE, ONLY THE BLOCKS THAT PARTICIPATE IN THE FUNCTION CHANGE   !
! WILL BE REINITIATED IN DATA DICTIONARY.                         !

! INDATA:        CRESTCASE        RESTART CASE                    !
!                CFC              HAS AN FC OCCURRED?             !

! OUTDATA:       CSMALLREST       BOOLEAN                         !
!                CONLYSOMEBLOCKS  BOOLEAN                         !

! ACTIONS:       CALL SUBROUTINE CLEARSOMETABS, CLEARALLTABS OR   !
!                DO NOTHING                                       !

WHICHRESTCASE)

   CONLYSOMEBLOCKS = FALSE;
   CSMALLREST=FALSE;
   
   CASE CRESTCASE IS

      WHEN ZSMALLRESTART DO
         CSMALLREST=TRUE;
         IF  CFC=TRUE THEN
            CONLYSOMEBLOCKS = TRUE;
            CRETURNFROMCLEARSOMETABS=SYMWHICHRESTCASE10;          
            GOTO CLEARSOMETABS;       
         FI;

      WHEN ZLARGERELOAD, ZLARGERESTART, ZSYSTEMSTART DO
         CRETURNFROMCLEARALLTABS = SYMWHICHRESTCASE10;
         CNEXTTROWNO = 0;
         CNEXTFROWNO = 0;  
         GOTO CLEARALLTABS;
         
      OTHERWISE DO;   
   ESAC;
   


WHICHRESTCASE10) 
  
   BRANCH ON CRETURNFROMWHICHRESTCASE
      TO STTOR10 IF SYMSTTOR10
      ELSE TO STTOR10;


! Additional SQL statments are stated to make sure that all the grammar 
  rules are used at least one time !


!BEGIN SQL CONTINUE 0!
!******************************************************************************!

!EXEC SQL CONTINUE AT LEVEL B DELAY 5 MS!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       continueStat    !
!--------------------------------------!
    SEND CONTINUEB REFERENCE cOwnRef WITH
        PROTECTEDP,
        1
        DELAY 5 MS
        ;
    EXIT;
continueBLab1)


!******************************************************************************!
!END SQL!



!BEGIN SQL CONTINUE 0!
!******************************************************************************!

!EXEC SQL CONTINUE B!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       continueStat    !
!--------------------------------------!
    SEND CONTINUEB REFERENCE cOwnRef WITH
        PROTECTEDP,
        2
        ;
    EXIT;
continueBLab2)


!******************************************************************************!
!END SQL!



!BEGIN SQL GET_DB_NUMBER 0!
!******************************************************************************!

!EXEC SQL GET DBNUMBER INTO %a!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       getDbnumberStat !
!--------------------------------------!
    SEND trhGetDBno WITH
        PROTECTEDP,
        cOwnRef
        WAIT FOR trhGetDBnoAck IN RETURNLABELgetDbnumberStat63;
RETURNLABELgetDbnumberStat63)
    RETRIEVE trhgetDBnoAck WITH
        A.PART1,
        A.PART2;


!******************************************************************************!
!END SQL!



!BEGIN SQL UPDATE 0!
!******************************************************************************!

!EXEC SQL UPDATE test1 AS tt SET col3=%a%b, col6=%b WHERE col2 = "bb" AND col1 = "aa"!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       updateStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITupdateStat64;
    FI;
! Pack signal with required data and primary key. Then send update
  signal to transaction handler. !
    PROTECTEDP:SQLX_SQLRETURN=1;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!



    PROTECTEDP:SQLM_2 = "bb";
    PROTECTEDP:SQLM_1 = "aa";
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack3;  ! pack string into signal registers !

    SQLX_DR15 = PROTECTEDP:SQLM_2;
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 4;
    SQLX_DR7 = B;

    SQLX_DR8 = A;
    SEND trhChaRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef,
        cOwnRef,
        10,
        2
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
trhChaRowLab1)
! If not successful abort command !
    IF SQLCODE /= 0 GOTO EXITupdateStat64;
! Send let field signal to transaction handler until all data is
  transferred to the table. Abort the command if any signal fails. !
    PROTECTEDP:SQLX_SQLRETURN=1;
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 7;
    SQLX_DR7 = 0;

    DO SQLS_Pack4;  ! pack string into signal registers !
    SEND trhLetFld WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref,
        +,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
trhLetFldLab3)
    IF SQLCODE /= 0 GOTO EXITupdateStat64;
EXITupdateStat64)


!******************************************************************************!
!END SQL!



!BEGIN SQL UPDATE 0!
!******************************************************************************!

!EXEC SQL UPDATE test1 AS tt SET col3=%a:b%c:d, col6=%b WHERE CURRENT OF WORK!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       workUpdateStat   !
!--------------------------------------!
    IF PROTECTEDP:SQLX_SQLWORKROW = 0 THEN
        SQLCODE=3 + 16 <= 8;
    ELSE
        SQLM_TEST1_OperRow=PROTECTEDP:SQLX_SQLWORKROW;
! Copy variables into columns !
!------------------------------------------------!
!       putData !
!------------------------------------------------!
    SQLM_TEST1_OperRow:SQLC_TEST1_COL3_Null =
        D;

    SQLM_TEST1_OperRow:SQLC_TEST1_COL3_Data =
        A:B;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL6_Null = 0;

    SQLM_TEST1_OperRow:SQLC_TEST1_COL6_Data =
        B;
        SQLCODE=0;
    FI;


!******************************************************************************!
!END SQL!



!BEGIN SQL UPDATE_VOLATILE 1!
!******************************************************************************!

!EXEC SQL UPDATE test3 AT (%xx) tt VOLATILE col4=%a 
         WHERE test3.col9 = 4!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remUpdateVolatileStat!
!--------------------------------------!
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!

! Loop for each hunk of columns to update !
! Update some columns !
    PROTECTEDP:SQLX_SQLRETURN=1;
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 5;

    DO SQLS_Pack5;  ! pack string into signal registers !
    SEND towChaVolRow REFERENCE XX WITH
        cOwnRef,
        PROTECTEDP,
        5,
        4,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ;
    EXIT;
towChaVolRowLab1)
! If update failed abort command !
    IF SQLCODE /= 0 GOTO EXITremUpdateVolatileStat66;
EXITremUpdateVolatileStat66)


!******************************************************************************!
!END SQL!



!BEGIN SQL SELECT 0!
!******************************************************************************!

!EXEC SQL SELECT col3 INTO %a%b FROM test1 WHERE CURRENT OF WORK!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TEST1_OperRow = PROTECTEDP:SQLX_SQLWORKROW;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    B = SQLM_TEST1_OperRow:SQLC_TEST1_COL3_Null;
    A = SQLM_TEST1_OperRow:SQLC_TEST1_COL3_Data;


!******************************************************************************!
!END SQL!
  


!BEGIN SQL SELECT 0!
!******************************************************************************!

!EXEC SQL SELECT col3 INTO %a%b FROM test1 WHERE CURRENT OF ORIGINAL!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TEST1_OperRow = PROTECTEDP:SQLX_SQLOPERROW;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    B = SQLM_TEST1_OperRow:SQLC_TEST1_COL3_Null;
    A = SQLM_TEST1_OperRow:SQLC_TEST1_COL3_Data;


!******************************************************************************!
!END SQL!
  


!BEGIN SQL START 0!
!******************************************************************************!

!EXEC SQL START WORK "abc"!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       startStat!
!--------------------------------------!
! Check if inside a transaction, if so report failure !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
        SQLCODE=3+15 <= 8;
        GOTO trhStaTransLab1;
    FI;
    PROTECTEDP:SQLX_SQLRETURN=1;
    SEND trhStaTrans WITH
        PROTECTEDP,
        cOwnRef,
        1,
        "abc";
    EXIT;
trhStaTransLab1)


!******************************************************************************!
!END SQL!



!BEGIN SQL START 0!
!******************************************************************************!

!EXEC SQL START WORK!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       startStat!
!--------------------------------------!
! Check if inside a transaction, if so report failure !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
        SQLCODE=3+15 <= 8;
        GOTO trhStaTransLab2;
    FI;
    PROTECTEDP:SQLX_SQLRETURN=2;
    SEND trhStaTrans WITH
        PROTECTEDP,
        cOwnRef,
        1,
        "";
    EXIT;
trhStaTransLab2)


!******************************************************************************!
!END SQL!



!BEGIN SQL ROLLBACK 0!
!******************************************************************************!

!EXEC SQL ROLLBACK TRANSACTION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       rollbackStat    !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhRollBckLab8;
    FI;
! Request to rollback a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=8;
    SEND trhRollBck WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhRollBckLab8)
! Close the transaction !
    PROTECTEDP:SQLTRANSID=0;


!******************************************************************************!
!END SQL!




! Comment test !
! EXEC SQL START WORK "abc""def%ghi`jkl%%mno``pqr" !

   

! String test !

!BEGIN SQL START 0!
!******************************************************************************!

!EXEC SQL START WORK "abc""def%ghi`jkl%%mno``pqr"!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       startStat!
!--------------------------------------!
! Check if inside a transaction, if so report failure !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
        SQLCODE=3+15 <= 8;
        GOTO trhStaTransLab3;
    FI;
    PROTECTEDP:SQLX_SQLRETURN=3;
    SEND trhStaTrans WITH
        PROTECTEDP,
        cOwnRef,
        1,
        "abc"def`%ghi``jkl`%`%mno````pqr";
    EXIT;
trhStaTransLab3)


!******************************************************************************!
!END SQL!

   

      


!BEGIN SQL COMMON 0!
!------------------------------------------------!
!       comGiveFs !
!------------------------------------------------!
    ENTER GIVEFS WITH
        SQLX_SizeEvent,
        +;
    CASE SQLX_SizeEvent IS
    WHEN 21 DO GOTO SAE21L1;
    WHEN 21 DO GOTO SAE21L1;
    WHEN 1 DO GOTO SAE1L1;
    WHEN 3 DO GOTO SAE3L1;
    WHEN 5 DO GOTO SAE5L1;
    WHEN 7 DO GOTO SAE7L1;
    WHEN 9 DO GOTO SAE9L1;
    WHEN 13 DO GOTO SAE13L1;
    WHEN 15 DO GOTO SAE15L1;
    WHEN 19 DO GOTO SAE19L1;
    WHEN 10 DO GOTO SAE10L1;
    WHEN 22 DO GOTO SAE22L1;
    WHEN 22 DO GOTO SAE22L1;
    WHEN 2 DO GOTO SAE2L1;
    WHEN 4 DO GOTO SAE4L1;
    WHEN 6 DO GOTO SAE6L1;
    WHEN 8 DO GOTO SAE8L1;
    WHEN 10 DO GOTO SAE10L1;
    WHEN 14 DO GOTO SAE14L1;
    WHEN 16 DO GOTO SAE16L1;
    WHEN 20 DO GOTO SAE20L1;
    WHEN 20 DO GOTO SAE20L1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! No appropriate Size Alteration Event was found. !
    SEND GIVEFSEND WITH #100;
    EXIT;

!------------------------------------------------!
!       comContFs !
!------------------------------------------------!
    ENTER CONTFS WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum;
! Select Size Alteration Event !
    CASE SQLX_SizeEvent IS
    WHEN 21 DO GOTO SAE21L2;
    WHEN 21 DO GOTO SAE21L2;
    WHEN 1 DO GOTO SAE1L2;
    WHEN 3 DO GOTO SAE3L2;
    WHEN 5 DO GOTO SAE5L2;
    WHEN 7 DO GOTO SAE7L2;
    WHEN 9 DO GOTO SAE9L2;
    WHEN 13 DO GOTO SAE13L2;
    WHEN 15 DO GOTO SAE15L2;
    WHEN 19 DO GOTO SAE19L2;
    WHEN 10 DO GOTO SAE10L2;
    WHEN 22 DO GOTO SAE22L2;
    WHEN 22 DO GOTO SAE22L2;
    WHEN 2 DO GOTO SAE2L2;
    WHEN 4 DO GOTO SAE4L2;
    WHEN 6 DO GOTO SAE6L2;
    WHEN 8 DO GOTO SAE8L2;
    WHEN 10 DO GOTO SAE10L2;
    WHEN 14 DO GOTO SAE14L2;
    WHEN 16 DO GOTO SAE16L2;
    WHEN 20 DO GOTO SAE20L2;
    WHEN 20 DO GOTO SAE20L2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! The size alteration event was of no interest !
    SEND CONTFSEND WITH 1;
    EXIT;

!------------------------------------------------!
!       comSetFs !
!------------------------------------------------!
    ENTER SETFS WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum;
! Select Size Alteration Event !
    CASE SQLX_SizeEvent IS
    WHEN 21 DO GOTO SAE21L3;
    WHEN 21 DO GOTO SAE21L3;
    WHEN 1 DO GOTO SAE1L3;
    WHEN 3 DO GOTO SAE3L3;
    WHEN 5 DO GOTO SAE5L3;
    WHEN 7 DO GOTO SAE7L3;
    WHEN 9 DO GOTO SAE9L3;
    WHEN 13 DO GOTO SAE13L3;
    WHEN 15 DO GOTO SAE15L3;
    WHEN 19 DO GOTO SAE19L3;
    WHEN 10 DO GOTO SAE10L3;
    WHEN 22 DO GOTO SAE22L3;
    WHEN 22 DO GOTO SAE22L3;
    WHEN 2 DO GOTO SAE2L3;
    WHEN 4 DO GOTO SAE4L3;
    WHEN 6 DO GOTO SAE6L3;
    WHEN 8 DO GOTO SAE8L3;
    WHEN 10 DO GOTO SAE10L3;
    WHEN 14 DO GOTO SAE14L3;
    WHEN 16 DO GOTO SAE16L3;
    WHEN 20 DO GOTO SAE20L3;
    WHEN 20 DO GOTO SAE20L3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Ignore non-interesting size alteration events !
    SEND SETFSEND;
    EXIT;

!------------------------------------------------!
!       towPlexCode !
!------------------------------------------------!
!------------------------------------------------!
!       comPlexCode !
!------------------------------------------------!
!------------------------------------------------!
!       towResPart !
!------------------------------------------------!
    ENTER towResPart WITH
        SQLX_OtherBlock,        ! Other users block number !
        SQLX_OtherProtected,    ! Other users protected pointer !
        SQLX_RestartPhase;      ! Our internal restart phase !
   ! Store block ref and pointer !
    CSQLX_OtherBlock = SQLX_OtherBlock;
    CSQLX_OtherProtected = SQLX_OtherProtected;
! Select code to execute the specified restart code !
    CASE SQLX_RestartPhase IS
    WHEN 1 DO GOTO RESTARTPHASE1;
    WHEN 2 DO GOTO RESTARTPHASE2;
    WHEN 3 DO GOTO RESTARTPHASE3;
    WHEN 4 DO GOTO RESTARTPHASE4;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Return execution to Data Dictionary or Transaction Handler !
RESTARTEND)
    SEND towResPartR REFERENCE CSQLX_OtherBlock WITH
        CSQLX_OtherProtected,    ! Other users protected pointer !
        0;                  ! Return code !
    EXIT;
!------------------------------------------------!
!       comGiveFsSae !
!------------------------------------------------!
SAE21L1)
    SQLM_TableReference = 0;
    FILENUMBER FOR SQLC_PROGRAMS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        65000+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE21L1)
    SQLM_TableReference = 1;
    FILENUMBER FOR SQLC_TABLES_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        65000+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE1L1)
    SQLM_TableReference = 2;
    FILENUMBER FOR SQLC_FIELDS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        65000+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE3L1)
    SQLM_TableReference = 3;
    FILENUMBER FOR SQLC_KEYS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        30+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE5L1)
    SQLM_TableReference = 4;
    FILENUMBER FOR SQLC_KEYFIELDS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        30+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE7L1)
    SQLM_TableReference = 5;
    FILENUMBER FOR SQLC_FOREIGNKEYS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        65000+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE9L1)
    SQLM_TableReference = 6;
    FILENUMBER FOR SQLC_SYMBOLS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        30+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE13L1)
    SQLM_TableReference = 7;
    FILENUMBER FOR SQLC_TOWFAULTCODES_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        30+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE15L1)
    SQLM_TableReference = 8;
    FILENUMBER FOR SQLC_SYSFAULTCODES_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        65000+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE19L1)
    SQLM_TableReference = 9;
    FILENUMBER FOR SQLC_SYSTEMFIELDS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        65000+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE10L1)
    SQLM_TableReference = 10;
    FILENUMBER FOR SQLC_TEST1_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        65000+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE22L1)
    SQLM_TableReference = 0;
    FILENUMBER FOR SQLC_PROGRAMS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
SAE22L1)
    SQLM_TableReference = 1;
    FILENUMBER FOR SQLC_TABLES_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
SAE2L1)
    SQLM_TableReference = 2;
    FILENUMBER FOR SQLC_FIELDS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
SAE4L1)
    SQLM_TableReference = 3;
    FILENUMBER FOR SQLC_KEYS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
SAE6L1)
    SQLM_TableReference = 4;
    FILENUMBER FOR SQLC_KEYFIELDS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
SAE8L1)
    SQLM_TableReference = 5;
    FILENUMBER FOR SQLC_FOREIGNKEYS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
SAE10L1)
    SQLM_TableReference = 6;
    FILENUMBER FOR SQLC_SYMBOLS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
SAE14L1)
    SQLM_TableReference = 7;
    FILENUMBER FOR SQLC_TOWFAULTCODES_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
SAE16L1)
    SQLM_TableReference = 8;
    FILENUMBER FOR SQLC_SYSFAULTCODES_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
SAE20L1)
    SQLM_TableReference = 9;
    FILENUMBER FOR SQLC_SYSTEMFIELDS_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
SAE20L1)
    SQLM_TableReference = 10;
    FILENUMBER FOR SQLC_TEST1_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
!------------------------------------------------!
!       comContFsSae !
!------------------------------------------------!

BEGIN SQLS_PROGRAMS_SAEDecrease;
    SQLM_PROGRAMS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_PROGRAMS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_PROGRAMS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_PROGRAMS_OperRow=
        SQLM_PROGRAMS_GuardRow-SQLM_PROGRAMS_WorkRow;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2=
        SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Color2;    
    IF SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Left2 =
        SQLM_PROGRAMS_NilRow
    THEN
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
            SQLM_PROGRAMS_NilRow-SQLM_PROGRAMS_WorkRow;
    ELSE
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
            SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Left2;
    FI;
    IF SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2 =
        SQLM_PROGRAMS_NilRow
    THEN
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
              SQLM_PROGRAMS_NilRow-SQLM_PROGRAMS_WorkRow;
    ELSE
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
            SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2;
    FI;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated=1;
! Move Nil Row !
    SQLM_PROGRAMS_OperRow=
        SQLM_PROGRAMS_NilRow-SQLM_PROGRAMS_WorkRow;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2=
        SQLM_PROGRAMS_NilRow:SQLC_PROGRAMS_Color2;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
        SQLM_PROGRAMS_GuardRow-SQLM_PROGRAMS_WorkRow;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2 =
        SQLM_PROGRAMS_GuardRow-SQLM_PROGRAMS_WorkRow;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated=1;
! Move Root Row !
    SQLM_PROGRAMS_OperRow=
        SQLM_PROGRAMS_RootRow-SQLM_PROGRAMS_WorkRow;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2=
        SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Color2;    
    IF SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Right2 =
        SQLM_PROGRAMS_NilRow
    THEN
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
            SQLM_PROGRAMS_NilRow-SQLM_PROGRAMS_WorkRow;    
    ELSE
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
            SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Right2;    
    FI;
    IF SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Left2 =
        SQLM_PROGRAMS_NilRow
    THEN
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
            SQLM_PROGRAMS_NilRow-SQLM_PROGRAMS_WorkRow;    
    ELSE
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
            SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Left2;    
    FI;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated=1;
END SQLS_PROGRAMS_SAEDecrease;

BEGIN SQLS_TABLES_SAEDecrease;
    SQLM_TABLES_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TABLES_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_TABLES_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_TABLES_OperRow=
        SQLM_TABLES_GuardRow-SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Color3=
        SQLM_TABLES_GuardRow:SQLC_TABLES_Color3;    
    SQLM_TABLES_OperRow:SQLC_TABLES_Color4=
        SQLM_TABLES_GuardRow:SQLC_TABLES_Color4;    
    IF SQLM_TABLES_GuardRow:SQLC_TABLES_Left3 =
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
            SQLM_TABLES_NilRow-SQLM_TABLES_WorkRow;
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
            SQLM_TABLES_GuardRow:SQLC_TABLES_Left3;
    FI;
    IF SQLM_TABLES_GuardRow:SQLC_TABLES_Right3 =
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
              SQLM_TABLES_NilRow-SQLM_TABLES_WorkRow;
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
            SQLM_TABLES_GuardRow:SQLC_TABLES_Right3;
    FI;
    SQLM_TABLES_OperRow:SQLC_TABLES_Allocated=1;
! Move Nil Row !
    SQLM_TABLES_OperRow=
        SQLM_TABLES_NilRow-SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Color3=
        SQLM_TABLES_NilRow:SQLC_TABLES_Color3;
    SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
        SQLM_TABLES_GuardRow-SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Left3 =
        SQLM_TABLES_GuardRow-SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Color4=
        SQLM_TABLES_NilRow:SQLC_TABLES_Color4;
    SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
        SQLM_TABLES_GuardRow-SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Left4 =
        SQLM_TABLES_GuardRow-SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Allocated=1;
! Move Root Row !
    SQLM_TABLES_OperRow=
        SQLM_TABLES_RootRow-SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Color3=
        SQLM_TABLES_RootRow:SQLC_TABLES_Color3;    
    IF SQLM_TABLES_RootRow:SQLC_TABLES_Right3 =
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
            SQLM_TABLES_NilRow-SQLM_TABLES_WorkRow;    
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
            SQLM_TABLES_RootRow:SQLC_TABLES_Right3;    
    FI;
    IF SQLM_TABLES_RootRow:SQLC_TABLES_Left3 =
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
            SQLM_TABLES_NilRow-SQLM_TABLES_WorkRow;    
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
            SQLM_TABLES_RootRow:SQLC_TABLES_Left3;    
    FI;
    SQLM_TABLES_OperRow:SQLC_TABLES_Color4=
        SQLM_TABLES_RootRow:SQLC_TABLES_Color4;    
    IF SQLM_TABLES_RootRow:SQLC_TABLES_Right4 =
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
            SQLM_TABLES_NilRow-SQLM_TABLES_WorkRow;    
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
            SQLM_TABLES_RootRow:SQLC_TABLES_Right4;    
    FI;
    IF SQLM_TABLES_RootRow:SQLC_TABLES_Left4 =
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Left4=
            SQLM_TABLES_NilRow-SQLM_TABLES_WorkRow;    
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Left4=
            SQLM_TABLES_RootRow:SQLC_TABLES_Left4;    
    FI;
    SQLM_TABLES_OperRow:SQLC_TABLES_Allocated=1;
END SQLS_TABLES_SAEDecrease;

BEGIN SQLS_FIELDS_SAEDecrease;
    SQLM_FIELDS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_FIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_FIELDS_OperRow=
        SQLM_FIELDS_GuardRow-SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3=
        SQLM_FIELDS_GuardRow:SQLC_FIELDS_Color3;    
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4=
        SQLM_FIELDS_GuardRow:SQLC_FIELDS_Color4;    
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5=
        SQLM_FIELDS_GuardRow:SQLC_FIELDS_Color5;    
    IF SQLM_FIELDS_GuardRow:SQLC_FIELDS_Left3 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
            SQLM_FIELDS_NilRow-SQLM_FIELDS_WorkRow;
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
            SQLM_FIELDS_GuardRow:SQLC_FIELDS_Left3;
    FI;
    IF SQLM_FIELDS_GuardRow:SQLC_FIELDS_Right3 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
              SQLM_FIELDS_NilRow-SQLM_FIELDS_WorkRow;
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
            SQLM_FIELDS_GuardRow:SQLC_FIELDS_Right3;
    FI;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated=1;
! Move Nil Row !
    SQLM_FIELDS_OperRow=
        SQLM_FIELDS_NilRow-SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3=
        SQLM_FIELDS_NilRow:SQLC_FIELDS_Color3;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
        SQLM_FIELDS_GuardRow-SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3 =
        SQLM_FIELDS_GuardRow-SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4=
        SQLM_FIELDS_NilRow:SQLC_FIELDS_Color4;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
        SQLM_FIELDS_GuardRow-SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4 =
        SQLM_FIELDS_GuardRow-SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5=
        SQLM_FIELDS_NilRow:SQLC_FIELDS_Color5;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
        SQLM_FIELDS_GuardRow-SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5 =
        SQLM_FIELDS_GuardRow-SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated=1;
! Move Root Row !
    SQLM_FIELDS_OperRow=
        SQLM_FIELDS_RootRow-SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3=
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Color3;    
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Right3 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
            SQLM_FIELDS_NilRow-SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Right3;    
    FI;
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Left3 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
            SQLM_FIELDS_NilRow-SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Left3;    
    FI;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4=
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Color4;    
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Right4 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
            SQLM_FIELDS_NilRow-SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Right4;    
    FI;
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Left4 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4=
            SQLM_FIELDS_NilRow-SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Left4;    
    FI;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5=
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Color5;    
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Right5 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
            SQLM_FIELDS_NilRow-SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Right5;    
    FI;
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Left5 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5=
            SQLM_FIELDS_NilRow-SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Left5;    
    FI;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated=1;
END SQLS_FIELDS_SAEDecrease;

BEGIN SQLS_KEYS_SAEDecrease;
    SQLM_KEYS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_KEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_KEYS_OperRow=
        SQLM_KEYS_GuardRow-SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color2=
        SQLM_KEYS_GuardRow:SQLC_KEYS_Color2;    
    SQLM_KEYS_OperRow:SQLC_KEYS_Color3=
        SQLM_KEYS_GuardRow:SQLC_KEYS_Color3;    
    SQLM_KEYS_OperRow:SQLC_KEYS_Color4=
        SQLM_KEYS_GuardRow:SQLC_KEYS_Color4;    
    IF SQLM_KEYS_GuardRow:SQLC_KEYS_Left2 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
            SQLM_KEYS_NilRow-SQLM_KEYS_WorkRow;
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
            SQLM_KEYS_GuardRow:SQLC_KEYS_Left2;
    FI;
    IF SQLM_KEYS_GuardRow:SQLC_KEYS_Right2 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
              SQLM_KEYS_NilRow-SQLM_KEYS_WorkRow;
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
            SQLM_KEYS_GuardRow:SQLC_KEYS_Right2;
    FI;
    SQLM_KEYS_OperRow:SQLC_KEYS_Allocated=1;
! Move Nil Row !
    SQLM_KEYS_OperRow=
        SQLM_KEYS_NilRow-SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color2=
        SQLM_KEYS_NilRow:SQLC_KEYS_Color2;
    SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
        SQLM_KEYS_GuardRow-SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2 =
        SQLM_KEYS_GuardRow-SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color3=
        SQLM_KEYS_NilRow:SQLC_KEYS_Color3;
    SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
        SQLM_KEYS_GuardRow-SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Left3 =
        SQLM_KEYS_GuardRow-SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color4=
        SQLM_KEYS_NilRow:SQLC_KEYS_Color4;
    SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
        SQLM_KEYS_GuardRow-SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Left4 =
        SQLM_KEYS_GuardRow-SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Allocated=1;
! Move Root Row !
    SQLM_KEYS_OperRow=
        SQLM_KEYS_RootRow-SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color2=
        SQLM_KEYS_RootRow:SQLC_KEYS_Color2;    
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Right2 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
            SQLM_KEYS_NilRow-SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
            SQLM_KEYS_RootRow:SQLC_KEYS_Right2;    
    FI;
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Left2 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
            SQLM_KEYS_NilRow-SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
            SQLM_KEYS_RootRow:SQLC_KEYS_Left2;    
    FI;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color3=
        SQLM_KEYS_RootRow:SQLC_KEYS_Color3;    
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Right3 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
            SQLM_KEYS_NilRow-SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
            SQLM_KEYS_RootRow:SQLC_KEYS_Right3;    
    FI;
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Left3 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Left3=
            SQLM_KEYS_NilRow-SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Left3=
            SQLM_KEYS_RootRow:SQLC_KEYS_Left3;    
    FI;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color4=
        SQLM_KEYS_RootRow:SQLC_KEYS_Color4;    
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Right4 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
            SQLM_KEYS_NilRow-SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
            SQLM_KEYS_RootRow:SQLC_KEYS_Right4;    
    FI;
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Left4 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Left4=
            SQLM_KEYS_NilRow-SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Left4=
            SQLM_KEYS_RootRow:SQLC_KEYS_Left4;    
    FI;
    SQLM_KEYS_OperRow:SQLC_KEYS_Allocated=1;
END SQLS_KEYS_SAEDecrease;

BEGIN SQLS_KEYFIELDS_SAEDecrease;
    SQLM_KEYFIELDS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_KEYFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_KEYFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_KEYFIELDS_OperRow=
        SQLM_KEYFIELDS_GuardRow-SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2=
        SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Color2;    
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3=
        SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Color3;    
    IF SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Left2 =
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
            SQLM_KEYFIELDS_NilRow-SQLM_KEYFIELDS_WorkRow;
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
            SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Left2;
    FI;
    IF SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2 =
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
              SQLM_KEYFIELDS_NilRow-SQLM_KEYFIELDS_WorkRow;
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
            SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2;
    FI;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated=1;
! Move Nil Row !
    SQLM_KEYFIELDS_OperRow=
        SQLM_KEYFIELDS_NilRow-SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2=
        SQLM_KEYFIELDS_NilRow:SQLC_KEYFIELDS_Color2;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
        SQLM_KEYFIELDS_GuardRow-SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2 =
        SQLM_KEYFIELDS_GuardRow-SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3=
        SQLM_KEYFIELDS_NilRow:SQLC_KEYFIELDS_Color3;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
        SQLM_KEYFIELDS_GuardRow-SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3 =
        SQLM_KEYFIELDS_GuardRow-SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated=1;
! Move Root Row !
    SQLM_KEYFIELDS_OperRow=
        SQLM_KEYFIELDS_RootRow-SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2=
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Color2;    
    IF SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right2 =
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
            SQLM_KEYFIELDS_NilRow-SQLM_KEYFIELDS_WorkRow;    
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
            SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right2;    
    FI;
    IF SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left2 =
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
            SQLM_KEYFIELDS_NilRow-SQLM_KEYFIELDS_WorkRow;    
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
            SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left2;    
    FI;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3=
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Color3;    
    IF SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right3 =
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
            SQLM_KEYFIELDS_NilRow-SQLM_KEYFIELDS_WorkRow;    
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
            SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right3;    
    FI;
    IF SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left3 =
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3=
            SQLM_KEYFIELDS_NilRow-SQLM_KEYFIELDS_WorkRow;    
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3=
            SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left3;    
    FI;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated=1;
END SQLS_KEYFIELDS_SAEDecrease;

BEGIN SQLS_FOREIGNKEYS_SAEDecrease;
    SQLM_FOREIGNKEYS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_FOREIGNKEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_FOREIGNKEYS_OperRow=
        SQLM_FOREIGNKEYS_GuardRow-SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2=
        SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Color2;    
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3=
        SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Color3;    
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4=
        SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Color4;    
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5=
        SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Color5;    
    IF SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Left2 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
            SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
            SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Left2;
    FI;
    IF SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
              SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
            SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2;
    FI;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated=1;
! Move Nil Row !
    SQLM_FOREIGNKEYS_OperRow=
        SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2=
        SQLM_FOREIGNKEYS_NilRow:SQLC_FOREIGNKEYS_Color2;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
        SQLM_FOREIGNKEYS_GuardRow-SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2 =
        SQLM_FOREIGNKEYS_GuardRow-SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3=
        SQLM_FOREIGNKEYS_NilRow:SQLC_FOREIGNKEYS_Color3;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
        SQLM_FOREIGNKEYS_GuardRow-SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3 =
        SQLM_FOREIGNKEYS_GuardRow-SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4=
        SQLM_FOREIGNKEYS_NilRow:SQLC_FOREIGNKEYS_Color4;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
        SQLM_FOREIGNKEYS_GuardRow-SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4 =
        SQLM_FOREIGNKEYS_GuardRow-SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5=
        SQLM_FOREIGNKEYS_NilRow:SQLC_FOREIGNKEYS_Color5;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
        SQLM_FOREIGNKEYS_GuardRow-SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5 =
        SQLM_FOREIGNKEYS_GuardRow-SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated=1;
! Move Root Row !
    SQLM_FOREIGNKEYS_OperRow=
        SQLM_FOREIGNKEYS_RootRow-SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2=
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Color2;    
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right2 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
            SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right2;    
    FI;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left2 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
            SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left2;    
    FI;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3=
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Color3;    
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right3 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
            SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right3;    
    FI;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left3 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3=
            SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left3;    
    FI;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4=
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Color4;    
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right4 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
            SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right4;    
    FI;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left4 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4=
            SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left4;    
    FI;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5=
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Color5;    
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right5 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
            SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right5;    
    FI;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left5 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5=
            SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left5;    
    FI;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated=1;
END SQLS_FOREIGNKEYS_SAEDecrease;

BEGIN SQLS_SYMBOLS_SAEDecrease;
    SQLM_SYMBOLS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_SYMBOLS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_SYMBOLS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_SYMBOLS_OperRow=
        SQLM_SYMBOLS_GuardRow-SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2=
        SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Color2;    
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3=
        SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Color3;    
    IF SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Left2 =
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
            SQLM_SYMBOLS_NilRow-SQLM_SYMBOLS_WorkRow;
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
            SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Left2;
    FI;
    IF SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2 =
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
              SQLM_SYMBOLS_NilRow-SQLM_SYMBOLS_WorkRow;
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
            SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2;
    FI;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated=1;
! Move Nil Row !
    SQLM_SYMBOLS_OperRow=
        SQLM_SYMBOLS_NilRow-SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2=
        SQLM_SYMBOLS_NilRow:SQLC_SYMBOLS_Color2;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
        SQLM_SYMBOLS_GuardRow-SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2 =
        SQLM_SYMBOLS_GuardRow-SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3=
        SQLM_SYMBOLS_NilRow:SQLC_SYMBOLS_Color3;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
        SQLM_SYMBOLS_GuardRow-SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3 =
        SQLM_SYMBOLS_GuardRow-SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated=1;
! Move Root Row !
    SQLM_SYMBOLS_OperRow=
        SQLM_SYMBOLS_RootRow-SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2=
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Color2;    
    IF SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right2 =
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
            SQLM_SYMBOLS_NilRow-SQLM_SYMBOLS_WorkRow;    
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
            SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right2;    
    FI;
    IF SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left2 =
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
            SQLM_SYMBOLS_NilRow-SQLM_SYMBOLS_WorkRow;    
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
            SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left2;    
    FI;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3=
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Color3;    
    IF SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right3 =
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
            SQLM_SYMBOLS_NilRow-SQLM_SYMBOLS_WorkRow;    
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
            SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right3;    
    FI;
    IF SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left3 =
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3=
            SQLM_SYMBOLS_NilRow-SQLM_SYMBOLS_WorkRow;    
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3=
            SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left3;    
    FI;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated=1;
END SQLS_SYMBOLS_SAEDecrease;

BEGIN SQLS_TOWFAULTCODES_SAEDecrease;
    SQLM_TOWFAULTCODES_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TOWFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_TOWFAULTCODES_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_TOWFAULTCODES_OperRow=
        SQLM_TOWFAULTCODES_GuardRow-SQLM_TOWFAULTCODES_WorkRow;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2=
        SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Color2;    
    IF SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Left2 =
        SQLM_TOWFAULTCODES_NilRow
    THEN
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
            SQLM_TOWFAULTCODES_NilRow-SQLM_TOWFAULTCODES_WorkRow;
    ELSE
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
            SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Left2;
    FI;
    IF SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2 =
        SQLM_TOWFAULTCODES_NilRow
    THEN
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
              SQLM_TOWFAULTCODES_NilRow-SQLM_TOWFAULTCODES_WorkRow;
    ELSE
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
            SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2;
    FI;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated=1;
! Move Nil Row !
    SQLM_TOWFAULTCODES_OperRow=
        SQLM_TOWFAULTCODES_NilRow-SQLM_TOWFAULTCODES_WorkRow;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2=
        SQLM_TOWFAULTCODES_NilRow:SQLC_TOWFAULTCODES_Color2;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
        SQLM_TOWFAULTCODES_GuardRow-SQLM_TOWFAULTCODES_WorkRow;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2 =
        SQLM_TOWFAULTCODES_GuardRow-SQLM_TOWFAULTCODES_WorkRow;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated=1;
! Move Root Row !
    SQLM_TOWFAULTCODES_OperRow=
        SQLM_TOWFAULTCODES_RootRow-SQLM_TOWFAULTCODES_WorkRow;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2=
        SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Color2;    
    IF SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Right2 =
        SQLM_TOWFAULTCODES_NilRow
    THEN
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
            SQLM_TOWFAULTCODES_NilRow-SQLM_TOWFAULTCODES_WorkRow;    
    ELSE
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
            SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Right2;    
    FI;
    IF SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Left2 =
        SQLM_TOWFAULTCODES_NilRow
    THEN
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
            SQLM_TOWFAULTCODES_NilRow-SQLM_TOWFAULTCODES_WorkRow;    
    ELSE
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
            SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Left2;    
    FI;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated=1;
END SQLS_TOWFAULTCODES_SAEDecrease;

BEGIN SQLS_SYSFAULTCODES_SAEDecrease;
    SQLM_SYSFAULTCODES_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_SYSFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_SYSFAULTCODES_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_SYSFAULTCODES_OperRow=
        SQLM_SYSFAULTCODES_GuardRow-SQLM_SYSFAULTCODES_WorkRow;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2=
        SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Color2;    
    IF SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Left2 =
        SQLM_SYSFAULTCODES_NilRow
    THEN
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
            SQLM_SYSFAULTCODES_NilRow-SQLM_SYSFAULTCODES_WorkRow;
    ELSE
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
            SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Left2;
    FI;
    IF SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2 =
        SQLM_SYSFAULTCODES_NilRow
    THEN
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
              SQLM_SYSFAULTCODES_NilRow-SQLM_SYSFAULTCODES_WorkRow;
    ELSE
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
            SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2;
    FI;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated=1;
! Move Nil Row !
    SQLM_SYSFAULTCODES_OperRow=
        SQLM_SYSFAULTCODES_NilRow-SQLM_SYSFAULTCODES_WorkRow;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2=
        SQLM_SYSFAULTCODES_NilRow:SQLC_SYSFAULTCODES_Color2;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
        SQLM_SYSFAULTCODES_GuardRow-SQLM_SYSFAULTCODES_WorkRow;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2 =
        SQLM_SYSFAULTCODES_GuardRow-SQLM_SYSFAULTCODES_WorkRow;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated=1;
! Move Root Row !
    SQLM_SYSFAULTCODES_OperRow=
        SQLM_SYSFAULTCODES_RootRow-SQLM_SYSFAULTCODES_WorkRow;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2=
        SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Color2;    
    IF SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Right2 =
        SQLM_SYSFAULTCODES_NilRow
    THEN
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
            SQLM_SYSFAULTCODES_NilRow-SQLM_SYSFAULTCODES_WorkRow;    
    ELSE
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
            SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Right2;    
    FI;
    IF SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Left2 =
        SQLM_SYSFAULTCODES_NilRow
    THEN
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
            SQLM_SYSFAULTCODES_NilRow-SQLM_SYSFAULTCODES_WorkRow;    
    ELSE
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
            SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Left2;    
    FI;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated=1;
END SQLS_SYSFAULTCODES_SAEDecrease;

BEGIN SQLS_SYSTEMFIELDS_SAEDecrease;
    SQLM_SYSTEMFIELDS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_SYSTEMFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_SYSTEMFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_SYSTEMFIELDS_OperRow=
        SQLM_SYSTEMFIELDS_GuardRow-SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2=
        SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Color2;    
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3=
        SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Color3;    
    IF SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Left2 =
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
            SQLM_SYSTEMFIELDS_NilRow-SQLM_SYSTEMFIELDS_WorkRow;
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
            SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Left2;
    FI;
    IF SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2 =
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
              SQLM_SYSTEMFIELDS_NilRow-SQLM_SYSTEMFIELDS_WorkRow;
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
            SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2;
    FI;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated=1;
! Move Nil Row !
    SQLM_SYSTEMFIELDS_OperRow=
        SQLM_SYSTEMFIELDS_NilRow-SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2=
        SQLM_SYSTEMFIELDS_NilRow:SQLC_SYSTEMFIELDS_Color2;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
        SQLM_SYSTEMFIELDS_GuardRow-SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2 =
        SQLM_SYSTEMFIELDS_GuardRow-SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3=
        SQLM_SYSTEMFIELDS_NilRow:SQLC_SYSTEMFIELDS_Color3;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
        SQLM_SYSTEMFIELDS_GuardRow-SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3 =
        SQLM_SYSTEMFIELDS_GuardRow-SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated=1;
! Move Root Row !
    SQLM_SYSTEMFIELDS_OperRow=
        SQLM_SYSTEMFIELDS_RootRow-SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2=
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Color2;    
    IF SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right2 =
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
            SQLM_SYSTEMFIELDS_NilRow-SQLM_SYSTEMFIELDS_WorkRow;    
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
            SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right2;    
    FI;
    IF SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left2 =
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
            SQLM_SYSTEMFIELDS_NilRow-SQLM_SYSTEMFIELDS_WorkRow;    
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
            SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left2;    
    FI;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3=
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Color3;    
    IF SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right3 =
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
            SQLM_SYSTEMFIELDS_NilRow-SQLM_SYSTEMFIELDS_WorkRow;    
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
            SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right3;    
    FI;
    IF SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left3 =
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3=
            SQLM_SYSTEMFIELDS_NilRow-SQLM_SYSTEMFIELDS_WorkRow;    
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3=
            SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left3;    
    FI;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated=1;
END SQLS_SYSTEMFIELDS_SAEDecrease;

BEGIN SQLS_TEST1_SAEDecrease;
    SQLM_TEST1_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TEST1_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_TEST1_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_TEST1_OperRow=
        SQLM_TEST1_GuardRow-SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Color2=
        SQLM_TEST1_GuardRow:SQLC_TEST1_Color2;    
    SQLM_TEST1_OperRow:SQLC_TEST1_Color3=
        SQLM_TEST1_GuardRow:SQLC_TEST1_Color3;    
    IF SQLM_TEST1_GuardRow:SQLC_TEST1_Left2 =
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
            SQLM_TEST1_NilRow-SQLM_TEST1_WorkRow;
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
            SQLM_TEST1_GuardRow:SQLC_TEST1_Left2;
    FI;
    IF SQLM_TEST1_GuardRow:SQLC_TEST1_Right2 =
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
              SQLM_TEST1_NilRow-SQLM_TEST1_WorkRow;
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
            SQLM_TEST1_GuardRow:SQLC_TEST1_Right2;
    FI;
    SQLM_TEST1_OperRow:SQLC_TEST1_Allocated=1;
! Move Nil Row !
    SQLM_TEST1_OperRow=
        SQLM_TEST1_NilRow-SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Color2=
        SQLM_TEST1_NilRow:SQLC_TEST1_Color2;
    SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
        SQLM_TEST1_GuardRow-SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Left2 =
        SQLM_TEST1_GuardRow-SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Color3=
        SQLM_TEST1_NilRow:SQLC_TEST1_Color3;
    SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
        SQLM_TEST1_GuardRow-SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Left3 =
        SQLM_TEST1_GuardRow-SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Allocated=1;
! Move Root Row !
    SQLM_TEST1_OperRow=
        SQLM_TEST1_RootRow-SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Color2=
        SQLM_TEST1_RootRow:SQLC_TEST1_Color2;    
    IF SQLM_TEST1_RootRow:SQLC_TEST1_Right2 =
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
            SQLM_TEST1_NilRow-SQLM_TEST1_WorkRow;    
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
            SQLM_TEST1_RootRow:SQLC_TEST1_Right2;    
    FI;
    IF SQLM_TEST1_RootRow:SQLC_TEST1_Left2 =
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
            SQLM_TEST1_NilRow-SQLM_TEST1_WorkRow;    
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
            SQLM_TEST1_RootRow:SQLC_TEST1_Left2;    
    FI;
    SQLM_TEST1_OperRow:SQLC_TEST1_Color3=
        SQLM_TEST1_RootRow:SQLC_TEST1_Color3;    
    IF SQLM_TEST1_RootRow:SQLC_TEST1_Right3 =
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
            SQLM_TEST1_NilRow-SQLM_TEST1_WorkRow;    
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
            SQLM_TEST1_RootRow:SQLC_TEST1_Right3;    
    FI;
    IF SQLM_TEST1_RootRow:SQLC_TEST1_Left3 =
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Left3=
            SQLM_TEST1_NilRow-SQLM_TEST1_WorkRow;    
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Left3=
            SQLM_TEST1_RootRow:SQLC_TEST1_Left3;    
    FI;
    SQLM_TEST1_OperRow:SQLC_TEST1_Allocated=1;
END SQLS_TEST1_SAEDecrease;
SAE21L2)
    SQLM_TableReference=0;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE121;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 30 GOTO FAILURE121;
    IF SQLX_NewIndNum > 65000 GOTO FAILURE121;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE121;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE221;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Remove rows from free list !
        SQLM_PROGRAMS_NilRow=SQLM_TableReference:SQLM_System+1;
        SQLM_PROGRAMS_GuardRow=SQLM_TableReference:SQLM_System;
        SQLM_PROGRAMS_WorkRow=SQLM_PROGRAMS_GuardRow;
        SQLM_PROGRAMS_OperRow=
            SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2;
LOOP21)
        IF SQLM_PROGRAMS_OperRow = SQLM_PROGRAMS_NilRow
            GOTO EXIT21;
        IF SQLM_PROGRAMS_OperRow >= SQLX_NewIndNum THEN
            IF SQLM_PROGRAMS_WorkRow = SQLM_PROGRAMS_GuardRow THEN
                SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
            ELSE
                SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
            FI;
            SQLM_PROGRAMS_OperRow=
                SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
        ELSE
            SQLM_PROGRAMS_WorkRow=SQLM_PROGRAMS_OperRow;
            SQLM_PROGRAMS_OperRow=
                SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
        FI;
        GOTO LOOP21;
EXIT21)
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_PROGRAMS_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_PROGRAMS_SAEDecrease;
! Remap NIL pointers !
        SQLM_PROGRAMS_WorkRow=
            SQLM_PROGRAMS_NilRow-SQLM_PROGRAMS_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_PROGRAMS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_NilRow
                DO SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_WorkRow;
            FOR ALL SQLM_PROGRAMS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_NilRow
                DO SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE121)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE221)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE21L2)
    SQLM_TableReference=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE121;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 30 GOTO FAILURE121;
    IF SQLX_NewIndNum > 65000 GOTO FAILURE121;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE121;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE221;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TABLES_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_TABLES_SAEDecrease;
! Remap NIL pointers !
        SQLM_TABLES_WorkRow=
            SQLM_TABLES_NilRow-SQLM_TABLES_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_TABLES_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
                    SQLM_TABLES_NilRow
                DO SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
                    SQLM_TABLES_WorkRow;
            FOR ALL SQLM_TABLES_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
                    SQLM_TABLES_NilRow
                DO SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
                    SQLM_TABLES_WorkRow;
            FOR ALL SQLM_TABLES_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
                    SQLM_TABLES_NilRow
                DO SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
                    SQLM_TABLES_WorkRow;
            FOR ALL SQLM_TABLES_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Left4=
                    SQLM_TABLES_NilRow
                DO SQLM_TABLES_OperRow:SQLC_TABLES_Left4=
                    SQLM_TABLES_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE121)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE221)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE1L2)
    SQLM_TableReference=2;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE11;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 200 GOTO FAILURE11;
    IF SQLX_NewIndNum > 65000 GOTO FAILURE11;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE11;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE21;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_FIELDS_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_FIELDS_SAEDecrease;
! Remap NIL pointers !
        SQLM_FIELDS_WorkRow=
            SQLM_FIELDS_NilRow-SQLM_FIELDS_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_WorkRow;
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_WorkRow;
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_WorkRow;
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_WorkRow;
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_WorkRow;
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE11)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE21)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE3L2)
    SQLM_TableReference=3;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE13;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE13;
    IF SQLX_NewIndNum > 30 GOTO FAILURE13;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE13;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE23;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Remove rows from free list !
        SQLM_KEYS_NilRow=SQLM_TableReference:SQLM_System+1;
        SQLM_KEYS_GuardRow=SQLM_TableReference:SQLM_System;
        SQLM_KEYS_WorkRow=SQLM_KEYS_GuardRow;
        SQLM_KEYS_OperRow=
            SQLM_KEYS_GuardRow:SQLC_KEYS_Right2;
LOOP3)
        IF SQLM_KEYS_OperRow = SQLM_KEYS_NilRow
            GOTO EXIT3;
        IF SQLM_KEYS_OperRow >= SQLX_NewIndNum THEN
            IF SQLM_KEYS_WorkRow = SQLM_KEYS_GuardRow THEN
                SQLM_KEYS_WorkRow:SQLC_KEYS_Right2=
                    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
            ELSE
                SQLM_KEYS_WorkRow:SQLC_KEYS_Left2=
                    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
            FI;
            SQLM_KEYS_OperRow=
                SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
        ELSE
            SQLM_KEYS_WorkRow=SQLM_KEYS_OperRow;
            SQLM_KEYS_OperRow=
                SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
        FI;
        GOTO LOOP3;
EXIT3)
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_KEYS_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_KEYS_SAEDecrease;
! Remap NIL pointers !
        SQLM_KEYS_WorkRow=
            SQLM_KEYS_NilRow-SQLM_KEYS_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
                    SQLM_KEYS_WorkRow;
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
                    SQLM_KEYS_WorkRow;
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
                    SQLM_KEYS_WorkRow;
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Left3=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Left3=
                    SQLM_KEYS_WorkRow;
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
                    SQLM_KEYS_WorkRow;
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Left4=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Left4=
                    SQLM_KEYS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE13)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE23)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE5L2)
    SQLM_TableReference=4;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE15;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE15;
    IF SQLX_NewIndNum > 30 GOTO FAILURE15;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE15;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE25;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Remove rows from free list !
        SQLM_KEYFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
        SQLM_KEYFIELDS_GuardRow=SQLM_TableReference:SQLM_System;
        SQLM_KEYFIELDS_WorkRow=SQLM_KEYFIELDS_GuardRow;
        SQLM_KEYFIELDS_OperRow=
            SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2;
LOOP5)
        IF SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_NilRow
            GOTO EXIT5;
        IF SQLM_KEYFIELDS_OperRow >= SQLX_NewIndNum THEN
            IF SQLM_KEYFIELDS_WorkRow = SQLM_KEYFIELDS_GuardRow THEN
                SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
            ELSE
                SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
            FI;
            SQLM_KEYFIELDS_OperRow=
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
        ELSE
            SQLM_KEYFIELDS_WorkRow=SQLM_KEYFIELDS_OperRow;
            SQLM_KEYFIELDS_OperRow=
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
        FI;
        GOTO LOOP5;
EXIT5)
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_KEYFIELDS_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_KEYFIELDS_SAEDecrease;
! Remap NIL pointers !
        SQLM_KEYFIELDS_WorkRow=
            SQLM_KEYFIELDS_NilRow-SQLM_KEYFIELDS_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_KEYFIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_NilRow
                DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_WorkRow;
            FOR ALL SQLM_KEYFIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_NilRow
                DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_WorkRow;
            FOR ALL SQLM_KEYFIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_NilRow
                DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_WorkRow;
            FOR ALL SQLM_KEYFIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_NilRow
                DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE15)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE25)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE7L2)
    SQLM_TableReference=5;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE17;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 30 GOTO FAILURE17;
    IF SQLX_NewIndNum > 65000 GOTO FAILURE17;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE17;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE27;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Remove rows from free list !
        SQLM_FOREIGNKEYS_NilRow=SQLM_TableReference:SQLM_System+1;
        SQLM_FOREIGNKEYS_GuardRow=SQLM_TableReference:SQLM_System;
        SQLM_FOREIGNKEYS_WorkRow=SQLM_FOREIGNKEYS_GuardRow;
        SQLM_FOREIGNKEYS_OperRow=
            SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2;
LOOP7)
        IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow
            GOTO EXIT7;
        IF SQLM_FOREIGNKEYS_OperRow >= SQLX_NewIndNum THEN
            IF SQLM_FOREIGNKEYS_WorkRow = SQLM_FOREIGNKEYS_GuardRow THEN
                SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
            ELSE
                SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
            FI;
            SQLM_FOREIGNKEYS_OperRow=
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
        ELSE
            SQLM_FOREIGNKEYS_WorkRow=SQLM_FOREIGNKEYS_OperRow;
            SQLM_FOREIGNKEYS_OperRow=
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
        FI;
        GOTO LOOP7;
EXIT7)
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_FOREIGNKEYS_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_FOREIGNKEYS_SAEDecrease;
! Remap NIL pointers !
        SQLM_FOREIGNKEYS_WorkRow=
            SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE17)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE27)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE9L2)
    SQLM_TableReference=6;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE19;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE19;
    IF SQLX_NewIndNum > 30 GOTO FAILURE19;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE19;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE29;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Remove rows from free list !
        SQLM_SYMBOLS_NilRow=SQLM_TableReference:SQLM_System+1;
        SQLM_SYMBOLS_GuardRow=SQLM_TableReference:SQLM_System;
        SQLM_SYMBOLS_WorkRow=SQLM_SYMBOLS_GuardRow;
        SQLM_SYMBOLS_OperRow=
            SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2;
LOOP9)
        IF SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_NilRow
            GOTO EXIT9;
        IF SQLM_SYMBOLS_OperRow >= SQLX_NewIndNum THEN
            IF SQLM_SYMBOLS_WorkRow = SQLM_SYMBOLS_GuardRow THEN
                SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
            ELSE
                SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
            FI;
            SQLM_SYMBOLS_OperRow=
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
        ELSE
            SQLM_SYMBOLS_WorkRow=SQLM_SYMBOLS_OperRow;
            SQLM_SYMBOLS_OperRow=
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
        FI;
        GOTO LOOP9;
EXIT9)
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYMBOLS_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYMBOLS_SAEDecrease;
! Remap NIL pointers !
        SQLM_SYMBOLS_WorkRow=
            SQLM_SYMBOLS_NilRow-SQLM_SYMBOLS_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_SYMBOLS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_NilRow
                DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_WorkRow;
            FOR ALL SQLM_SYMBOLS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_NilRow
                DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_WorkRow;
            FOR ALL SQLM_SYMBOLS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_NilRow
                DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_WorkRow;
            FOR ALL SQLM_SYMBOLS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_NilRow
                DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE19)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE29)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE13L2)
    SQLM_TableReference=7;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE113;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE113;
    IF SQLX_NewIndNum > 30 GOTO FAILURE113;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE113;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE213;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Remove rows from free list !
        SQLM_TOWFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
        SQLM_TOWFAULTCODES_GuardRow=SQLM_TableReference:SQLM_System;
        SQLM_TOWFAULTCODES_WorkRow=SQLM_TOWFAULTCODES_GuardRow;
        SQLM_TOWFAULTCODES_OperRow=
            SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2;
LOOP13)
        IF SQLM_TOWFAULTCODES_OperRow = SQLM_TOWFAULTCODES_NilRow
            GOTO EXIT13;
        IF SQLM_TOWFAULTCODES_OperRow >= SQLX_NewIndNum THEN
            IF SQLM_TOWFAULTCODES_WorkRow = SQLM_TOWFAULTCODES_GuardRow THEN
                SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
            ELSE
                SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
            FI;
            SQLM_TOWFAULTCODES_OperRow=
                SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
        ELSE
            SQLM_TOWFAULTCODES_WorkRow=SQLM_TOWFAULTCODES_OperRow;
            SQLM_TOWFAULTCODES_OperRow=
                SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
        FI;
        GOTO LOOP13;
EXIT13)
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TOWFAULTCODES_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_TOWFAULTCODES_SAEDecrease;
! Remap NIL pointers !
        SQLM_TOWFAULTCODES_WorkRow=
            SQLM_TOWFAULTCODES_NilRow-SQLM_TOWFAULTCODES_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_TOWFAULTCODES_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_NilRow
                DO SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_WorkRow;
            FOR ALL SQLM_TOWFAULTCODES_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_NilRow
                DO SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE113)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE213)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE15L2)
    SQLM_TableReference=8;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE115;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE115;
    IF SQLX_NewIndNum > 65000 GOTO FAILURE115;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE115;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE215;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Remove rows from free list !
        SQLM_SYSFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
        SQLM_SYSFAULTCODES_GuardRow=SQLM_TableReference:SQLM_System;
        SQLM_SYSFAULTCODES_WorkRow=SQLM_SYSFAULTCODES_GuardRow;
        SQLM_SYSFAULTCODES_OperRow=
            SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2;
LOOP15)
        IF SQLM_SYSFAULTCODES_OperRow = SQLM_SYSFAULTCODES_NilRow
            GOTO EXIT15;
        IF SQLM_SYSFAULTCODES_OperRow >= SQLX_NewIndNum THEN
            IF SQLM_SYSFAULTCODES_WorkRow = SQLM_SYSFAULTCODES_GuardRow THEN
                SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
            ELSE
                SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
            FI;
            SQLM_SYSFAULTCODES_OperRow=
                SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
        ELSE
            SQLM_SYSFAULTCODES_WorkRow=SQLM_SYSFAULTCODES_OperRow;
            SQLM_SYSFAULTCODES_OperRow=
                SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
        FI;
        GOTO LOOP15;
EXIT15)
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYSFAULTCODES_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYSFAULTCODES_SAEDecrease;
! Remap NIL pointers !
        SQLM_SYSFAULTCODES_WorkRow=
            SQLM_SYSFAULTCODES_NilRow-SQLM_SYSFAULTCODES_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_SYSFAULTCODES_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_NilRow
                DO SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_WorkRow;
            FOR ALL SQLM_SYSFAULTCODES_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_NilRow
                DO SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE115)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE215)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE19L2)
    SQLM_TableReference=9;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE119;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE119;
    IF SQLX_NewIndNum > 65000 GOTO FAILURE119;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE119;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE219;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Remove rows from free list !
        SQLM_SYSTEMFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
        SQLM_SYSTEMFIELDS_GuardRow=SQLM_TableReference:SQLM_System;
        SQLM_SYSTEMFIELDS_WorkRow=SQLM_SYSTEMFIELDS_GuardRow;
        SQLM_SYSTEMFIELDS_OperRow=
            SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2;
LOOP19)
        IF SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_NilRow
            GOTO EXIT19;
        IF SQLM_SYSTEMFIELDS_OperRow >= SQLX_NewIndNum THEN
            IF SQLM_SYSTEMFIELDS_WorkRow = SQLM_SYSTEMFIELDS_GuardRow THEN
                SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
            ELSE
                SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
            FI;
            SQLM_SYSTEMFIELDS_OperRow=
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
        ELSE
            SQLM_SYSTEMFIELDS_WorkRow=SQLM_SYSTEMFIELDS_OperRow;
            SQLM_SYSTEMFIELDS_OperRow=
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
        FI;
        GOTO LOOP19;
EXIT19)
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYSTEMFIELDS_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYSTEMFIELDS_SAEDecrease;
! Remap NIL pointers !
        SQLM_SYSTEMFIELDS_WorkRow=
            SQLM_SYSTEMFIELDS_NilRow-SQLM_SYSTEMFIELDS_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_SYSTEMFIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_NilRow
                DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_WorkRow;
            FOR ALL SQLM_SYSTEMFIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_NilRow
                DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_WorkRow;
            FOR ALL SQLM_SYSTEMFIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_NilRow
                DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_WorkRow;
            FOR ALL SQLM_SYSTEMFIELDS_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_NilRow
                DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE119)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE219)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE10L2)
    SQLM_TableReference=10;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE110;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE110;
    IF SQLX_NewIndNum > 65000 GOTO FAILURE110;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE110;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE210;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Remove rows from free list !
        SQLM_TEST1_NilRow=SQLM_TableReference:SQLM_System+1;
        SQLM_TEST1_GuardRow=SQLM_TableReference:SQLM_System;
        SQLM_TEST1_WorkRow=SQLM_TEST1_GuardRow;
        SQLM_TEST1_OperRow=
            SQLM_TEST1_GuardRow:SQLC_TEST1_Right2;
LOOP10)
        IF SQLM_TEST1_OperRow = SQLM_TEST1_NilRow
            GOTO EXIT10;
        IF SQLM_TEST1_OperRow >= SQLX_NewIndNum THEN
            IF SQLM_TEST1_WorkRow = SQLM_TEST1_GuardRow THEN
                SQLM_TEST1_WorkRow:SQLC_TEST1_Right2=
                    SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
            ELSE
                SQLM_TEST1_WorkRow:SQLC_TEST1_Left2=
                    SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
            FI;
            SQLM_TEST1_OperRow=
                SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
        ELSE
            SQLM_TEST1_WorkRow=SQLM_TEST1_OperRow;
            SQLM_TEST1_OperRow=
                SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
        FI;
        GOTO LOOP10;
EXIT10)
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TEST1_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_TEST1_SAEDecrease;
! Remap NIL pointers !
        SQLM_TEST1_WorkRow=
            SQLM_TEST1_NilRow-SQLM_TEST1_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_TEST1_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
                    SQLM_TEST1_NilRow
                DO SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
                    SQLM_TEST1_WorkRow;
            FOR ALL SQLM_TEST1_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
                    SQLM_TEST1_NilRow
                DO SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
                    SQLM_TEST1_WorkRow;
            FOR ALL SQLM_TEST1_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
                    SQLM_TEST1_NilRow
                DO SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
                    SQLM_TEST1_WorkRow;
            FOR ALL SQLM_TEST1_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Left3=
                    SQLM_TEST1_NilRow
                DO SQLM_TEST1_OperRow:SQLC_TEST1_Left3=
                    SQLM_TEST1_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE110)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE210)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE22L2)
    SQLM_TableReference=0;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE121;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE122;
    IF SQLX_NewIndNum > 500 GOTO FAILURE122;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE222;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_PROGRAMS_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_PROGRAMS_SAEDecrease;
! Remap NIL pointers !
        SQLM_PROGRAMS_WorkRow=
            SQLM_PROGRAMS_NilRow-SQLM_PROGRAMS_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_PROGRAMS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_NilRow
                DO SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_WorkRow;
            FOR ALL SQLM_PROGRAMS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_NilRow
                DO SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE122)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE222)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE22L2)
    SQLM_TableReference=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE121;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE122;
    IF SQLX_NewIndNum > 500 GOTO FAILURE122;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE222;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TABLES_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_TABLES_SAEDecrease;
! Remap NIL pointers !
        SQLM_TABLES_WorkRow=
            SQLM_TABLES_NilRow-SQLM_TABLES_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_TABLES_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
                    SQLM_TABLES_NilRow
                DO SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
                    SQLM_TABLES_WorkRow;
            FOR ALL SQLM_TABLES_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
                    SQLM_TABLES_NilRow
                DO SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
                    SQLM_TABLES_WorkRow;
            FOR ALL SQLM_TABLES_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
                    SQLM_TABLES_NilRow
                DO SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
                    SQLM_TABLES_WorkRow;
            FOR ALL SQLM_TABLES_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Left4=
                    SQLM_TABLES_NilRow
                DO SQLM_TABLES_OperRow:SQLC_TABLES_Left4=
                    SQLM_TABLES_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE122)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE222)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE2L2)
    SQLM_TableReference=2;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE11;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE12;
    IF SQLX_NewIndNum > 500 GOTO FAILURE12;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE22;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_FIELDS_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_FIELDS_SAEDecrease;
! Remap NIL pointers !
        SQLM_FIELDS_WorkRow=
            SQLM_FIELDS_NilRow-SQLM_FIELDS_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_WorkRow;
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_WorkRow;
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_WorkRow;
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_WorkRow;
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_WorkRow;
            FOR ALL SQLM_FIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_NilRow
                DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE12)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE22)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE4L2)
    SQLM_TableReference=3;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE13;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE14;
    IF SQLX_NewIndNum > 500 GOTO FAILURE14;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE24;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_KEYS_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_KEYS_SAEDecrease;
! Remap NIL pointers !
        SQLM_KEYS_WorkRow=
            SQLM_KEYS_NilRow-SQLM_KEYS_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
                    SQLM_KEYS_WorkRow;
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
                    SQLM_KEYS_WorkRow;
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
                    SQLM_KEYS_WorkRow;
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Left3=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Left3=
                    SQLM_KEYS_WorkRow;
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
                    SQLM_KEYS_WorkRow;
            FOR ALL SQLM_KEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Left4=
                    SQLM_KEYS_NilRow
                DO SQLM_KEYS_OperRow:SQLC_KEYS_Left4=
                    SQLM_KEYS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE14)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE24)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE6L2)
    SQLM_TableReference=4;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE15;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE16;
    IF SQLX_NewIndNum > 500 GOTO FAILURE16;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE26;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_KEYFIELDS_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_KEYFIELDS_SAEDecrease;
! Remap NIL pointers !
        SQLM_KEYFIELDS_WorkRow=
            SQLM_KEYFIELDS_NilRow-SQLM_KEYFIELDS_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_KEYFIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_NilRow
                DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_WorkRow;
            FOR ALL SQLM_KEYFIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_NilRow
                DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_WorkRow;
            FOR ALL SQLM_KEYFIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_NilRow
                DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_WorkRow;
            FOR ALL SQLM_KEYFIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_NilRow
                DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE16)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE26)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE8L2)
    SQLM_TableReference=5;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE17;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE18;
    IF SQLX_NewIndNum > 500 GOTO FAILURE18;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE28;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_FOREIGNKEYS_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_FOREIGNKEYS_SAEDecrease;
! Remap NIL pointers !
        SQLM_FOREIGNKEYS_WorkRow=
            SQLM_FOREIGNKEYS_NilRow-SQLM_FOREIGNKEYS_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_WorkRow;
            FOR ALL SQLM_FOREIGNKEYS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_NilRow
                DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE18)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE28)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE10L2)
    SQLM_TableReference=6;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE19;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE110;
    IF SQLX_NewIndNum > 500 GOTO FAILURE110;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE210;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYMBOLS_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYMBOLS_SAEDecrease;
! Remap NIL pointers !
        SQLM_SYMBOLS_WorkRow=
            SQLM_SYMBOLS_NilRow-SQLM_SYMBOLS_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_SYMBOLS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_NilRow
                DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_WorkRow;
            FOR ALL SQLM_SYMBOLS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_NilRow
                DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_WorkRow;
            FOR ALL SQLM_SYMBOLS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_NilRow
                DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_WorkRow;
            FOR ALL SQLM_SYMBOLS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_NilRow
                DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE110)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE210)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE14L2)
    SQLM_TableReference=7;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE113;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE114;
    IF SQLX_NewIndNum > 500 GOTO FAILURE114;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE214;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TOWFAULTCODES_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_TOWFAULTCODES_SAEDecrease;
! Remap NIL pointers !
        SQLM_TOWFAULTCODES_WorkRow=
            SQLM_TOWFAULTCODES_NilRow-SQLM_TOWFAULTCODES_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_TOWFAULTCODES_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_NilRow
                DO SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_WorkRow;
            FOR ALL SQLM_TOWFAULTCODES_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_NilRow
                DO SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE114)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE214)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE16L2)
    SQLM_TableReference=8;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE115;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE116;
    IF SQLX_NewIndNum > 500 GOTO FAILURE116;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE216;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYSFAULTCODES_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYSFAULTCODES_SAEDecrease;
! Remap NIL pointers !
        SQLM_SYSFAULTCODES_WorkRow=
            SQLM_SYSFAULTCODES_NilRow-SQLM_SYSFAULTCODES_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_SYSFAULTCODES_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_NilRow
                DO SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_WorkRow;
            FOR ALL SQLM_SYSFAULTCODES_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_NilRow
                DO SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE116)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE216)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE20L2)
    SQLM_TableReference=9;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE119;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE120;
    IF SQLX_NewIndNum > 500 GOTO FAILURE120;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE220;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYSTEMFIELDS_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYSTEMFIELDS_SAEDecrease;
! Remap NIL pointers !
        SQLM_SYSTEMFIELDS_WorkRow=
            SQLM_SYSTEMFIELDS_NilRow-SQLM_SYSTEMFIELDS_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_SYSTEMFIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_NilRow
                DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_WorkRow;
            FOR ALL SQLM_SYSTEMFIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_NilRow
                DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_WorkRow;
            FOR ALL SQLM_SYSTEMFIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_NilRow
                DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_WorkRow;
            FOR ALL SQLM_SYSTEMFIELDS_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_NilRow
                DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE120)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE220)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE20L2)
    SQLM_TableReference=10;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE110;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE120;
    IF SQLX_NewIndNum > 500 GOTO FAILURE120;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE220;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TEST1_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_TEST1_SAEDecrease;
! Remap NIL pointers !
        SQLM_TEST1_WorkRow=
            SQLM_TEST1_NilRow-SQLM_TEST1_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_TEST1_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
                    SQLM_TEST1_NilRow
                DO SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
                    SQLM_TEST1_WorkRow;
            FOR ALL SQLM_TEST1_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
                    SQLM_TEST1_NilRow
                DO SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
                    SQLM_TEST1_WorkRow;
            FOR ALL SQLM_TEST1_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
                    SQLM_TEST1_NilRow
                DO SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
                    SQLM_TEST1_WorkRow;
            FOR ALL SQLM_TEST1_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Left3=
                    SQLM_TEST1_NilRow
                DO SQLM_TEST1_OperRow:SQLC_TEST1_Left3=
                    SQLM_TEST1_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE120)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE220)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
!------------------------------------------------!
!       comSetFsSae !
!------------------------------------------------!

BEGIN SQLS_PROGRAMS_SAEIncrease;
    SQLM_PROGRAMS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_PROGRAMS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_PROGRAMS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_PROGRAMS_OperRow=
        SQLM_PROGRAMS_GuardRow+SQLM_PROGRAMS_WorkRow;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2=
        SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Color2;    
    IF SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Left2=
        SQLM_PROGRAMS_NilRow
    THEN
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
            SQLM_PROGRAMS_NilRow+SQLM_PROGRAMS_WorkRow;
    ELSE
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
            SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Left2;
    FI;
    IF SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2=
        SQLM_PROGRAMS_NilRow
    THEN
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
            SQLM_PROGRAMS_NilRow+SQLM_PROGRAMS_WorkRow;
    ELSE
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
            SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2;
    FI;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated=1;
! Move Nil Row !
    SQLM_PROGRAMS_OperRow=
        SQLM_PROGRAMS_NilRow+SQLM_PROGRAMS_WorkRow;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2=
        SQLM_PROGRAMS_NilRow:SQLC_PROGRAMS_Color2;    
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
        SQLM_PROGRAMS_GuardRow+SQLM_PROGRAMS_WorkRow;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2 =
        SQLM_PROGRAMS_GuardRow+SQLM_PROGRAMS_WorkRow;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated=1;
! Move Root Row !
    SQLM_PROGRAMS_OperRow=
        SQLM_PROGRAMS_RootRow+SQLM_PROGRAMS_WorkRow;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2=
        SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Color2;    
    IF SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Right2 =
        SQLM_PROGRAMS_NilRow
    THEN
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
            SQLM_PROGRAMS_NilRow+SQLM_PROGRAMS_WorkRow;    
    ELSE
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
            SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Right2;    
    FI;
    IF SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Left2 =
        SQLM_PROGRAMS_NilRow
    THEN
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
            SQLM_PROGRAMS_NilRow+SQLM_PROGRAMS_WorkRow;    
    ELSE
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
            SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Left2;    
    FI;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_PROGRAMS_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_PROGRAMS_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_PROGRAMS_SAEClear;
! Remap NIL pointers !
    SQLM_PROGRAMS_WorkRow=
        SQLM_PROGRAMS_WorkRow+SQLM_PROGRAMS_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_PROGRAMS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
                SQLM_PROGRAMS_NilRow
            DO SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=
                SQLM_PROGRAMS_WorkRow;
        FOR ALL SQLM_PROGRAMS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
                SQLM_PROGRAMS_NilRow
            DO SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
                SQLM_PROGRAMS_WorkRow;
    FI;
END SQLS_PROGRAMS_SAEIncrease;

BEGIN SQLS_PROGRAMS_SAEClear;
! Clear allocate bit. !
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated=0;
! Clear btree pointers. !
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=0;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2=0;
END SQLS_PROGRAMS_SAEClear;

BEGIN SQLS_TABLES_SAEIncrease;
    SQLM_TABLES_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TABLES_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_TABLES_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_TABLES_OperRow=
        SQLM_TABLES_GuardRow+SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Color3=
        SQLM_TABLES_GuardRow:SQLC_TABLES_Color3;    
    SQLM_TABLES_OperRow:SQLC_TABLES_Color4=
        SQLM_TABLES_GuardRow:SQLC_TABLES_Color4;    
    IF SQLM_TABLES_GuardRow:SQLC_TABLES_Left3=
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
            SQLM_TABLES_NilRow+SQLM_TABLES_WorkRow;
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
            SQLM_TABLES_GuardRow:SQLC_TABLES_Left3;
    FI;
    IF SQLM_TABLES_GuardRow:SQLC_TABLES_Right3=
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
            SQLM_TABLES_NilRow+SQLM_TABLES_WorkRow;
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
            SQLM_TABLES_GuardRow:SQLC_TABLES_Right3;
    FI;
    SQLM_TABLES_OperRow:SQLC_TABLES_Allocated=1;
! Move Nil Row !
    SQLM_TABLES_OperRow=
        SQLM_TABLES_NilRow+SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Color3=
        SQLM_TABLES_NilRow:SQLC_TABLES_Color3;    
    SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
        SQLM_TABLES_GuardRow+SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Left3 =
        SQLM_TABLES_GuardRow+SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Color4=
        SQLM_TABLES_NilRow:SQLC_TABLES_Color4;    
    SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
        SQLM_TABLES_GuardRow+SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Left4 =
        SQLM_TABLES_GuardRow+SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Allocated=1;
! Move Root Row !
    SQLM_TABLES_OperRow=
        SQLM_TABLES_RootRow+SQLM_TABLES_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_Color3=
        SQLM_TABLES_RootRow:SQLC_TABLES_Color3;    
    IF SQLM_TABLES_RootRow:SQLC_TABLES_Right3 =
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
            SQLM_TABLES_NilRow+SQLM_TABLES_WorkRow;    
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
            SQLM_TABLES_RootRow:SQLC_TABLES_Right3;    
    FI;
    IF SQLM_TABLES_RootRow:SQLC_TABLES_Left3 =
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
            SQLM_TABLES_NilRow+SQLM_TABLES_WorkRow;    
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
            SQLM_TABLES_RootRow:SQLC_TABLES_Left3;    
    FI;
    SQLM_TABLES_OperRow:SQLC_TABLES_Color4=
        SQLM_TABLES_RootRow:SQLC_TABLES_Color4;    
    IF SQLM_TABLES_RootRow:SQLC_TABLES_Right4 =
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
            SQLM_TABLES_NilRow+SQLM_TABLES_WorkRow;    
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
            SQLM_TABLES_RootRow:SQLC_TABLES_Right4;    
    FI;
    IF SQLM_TABLES_RootRow:SQLC_TABLES_Left4 =
        SQLM_TABLES_NilRow
    THEN
        SQLM_TABLES_OperRow:SQLC_TABLES_Left4=
            SQLM_TABLES_NilRow+SQLM_TABLES_WorkRow;    
    ELSE
        SQLM_TABLES_OperRow:SQLC_TABLES_Left4=
            SQLM_TABLES_RootRow:SQLC_TABLES_Left4;    
    FI;
    SQLM_TABLES_OperRow:SQLC_TABLES_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_TABLES_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_TABLES_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_TABLES_SAEClear;
! Remap NIL pointers !
    SQLM_TABLES_WorkRow=
        SQLM_TABLES_WorkRow+SQLM_TABLES_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_TABLES_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
                SQLM_TABLES_NilRow
            DO SQLM_TABLES_OperRow:SQLC_TABLES_Right3=
                SQLM_TABLES_WorkRow;
        FOR ALL SQLM_TABLES_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
                SQLM_TABLES_NilRow
            DO SQLM_TABLES_OperRow:SQLC_TABLES_Left3=
                SQLM_TABLES_WorkRow;
        FOR ALL SQLM_TABLES_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
                SQLM_TABLES_NilRow
            DO SQLM_TABLES_OperRow:SQLC_TABLES_Right4=
                SQLM_TABLES_WorkRow;
        FOR ALL SQLM_TABLES_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Left4=
                SQLM_TABLES_NilRow
            DO SQLM_TABLES_OperRow:SQLC_TABLES_Left4=
                SQLM_TABLES_WorkRow;
    FI;
END SQLS_TABLES_SAEIncrease;

BEGIN SQLS_TABLES_SAEClear;
! Clear allocate bit. !
    SQLM_TABLES_OperRow:SQLC_TABLES_Allocated=0;
! Clear btree pointers. !
    SQLM_TABLES_OperRow:SQLC_TABLES_Left3=0;
    SQLM_TABLES_OperRow:SQLC_TABLES_Right3=0;
    SQLM_TABLES_OperRow:SQLC_TABLES_Left4=0;
    SQLM_TABLES_OperRow:SQLC_TABLES_Right4=0;
END SQLS_TABLES_SAEClear;

BEGIN SQLS_FIELDS_SAEIncrease;
    SQLM_FIELDS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_FIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_FIELDS_OperRow=
        SQLM_FIELDS_GuardRow+SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3=
        SQLM_FIELDS_GuardRow:SQLC_FIELDS_Color3;    
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4=
        SQLM_FIELDS_GuardRow:SQLC_FIELDS_Color4;    
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5=
        SQLM_FIELDS_GuardRow:SQLC_FIELDS_Color5;    
    IF SQLM_FIELDS_GuardRow:SQLC_FIELDS_Left3=
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
            SQLM_FIELDS_NilRow+SQLM_FIELDS_WorkRow;
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
            SQLM_FIELDS_GuardRow:SQLC_FIELDS_Left3;
    FI;
    IF SQLM_FIELDS_GuardRow:SQLC_FIELDS_Right3=
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
            SQLM_FIELDS_NilRow+SQLM_FIELDS_WorkRow;
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
            SQLM_FIELDS_GuardRow:SQLC_FIELDS_Right3;
    FI;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated=1;
! Move Nil Row !
    SQLM_FIELDS_OperRow=
        SQLM_FIELDS_NilRow+SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3=
        SQLM_FIELDS_NilRow:SQLC_FIELDS_Color3;    
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
        SQLM_FIELDS_GuardRow+SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3 =
        SQLM_FIELDS_GuardRow+SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4=
        SQLM_FIELDS_NilRow:SQLC_FIELDS_Color4;    
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
        SQLM_FIELDS_GuardRow+SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4 =
        SQLM_FIELDS_GuardRow+SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5=
        SQLM_FIELDS_NilRow:SQLC_FIELDS_Color5;    
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
        SQLM_FIELDS_GuardRow+SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5 =
        SQLM_FIELDS_GuardRow+SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated=1;
! Move Root Row !
    SQLM_FIELDS_OperRow=
        SQLM_FIELDS_RootRow+SQLM_FIELDS_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3=
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Color3;    
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Right3 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
            SQLM_FIELDS_NilRow+SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Right3;    
    FI;
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Left3 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
            SQLM_FIELDS_NilRow+SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Left3;    
    FI;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4=
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Color4;    
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Right4 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
            SQLM_FIELDS_NilRow+SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Right4;    
    FI;
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Left4 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4=
            SQLM_FIELDS_NilRow+SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Left4;    
    FI;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5=
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Color5;    
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Right5 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
            SQLM_FIELDS_NilRow+SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Right5;    
    FI;
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Left5 =
        SQLM_FIELDS_NilRow
    THEN
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5=
            SQLM_FIELDS_NilRow+SQLM_FIELDS_WorkRow;    
    ELSE
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5=
            SQLM_FIELDS_RootRow:SQLC_FIELDS_Left5;    
    FI;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_FIELDS_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_FIELDS_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_FIELDS_SAEClear;
! Remap NIL pointers !
    SQLM_FIELDS_WorkRow=
        SQLM_FIELDS_WorkRow+SQLM_FIELDS_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_FIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
                SQLM_FIELDS_NilRow
            DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=
                SQLM_FIELDS_WorkRow;
        FOR ALL SQLM_FIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
                SQLM_FIELDS_NilRow
            DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=
                SQLM_FIELDS_WorkRow;
        FOR ALL SQLM_FIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
                SQLM_FIELDS_NilRow
            DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=
                SQLM_FIELDS_WorkRow;
        FOR ALL SQLM_FIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4=
                SQLM_FIELDS_NilRow
            DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4=
                SQLM_FIELDS_WorkRow;
        FOR ALL SQLM_FIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
                SQLM_FIELDS_NilRow
            DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=
                SQLM_FIELDS_WorkRow;
        FOR ALL SQLM_FIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5=
                SQLM_FIELDS_NilRow
            DO SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5=
                SQLM_FIELDS_WorkRow;
    FI;
END SQLS_FIELDS_SAEIncrease;

BEGIN SQLS_FIELDS_SAEClear;
! Clear allocate bit. !
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated=0;
! Clear btree pointers. !
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3=0;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3=0;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4=0;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4=0;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5=0;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5=0;
END SQLS_FIELDS_SAEClear;

BEGIN SQLS_KEYS_SAEIncrease;
    SQLM_KEYS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_KEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_KEYS_OperRow=
        SQLM_KEYS_GuardRow+SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color2=
        SQLM_KEYS_GuardRow:SQLC_KEYS_Color2;    
    SQLM_KEYS_OperRow:SQLC_KEYS_Color3=
        SQLM_KEYS_GuardRow:SQLC_KEYS_Color3;    
    SQLM_KEYS_OperRow:SQLC_KEYS_Color4=
        SQLM_KEYS_GuardRow:SQLC_KEYS_Color4;    
    IF SQLM_KEYS_GuardRow:SQLC_KEYS_Left2=
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
            SQLM_KEYS_NilRow+SQLM_KEYS_WorkRow;
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
            SQLM_KEYS_GuardRow:SQLC_KEYS_Left2;
    FI;
    IF SQLM_KEYS_GuardRow:SQLC_KEYS_Right2=
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
            SQLM_KEYS_NilRow+SQLM_KEYS_WorkRow;
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
            SQLM_KEYS_GuardRow:SQLC_KEYS_Right2;
    FI;
    SQLM_KEYS_OperRow:SQLC_KEYS_Allocated=1;
! Move Nil Row !
    SQLM_KEYS_OperRow=
        SQLM_KEYS_NilRow+SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color2=
        SQLM_KEYS_NilRow:SQLC_KEYS_Color2;    
    SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
        SQLM_KEYS_GuardRow+SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2 =
        SQLM_KEYS_GuardRow+SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color3=
        SQLM_KEYS_NilRow:SQLC_KEYS_Color3;    
    SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
        SQLM_KEYS_GuardRow+SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Left3 =
        SQLM_KEYS_GuardRow+SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color4=
        SQLM_KEYS_NilRow:SQLC_KEYS_Color4;    
    SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
        SQLM_KEYS_GuardRow+SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Left4 =
        SQLM_KEYS_GuardRow+SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Allocated=1;
! Move Root Row !
    SQLM_KEYS_OperRow=
        SQLM_KEYS_RootRow+SQLM_KEYS_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color2=
        SQLM_KEYS_RootRow:SQLC_KEYS_Color2;    
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Right2 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
            SQLM_KEYS_NilRow+SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
            SQLM_KEYS_RootRow:SQLC_KEYS_Right2;    
    FI;
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Left2 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
            SQLM_KEYS_NilRow+SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
            SQLM_KEYS_RootRow:SQLC_KEYS_Left2;    
    FI;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color3=
        SQLM_KEYS_RootRow:SQLC_KEYS_Color3;    
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Right3 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
            SQLM_KEYS_NilRow+SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
            SQLM_KEYS_RootRow:SQLC_KEYS_Right3;    
    FI;
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Left3 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Left3=
            SQLM_KEYS_NilRow+SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Left3=
            SQLM_KEYS_RootRow:SQLC_KEYS_Left3;    
    FI;
    SQLM_KEYS_OperRow:SQLC_KEYS_Color4=
        SQLM_KEYS_RootRow:SQLC_KEYS_Color4;    
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Right4 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
            SQLM_KEYS_NilRow+SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
            SQLM_KEYS_RootRow:SQLC_KEYS_Right4;    
    FI;
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Left4 =
        SQLM_KEYS_NilRow
    THEN
        SQLM_KEYS_OperRow:SQLC_KEYS_Left4=
            SQLM_KEYS_NilRow+SQLM_KEYS_WorkRow;    
    ELSE
        SQLM_KEYS_OperRow:SQLC_KEYS_Left4=
            SQLM_KEYS_RootRow:SQLC_KEYS_Left4;    
    FI;
    SQLM_KEYS_OperRow:SQLC_KEYS_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_KEYS_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_KEYS_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_KEYS_SAEClear;
! Remap NIL pointers !
    SQLM_KEYS_WorkRow=
        SQLM_KEYS_WorkRow+SQLM_KEYS_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_KEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
                SQLM_KEYS_NilRow
            DO SQLM_KEYS_OperRow:SQLC_KEYS_Right2=
                SQLM_KEYS_WorkRow;
        FOR ALL SQLM_KEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
                SQLM_KEYS_NilRow
            DO SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
                SQLM_KEYS_WorkRow;
        FOR ALL SQLM_KEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
                SQLM_KEYS_NilRow
            DO SQLM_KEYS_OperRow:SQLC_KEYS_Right3=
                SQLM_KEYS_WorkRow;
        FOR ALL SQLM_KEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Left3=
                SQLM_KEYS_NilRow
            DO SQLM_KEYS_OperRow:SQLC_KEYS_Left3=
                SQLM_KEYS_WorkRow;
        FOR ALL SQLM_KEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
                SQLM_KEYS_NilRow
            DO SQLM_KEYS_OperRow:SQLC_KEYS_Right4=
                SQLM_KEYS_WorkRow;
        FOR ALL SQLM_KEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Left4=
                SQLM_KEYS_NilRow
            DO SQLM_KEYS_OperRow:SQLC_KEYS_Left4=
                SQLM_KEYS_WorkRow;
    FI;
END SQLS_KEYS_SAEIncrease;

BEGIN SQLS_KEYS_SAEClear;
! Clear allocate bit. !
    SQLM_KEYS_OperRow:SQLC_KEYS_Allocated=0;
! Clear btree pointers. !
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2=0;
    SQLM_KEYS_OperRow:SQLC_KEYS_Right2=0;
    SQLM_KEYS_OperRow:SQLC_KEYS_Left3=0;
    SQLM_KEYS_OperRow:SQLC_KEYS_Right3=0;
    SQLM_KEYS_OperRow:SQLC_KEYS_Left4=0;
    SQLM_KEYS_OperRow:SQLC_KEYS_Right4=0;
END SQLS_KEYS_SAEClear;

BEGIN SQLS_KEYFIELDS_SAEIncrease;
    SQLM_KEYFIELDS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_KEYFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_KEYFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_KEYFIELDS_OperRow=
        SQLM_KEYFIELDS_GuardRow+SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2=
        SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Color2;    
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3=
        SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Color3;    
    IF SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Left2=
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
            SQLM_KEYFIELDS_NilRow+SQLM_KEYFIELDS_WorkRow;
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
            SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Left2;
    FI;
    IF SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2=
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
            SQLM_KEYFIELDS_NilRow+SQLM_KEYFIELDS_WorkRow;
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
            SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2;
    FI;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated=1;
! Move Nil Row !
    SQLM_KEYFIELDS_OperRow=
        SQLM_KEYFIELDS_NilRow+SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2=
        SQLM_KEYFIELDS_NilRow:SQLC_KEYFIELDS_Color2;    
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
        SQLM_KEYFIELDS_GuardRow+SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2 =
        SQLM_KEYFIELDS_GuardRow+SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3=
        SQLM_KEYFIELDS_NilRow:SQLC_KEYFIELDS_Color3;    
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
        SQLM_KEYFIELDS_GuardRow+SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3 =
        SQLM_KEYFIELDS_GuardRow+SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated=1;
! Move Root Row !
    SQLM_KEYFIELDS_OperRow=
        SQLM_KEYFIELDS_RootRow+SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2=
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Color2;    
    IF SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right2 =
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
            SQLM_KEYFIELDS_NilRow+SQLM_KEYFIELDS_WorkRow;    
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
            SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right2;    
    FI;
    IF SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left2 =
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
            SQLM_KEYFIELDS_NilRow+SQLM_KEYFIELDS_WorkRow;    
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
            SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left2;    
    FI;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3=
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Color3;    
    IF SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right3 =
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
            SQLM_KEYFIELDS_NilRow+SQLM_KEYFIELDS_WorkRow;    
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
            SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right3;    
    FI;
    IF SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left3 =
        SQLM_KEYFIELDS_NilRow
    THEN
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3=
            SQLM_KEYFIELDS_NilRow+SQLM_KEYFIELDS_WorkRow;    
    ELSE
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3=
            SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left3;    
    FI;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_KEYFIELDS_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_KEYFIELDS_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_KEYFIELDS_SAEClear;
! Remap NIL pointers !
    SQLM_KEYFIELDS_WorkRow=
        SQLM_KEYFIELDS_WorkRow+SQLM_KEYFIELDS_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_KEYFIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
                SQLM_KEYFIELDS_NilRow
            DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=
                SQLM_KEYFIELDS_WorkRow;
        FOR ALL SQLM_KEYFIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
                SQLM_KEYFIELDS_NilRow
            DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
                SQLM_KEYFIELDS_WorkRow;
        FOR ALL SQLM_KEYFIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
                SQLM_KEYFIELDS_NilRow
            DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=
                SQLM_KEYFIELDS_WorkRow;
        FOR ALL SQLM_KEYFIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3=
                SQLM_KEYFIELDS_NilRow
            DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3=
                SQLM_KEYFIELDS_WorkRow;
    FI;
END SQLS_KEYFIELDS_SAEIncrease;

BEGIN SQLS_KEYFIELDS_SAEClear;
! Clear allocate bit. !
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated=0;
! Clear btree pointers. !
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=0;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2=0;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3=0;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3=0;
END SQLS_KEYFIELDS_SAEClear;

BEGIN SQLS_FOREIGNKEYS_SAEIncrease;
    SQLM_FOREIGNKEYS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_FOREIGNKEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_FOREIGNKEYS_OperRow=
        SQLM_FOREIGNKEYS_GuardRow+SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2=
        SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Color2;    
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3=
        SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Color3;    
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4=
        SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Color4;    
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5=
        SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Color5;    
    IF SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Left2=
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
            SQLM_FOREIGNKEYS_NilRow+SQLM_FOREIGNKEYS_WorkRow;
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
            SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Left2;
    FI;
    IF SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2=
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
            SQLM_FOREIGNKEYS_NilRow+SQLM_FOREIGNKEYS_WorkRow;
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
            SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2;
    FI;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated=1;
! Move Nil Row !
    SQLM_FOREIGNKEYS_OperRow=
        SQLM_FOREIGNKEYS_NilRow+SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2=
        SQLM_FOREIGNKEYS_NilRow:SQLC_FOREIGNKEYS_Color2;    
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
        SQLM_FOREIGNKEYS_GuardRow+SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2 =
        SQLM_FOREIGNKEYS_GuardRow+SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3=
        SQLM_FOREIGNKEYS_NilRow:SQLC_FOREIGNKEYS_Color3;    
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
        SQLM_FOREIGNKEYS_GuardRow+SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3 =
        SQLM_FOREIGNKEYS_GuardRow+SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4=
        SQLM_FOREIGNKEYS_NilRow:SQLC_FOREIGNKEYS_Color4;    
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
        SQLM_FOREIGNKEYS_GuardRow+SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4 =
        SQLM_FOREIGNKEYS_GuardRow+SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5=
        SQLM_FOREIGNKEYS_NilRow:SQLC_FOREIGNKEYS_Color5;    
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
        SQLM_FOREIGNKEYS_GuardRow+SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5 =
        SQLM_FOREIGNKEYS_GuardRow+SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated=1;
! Move Root Row !
    SQLM_FOREIGNKEYS_OperRow=
        SQLM_FOREIGNKEYS_RootRow+SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2=
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Color2;    
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right2 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
            SQLM_FOREIGNKEYS_NilRow+SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right2;    
    FI;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left2 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
            SQLM_FOREIGNKEYS_NilRow+SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left2;    
    FI;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3=
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Color3;    
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right3 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
            SQLM_FOREIGNKEYS_NilRow+SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right3;    
    FI;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left3 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3=
            SQLM_FOREIGNKEYS_NilRow+SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left3;    
    FI;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4=
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Color4;    
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right4 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
            SQLM_FOREIGNKEYS_NilRow+SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right4;    
    FI;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left4 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4=
            SQLM_FOREIGNKEYS_NilRow+SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left4;    
    FI;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5=
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Color5;    
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right5 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
            SQLM_FOREIGNKEYS_NilRow+SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right5;    
    FI;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left5 =
        SQLM_FOREIGNKEYS_NilRow
    THEN
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5=
            SQLM_FOREIGNKEYS_NilRow+SQLM_FOREIGNKEYS_WorkRow;    
    ELSE
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5=
            SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left5;    
    FI;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_FOREIGNKEYS_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_FOREIGNKEYS_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_FOREIGNKEYS_SAEClear;
! Remap NIL pointers !
    SQLM_FOREIGNKEYS_WorkRow=
        SQLM_FOREIGNKEYS_WorkRow+SQLM_FOREIGNKEYS_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_FOREIGNKEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
                SQLM_FOREIGNKEYS_NilRow
            DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=
                SQLM_FOREIGNKEYS_WorkRow;
        FOR ALL SQLM_FOREIGNKEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
                SQLM_FOREIGNKEYS_NilRow
            DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
                SQLM_FOREIGNKEYS_WorkRow;
        FOR ALL SQLM_FOREIGNKEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
                SQLM_FOREIGNKEYS_NilRow
            DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=
                SQLM_FOREIGNKEYS_WorkRow;
        FOR ALL SQLM_FOREIGNKEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3=
                SQLM_FOREIGNKEYS_NilRow
            DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3=
                SQLM_FOREIGNKEYS_WorkRow;
        FOR ALL SQLM_FOREIGNKEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
                SQLM_FOREIGNKEYS_NilRow
            DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=
                SQLM_FOREIGNKEYS_WorkRow;
        FOR ALL SQLM_FOREIGNKEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4=
                SQLM_FOREIGNKEYS_NilRow
            DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4=
                SQLM_FOREIGNKEYS_WorkRow;
        FOR ALL SQLM_FOREIGNKEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
                SQLM_FOREIGNKEYS_NilRow
            DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=
                SQLM_FOREIGNKEYS_WorkRow;
        FOR ALL SQLM_FOREIGNKEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5=
                SQLM_FOREIGNKEYS_NilRow
            DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5=
                SQLM_FOREIGNKEYS_WorkRow;
    FI;
END SQLS_FOREIGNKEYS_SAEIncrease;

BEGIN SQLS_FOREIGNKEYS_SAEClear;
! Clear allocate bit. !
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated=0;
! Clear btree pointers. !
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=0;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2=0;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3=0;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3=0;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4=0;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4=0;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5=0;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5=0;
END SQLS_FOREIGNKEYS_SAEClear;

BEGIN SQLS_SYMBOLS_SAEIncrease;
    SQLM_SYMBOLS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_SYMBOLS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_SYMBOLS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_SYMBOLS_OperRow=
        SQLM_SYMBOLS_GuardRow+SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2=
        SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Color2;    
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3=
        SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Color3;    
    IF SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Left2=
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
            SQLM_SYMBOLS_NilRow+SQLM_SYMBOLS_WorkRow;
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
            SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Left2;
    FI;
    IF SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2=
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
            SQLM_SYMBOLS_NilRow+SQLM_SYMBOLS_WorkRow;
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
            SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2;
    FI;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated=1;
! Move Nil Row !
    SQLM_SYMBOLS_OperRow=
        SQLM_SYMBOLS_NilRow+SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2=
        SQLM_SYMBOLS_NilRow:SQLC_SYMBOLS_Color2;    
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
        SQLM_SYMBOLS_GuardRow+SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2 =
        SQLM_SYMBOLS_GuardRow+SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3=
        SQLM_SYMBOLS_NilRow:SQLC_SYMBOLS_Color3;    
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
        SQLM_SYMBOLS_GuardRow+SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3 =
        SQLM_SYMBOLS_GuardRow+SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated=1;
! Move Root Row !
    SQLM_SYMBOLS_OperRow=
        SQLM_SYMBOLS_RootRow+SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2=
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Color2;    
    IF SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right2 =
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
            SQLM_SYMBOLS_NilRow+SQLM_SYMBOLS_WorkRow;    
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
            SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right2;    
    FI;
    IF SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left2 =
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
            SQLM_SYMBOLS_NilRow+SQLM_SYMBOLS_WorkRow;    
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
            SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left2;    
    FI;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3=
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Color3;    
    IF SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right3 =
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
            SQLM_SYMBOLS_NilRow+SQLM_SYMBOLS_WorkRow;    
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
            SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right3;    
    FI;
    IF SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left3 =
        SQLM_SYMBOLS_NilRow
    THEN
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3=
            SQLM_SYMBOLS_NilRow+SQLM_SYMBOLS_WorkRow;    
    ELSE
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3=
            SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left3;    
    FI;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_SYMBOLS_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_SYMBOLS_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_SYMBOLS_SAEClear;
! Remap NIL pointers !
    SQLM_SYMBOLS_WorkRow=
        SQLM_SYMBOLS_WorkRow+SQLM_SYMBOLS_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_SYMBOLS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
                SQLM_SYMBOLS_NilRow
            DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=
                SQLM_SYMBOLS_WorkRow;
        FOR ALL SQLM_SYMBOLS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
                SQLM_SYMBOLS_NilRow
            DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
                SQLM_SYMBOLS_WorkRow;
        FOR ALL SQLM_SYMBOLS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
                SQLM_SYMBOLS_NilRow
            DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=
                SQLM_SYMBOLS_WorkRow;
        FOR ALL SQLM_SYMBOLS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3=
                SQLM_SYMBOLS_NilRow
            DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3=
                SQLM_SYMBOLS_WorkRow;
    FI;
END SQLS_SYMBOLS_SAEIncrease;

BEGIN SQLS_SYMBOLS_SAEClear;
! Clear allocate bit. !
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated=0;
! Clear btree pointers. !
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=0;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2=0;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3=0;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3=0;
END SQLS_SYMBOLS_SAEClear;

BEGIN SQLS_TOWFAULTCODES_SAEIncrease;
    SQLM_TOWFAULTCODES_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TOWFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_TOWFAULTCODES_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_TOWFAULTCODES_OperRow=
        SQLM_TOWFAULTCODES_GuardRow+SQLM_TOWFAULTCODES_WorkRow;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2=
        SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Color2;    
    IF SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Left2=
        SQLM_TOWFAULTCODES_NilRow
    THEN
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
            SQLM_TOWFAULTCODES_NilRow+SQLM_TOWFAULTCODES_WorkRow;
    ELSE
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
            SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Left2;
    FI;
    IF SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2=
        SQLM_TOWFAULTCODES_NilRow
    THEN
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
            SQLM_TOWFAULTCODES_NilRow+SQLM_TOWFAULTCODES_WorkRow;
    ELSE
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
            SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2;
    FI;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated=1;
! Move Nil Row !
    SQLM_TOWFAULTCODES_OperRow=
        SQLM_TOWFAULTCODES_NilRow+SQLM_TOWFAULTCODES_WorkRow;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2=
        SQLM_TOWFAULTCODES_NilRow:SQLC_TOWFAULTCODES_Color2;    
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
        SQLM_TOWFAULTCODES_GuardRow+SQLM_TOWFAULTCODES_WorkRow;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2 =
        SQLM_TOWFAULTCODES_GuardRow+SQLM_TOWFAULTCODES_WorkRow;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated=1;
! Move Root Row !
    SQLM_TOWFAULTCODES_OperRow=
        SQLM_TOWFAULTCODES_RootRow+SQLM_TOWFAULTCODES_WorkRow;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2=
        SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Color2;    
    IF SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Right2 =
        SQLM_TOWFAULTCODES_NilRow
    THEN
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
            SQLM_TOWFAULTCODES_NilRow+SQLM_TOWFAULTCODES_WorkRow;    
    ELSE
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
            SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Right2;    
    FI;
    IF SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Left2 =
        SQLM_TOWFAULTCODES_NilRow
    THEN
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
            SQLM_TOWFAULTCODES_NilRow+SQLM_TOWFAULTCODES_WorkRow;    
    ELSE
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
            SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Left2;    
    FI;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_TOWFAULTCODES_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_TOWFAULTCODES_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_TOWFAULTCODES_SAEClear;
! Remap NIL pointers !
    SQLM_TOWFAULTCODES_WorkRow=
        SQLM_TOWFAULTCODES_WorkRow+SQLM_TOWFAULTCODES_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_TOWFAULTCODES_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
                SQLM_TOWFAULTCODES_NilRow
            DO SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=
                SQLM_TOWFAULTCODES_WorkRow;
        FOR ALL SQLM_TOWFAULTCODES_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
                SQLM_TOWFAULTCODES_NilRow
            DO SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
                SQLM_TOWFAULTCODES_WorkRow;
    FI;
END SQLS_TOWFAULTCODES_SAEIncrease;

BEGIN SQLS_TOWFAULTCODES_SAEClear;
! Clear allocate bit. !
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated=0;
! Clear btree pointers. !
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=0;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2=0;
END SQLS_TOWFAULTCODES_SAEClear;

BEGIN SQLS_SYSFAULTCODES_SAEIncrease;
    SQLM_SYSFAULTCODES_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_SYSFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_SYSFAULTCODES_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_SYSFAULTCODES_OperRow=
        SQLM_SYSFAULTCODES_GuardRow+SQLM_SYSFAULTCODES_WorkRow;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2=
        SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Color2;    
    IF SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Left2=
        SQLM_SYSFAULTCODES_NilRow
    THEN
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
            SQLM_SYSFAULTCODES_NilRow+SQLM_SYSFAULTCODES_WorkRow;
    ELSE
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
            SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Left2;
    FI;
    IF SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2=
        SQLM_SYSFAULTCODES_NilRow
    THEN
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
            SQLM_SYSFAULTCODES_NilRow+SQLM_SYSFAULTCODES_WorkRow;
    ELSE
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
            SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2;
    FI;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated=1;
! Move Nil Row !
    SQLM_SYSFAULTCODES_OperRow=
        SQLM_SYSFAULTCODES_NilRow+SQLM_SYSFAULTCODES_WorkRow;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2=
        SQLM_SYSFAULTCODES_NilRow:SQLC_SYSFAULTCODES_Color2;    
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
        SQLM_SYSFAULTCODES_GuardRow+SQLM_SYSFAULTCODES_WorkRow;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2 =
        SQLM_SYSFAULTCODES_GuardRow+SQLM_SYSFAULTCODES_WorkRow;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated=1;
! Move Root Row !
    SQLM_SYSFAULTCODES_OperRow=
        SQLM_SYSFAULTCODES_RootRow+SQLM_SYSFAULTCODES_WorkRow;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2=
        SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Color2;    
    IF SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Right2 =
        SQLM_SYSFAULTCODES_NilRow
    THEN
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
            SQLM_SYSFAULTCODES_NilRow+SQLM_SYSFAULTCODES_WorkRow;    
    ELSE
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
            SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Right2;    
    FI;
    IF SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Left2 =
        SQLM_SYSFAULTCODES_NilRow
    THEN
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
            SQLM_SYSFAULTCODES_NilRow+SQLM_SYSFAULTCODES_WorkRow;    
    ELSE
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
            SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Left2;    
    FI;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_SYSFAULTCODES_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_SYSFAULTCODES_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_SYSFAULTCODES_SAEClear;
! Remap NIL pointers !
    SQLM_SYSFAULTCODES_WorkRow=
        SQLM_SYSFAULTCODES_WorkRow+SQLM_SYSFAULTCODES_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_SYSFAULTCODES_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
                SQLM_SYSFAULTCODES_NilRow
            DO SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=
                SQLM_SYSFAULTCODES_WorkRow;
        FOR ALL SQLM_SYSFAULTCODES_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
                SQLM_SYSFAULTCODES_NilRow
            DO SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
                SQLM_SYSFAULTCODES_WorkRow;
    FI;
END SQLS_SYSFAULTCODES_SAEIncrease;

BEGIN SQLS_SYSFAULTCODES_SAEClear;
! Clear allocate bit. !
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated=0;
! Clear btree pointers. !
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=0;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2=0;
END SQLS_SYSFAULTCODES_SAEClear;

BEGIN SQLS_SYSTEMFIELDS_SAEIncrease;
    SQLM_SYSTEMFIELDS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_SYSTEMFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_SYSTEMFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_SYSTEMFIELDS_OperRow=
        SQLM_SYSTEMFIELDS_GuardRow+SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2=
        SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Color2;    
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3=
        SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Color3;    
    IF SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Left2=
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
            SQLM_SYSTEMFIELDS_NilRow+SQLM_SYSTEMFIELDS_WorkRow;
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
            SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Left2;
    FI;
    IF SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2=
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
            SQLM_SYSTEMFIELDS_NilRow+SQLM_SYSTEMFIELDS_WorkRow;
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
            SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2;
    FI;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated=1;
! Move Nil Row !
    SQLM_SYSTEMFIELDS_OperRow=
        SQLM_SYSTEMFIELDS_NilRow+SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2=
        SQLM_SYSTEMFIELDS_NilRow:SQLC_SYSTEMFIELDS_Color2;    
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
        SQLM_SYSTEMFIELDS_GuardRow+SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2 =
        SQLM_SYSTEMFIELDS_GuardRow+SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3=
        SQLM_SYSTEMFIELDS_NilRow:SQLC_SYSTEMFIELDS_Color3;    
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
        SQLM_SYSTEMFIELDS_GuardRow+SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3 =
        SQLM_SYSTEMFIELDS_GuardRow+SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated=1;
! Move Root Row !
    SQLM_SYSTEMFIELDS_OperRow=
        SQLM_SYSTEMFIELDS_RootRow+SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2=
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Color2;    
    IF SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right2 =
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
            SQLM_SYSTEMFIELDS_NilRow+SQLM_SYSTEMFIELDS_WorkRow;    
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
            SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right2;    
    FI;
    IF SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left2 =
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
            SQLM_SYSTEMFIELDS_NilRow+SQLM_SYSTEMFIELDS_WorkRow;    
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
            SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left2;    
    FI;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3=
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Color3;    
    IF SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right3 =
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
            SQLM_SYSTEMFIELDS_NilRow+SQLM_SYSTEMFIELDS_WorkRow;    
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
            SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right3;    
    FI;
    IF SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left3 =
        SQLM_SYSTEMFIELDS_NilRow
    THEN
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3=
            SQLM_SYSTEMFIELDS_NilRow+SQLM_SYSTEMFIELDS_WorkRow;    
    ELSE
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3=
            SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left3;    
    FI;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_SYSTEMFIELDS_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_SYSTEMFIELDS_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_SYSTEMFIELDS_SAEClear;
! Remap NIL pointers !
    SQLM_SYSTEMFIELDS_WorkRow=
        SQLM_SYSTEMFIELDS_WorkRow+SQLM_SYSTEMFIELDS_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_SYSTEMFIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
                SQLM_SYSTEMFIELDS_NilRow
            DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=
                SQLM_SYSTEMFIELDS_WorkRow;
        FOR ALL SQLM_SYSTEMFIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
                SQLM_SYSTEMFIELDS_NilRow
            DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
                SQLM_SYSTEMFIELDS_WorkRow;
        FOR ALL SQLM_SYSTEMFIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
                SQLM_SYSTEMFIELDS_NilRow
            DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=
                SQLM_SYSTEMFIELDS_WorkRow;
        FOR ALL SQLM_SYSTEMFIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3=
                SQLM_SYSTEMFIELDS_NilRow
            DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3=
                SQLM_SYSTEMFIELDS_WorkRow;
    FI;
END SQLS_SYSTEMFIELDS_SAEIncrease;

BEGIN SQLS_SYSTEMFIELDS_SAEClear;
! Clear allocate bit. !
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated=0;
! Clear btree pointers. !
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=0;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2=0;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3=0;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3=0;
END SQLS_SYSTEMFIELDS_SAEClear;

BEGIN SQLS_TEST1_SAEIncrease;
    SQLM_TEST1_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TEST1_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_TEST1_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_TEST1_OperRow=
        SQLM_TEST1_GuardRow+SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Color2=
        SQLM_TEST1_GuardRow:SQLC_TEST1_Color2;    
    SQLM_TEST1_OperRow:SQLC_TEST1_Color3=
        SQLM_TEST1_GuardRow:SQLC_TEST1_Color3;    
    IF SQLM_TEST1_GuardRow:SQLC_TEST1_Left2=
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
            SQLM_TEST1_NilRow+SQLM_TEST1_WorkRow;
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
            SQLM_TEST1_GuardRow:SQLC_TEST1_Left2;
    FI;
    IF SQLM_TEST1_GuardRow:SQLC_TEST1_Right2=
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
            SQLM_TEST1_NilRow+SQLM_TEST1_WorkRow;
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
            SQLM_TEST1_GuardRow:SQLC_TEST1_Right2;
    FI;
    SQLM_TEST1_OperRow:SQLC_TEST1_Allocated=1;
! Move Nil Row !
    SQLM_TEST1_OperRow=
        SQLM_TEST1_NilRow+SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Color2=
        SQLM_TEST1_NilRow:SQLC_TEST1_Color2;    
    SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
        SQLM_TEST1_GuardRow+SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Left2 =
        SQLM_TEST1_GuardRow+SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Color3=
        SQLM_TEST1_NilRow:SQLC_TEST1_Color3;    
    SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
        SQLM_TEST1_GuardRow+SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Left3 =
        SQLM_TEST1_GuardRow+SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Allocated=1;
! Move Root Row !
    SQLM_TEST1_OperRow=
        SQLM_TEST1_RootRow+SQLM_TEST1_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_Color2=
        SQLM_TEST1_RootRow:SQLC_TEST1_Color2;    
    IF SQLM_TEST1_RootRow:SQLC_TEST1_Right2 =
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
            SQLM_TEST1_NilRow+SQLM_TEST1_WorkRow;    
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
            SQLM_TEST1_RootRow:SQLC_TEST1_Right2;    
    FI;
    IF SQLM_TEST1_RootRow:SQLC_TEST1_Left2 =
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
            SQLM_TEST1_NilRow+SQLM_TEST1_WorkRow;    
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
            SQLM_TEST1_RootRow:SQLC_TEST1_Left2;    
    FI;
    SQLM_TEST1_OperRow:SQLC_TEST1_Color3=
        SQLM_TEST1_RootRow:SQLC_TEST1_Color3;    
    IF SQLM_TEST1_RootRow:SQLC_TEST1_Right3 =
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
            SQLM_TEST1_NilRow+SQLM_TEST1_WorkRow;    
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
            SQLM_TEST1_RootRow:SQLC_TEST1_Right3;    
    FI;
    IF SQLM_TEST1_RootRow:SQLC_TEST1_Left3 =
        SQLM_TEST1_NilRow
    THEN
        SQLM_TEST1_OperRow:SQLC_TEST1_Left3=
            SQLM_TEST1_NilRow+SQLM_TEST1_WorkRow;    
    ELSE
        SQLM_TEST1_OperRow:SQLC_TEST1_Left3=
            SQLM_TEST1_RootRow:SQLC_TEST1_Left3;    
    FI;
    SQLM_TEST1_OperRow:SQLC_TEST1_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_TEST1_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_TEST1_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_TEST1_SAEClear;
! Remap NIL pointers !
    SQLM_TEST1_WorkRow=
        SQLM_TEST1_WorkRow+SQLM_TEST1_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_TEST1_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
                SQLM_TEST1_NilRow
            DO SQLM_TEST1_OperRow:SQLC_TEST1_Right2=
                SQLM_TEST1_WorkRow;
        FOR ALL SQLM_TEST1_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
                SQLM_TEST1_NilRow
            DO SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
                SQLM_TEST1_WorkRow;
        FOR ALL SQLM_TEST1_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
                SQLM_TEST1_NilRow
            DO SQLM_TEST1_OperRow:SQLC_TEST1_Right3=
                SQLM_TEST1_WorkRow;
        FOR ALL SQLM_TEST1_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Left3=
                SQLM_TEST1_NilRow
            DO SQLM_TEST1_OperRow:SQLC_TEST1_Left3=
                SQLM_TEST1_WorkRow;
    FI;
END SQLS_TEST1_SAEIncrease;

BEGIN SQLS_TEST1_SAEClear;
! Clear allocate bit. !
    SQLM_TEST1_OperRow:SQLC_TEST1_Allocated=0;
! Clear btree pointers. !
    SQLM_TEST1_OperRow:SQLC_TEST1_Left2=0;
    SQLM_TEST1_OperRow:SQLC_TEST1_Right2=0;
    SQLM_TEST1_OperRow:SQLC_TEST1_Left3=0;
    SQLM_TEST1_OperRow:SQLC_TEST1_Right3=0;
END SQLS_TEST1_SAEClear;
SAE21L3)
    SQLM_TableReference=0;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_PROGRAMS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_PROGRAMS_SAEIncrease;
! Link in new rows into the free list (first in list) !
        ON SQLM_PROGRAMS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated
            UPTO SQLX_NewIndNum-2
            DO SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
                SQLM_PROGRAMS_OperRow+1;
        NO;
        SQLM_PROGRAMS_OperRow=SQLX_NewIndNum-1;
        SQLM_PROGRAMS_GuardRow=SQLM_TableReference:SQLM_WorkAllocated+SQLX_NewIndNum;
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2=
            SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2;
        SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2=
            SQLM_TableReference:SQLM_TableAllocated;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE21L3)
    SQLM_TableReference=1;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TABLES_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_TABLES_SAEIncrease;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE1L3)
    SQLM_TableReference=2;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_FIELDS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_FIELDS_SAEIncrease;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE3L3)
    SQLM_TableReference=3;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_KEYS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_KEYS_SAEIncrease;
! Link in new rows into the free list (first in list) !
        ON SQLM_KEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated
            UPTO SQLX_NewIndNum-2
            DO SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
                SQLM_KEYS_OperRow+1;
        NO;
        SQLM_KEYS_OperRow=SQLX_NewIndNum-1;
        SQLM_KEYS_GuardRow=SQLM_TableReference:SQLM_WorkAllocated+SQLX_NewIndNum;
        SQLM_KEYS_OperRow:SQLC_KEYS_Left2=
            SQLM_KEYS_GuardRow:SQLC_KEYS_Right2;
        SQLM_KEYS_GuardRow:SQLC_KEYS_Right2=
            SQLM_TableReference:SQLM_TableAllocated;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE5L3)
    SQLM_TableReference=4;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_KEYFIELDS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_KEYFIELDS_SAEIncrease;
! Link in new rows into the free list (first in list) !
        ON SQLM_KEYFIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated
            UPTO SQLX_NewIndNum-2
            DO SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
                SQLM_KEYFIELDS_OperRow+1;
        NO;
        SQLM_KEYFIELDS_OperRow=SQLX_NewIndNum-1;
        SQLM_KEYFIELDS_GuardRow=SQLM_TableReference:SQLM_WorkAllocated+SQLX_NewIndNum;
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2=
            SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2;
        SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2=
            SQLM_TableReference:SQLM_TableAllocated;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE7L3)
    SQLM_TableReference=5;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_FOREIGNKEYS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_FOREIGNKEYS_SAEIncrease;
! Link in new rows into the free list (first in list) !
        ON SQLM_FOREIGNKEYS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated
            UPTO SQLX_NewIndNum-2
            DO SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
                SQLM_FOREIGNKEYS_OperRow+1;
        NO;
        SQLM_FOREIGNKEYS_OperRow=SQLX_NewIndNum-1;
        SQLM_FOREIGNKEYS_GuardRow=SQLM_TableReference:SQLM_WorkAllocated+SQLX_NewIndNum;
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2=
            SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2;
        SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2=
            SQLM_TableReference:SQLM_TableAllocated;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE9L3)
    SQLM_TableReference=6;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYMBOLS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYMBOLS_SAEIncrease;
! Link in new rows into the free list (first in list) !
        ON SQLM_SYMBOLS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated
            UPTO SQLX_NewIndNum-2
            DO SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
                SQLM_SYMBOLS_OperRow+1;
        NO;
        SQLM_SYMBOLS_OperRow=SQLX_NewIndNum-1;
        SQLM_SYMBOLS_GuardRow=SQLM_TableReference:SQLM_WorkAllocated+SQLX_NewIndNum;
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2=
            SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2;
        SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2=
            SQLM_TableReference:SQLM_TableAllocated;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE13L3)
    SQLM_TableReference=7;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TOWFAULTCODES_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_TOWFAULTCODES_SAEIncrease;
! Link in new rows into the free list (first in list) !
        ON SQLM_TOWFAULTCODES_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated
            UPTO SQLX_NewIndNum-2
            DO SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
                SQLM_TOWFAULTCODES_OperRow+1;
        NO;
        SQLM_TOWFAULTCODES_OperRow=SQLX_NewIndNum-1;
        SQLM_TOWFAULTCODES_GuardRow=SQLM_TableReference:SQLM_WorkAllocated+SQLX_NewIndNum;
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2=
            SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2;
        SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2=
            SQLM_TableReference:SQLM_TableAllocated;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE15L3)
    SQLM_TableReference=8;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYSFAULTCODES_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYSFAULTCODES_SAEIncrease;
! Link in new rows into the free list (first in list) !
        ON SQLM_SYSFAULTCODES_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated
            UPTO SQLX_NewIndNum-2
            DO SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
                SQLM_SYSFAULTCODES_OperRow+1;
        NO;
        SQLM_SYSFAULTCODES_OperRow=SQLX_NewIndNum-1;
        SQLM_SYSFAULTCODES_GuardRow=SQLM_TableReference:SQLM_WorkAllocated+SQLX_NewIndNum;
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2=
            SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2;
        SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2=
            SQLM_TableReference:SQLM_TableAllocated;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE19L3)
    SQLM_TableReference=9;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYSTEMFIELDS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYSTEMFIELDS_SAEIncrease;
! Link in new rows into the free list (first in list) !
        ON SQLM_SYSTEMFIELDS_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated
            UPTO SQLX_NewIndNum-2
            DO SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
                SQLM_SYSTEMFIELDS_OperRow+1;
        NO;
        SQLM_SYSTEMFIELDS_OperRow=SQLX_NewIndNum-1;
        SQLM_SYSTEMFIELDS_GuardRow=SQLM_TableReference:SQLM_WorkAllocated+SQLX_NewIndNum;
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2=
            SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2;
        SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2=
            SQLM_TableReference:SQLM_TableAllocated;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE10L3)
    SQLM_TableReference=10;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TEST1_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_TEST1_SAEIncrease;
! Link in new rows into the free list (first in list) !
        ON SQLM_TEST1_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated
            UPTO SQLX_NewIndNum-2
            DO SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
                SQLM_TEST1_OperRow+1;
        NO;
        SQLM_TEST1_OperRow=SQLX_NewIndNum-1;
        SQLM_TEST1_GuardRow=SQLM_TableReference:SQLM_WorkAllocated+SQLX_NewIndNum;
        SQLM_TEST1_OperRow:SQLC_TEST1_Left2=
            SQLM_TEST1_GuardRow:SQLC_TEST1_Right2;
        SQLM_TEST1_GuardRow:SQLC_TEST1_Right2=
            SQLM_TableReference:SQLM_TableAllocated;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE22L3)
    SQLM_TableReference=0;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_PROGRAMS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_PROGRAMS_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE22L3)
    SQLM_TableReference=1;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TABLES_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_TABLES_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE2L3)
    SQLM_TableReference=2;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_FIELDS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_FIELDS_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE4L3)
    SQLM_TableReference=3;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_KEYS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_KEYS_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE6L3)
    SQLM_TableReference=4;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_KEYFIELDS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_KEYFIELDS_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE8L3)
    SQLM_TableReference=5;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_FOREIGNKEYS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_FOREIGNKEYS_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE10L3)
    SQLM_TableReference=6;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYMBOLS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYMBOLS_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE14L3)
    SQLM_TableReference=7;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TOWFAULTCODES_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_TOWFAULTCODES_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE16L3)
    SQLM_TableReference=8;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYSFAULTCODES_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYSFAULTCODES_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE20L3)
    SQLM_TableReference=9;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_SYSTEMFIELDS_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_SYSTEMFIELDS_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE20L3)
    SQLM_TableReference=10;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TEST1_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_TEST1_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
!------------------------------------------------!
!       towGetRow !
!------------------------------------------------!
    ENTER towGetRow WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    CASE SQLM_TableReference IS
    WHEN 0 DO GOTO towGetRow0;
    WHEN 1 DO GOTO towGetRow1;
    WHEN 2 DO GOTO towGetRow2;
    WHEN 3 DO GOTO towGetRow3;
    WHEN 4 DO GOTO towGetRow4;
    WHEN 5 DO GOTO towGetRow5;
    WHEN 6 DO GOTO towGetRow6;
    WHEN 7 DO GOTO towGetRow7;
    WHEN 8 DO GOTO towGetRow8;
    WHEN 9 DO GOTO towGetRow9;
    WHEN 10 DO GOTO towGetRow10;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
towGetRow0)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow0_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_PROGRAMS_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor0_0;
        WHEN 2 DO GOTO towGetRowCursor0_2;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow0_2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow0_0)
! get row number.!
    DO SQLS_PROGRAMS_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_PROGRAMS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_PROGRAMS_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_PROGRAMS_OperRow,
            SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_PROGRAMS_OperRow,
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow0_2)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree0_2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree0_2;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow16;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow16;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree0_2;
WORKALLOCATEallocateWorkRow16)
    IF SQLM_PROGRAMS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_PROGRAMS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=1;
!store packed key in work row!
    DO SQLS_PROGRAMS_UnPackKey;
!find an operating row.!
    SQLM_PROGRAMS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Right2,
        SQLM_PROGRAMS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        26;
    EXIT;
towGetSchLab26)
    SQLM_PROGRAMS_WorkRow=SQLX_WorkRow;
    SQLM_PROGRAMS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_PROGRAMS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_PROGRAMS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_PROGRAMS_OperRow,
            SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_PROGRAMS_OperRow,
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree0_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree0_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor0_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2;
        SQLX_WorkRow = SQLM_PROGRAMS_WorkRow;
    ELSIF SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_PROGRAMS_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2,
            SQLM_PROGRAMS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            27;
        EXIT;
    FI;
towGetSchLab27)
    SQLM_PROGRAMS_WorkRow = SQLX_WorkRow;
    SQLM_PROGRAMS_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_PROGRAMS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated = 0 THEN
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2 =
            SQLM_PROGRAMS_OperRow;
    FI;
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_DBnumber2 =
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2;
! pack data in signal.!
    DO SQLS_PROGRAMS_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock > 1 THEN
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_PROGRAMS_OperRow,
            SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_PROGRAMS_OperRow,
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor0_2)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_PROGRAMS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Right2,
        SQLM_PROGRAMS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        28;
    EXIT;
towGetSchLab28)
    SQLM_PROGRAMS_WorkRow = SQLX_WorkRow;
    SQLM_PROGRAMS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_PROGRAMS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_PROGRAMS_WorkRow:
            SQLC_PROGRAMS_BLKREF_Data=
                SQLM_PROGRAMS_OperRow:
                    SQLC_PROGRAMS_BLKREF_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2 =
        SQLM_PROGRAMS_OperRow;
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_DBnumber2 =
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2;
! pack data in signal.!
    DO SQLS_PROGRAMS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock > 1 THEN
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_PROGRAMS_OperRow,
            SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_PROGRAMS_OperRow,
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
towGetRow1)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow1_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_TABLES_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor1_0;
        WHEN 3 DO GOTO towGetRowCursor1_3;
        WHEN 4 DO GOTO towGetRowCursor1_4;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow1_0;
    WHEN 3 DO GOTO towGetRow1_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow1_0)
! get row number.!
    DO SQLS_TABLES_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_TABLES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TABLES_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLES_OperRow,
            SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLES_OperRow,
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow1_3)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree1_3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree1_3;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow17;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow17;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree1_3;
WORKALLOCATEallocateWorkRow17)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
!store packed key in work row!
    DO SQLS_TABLES_UnPackKey;
!find an operating row.!
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        29;
    EXIT;
towGetSchLab29)
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_TABLES_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLES_OperRow,
            SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLES_OperRow,
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree1_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree1_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor1_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_TABLES_WorkRow:SQLC_TABLES_Left3;
        SQLX_WorkRow = SQLM_TABLES_WorkRow;
    ELSIF SQLM_TABLES_WorkRow:SQLC_TABLES_Left3 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_TABLES_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_TABLES_WorkRow:SQLC_TABLES_Left3,
            SQLM_TABLES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            30;
        EXIT;
    FI;
towGetSchLab30)
    SQLM_TABLES_WorkRow = SQLX_WorkRow;
    SQLM_TABLES_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_TABLES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 0 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Left3 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TABLES_WorkRow:SQLC_TABLES_Left3 =
            SQLM_TABLES_OperRow;
    FI;
    SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2 =
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2;
! pack data in signal.!
    DO SQLS_TABLES_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLES_OperRow,
            SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLES_OperRow,
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor1_3)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 2;
    FI;
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        31;
    EXIT;
towGetSchLab31)
    SQLM_TABLES_WorkRow = SQLX_WorkRow;
    SQLM_TABLES_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_TABLES_WorkRow:
            SQLC_TABLES_NAME_Data=
                SQLM_TABLES_OperRow:
                    SQLC_TABLES_NAME_Data;
    WHEN 2 DO
        SQLM_TABLES_WorkRow:
            SQLC_TABLES_BLKREF_Data=
                SQLM_TABLES_OperRow:
                    SQLC_TABLES_BLKREF_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3 =
        SQLM_TABLES_OperRow;
    SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2 =
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2;
! pack data in signal.!
    DO SQLS_TABLES_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLES_OperRow,
            SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLES_OperRow,
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor1_4)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right4,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        32;
    EXIT;
towGetSchLab32)
    SQLM_TABLES_WorkRow = SQLX_WorkRow;
    SQLM_TABLES_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_TABLES_WorkRow:
            SQLC_TABLES_BLKREF_Data=
                SQLM_TABLES_OperRow:
                    SQLC_TABLES_BLKREF_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Left3 =
        SQLM_TABLES_OperRow;
    SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2 =
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2;
! pack data in signal.!
    DO SQLS_TABLES_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLES_OperRow,
            SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLES_OperRow,
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
towGetRow2)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow2_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_FIELDS_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor2_0;
        WHEN 3 DO GOTO towGetRowCursor2_3;
        WHEN 4 DO GOTO towGetRowCursor2_4;
        WHEN 5 DO GOTO towGetRowCursor2_5;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow2_0;
    WHEN 3 DO GOTO towGetRow2_3;
    WHEN 4 DO GOTO towGetRow2_4;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow2_0)
! get row number.!
    DO SQLS_FIELDS_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_FIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_FIELDS_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FIELDS_OperRow,
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow2_3)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree2_3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree2_3;
    FOR FIRST SQLM_FIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow18;
    FOR FIRST SQLM_FIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow18;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree2_3;
WORKALLOCATEallocateWorkRow18)
    IF SQLM_FIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated=1;
!store packed key in work row!
    DO SQLS_FIELDS_UnPackKey;
!find an operating row.!
    SQLM_FIELDS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right3,
        SQLM_FIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        3,
        +,
        33;
    EXIT;
towGetSchLab33)
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    SQLM_FIELDS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_FIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_FIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FIELDS_OperRow,
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree2_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree2_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow2_4)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree2_4;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree2_4;
    FOR FIRST SQLM_FIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow19;
    FOR FIRST SQLM_FIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow19;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree2_4;
WORKALLOCATEallocateWorkRow19)
    IF SQLM_FIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated=1;
!store packed key in work row!
    DO SQLS_FIELDS_UnPackKey;
!find an operating row.!
    SQLM_FIELDS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right4,
        SQLM_FIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        3,
        +,
        34;
    EXIT;
towGetSchLab34)
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    SQLM_FIELDS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_FIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_FIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FIELDS_OperRow,
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree2_4)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree2_4)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor2_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3;
        SQLX_WorkRow = SQLM_FIELDS_WorkRow;
    ELSIF SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_FIELDS_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3,
            SQLM_FIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            35;
        EXIT;
    FI;
towGetSchLab35)
    SQLM_FIELDS_WorkRow = SQLX_WorkRow;
    SQLM_FIELDS_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_FIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 0 THEN
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3 =
            SQLM_FIELDS_OperRow;
    FI;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DBnumber2 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2;
! pack data in signal.!
    DO SQLS_FIELDS_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 1 THEN
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FIELDS_OperRow,
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor2_3)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 3;
    FI;
    SQLM_FIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right3,
        SQLM_FIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        36;
    EXIT;
towGetSchLab36)
    SQLM_FIELDS_WorkRow = SQLX_WorkRow;
    SQLM_FIELDS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_FIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_FIELDS_WorkRow:
            SQLC_FIELDS_NAME_Data=
                SQLM_FIELDS_OperRow:
                    SQLC_FIELDS_NAME_Data;
    WHEN 2 DO
        SQLM_FIELDS_WorkRow:
            SQLC_FIELDS_TABREF_Data=
                SQLM_FIELDS_OperRow:
                    SQLC_FIELDS_TABREF_Data;
    WHEN 3 DO
        SQLM_FIELDS_WorkRow:
            SQLC_FIELDS_BLKREF_Data=
                SQLM_FIELDS_OperRow:
                    SQLC_FIELDS_BLKREF_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3 =
        SQLM_FIELDS_OperRow;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DBnumber2 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2;
! pack data in signal.!
    DO SQLS_FIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 1 THEN
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FIELDS_OperRow,
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor2_4)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 3;
    FI;
    SQLM_FIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right4,
        SQLM_FIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        37;
    EXIT;
towGetSchLab37)
    SQLM_FIELDS_WorkRow = SQLX_WorkRow;
    SQLM_FIELDS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_FIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_FIELDS_WorkRow:
            SQLC_FIELDS_TABREF_Data=
                SQLM_FIELDS_OperRow:
                    SQLC_FIELDS_TABREF_Data;
    WHEN 2 DO
        SQLM_FIELDS_WorkRow:
            SQLC_FIELDS_BLKREF_Data=
                SQLM_FIELDS_OperRow:
                    SQLC_FIELDS_BLKREF_Data;
    WHEN 3 DO
        SQLM_FIELDS_WorkRow:
            SQLC_FIELDS_FIELDNO_Data=
                SQLM_FIELDS_OperRow:
                    SQLC_FIELDS_FIELDNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3 =
        SQLM_FIELDS_OperRow;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DBnumber2 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2;
! pack data in signal.!
    DO SQLS_FIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 1 THEN
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FIELDS_OperRow,
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor2_5)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_FIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right5,
        SQLM_FIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        38;
    EXIT;
towGetSchLab38)
    SQLM_FIELDS_WorkRow = SQLX_WorkRow;
    SQLM_FIELDS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_FIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_FIELDS_WorkRow:
            SQLC_FIELDS_TROWNO_Null=
                SQLM_FIELDS_OperRow:
                    SQLC_FIELDS_TROWNO_Null;
        SQLM_FIELDS_WorkRow:
            SQLC_FIELDS_TROWNO_Data=
                SQLM_FIELDS_OperRow:
                    SQLC_FIELDS_TROWNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3 =
        SQLM_FIELDS_OperRow;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DBnumber2 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2;
! pack data in signal.!
    DO SQLS_FIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 1 THEN
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FIELDS_OperRow,
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
towGetRow3)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow3_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_KEYS_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor3_0;
        WHEN 2 DO GOTO towGetRowCursor3_2;
        WHEN 3 DO GOTO towGetRowCursor3_3;
        WHEN 4 DO GOTO towGetRowCursor3_4;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow3_2;
    WHEN 3 DO GOTO towGetRow3_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow3_0)
! get row number.!
    DO SQLS_KEYS_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_KEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_KEYS_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYS_OperRow,
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow3_2)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree3_2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree3_2;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow20;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow20;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree3_2;
WORKALLOCATEallocateWorkRow20)
    IF SQLM_KEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=1;
!store packed key in work row!
    DO SQLS_KEYS_UnPackKey;
!find an operating row.!
    SQLM_KEYS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right2,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        39;
    EXIT;
towGetSchLab39)
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_KEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_KEYS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYS_OperRow,
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree3_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree3_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow3_3)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree3_3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree3_3;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow21;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow21;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree3_3;
WORKALLOCATEallocateWorkRow21)
    IF SQLM_KEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=1;
!store packed key in work row!
    DO SQLS_KEYS_UnPackKey;
!find an operating row.!
    SQLM_KEYS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right3,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        3,
        +,
        40;
    EXIT;
towGetSchLab40)
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_KEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_KEYS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYS_OperRow,
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree3_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree3_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor3_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_KEYS_WorkRow:SQLC_KEYS_Left2;
        SQLX_WorkRow = SQLM_KEYS_WorkRow;
    ELSIF SQLM_KEYS_WorkRow:SQLC_KEYS_Left2 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_KEYS_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_KEYS_WorkRow:SQLC_KEYS_Left2,
            SQLM_KEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            41;
        EXIT;
    FI;
towGetSchLab41)
    SQLM_KEYS_WorkRow = SQLX_WorkRow;
    SQLM_KEYS_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_KEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Allocated = 0 THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Left2 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_KEYS_WorkRow:SQLC_KEYS_Left2 =
            SQLM_KEYS_OperRow;
    FI;
    SQLM_KEYS_WorkRow:SQLC_KEYS_DBnumber2 =
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2;
! pack data in signal.!
    DO SQLS_KEYS_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 1 THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYS_OperRow,
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor3_2)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 2;
    FI;
    SQLM_KEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right2,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        42;
    EXIT;
towGetSchLab42)
    SQLM_KEYS_WorkRow = SQLX_WorkRow;
    SQLM_KEYS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_KEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_KEYS_WorkRow:
            SQLC_KEYS_TROWNO_Data=
                SQLM_KEYS_OperRow:
                    SQLC_KEYS_TROWNO_Data;
    WHEN 2 DO
        SQLM_KEYS_WorkRow:
            SQLC_KEYS_KEYNO_Data=
                SQLM_KEYS_OperRow:
                    SQLC_KEYS_KEYNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_KEYS_WorkRow:SQLC_KEYS_Left2 =
        SQLM_KEYS_OperRow;
    SQLM_KEYS_WorkRow:SQLC_KEYS_DBnumber2 =
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2;
! pack data in signal.!
    DO SQLS_KEYS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 1 THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYS_OperRow,
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor3_3)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 3;
    FI;
    SQLM_KEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right3,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        43;
    EXIT;
towGetSchLab43)
    SQLM_KEYS_WorkRow = SQLX_WorkRow;
    SQLM_KEYS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_KEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_KEYS_WorkRow:
            SQLC_KEYS_BLKREF_Data=
                SQLM_KEYS_OperRow:
                    SQLC_KEYS_BLKREF_Data;
    WHEN 2 DO
        SQLM_KEYS_WorkRow:
            SQLC_KEYS_TABREF_Data=
                SQLM_KEYS_OperRow:
                    SQLC_KEYS_TABREF_Data;
    WHEN 3 DO
        SQLM_KEYS_WorkRow:
            SQLC_KEYS_KEYNO_Data=
                SQLM_KEYS_OperRow:
                    SQLC_KEYS_KEYNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_KEYS_WorkRow:SQLC_KEYS_Left2 =
        SQLM_KEYS_OperRow;
    SQLM_KEYS_WorkRow:SQLC_KEYS_DBnumber2 =
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2;
! pack data in signal.!
    DO SQLS_KEYS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 1 THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYS_OperRow,
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor3_4)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_KEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right4,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        44;
    EXIT;
towGetSchLab44)
    SQLM_KEYS_WorkRow = SQLX_WorkRow;
    SQLM_KEYS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_KEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_KEYS_WorkRow:
            SQLC_KEYS_TROWNO_Data=
                SQLM_KEYS_OperRow:
                    SQLC_KEYS_TROWNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_KEYS_WorkRow:SQLC_KEYS_Left2 =
        SQLM_KEYS_OperRow;
    SQLM_KEYS_WorkRow:SQLC_KEYS_DBnumber2 =
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2;
! pack data in signal.!
    DO SQLS_KEYS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 1 THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYS_OperRow,
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
towGetRow4)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow4_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_KEYFIELDS_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor4_0;
        WHEN 2 DO GOTO towGetRowCursor4_2;
        WHEN 3 DO GOTO towGetRowCursor4_3;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow4_2;
    WHEN 3 DO GOTO towGetRow4_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow4_0)
! get row number.!
    DO SQLS_KEYFIELDS_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_KEYFIELDS_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYFIELDS_OperRow,
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow4_2)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree4_2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree4_2;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow22;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow22;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree4_2;
WORKALLOCATEallocateWorkRow22)
    IF SQLM_KEYFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=1;
!store packed key in work row!
    DO SQLS_KEYFIELDS_UnPackKey;
!find an operating row.!
    SQLM_KEYFIELDS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right2,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        3,
        +,
        45;
    EXIT;
towGetSchLab45)
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_KEYFIELDS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_KEYFIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_KEYFIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYFIELDS_OperRow,
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree4_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree4_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow4_3)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree4_3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree4_3;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow23;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow23;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree4_3;
WORKALLOCATEallocateWorkRow23)
    IF SQLM_KEYFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=1;
!store packed key in work row!
    DO SQLS_KEYFIELDS_UnPackKey;
!find an operating row.!
    SQLM_KEYFIELDS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right3,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        4,
        +,
        46;
    EXIT;
towGetSchLab46)
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_KEYFIELDS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_KEYFIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_KEYFIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYFIELDS_OperRow,
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree4_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree4_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor4_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2;
        SQLX_WorkRow = SQLM_KEYFIELDS_WorkRow;
    ELSIF SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_KEYFIELDS_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2,
            SQLM_KEYFIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            47;
        EXIT;
    FI;
towGetSchLab47)
    SQLM_KEYFIELDS_WorkRow = SQLX_WorkRow;
    SQLM_KEYFIELDS_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated = 0 THEN
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2 =
            SQLM_KEYFIELDS_OperRow;
    FI;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_DBnumber2 =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2;
! pack data in signal.!
    DO SQLS_KEYFIELDS_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 1 THEN
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYFIELDS_OperRow,
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor4_2)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 3;
    FI;
    SQLM_KEYFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right2,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        48;
    EXIT;
towGetSchLab48)
    SQLM_KEYFIELDS_WorkRow = SQLX_WorkRow;
    SQLM_KEYFIELDS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_KEYFIELDS_WorkRow:
            SQLC_KEYFIELDS_TROWNO_Data=
                SQLM_KEYFIELDS_OperRow:
                    SQLC_KEYFIELDS_TROWNO_Data;
    WHEN 2 DO
        SQLM_KEYFIELDS_WorkRow:
            SQLC_KEYFIELDS_KEYNO_Data=
                SQLM_KEYFIELDS_OperRow:
                    SQLC_KEYFIELDS_KEYNO_Data;
    WHEN 3 DO
        SQLM_KEYFIELDS_WorkRow:
            SQLC_KEYFIELDS_COMPNO_Data=
                SQLM_KEYFIELDS_OperRow:
                    SQLC_KEYFIELDS_COMPNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2 =
        SQLM_KEYFIELDS_OperRow;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_DBnumber2 =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2;
! pack data in signal.!
    DO SQLS_KEYFIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 1 THEN
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYFIELDS_OperRow,
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor4_3)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 4;
    FI;
    SQLM_KEYFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right3,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        49;
    EXIT;
towGetSchLab49)
    SQLM_KEYFIELDS_WorkRow = SQLX_WorkRow;
    SQLM_KEYFIELDS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_KEYFIELDS_WorkRow:
            SQLC_KEYFIELDS_BLKREF_Data=
                SQLM_KEYFIELDS_OperRow:
                    SQLC_KEYFIELDS_BLKREF_Data;
    WHEN 2 DO
        SQLM_KEYFIELDS_WorkRow:
            SQLC_KEYFIELDS_TABREF_Data=
                SQLM_KEYFIELDS_OperRow:
                    SQLC_KEYFIELDS_TABREF_Data;
    WHEN 3 DO
        SQLM_KEYFIELDS_WorkRow:
            SQLC_KEYFIELDS_KEYNO_Data=
                SQLM_KEYFIELDS_OperRow:
                    SQLC_KEYFIELDS_KEYNO_Data;
    WHEN 4 DO
        SQLM_KEYFIELDS_WorkRow:
            SQLC_KEYFIELDS_COMPNO_Data=
                SQLM_KEYFIELDS_OperRow:
                    SQLC_KEYFIELDS_COMPNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2 =
        SQLM_KEYFIELDS_OperRow;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_DBnumber2 =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2;
! pack data in signal.!
    DO SQLS_KEYFIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 1 THEN
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYFIELDS_OperRow,
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
towGetRow5)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow5_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_FOREIGNKEYS_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor5_0;
        WHEN 2 DO GOTO towGetRowCursor5_2;
        WHEN 3 DO GOTO towGetRowCursor5_3;
        WHEN 4 DO GOTO towGetRowCursor5_4;
        WHEN 5 DO GOTO towGetRowCursor5_5;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow5_2;
    WHEN 3 DO GOTO towGetRow5_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow5_0)
! get row number.!
    DO SQLS_FOREIGNKEYS_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_FOREIGNKEYS_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow5_2)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree5_2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree5_2;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow24;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow24;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree5_2;
WORKALLOCATEallocateWorkRow24)
    IF SQLM_FOREIGNKEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FOREIGNKEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=1;
!store packed key in work row!
    DO SQLS_FOREIGNKEYS_UnPackKey;
!find an operating row.!
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right2,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        50;
    EXIT;
towGetSchLab50)
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_FOREIGNKEYS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree5_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree5_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow5_3)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree5_3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree5_3;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow25;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow25;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree5_3;
WORKALLOCATEallocateWorkRow25)
    IF SQLM_FOREIGNKEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FOREIGNKEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=1;
!store packed key in work row!
    DO SQLS_FOREIGNKEYS_UnPackKey;
!find an operating row.!
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right3,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        3,
        +,
        51;
    EXIT;
towGetSchLab51)
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_FOREIGNKEYS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree5_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree5_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor5_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2;
        SQLX_WorkRow = SQLM_FOREIGNKEYS_WorkRow;
    ELSIF SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_FOREIGNKEYS_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2,
            SQLM_FOREIGNKEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            52;
        EXIT;
    FI;
towGetSchLab52)
    SQLM_FOREIGNKEYS_WorkRow = SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated = 0 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 =
            SQLM_FOREIGNKEYS_OperRow;
    FI;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_DBnumber2 =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2;
! pack data in signal.!
    DO SQLS_FOREIGNKEYS_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor5_2)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 2;
    FI;
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right2,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        53;
    EXIT;
towGetSchLab53)
    SQLM_FOREIGNKEYS_WorkRow = SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_FOREIGNKEYS_WorkRow:
            SQLC_FOREIGNKEYS_TROWNO_Data=
                SQLM_FOREIGNKEYS_OperRow:
                    SQLC_FOREIGNKEYS_TROWNO_Data;
    WHEN 2 DO
        SQLM_FOREIGNKEYS_WorkRow:
            SQLC_FOREIGNKEYS_ORDNO_Data=
                SQLM_FOREIGNKEYS_OperRow:
                    SQLC_FOREIGNKEYS_ORDNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 =
        SQLM_FOREIGNKEYS_OperRow;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_DBnumber2 =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2;
! pack data in signal.!
    DO SQLS_FOREIGNKEYS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor5_3)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 3;
    FI;
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right3,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        54;
    EXIT;
towGetSchLab54)
    SQLM_FOREIGNKEYS_WorkRow = SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_FOREIGNKEYS_WorkRow:
            SQLC_FOREIGNKEYS_ORDNO_Data=
                SQLM_FOREIGNKEYS_OperRow:
                    SQLC_FOREIGNKEYS_ORDNO_Data;
    WHEN 2 DO
        SQLM_FOREIGNKEYS_WorkRow:
            SQLC_FOREIGNKEYS_BLKREF_Data=
                SQLM_FOREIGNKEYS_OperRow:
                    SQLC_FOREIGNKEYS_BLKREF_Data;
    WHEN 3 DO
        SQLM_FOREIGNKEYS_WorkRow:
            SQLC_FOREIGNKEYS_TABREF_Data=
                SQLM_FOREIGNKEYS_OperRow:
                    SQLC_FOREIGNKEYS_TABREF_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 =
        SQLM_FOREIGNKEYS_OperRow;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_DBnumber2 =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2;
! pack data in signal.!
    DO SQLS_FOREIGNKEYS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor5_4)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right4,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        55;
    EXIT;
towGetSchLab55)
    SQLM_FOREIGNKEYS_WorkRow = SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_FOREIGNKEYS_WorkRow:
            SQLC_FOREIGNKEYS_TROWNO_Data=
                SQLM_FOREIGNKEYS_OperRow:
                    SQLC_FOREIGNKEYS_TROWNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 =
        SQLM_FOREIGNKEYS_OperRow;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_DBnumber2 =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2;
! pack data in signal.!
    DO SQLS_FOREIGNKEYS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor5_5)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right5,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        56;
    EXIT;
towGetSchLab56)
    SQLM_FOREIGNKEYS_WorkRow = SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_FOREIGNKEYS_WorkRow:
            SQLC_FOREIGNKEYS_FTROWNO_Data=
                SQLM_FOREIGNKEYS_OperRow:
                    SQLC_FOREIGNKEYS_FTROWNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 =
        SQLM_FOREIGNKEYS_OperRow;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_DBnumber2 =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2;
! pack data in signal.!
    DO SQLS_FOREIGNKEYS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
towGetRow6)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow6_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_SYMBOLS_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor6_0;
        WHEN 2 DO GOTO towGetRowCursor6_2;
        WHEN 3 DO GOTO towGetRowCursor6_3;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow6_2;
    WHEN 3 DO GOTO towGetRow6_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow6_0)
! get row number.!
    DO SQLS_SYMBOLS_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_SYMBOLS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_SYMBOLS_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYMBOLS_OperRow,
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow6_2)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree6_2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree6_2;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow26;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow26;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree6_2;
WORKALLOCATEallocateWorkRow26)
    IF SQLM_SYMBOLS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYMBOLS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=1;
!store packed key in work row!
    DO SQLS_SYMBOLS_UnPackKey;
!find an operating row.!
    SQLM_SYMBOLS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right2,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        57;
    EXIT;
towGetSchLab57)
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    SQLM_SYMBOLS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_SYMBOLS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_SYMBOLS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYMBOLS_OperRow,
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree6_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree6_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow6_3)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree6_3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree6_3;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow27;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow27;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree6_3;
WORKALLOCATEallocateWorkRow27)
    IF SQLM_SYMBOLS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYMBOLS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=1;
!store packed key in work row!
    DO SQLS_SYMBOLS_UnPackKey;
!find an operating row.!
    SQLM_SYMBOLS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right3,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        58;
    EXIT;
towGetSchLab58)
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    SQLM_SYMBOLS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_SYMBOLS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_SYMBOLS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYMBOLS_OperRow,
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree6_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree6_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor6_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2;
        SQLX_WorkRow = SQLM_SYMBOLS_WorkRow;
    ELSIF SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_SYMBOLS_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2,
            SQLM_SYMBOLS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            59;
        EXIT;
    FI;
towGetSchLab59)
    SQLM_SYMBOLS_WorkRow = SQLX_WorkRow;
    SQLM_SYMBOLS_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_SYMBOLS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated = 0 THEN
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2 =
            SQLM_SYMBOLS_OperRow;
    FI;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_DBnumber2 =
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2;
! pack data in signal.!
    DO SQLS_SYMBOLS_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 1 THEN
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYMBOLS_OperRow,
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor6_2)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 2;
    FI;
    SQLM_SYMBOLS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right2,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        60;
    EXIT;
towGetSchLab60)
    SQLM_SYMBOLS_WorkRow = SQLX_WorkRow;
    SQLM_SYMBOLS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_SYMBOLS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_SYMBOLS_WorkRow:
            SQLC_SYMBOLS_FROWNO_Data=
                SQLM_SYMBOLS_OperRow:
                    SQLC_SYMBOLS_FROWNO_Data;
    WHEN 2 DO
        SQLM_SYMBOLS_WorkRow:
            SQLC_SYMBOLS_SYMBOL_Data=
                SQLM_SYMBOLS_OperRow:
                    SQLC_SYMBOLS_SYMBOL_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2 =
        SQLM_SYMBOLS_OperRow;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_DBnumber2 =
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2;
! pack data in signal.!
    DO SQLS_SYMBOLS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 1 THEN
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYMBOLS_OperRow,
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor6_3)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 2;
    FI;
    SQLM_SYMBOLS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right3,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        61;
    EXIT;
towGetSchLab61)
    SQLM_SYMBOLS_WorkRow = SQLX_WorkRow;
    SQLM_SYMBOLS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_SYMBOLS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_SYMBOLS_WorkRow:
            SQLC_SYMBOLS_FROWNO_Data=
                SQLM_SYMBOLS_OperRow:
                    SQLC_SYMBOLS_FROWNO_Data;
    WHEN 2 DO
        SQLM_SYMBOLS_WorkRow:
            SQLC_SYMBOLS_SYMVAL_Data=
                SQLM_SYMBOLS_OperRow:
                    SQLC_SYMBOLS_SYMVAL_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2 =
        SQLM_SYMBOLS_OperRow;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_DBnumber2 =
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2;
! pack data in signal.!
    DO SQLS_SYMBOLS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 1 THEN
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYMBOLS_OperRow,
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
towGetRow7)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow7_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_TOWFAULTCODES_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor7_0;
        WHEN 2 DO GOTO towGetRowCursor7_2;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow7_2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow7_0)
! get row number.!
    DO SQLS_TOWFAULTCODES_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TOWFAULTCODES_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TOWFAULTCODES_OperRow,
            SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TOWFAULTCODES_OperRow,
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow7_2)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree7_2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree7_2;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow28;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow28;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree7_2;
WORKALLOCATEallocateWorkRow28)
    IF SQLM_TOWFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TOWFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=1;
!store packed key in work row!
    DO SQLS_TOWFAULTCODES_UnPackKey;
!find an operating row.!
    SQLM_TOWFAULTCODES_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Right2,
        SQLM_TOWFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        62;
    EXIT;
towGetSchLab62)
    SQLM_TOWFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_TOWFAULTCODES_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_TOWFAULTCODES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_TOWFAULTCODES_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TOWFAULTCODES_OperRow,
            SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TOWFAULTCODES_OperRow,
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree7_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree7_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor7_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2;
        SQLX_WorkRow = SQLM_TOWFAULTCODES_WorkRow;
    ELSIF SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_TOWFAULTCODES_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2,
            SQLM_TOWFAULTCODES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            63;
        EXIT;
    FI;
towGetSchLab63)
    SQLM_TOWFAULTCODES_WorkRow = SQLX_WorkRow;
    SQLM_TOWFAULTCODES_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated = 0 THEN
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2 =
            SQLM_TOWFAULTCODES_OperRow;
    FI;
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_DBnumber2 =
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2;
! pack data in signal.!
    DO SQLS_TOWFAULTCODES_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock > 1 THEN
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TOWFAULTCODES_OperRow,
            SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TOWFAULTCODES_OperRow,
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor7_2)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 2;
    FI;
    SQLM_TOWFAULTCODES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Right2,
        SQLM_TOWFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        64;
    EXIT;
towGetSchLab64)
    SQLM_TOWFAULTCODES_WorkRow = SQLX_WorkRow;
    SQLM_TOWFAULTCODES_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_TOWFAULTCODES_WorkRow:
            SQLC_TOWFAULTCODES_TROWNO_Data=
                SQLM_TOWFAULTCODES_OperRow:
                    SQLC_TOWFAULTCODES_TROWNO_Data;
    WHEN 2 DO
        SQLM_TOWFAULTCODES_WorkRow:
            SQLC_TOWFAULTCODES_FAULTNO_Data=
                SQLM_TOWFAULTCODES_OperRow:
                    SQLC_TOWFAULTCODES_FAULTNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2 =
        SQLM_TOWFAULTCODES_OperRow;
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_DBnumber2 =
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2;
! pack data in signal.!
    DO SQLS_TOWFAULTCODES_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock > 1 THEN
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TOWFAULTCODES_OperRow,
            SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TOWFAULTCODES_OperRow,
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
towGetRow8)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow8_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_SYSFAULTCODES_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor8_0;
        WHEN 2 DO GOTO towGetRowCursor8_2;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow8_2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow8_0)
! get row number.!
    DO SQLS_SYSFAULTCODES_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_SYSFAULTCODES_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYSFAULTCODES_OperRow,
            SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSFAULTCODES_OperRow,
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow8_2)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree8_2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree8_2;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow29;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow29;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree8_2;
WORKALLOCATEallocateWorkRow29)
    IF SQLM_SYSFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=1;
!store packed key in work row!
    DO SQLS_SYSFAULTCODES_UnPackKey;
!find an operating row.!
    SQLM_SYSFAULTCODES_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Right2,
        SQLM_SYSFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        65;
    EXIT;
towGetSchLab65)
    SQLM_SYSFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_SYSFAULTCODES_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_SYSFAULTCODES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_SYSFAULTCODES_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYSFAULTCODES_OperRow,
            SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSFAULTCODES_OperRow,
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree8_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree8_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor8_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2;
        SQLX_WorkRow = SQLM_SYSFAULTCODES_WorkRow;
    ELSIF SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_SYSFAULTCODES_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2,
            SQLM_SYSFAULTCODES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            66;
        EXIT;
    FI;
towGetSchLab66)
    SQLM_SYSFAULTCODES_WorkRow = SQLX_WorkRow;
    SQLM_SYSFAULTCODES_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated = 0 THEN
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2 =
            SQLM_SYSFAULTCODES_OperRow;
    FI;
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_DBnumber2 =
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2;
! pack data in signal.!
    DO SQLS_SYSFAULTCODES_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock > 1 THEN
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYSFAULTCODES_OperRow,
            SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSFAULTCODES_OperRow,
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor8_2)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_SYSFAULTCODES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Right2,
        SQLM_SYSFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        67;
    EXIT;
towGetSchLab67)
    SQLM_SYSFAULTCODES_WorkRow = SQLX_WorkRow;
    SQLM_SYSFAULTCODES_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_SYSFAULTCODES_WorkRow:
            SQLC_SYSFAULTCODES_FAULTNO_Data=
                SQLM_SYSFAULTCODES_OperRow:
                    SQLC_SYSFAULTCODES_FAULTNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2 =
        SQLM_SYSFAULTCODES_OperRow;
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_DBnumber2 =
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2;
! pack data in signal.!
    DO SQLS_SYSFAULTCODES_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock > 1 THEN
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYSFAULTCODES_OperRow,
            SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSFAULTCODES_OperRow,
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
towGetRow9)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow9_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_SYSTEMFIELDS_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor9_0;
        WHEN 2 DO GOTO towGetRowCursor9_2;
        WHEN 3 DO GOTO towGetRowCursor9_3;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow9_2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow9_0)
! get row number.!
    DO SQLS_SYSTEMFIELDS_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_SYSTEMFIELDS_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYSTEMFIELDS_OperRow,
            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSTEMFIELDS_OperRow,
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow9_2)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree9_2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree9_2;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow30;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow30;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree9_2;
WORKALLOCATEallocateWorkRow30)
    IF SQLM_SYSTEMFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSTEMFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=1;
!store packed key in work row!
    DO SQLS_SYSTEMFIELDS_UnPackKey;
!find an operating row.!
    SQLM_SYSTEMFIELDS_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right2,
        SQLM_SYSTEMFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        68;
    EXIT;
towGetSchLab68)
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_SYSTEMFIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_SYSTEMFIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYSTEMFIELDS_OperRow,
            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSTEMFIELDS_OperRow,
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree9_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree9_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor9_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2;
        SQLX_WorkRow = SQLM_SYSTEMFIELDS_WorkRow;
    ELSIF SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_SYSTEMFIELDS_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2,
            SQLM_SYSTEMFIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            69;
        EXIT;
    FI;
towGetSchLab69)
    SQLM_SYSTEMFIELDS_WorkRow = SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated = 0 THEN
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2 =
            SQLM_SYSTEMFIELDS_OperRow;
    FI;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_DBnumber2 =
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2;
! pack data in signal.!
    DO SQLS_SYSTEMFIELDS_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock > 1 THEN
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYSTEMFIELDS_OperRow,
            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSTEMFIELDS_OperRow,
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor9_2)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_SYSTEMFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right2,
        SQLM_SYSTEMFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        70;
    EXIT;
towGetSchLab70)
    SQLM_SYSTEMFIELDS_WorkRow = SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_SYSTEMFIELDS_WorkRow:
            SQLC_SYSTEMFIELDS_TROWNO_Data=
                SQLM_SYSTEMFIELDS_OperRow:
                    SQLC_SYSTEMFIELDS_TROWNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2 =
        SQLM_SYSTEMFIELDS_OperRow;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_DBnumber2 =
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2;
! pack data in signal.!
    DO SQLS_SYSTEMFIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock > 1 THEN
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYSTEMFIELDS_OperRow,
            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSTEMFIELDS_OperRow,
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor9_3)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_SYSTEMFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right3,
        SQLM_SYSTEMFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        71;
    EXIT;
towGetSchLab71)
    SQLM_SYSTEMFIELDS_WorkRow = SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_SYSTEMFIELDS_WorkRow:
            SQLC_SYSTEMFIELDS_TROWNO_Data=
                SQLM_SYSTEMFIELDS_OperRow:
                    SQLC_SYSTEMFIELDS_TROWNO_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2 =
        SQLM_SYSTEMFIELDS_OperRow;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_DBnumber2 =
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2;
! pack data in signal.!
    DO SQLS_SYSTEMFIELDS_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock > 1 THEN
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_SYSTEMFIELDS_OperRow,
            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSTEMFIELDS_OperRow,
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
towGetRow10)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow10_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_TEST1_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor10_0;
        WHEN 2 DO GOTO towGetRowCursor10_2;
        WHEN 3 DO GOTO towGetRowCursor10_3;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow10_2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow10_0)
! get row number.!
    DO SQLS_TEST1_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_TEST1_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TEST1_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TEST1_OperRow,
            SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TEST1_OperRow,
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow10_2)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree10_2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree10_2;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow31;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow31;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree10_2;
WORKALLOCATEallocateWorkRow31)
    IF SQLM_TEST1_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TEST1_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=1;
!store packed key in work row!
    DO SQLS_TEST1_UnPackKey;
!find an operating row.!
    SQLM_TEST1_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TEST1_RootRow:SQLC_TEST1_Right2,
        SQLM_TEST1_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        72;
    EXIT;
towGetSchLab72)
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
    SQLM_TEST1_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_TEST1_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_TEST1_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TEST1_OperRow,
            SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TEST1_OperRow,
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree10_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree10_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor10_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_TEST1_WorkRow:SQLC_TEST1_Left2;
        SQLX_WorkRow = SQLM_TEST1_WorkRow;
    ELSIF SQLM_TEST1_WorkRow:SQLC_TEST1_Left2 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_TEST1_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_TEST1_WorkRow:SQLC_TEST1_Left2,
            SQLM_TEST1_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            73;
        EXIT;
    FI;
towGetSchLab73)
    SQLM_TEST1_WorkRow = SQLX_WorkRow;
    SQLM_TEST1_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_TEST1_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_TEST1_WorkRow:SQLC_TEST1_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Allocated = 0 THEN
        SQLM_TEST1_WorkRow:SQLC_TEST1_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_TEST1_WorkRow:SQLC_TEST1_Left2 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TEST1_WorkRow:SQLC_TEST1_Left2 =
            SQLM_TEST1_OperRow;
    FI;
    SQLM_TEST1_WorkRow:SQLC_TEST1_DBnumber2 =
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2;
! pack data in signal.!
    DO SQLS_TEST1_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Lock > 1 THEN
        SQLM_TEST1_WorkRow:SQLC_TEST1_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TEST1_OperRow,
            SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TEST1_WorkRow:SQLC_TEST1_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TEST1_OperRow,
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor10_2)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 2;
    FI;
    SQLM_TEST1_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TEST1_RootRow:SQLC_TEST1_Right2,
        SQLM_TEST1_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        74;
    EXIT;
towGetSchLab74)
    SQLM_TEST1_WorkRow = SQLX_WorkRow;
    SQLM_TEST1_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_TEST1_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TEST1_WorkRow:SQLC_TEST1_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_TEST1_WorkRow:
            SQLC_TEST1_COL1_Data=
                SQLM_TEST1_OperRow:
                    SQLC_TEST1_COL1_Data;
    WHEN 2 DO
        SQLM_TEST1_WorkRow:
            SQLC_TEST1_COL2_Data=
                SQLM_TEST1_OperRow:
                    SQLC_TEST1_COL2_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_TEST1_WorkRow:SQLC_TEST1_Left2 =
        SQLM_TEST1_OperRow;
    SQLM_TEST1_WorkRow:SQLC_TEST1_DBnumber2 =
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2;
! pack data in signal.!
    DO SQLS_TEST1_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Lock > 1 THEN
        SQLM_TEST1_WorkRow:SQLC_TEST1_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TEST1_OperRow,
            SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TEST1_WorkRow:SQLC_TEST1_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TEST1_OperRow,
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor10_3)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_TEST1_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TEST1_RootRow:SQLC_TEST1_Right3,
        SQLM_TEST1_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        75;
    EXIT;
towGetSchLab75)
    SQLM_TEST1_WorkRow = SQLX_WorkRow;
    SQLM_TEST1_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_TEST1_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TEST1_WorkRow:SQLC_TEST1_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_TEST1_WorkRow:
            SQLC_TEST1_COL5_Null=
                SQLM_TEST1_OperRow:
                    SQLC_TEST1_COL5_Null;
        SQLM_TEST1_WorkRow:
            SQLC_TEST1_COL5_Data=
                SQLM_TEST1_OperRow:
                    SQLC_TEST1_COL5_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_TEST1_WorkRow:SQLC_TEST1_Left2 =
        SQLM_TEST1_OperRow;
    SQLM_TEST1_WorkRow:SQLC_TEST1_DBnumber2 =
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2;
! pack data in signal.!
    DO SQLS_TEST1_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Lock > 1 THEN
        SQLM_TEST1_WorkRow:SQLC_TEST1_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TEST1_OperRow,
            SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TEST1_WorkRow:SQLC_TEST1_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TEST1_OperRow,
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetFld !
!------------------------------------------------!
    ENTER towGetFld WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_OperRow,
        SQLX_DBnumber2,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_PROGRAMS_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_PROGRAMS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_PROGRAMS_Pack;
! check if read lock, if so report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
    WHEN 1 DO
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_TABLES_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_TABLES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TABLES_Pack;
! check if read lock, if so report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
    WHEN 2 DO
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_FIELDS_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_FIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_FIELDS_Pack;
! check if read lock, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
    WHEN 3 DO
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_KEYS_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_KEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_KEYS_Pack;
! check if read lock, if so report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
    WHEN 4 DO
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_KEYFIELDS_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_KEYFIELDS_Pack;
! check if read lock, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
    WHEN 5 DO
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_FOREIGNKEYS_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_FOREIGNKEYS_Pack;
! check if read lock, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
    WHEN 6 DO
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_SYMBOLS_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYMBOLS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_SYMBOLS_Pack;
! check if read lock, if so report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
    WHEN 7 DO
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_TOWFAULTCODES_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TOWFAULTCODES_Pack;
! check if read lock, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
    WHEN 8 DO
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_SYSFAULTCODES_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_SYSFAULTCODES_Pack;
! check if read lock, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
    WHEN 9 DO
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_SYSTEMFIELDS_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_SYSTEMFIELDS_Pack;
! check if read lock, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
    WHEN 10 DO
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_TEST1_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_TEST1_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TEST1_Pack;
! check if read lock, if so report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
    OTHERWISE DO;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towGetKey !
!------------------------------------------------!
    ENTER towGetKey WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_OperRow,
        SQLX_DBnumber2,
        SQLX_KeyNumber;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_PROGRAMS_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_PROGRAMS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_PROGRAMS_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
    WHEN 1 DO
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_TABLES_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_TABLES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TABLES_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
    WHEN 2 DO
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_FIELDS_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_FIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_FIELDS_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
    WHEN 3 DO
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_KEYS_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_KEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_KEYS_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
    WHEN 4 DO
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_KEYFIELDS_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_KEYFIELDS_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
    WHEN 5 DO
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_FOREIGNKEYS_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_FOREIGNKEYS_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
    WHEN 6 DO
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_SYMBOLS_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_SYMBOLS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_SYMBOLS_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
    WHEN 7 DO
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_TOWFAULTCODES_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TOWFAULTCODES_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
    WHEN 8 DO
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_SYSFAULTCODES_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_SYSFAULTCODES_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
    WHEN 9 DO
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_SYSTEMFIELDS_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_SYSTEMFIELDS_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
    WHEN 10 DO
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_TEST1_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_TEST1_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TEST1_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
    OTHERWISE DO;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towOpen !
!------------------------------------------------!
    ENTER towOpen WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_KeyNumber,
        +,
        +
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable0;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable0;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow32;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow32;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable0;
WORKALLOCATEallocateWorkRow32)
    IF SQLM_PROGRAMS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_PROGRAMS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=1;
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock=2;
! unpack key into work row.!
    DO SQLS_PROGRAMS_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_PROGRAMS_OperRow = SQLM_PROGRAMS_OperRow+1;
        FI;
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2 =
            SQLM_PROGRAMS_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2 = 0;
        ELSE
            SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_PROGRAMS_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable0)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable0)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
    WHEN 1 DO
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable1;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable1;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow33;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow33;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable1;
WORKALLOCATEallocateWorkRow33)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=2;
! unpack key into work row.!
    DO SQLS_TABLES_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0,2 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_TABLES_OperRow = SQLM_TABLES_OperRow+1;
        FI;
        SQLM_TABLES_WorkRow:SQLC_TABLES_Left3 =
            SQLM_TABLES_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_TABLES_WorkRow:SQLC_TABLES_Left3 = 0;
        ELSE
            SQLM_TABLES_WorkRow:SQLC_TABLES_Left3 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLES_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable1)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable1)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
    WHEN 2 DO
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable2;
    FOR FIRST SQLM_FIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow34;
    FOR FIRST SQLM_FIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow34;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable2;
WORKALLOCATEallocateWorkRow34)
    IF SQLM_FIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated=1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock=2;
! unpack key into work row.!
    DO SQLS_FIELDS_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0,2 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_FIELDS_OperRow = SQLM_FIELDS_OperRow+1;
        FI;
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3 =
            SQLM_FIELDS_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3 = 0;
        ELSE
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FIELDS_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable2)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable2)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
    WHEN 3 DO
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable3;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow35;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow35;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable3;
WORKALLOCATEallocateWorkRow35)
    IF SQLM_KEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=1;
    SQLM_KEYS_WorkRow:SQLC_KEYS_Lock=2;
! unpack key into work row.!
    DO SQLS_KEYS_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_KEYS_OperRow = SQLM_KEYS_OperRow+1;
        FI;
        SQLM_KEYS_WorkRow:SQLC_KEYS_Left2 =
            SQLM_KEYS_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_KEYS_WorkRow:SQLC_KEYS_Left2 = 0;
        ELSE
            SQLM_KEYS_WorkRow:SQLC_KEYS_Left2 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYS_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable3)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable3)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
    WHEN 4 DO
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable4;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable4;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow36;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow36;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable4;
WORKALLOCATEallocateWorkRow36)
    IF SQLM_KEYFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=1;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock=2;
! unpack key into work row.!
    DO SQLS_KEYFIELDS_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_OperRow+1;
        FI;
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2 =
            SQLM_KEYFIELDS_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2 = 0;
        ELSE
            SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYFIELDS_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable4)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable4)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
    WHEN 5 DO
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable5;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable5;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow37;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow37;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable5;
WORKALLOCATEallocateWorkRow37)
    IF SQLM_FOREIGNKEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FOREIGNKEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=2;
! unpack key into work row.!
    DO SQLS_FOREIGNKEYS_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_OperRow+1;
        FI;
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 =
            SQLM_FOREIGNKEYS_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 = 0;
        ELSE
            SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable5)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable5)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
    WHEN 6 DO
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable6;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable6;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow38;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow38;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable6;
WORKALLOCATEallocateWorkRow38)
    IF SQLM_SYMBOLS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYMBOLS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=1;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock=2;
! unpack key into work row.!
    DO SQLS_SYMBOLS_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_OperRow+1;
        FI;
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2 =
            SQLM_SYMBOLS_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2 = 0;
        ELSE
            SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYMBOLS_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable6)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable6)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
    WHEN 7 DO
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable7;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable7;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow39;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow39;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable7;
WORKALLOCATEallocateWorkRow39)
    IF SQLM_TOWFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TOWFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=1;
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock=2;
! unpack key into work row.!
    DO SQLS_TOWFAULTCODES_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_TOWFAULTCODES_OperRow = SQLM_TOWFAULTCODES_OperRow+1;
        FI;
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2 =
            SQLM_TOWFAULTCODES_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2 = 0;
        ELSE
            SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TOWFAULTCODES_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable7)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable7)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
    WHEN 8 DO
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable8;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable8;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow40;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow40;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable8;
WORKALLOCATEallocateWorkRow40)
    IF SQLM_SYSFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=1;
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock=2;
! unpack key into work row.!
    DO SQLS_SYSFAULTCODES_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_SYSFAULTCODES_OperRow = SQLM_SYSFAULTCODES_OperRow+1;
        FI;
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2 =
            SQLM_SYSFAULTCODES_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2 = 0;
        ELSE
            SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSFAULTCODES_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable8)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable8)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
    WHEN 9 DO
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable9;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable9;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow41;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow41;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable9;
WORKALLOCATEallocateWorkRow41)
    IF SQLM_SYSTEMFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSTEMFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=1;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock=2;
! unpack key into work row.!
    DO SQLS_SYSTEMFIELDS_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_OperRow+1;
        FI;
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2 =
            SQLM_SYSTEMFIELDS_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2 = 0;
        ELSE
            SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSTEMFIELDS_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable9)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable9)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
    WHEN 10 DO
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable10;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable10;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow42;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow42;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable10;
WORKALLOCATEallocateWorkRow42)
    IF SQLM_TEST1_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TEST1_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_Lock=2;
! unpack key into work row.!
    DO SQLS_TEST1_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_TEST1_OperRow = SQLM_TEST1_OperRow+1;
        FI;
        SQLM_TEST1_WorkRow:SQLC_TEST1_Left2 =
            SQLM_TEST1_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_TEST1_WorkRow:SQLC_TEST1_Left2 = 0;
        ELSE
            SQLM_TEST1_WorkRow:SQLC_TEST1_Left2 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TEST1_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable10)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable10)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
    OTHERWISE DO;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towClose !
!------------------------------------------------!
    RECEIVE towClose WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_PROGRAMS_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 1 DO
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_TABLES_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 2 DO
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_FIELDS_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 3 DO
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_KEYS_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 4 DO
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_KEYFIELDS_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 5 DO
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_FOREIGNKEYS_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 6 DO
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_SYMBOLS_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 7 DO
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_TOWFAULTCODES_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 8 DO
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_SYSFAULTCODES_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 9 DO
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_SYSTEMFIELDS_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 10 DO
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_TEST1_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    OTHERWISE DO;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towChaVolRow !
!------------------------------------------------!
    ENTER towChaVolRow WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
!------------------------------------------------!
!       towChaVolRowTable !
!------------------------------------------------!
! set working row.!
    SQLM_TEST1_WorkRow = SQLX_WorkRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_TEST1_WorkRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaVolRowR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0 THEN
        SEND towChaVolRowR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! Unpack data into working row.!
    DO SQLS_TEST1_UnPack;
! send back success.!
    SEND towChaVolRowR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towInsRow !
!------------------------------------------------!
    ENTER towInsRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    CASE SQLM_TableReference IS
    WHEN 0 DO
        GOTO towInsRowTableBTree0;
    WHEN 1 DO
        GOTO towInsRowTableRow1;
    WHEN 2 DO
        GOTO towInsRowTableRow2;
    WHEN 3 DO
        GOTO towInsRowTableBTree3;
    WHEN 4 DO
        GOTO towInsRowTableBTree4;
    WHEN 5 DO
        GOTO towInsRowTableBTree5;
    WHEN 6 DO
        GOTO towInsRowTableBTree6;
    WHEN 7 DO
        GOTO towInsRowTableBTree7;
    WHEN 8 DO
        GOTO towInsRowTableBTree8;
    WHEN 9 DO
        GOTO towInsRowTableBTree9;
    WHEN 10 DO
        GOTO towInsRowTableBTree10;
    OTHERWISE DO;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towInsRowTableBTree !
!------------------------------------------------!
towInsRowTableBTree0)
    SQLM_PROGRAMS_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_PROGRAMS_NilRow = SQLM_PROGRAMS_GuardRow + 1;
! get free row.!
!------------------------------------------------!
!       getFromFreeList !
!------------------------------------------------!
! Get first row from free list !
SQLM_PROGRAMS_WorkRow =
    SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2;
IF SQLM_PROGRAMS_WorkRow /= SQLM_PROGRAMS_NilRow THEN
    SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2 =
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2;
FI;
    IF SQLM_PROGRAMS_WorkRow = SQLM_PROGRAMS_NilRow THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
!  Error: Table full !
            3+9 <= 8;
        EXIT;
    FI;
! allocate row and unpack primary key.!
    SQLM_PROGRAMS_Workrow:SQLC_PROGRAMS_Allocated = 1;
    DO SQLS_PROGRAMS_UnpackKey;
! insert row in insert list (double linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_PROGRAMS_TempRow =
    SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Left2;
IF SQLM_PROGRAMS_TempRow /= SQLM_PROGRAMS_NilRow THEN
    SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Right2 =
        SQLM_PROGRAMS_WorkRow;
FI;
SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2 =
    SQLM_PROGRAMS_TempRow;
SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Left2 =
    SQLM_PROGRAMS_WorkRow;
SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Right2 =
    SQLM_PROGRAMS_GuardRow;
! check if primary key is in insert list, if so jump to error.!
    SQLM_PROGRAMS_OperRow = SQLM_PROGRAMS_GuardRow;
    SQLX_Schedule = 0;
    SQLX_KeyPrefix = 1;
towInsSchLab1)
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towInsSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            1,
            SQLM_PROGRAMS_WorkRow,
            SQLM_PROGRAMS_OperRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            +,
            +,
            +,
            SQLX_KeyPrefix;
        EXIT;
    FI;
    SQLM_PROGRAMS_OperRow =
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
    IF SQLM_PROGRAMS_OperRow /= SQLM_PROGRAMS_NilRow THEN
        IF SQLM_PROGRAMS_OperRow /= SQLM_PROGRAMS_WorkRow THEN
            DO SQLS_PROGRAMS_KeyTest2;
            IF SQLX_KeyTest = 1 GOTO ERRORtowInsRowTableBTree0;
        FI;
        GOTO towInsSchLab1;
    FI;
! check if primary key IS in tree, if so jump to error.!
    SQLM_PROGRAMS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Right2,
        SQLM_PROGRAMS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        76;
    EXIT;
towGetSchLab76)
    SQLM_PROGRAMS_WorkRow=SQLX_WorkRow;
    SQLM_PROGRAMS_OperRow=SQLX_Operrow;
    IF SQLM_PROGRAMS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowInsRowTableBTree0;
! set default values and unpack data from D7 to D21.!
    DO SQLS_PROGRAMS_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_PROGRAMS_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_PROGRAMS_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_PROGRAMS_WorkRow;
    EXIT;
ERRORtowInsRowTableBTree0)
    SQLM_PROGRAMS_OperRow = SQLM_PROGRAMS_WorkRow;
    SQLM_PROGRAMS_GuardRow = SQLM_TableReference:SQLM_System;
! remove row from insert list.!
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_PROGRAMS_TempRow =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Left2 =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
SQLM_PROGRAMS_TempRow =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;

IF SQLM_PROGRAMS_TempRow /= SQLM_PROGRAMS_NilRow THEN
    SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Right2 =
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
FI;
! insert row in free list.!
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2 =
    SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2;
SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2 =
    SQLM_PROGRAMS_OperRow;
! deallocate row.!
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0;
! send failure.!
    SEND towInsRowR WITH
        SQLX_OtherProtected,
! Search failure: Row already exists !
        2+5 <= 8;
    EXIT;
!------------------------------------------------!
!       towInsRowTableRow !
!------------------------------------------------!
towInsRowTableRow1)
! unpack key (set pOperRow).!
    DO SQLS_TABLES_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_TABLES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
! Search failure: Rownumber outside defined table area !
            2+6 <= 8;
        EXIT;
    FI;
! check is row is allocated, if so report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 1 THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
! Search failure: Row already exists !
            2+5 <= 8;
        EXIT;
    FI;
! allocate and lock row.!
    SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 1;
    SQLM_TABLES_OperRow:SQLC_TABLES_Lock = 1;
! assign work row !
    SQLM_TABLES_WorkRow=SQLM_TABLES_OperRow;
    SQLM_TABLES_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_TABLES_NilRow = SQLM_TABLES_GuardRow + 1;
! insert row in insert list (dubbel linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_TABLES_TempRow =
    SQLM_TABLES_GuardRow:SQLC_TABLES_Left3;
IF SQLM_TABLES_TempRow /= SQLM_TABLES_NilRow THEN
    SQLM_TABLES_TempRow:SQLC_TABLES_Right3 =
        SQLM_TABLES_WorkRow;
FI;
SQLM_TABLES_WorkRow:SQLC_TABLES_Left3 =
    SQLM_TABLES_TempRow;
SQLM_TABLES_GuardRow:SQLC_TABLES_Left3 =
    SQLM_TABLES_WorkRow;
SQLM_TABLES_WorkRow:SQLC_TABLES_Right3 =
    SQLM_TABLES_GuardRow;
! set default values and unpack data from D7 to D21.!
    SQLM_TABLES_WorkRow:SQLC_TABLES_DESCR_Data = "  ";
    SQLM_TABLES_WorkRow:SQLC_TABLES_SAEIDT_Null = 1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_ESTEPT_Data = 1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_MAXST_Data = 65531;
    SQLM_TABLES_WorkRow:SQLC_TABLES_SAEIDW_Null = 1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_ESTEPW_Data = 1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_MAXSW_Data = 65531;
    SQLM_TABLES_WorkRow:SQLC_TABLES_STATE_Data = TABLESSTATEWORKING;
    SQLM_TABLES_WorkRow:SQLC_TABLES_LOCATE_Data = TABLESLOCATESINGLE;
    DO SQLS_TABLES_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_TABLES_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_TABLES_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLES_OperRow;
    EXIT;
!------------------------------------------------!
!       towInsRowTableRow !
!------------------------------------------------!
towInsRowTableRow2)
! unpack key (set pOperRow).!
    DO SQLS_FIELDS_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_FIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
! Search failure: Rownumber outside defined table area !
            2+6 <= 8;
        EXIT;
    FI;
! check is row is allocated, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 1 THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
! Search failure: Row already exists !
            2+5 <= 8;
        EXIT;
    FI;
! allocate and lock row.!
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 1;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock = 1;
! assign work row !
    SQLM_FIELDS_WorkRow=SQLM_FIELDS_OperRow;
    SQLM_FIELDS_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_FIELDS_NilRow = SQLM_FIELDS_GuardRow + 1;
! insert row in insert list (dubbel linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_FIELDS_TempRow =
    SQLM_FIELDS_GuardRow:SQLC_FIELDS_Left3;
IF SQLM_FIELDS_TempRow /= SQLM_FIELDS_NilRow THEN
    SQLM_FIELDS_TempRow:SQLC_FIELDS_Right3 =
        SQLM_FIELDS_WorkRow;
FI;
SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3 =
    SQLM_FIELDS_TempRow;
SQLM_FIELDS_GuardRow:SQLC_FIELDS_Left3 =
    SQLM_FIELDS_WorkRow;
SQLM_FIELDS_WorkRow:SQLC_FIELDS_Right3 =
    SQLM_FIELDS_GuardRow;
! set default values and unpack data from D7 to D21.!
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DESCR_Data = "  ";
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_VISIBIL_Data = FIELDSVISIBILREADWR;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_MIN_Null = 1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_MAX_Null = 1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DIDNR_Null = 1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DIDPOS_Null = 1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_PCLEAR_Data = FIELDSPCLEARNO;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_PRELOAD_Data = FIELDSPRELOADYES;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_PDUMP_Data = FIELDSPDUMPNO;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_PSTATIC_Data = FIELDSPSTATICNO;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_VOLATIL_Data = FIELDSVOLATILNO;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFBITS_Null = 1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFSTR_Null = 1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFNSTR_Null = 1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Null = 1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFSYMB_Null = 1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_TROWNO_Null = 1;
    DO SQLS_FIELDS_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_FIELDS_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_FIELDS_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_FIELDS_OperRow;
    EXIT;
!------------------------------------------------!
!       towInsRowTableBTree !
!------------------------------------------------!
towInsRowTableBTree3)
    SQLM_KEYS_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_KEYS_NilRow = SQLM_KEYS_GuardRow + 1;
! get free row.!
!------------------------------------------------!
!       getFromFreeList !
!------------------------------------------------!
! Get first row from free list !
SQLM_KEYS_WorkRow =
    SQLM_KEYS_GuardRow:SQLC_KEYS_Right2;
IF SQLM_KEYS_WorkRow /= SQLM_KEYS_NilRow THEN
    SQLM_KEYS_GuardRow:SQLC_KEYS_Right2 =
        SQLM_KEYS_WorkRow:SQLC_KEYS_Left2;
FI;
    IF SQLM_KEYS_WorkRow = SQLM_KEYS_NilRow THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
!  Error: Table full !
            3+9 <= 8;
        EXIT;
    FI;
! allocate row and unpack primary key.!
    SQLM_KEYS_Workrow:SQLC_KEYS_Allocated = 1;
    DO SQLS_KEYS_UnpackKey;
! insert row in insert list (double linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_KEYS_TempRow =
    SQLM_KEYS_GuardRow:SQLC_KEYS_Left2;
IF SQLM_KEYS_TempRow /= SQLM_KEYS_NilRow THEN
    SQLM_KEYS_TempRow:SQLC_KEYS_Right2 =
        SQLM_KEYS_WorkRow;
FI;
SQLM_KEYS_WorkRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_TempRow;
SQLM_KEYS_GuardRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_WorkRow;
SQLM_KEYS_WorkRow:SQLC_KEYS_Right2 =
    SQLM_KEYS_GuardRow;
! check if primary key is in insert list, if so jump to error.!
    SQLM_KEYS_OperRow = SQLM_KEYS_GuardRow;
    SQLX_Schedule = 0;
    SQLX_KeyPrefix = 2;
towInsSchLab2)
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towInsSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            2,
            SQLM_KEYS_WorkRow,
            SQLM_KEYS_OperRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            +,
            +,
            +,
            SQLX_KeyPrefix;
        EXIT;
    FI;
    SQLM_KEYS_OperRow =
        SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
    IF SQLM_KEYS_OperRow /= SQLM_KEYS_NilRow THEN
        IF SQLM_KEYS_OperRow /= SQLM_KEYS_WorkRow THEN
            DO SQLS_KEYS_KeyTest2;
            IF SQLX_KeyTest = 1 GOTO ERRORtowInsRowTableBTree3;
        FI;
        GOTO towInsSchLab2;
    FI;
! check if primary key IS in tree, if so jump to error.!
    SQLM_KEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right2,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        77;
    EXIT;
towGetSchLab77)
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_OperRow=SQLX_Operrow;
    IF SQLM_KEYS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowInsRowTableBTree3;
! set default values and unpack data from D7 to D21.!
    SQLM_KEYS_WorkRow:SQLC_KEYS_TROWNO_Data = 1;
    DO SQLS_KEYS_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_KEYS_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_KEYS_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYS_WorkRow;
    EXIT;
ERRORtowInsRowTableBTree3)
    SQLM_KEYS_OperRow = SQLM_KEYS_WorkRow;
    SQLM_KEYS_GuardRow = SQLM_TableReference:SQLM_System;
! remove row from insert list.!
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_KEYS_TempRow =
    SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
SQLM_KEYS_TempRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
SQLM_KEYS_TempRow =
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;

IF SQLM_KEYS_TempRow /= SQLM_KEYS_NilRow THEN
    SQLM_KEYS_TempRow:SQLC_KEYS_Right2 =
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
FI;
! insert row in free list.!
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_KEYS_OperRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_GuardRow:SQLC_KEYS_Right2;
SQLM_KEYS_GuardRow:SQLC_KEYS_Right2 =
    SQLM_KEYS_OperRow;
! deallocate row.!
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0;
! send failure.!
    SEND towInsRowR WITH
        SQLX_OtherProtected,
! Search failure: Row already exists !
        2+5 <= 8;
    EXIT;
!------------------------------------------------!
!       towInsRowTableBTree !
!------------------------------------------------!
towInsRowTableBTree4)
    SQLM_KEYFIELDS_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_KEYFIELDS_NilRow = SQLM_KEYFIELDS_GuardRow + 1;
! get free row.!
!------------------------------------------------!
!       getFromFreeList !
!------------------------------------------------!
! Get first row from free list !
SQLM_KEYFIELDS_WorkRow =
    SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2;
IF SQLM_KEYFIELDS_WorkRow /= SQLM_KEYFIELDS_NilRow THEN
    SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2 =
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2;
FI;
    IF SQLM_KEYFIELDS_WorkRow = SQLM_KEYFIELDS_NilRow THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
!  Error: Table full !
            3+9 <= 8;
        EXIT;
    FI;
! allocate row and unpack primary key.!
    SQLM_KEYFIELDS_Workrow:SQLC_KEYFIELDS_Allocated = 1;
    DO SQLS_KEYFIELDS_UnpackKey;
! insert row in insert list (double linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Left2;
IF SQLM_KEYFIELDS_TempRow /= SQLM_KEYFIELDS_NilRow THEN
    SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Right2 =
        SQLM_KEYFIELDS_WorkRow;
FI;
SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_TempRow;
SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_WorkRow;
SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Right2 =
    SQLM_KEYFIELDS_GuardRow;
! check if primary key is in insert list, if so jump to error.!
    SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_GuardRow;
    SQLX_Schedule = 0;
    SQLX_KeyPrefix = 3;
towInsSchLab3)
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towInsSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            3,
            SQLM_KEYFIELDS_WorkRow,
            SQLM_KEYFIELDS_OperRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            +,
            +,
            +,
            SQLX_KeyPrefix;
        EXIT;
    FI;
    SQLM_KEYFIELDS_OperRow =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
    IF SQLM_KEYFIELDS_OperRow /= SQLM_KEYFIELDS_NilRow THEN
        IF SQLM_KEYFIELDS_OperRow /= SQLM_KEYFIELDS_WorkRow THEN
            DO SQLS_KEYFIELDS_KeyTest2;
            IF SQLX_KeyTest = 1 GOTO ERRORtowInsRowTableBTree4;
        FI;
        GOTO towInsSchLab3;
    FI;
! check if primary key IS in tree, if so jump to error.!
    SQLM_KEYFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right2,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        3,
        +,
        78;
    EXIT;
towGetSchLab78)
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_KEYFIELDS_OperRow=SQLX_Operrow;
    IF SQLM_KEYFIELDS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowInsRowTableBTree4;
! set default values and unpack data from D7 to D21.!
    DO SQLS_KEYFIELDS_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_KEYFIELDS_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_KEYFIELDS_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYFIELDS_WorkRow;
    EXIT;
ERRORtowInsRowTableBTree4)
    SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_WorkRow;
    SQLM_KEYFIELDS_GuardRow = SQLM_TableReference:SQLM_System;
! remove row from insert list.!
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;

IF SQLM_KEYFIELDS_TempRow /= SQLM_KEYFIELDS_NilRow THEN
    SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Right2 =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
FI;
! insert row in free list.!
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2;
SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2 =
    SQLM_KEYFIELDS_OperRow;
! deallocate row.!
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0;
! send failure.!
    SEND towInsRowR WITH
        SQLX_OtherProtected,
! Search failure: Row already exists !
        2+5 <= 8;
    EXIT;
!------------------------------------------------!
!       towInsRowTableBTree !
!------------------------------------------------!
towInsRowTableBTree5)
    SQLM_FOREIGNKEYS_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_FOREIGNKEYS_NilRow = SQLM_FOREIGNKEYS_GuardRow + 1;
! get free row.!
!------------------------------------------------!
!       getFromFreeList !
!------------------------------------------------!
! Get first row from free list !
SQLM_FOREIGNKEYS_WorkRow =
    SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2;
IF SQLM_FOREIGNKEYS_WorkRow /= SQLM_FOREIGNKEYS_NilRow THEN
    SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2 =
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2;
FI;
    IF SQLM_FOREIGNKEYS_WorkRow = SQLM_FOREIGNKEYS_NilRow THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
!  Error: Table full !
            3+9 <= 8;
        EXIT;
    FI;
! allocate row and unpack primary key.!
    SQLM_FOREIGNKEYS_Workrow:SQLC_FOREIGNKEYS_Allocated = 1;
    DO SQLS_FOREIGNKEYS_UnpackKey;
! insert row in insert list (double linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Left2;
IF SQLM_FOREIGNKEYS_TempRow /= SQLM_FOREIGNKEYS_NilRow THEN
    SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Right2 =
        SQLM_FOREIGNKEYS_WorkRow;
FI;
SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_TempRow;
SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_WorkRow;
SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Right2 =
    SQLM_FOREIGNKEYS_GuardRow;
! check if primary key is in insert list, if so jump to error.!
    SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_GuardRow;
    SQLX_Schedule = 0;
    SQLX_KeyPrefix = 2;
towInsSchLab4)
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towInsSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            4,
            SQLM_FOREIGNKEYS_WorkRow,
            SQLM_FOREIGNKEYS_OperRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            +,
            +,
            +,
            SQLX_KeyPrefix;
        EXIT;
    FI;
    SQLM_FOREIGNKEYS_OperRow =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
    IF SQLM_FOREIGNKEYS_OperRow /= SQLM_FOREIGNKEYS_NilRow THEN
        IF SQLM_FOREIGNKEYS_OperRow /= SQLM_FOREIGNKEYS_WorkRow THEN
            DO SQLS_FOREIGNKEYS_KeyTest2;
            IF SQLX_KeyTest = 1 GOTO ERRORtowInsRowTableBTree5;
        FI;
        GOTO towInsSchLab4;
    FI;
! check if primary key IS in tree, if so jump to error.!
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right2,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        79;
    EXIT;
towGetSchLab79)
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Operrow;
    IF SQLM_FOREIGNKEYS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowInsRowTableBTree5;
! set default values and unpack data from D7 to D21.!
    DO SQLS_FOREIGNKEYS_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_FOREIGNKEYS_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_FOREIGNKEYS_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_WorkRow;
    EXIT;
ERRORtowInsRowTableBTree5)
    SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_WorkRow;
    SQLM_FOREIGNKEYS_GuardRow = SQLM_TableReference:SQLM_System;
! remove row from insert list.!
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;

IF SQLM_FOREIGNKEYS_TempRow /= SQLM_FOREIGNKEYS_NilRow THEN
    SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Right2 =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
FI;
! insert row in free list.!
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2;
SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2 =
    SQLM_FOREIGNKEYS_OperRow;
! deallocate row.!
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0;
! send failure.!
    SEND towInsRowR WITH
        SQLX_OtherProtected,
! Search failure: Row already exists !
        2+5 <= 8;
    EXIT;
!------------------------------------------------!
!       towInsRowTableBTree !
!------------------------------------------------!
towInsRowTableBTree6)
    SQLM_SYMBOLS_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_SYMBOLS_NilRow = SQLM_SYMBOLS_GuardRow + 1;
! get free row.!
!------------------------------------------------!
!       getFromFreeList !
!------------------------------------------------!
! Get first row from free list !
SQLM_SYMBOLS_WorkRow =
    SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2;
IF SQLM_SYMBOLS_WorkRow /= SQLM_SYMBOLS_NilRow THEN
    SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2 =
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2;
FI;
    IF SQLM_SYMBOLS_WorkRow = SQLM_SYMBOLS_NilRow THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
!  Error: Table full !
            3+9 <= 8;
        EXIT;
    FI;
! allocate row and unpack primary key.!
    SQLM_SYMBOLS_Workrow:SQLC_SYMBOLS_Allocated = 1;
    DO SQLS_SYMBOLS_UnpackKey;
! insert row in insert list (double linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Left2;
IF SQLM_SYMBOLS_TempRow /= SQLM_SYMBOLS_NilRow THEN
    SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Right2 =
        SQLM_SYMBOLS_WorkRow;
FI;
SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_TempRow;
SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_WorkRow;
SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Right2 =
    SQLM_SYMBOLS_GuardRow;
! check if primary key is in insert list, if so jump to error.!
    SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_GuardRow;
    SQLX_Schedule = 0;
    SQLX_KeyPrefix = 2;
towInsSchLab5)
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towInsSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            5,
            SQLM_SYMBOLS_WorkRow,
            SQLM_SYMBOLS_OperRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            +,
            +,
            +,
            SQLX_KeyPrefix;
        EXIT;
    FI;
    SQLM_SYMBOLS_OperRow =
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
    IF SQLM_SYMBOLS_OperRow /= SQLM_SYMBOLS_NilRow THEN
        IF SQLM_SYMBOLS_OperRow /= SQLM_SYMBOLS_WorkRow THEN
            DO SQLS_SYMBOLS_KeyTest2;
            IF SQLX_KeyTest = 1 GOTO ERRORtowInsRowTableBTree6;
        FI;
        GOTO towInsSchLab5;
    FI;
! check if primary key IS in tree, if so jump to error.!
    SQLM_SYMBOLS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right2,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        80;
    EXIT;
towGetSchLab80)
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    SQLM_SYMBOLS_OperRow=SQLX_Operrow;
    IF SQLM_SYMBOLS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowInsRowTableBTree6;
! set default values and unpack data from D7 to D21.!
    DO SQLS_SYMBOLS_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_SYMBOLS_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_SYMBOLS_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYMBOLS_WorkRow;
    EXIT;
ERRORtowInsRowTableBTree6)
    SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_WorkRow;
    SQLM_SYMBOLS_GuardRow = SQLM_TableReference:SQLM_System;
! remove row from insert list.!
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;

IF SQLM_SYMBOLS_TempRow /= SQLM_SYMBOLS_NilRow THEN
    SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Right2 =
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
FI;
! insert row in free list.!
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2;
SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2 =
    SQLM_SYMBOLS_OperRow;
! deallocate row.!
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0;
! send failure.!
    SEND towInsRowR WITH
        SQLX_OtherProtected,
! Search failure: Row already exists !
        2+5 <= 8;
    EXIT;
!------------------------------------------------!
!       towInsRowTableBTree !
!------------------------------------------------!
towInsRowTableBTree7)
    SQLM_TOWFAULTCODES_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_TOWFAULTCODES_NilRow = SQLM_TOWFAULTCODES_GuardRow + 1;
! get free row.!
!------------------------------------------------!
!       getFromFreeList !
!------------------------------------------------!
! Get first row from free list !
SQLM_TOWFAULTCODES_WorkRow =
    SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2;
IF SQLM_TOWFAULTCODES_WorkRow /= SQLM_TOWFAULTCODES_NilRow THEN
    SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2 =
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2;
FI;
    IF SQLM_TOWFAULTCODES_WorkRow = SQLM_TOWFAULTCODES_NilRow THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
!  Error: Table full !
            3+9 <= 8;
        EXIT;
    FI;
! allocate row and unpack primary key.!
    SQLM_TOWFAULTCODES_Workrow:SQLC_TOWFAULTCODES_Allocated = 1;
    DO SQLS_TOWFAULTCODES_UnpackKey;
! insert row in insert list (double linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_TOWFAULTCODES_TempRow =
    SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Left2;
IF SQLM_TOWFAULTCODES_TempRow /= SQLM_TOWFAULTCODES_NilRow THEN
    SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Right2 =
        SQLM_TOWFAULTCODES_WorkRow;
FI;
SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2 =
    SQLM_TOWFAULTCODES_TempRow;
SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Left2 =
    SQLM_TOWFAULTCODES_WorkRow;
SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Right2 =
    SQLM_TOWFAULTCODES_GuardRow;
! check if primary key is in insert list, if so jump to error.!
    SQLM_TOWFAULTCODES_OperRow = SQLM_TOWFAULTCODES_GuardRow;
    SQLX_Schedule = 0;
    SQLX_KeyPrefix = 2;
towInsSchLab6)
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towInsSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            6,
            SQLM_TOWFAULTCODES_WorkRow,
            SQLM_TOWFAULTCODES_OperRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            +,
            +,
            +,
            SQLX_KeyPrefix;
        EXIT;
    FI;
    SQLM_TOWFAULTCODES_OperRow =
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
    IF SQLM_TOWFAULTCODES_OperRow /= SQLM_TOWFAULTCODES_NilRow THEN
        IF SQLM_TOWFAULTCODES_OperRow /= SQLM_TOWFAULTCODES_WorkRow THEN
            DO SQLS_TOWFAULTCODES_KeyTest2;
            IF SQLX_KeyTest = 1 GOTO ERRORtowInsRowTableBTree7;
        FI;
        GOTO towInsSchLab6;
    FI;
! check if primary key IS in tree, if so jump to error.!
    SQLM_TOWFAULTCODES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Right2,
        SQLM_TOWFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        81;
    EXIT;
towGetSchLab81)
    SQLM_TOWFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_TOWFAULTCODES_OperRow=SQLX_Operrow;
    IF SQLM_TOWFAULTCODES_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowInsRowTableBTree7;
! set default values and unpack data from D7 to D21.!
    DO SQLS_TOWFAULTCODES_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_TOWFAULTCODES_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_TOWFAULTCODES_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TOWFAULTCODES_WorkRow;
    EXIT;
ERRORtowInsRowTableBTree7)
    SQLM_TOWFAULTCODES_OperRow = SQLM_TOWFAULTCODES_WorkRow;
    SQLM_TOWFAULTCODES_GuardRow = SQLM_TableReference:SQLM_System;
! remove row from insert list.!
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TOWFAULTCODES_TempRow =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Left2 =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
SQLM_TOWFAULTCODES_TempRow =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;

IF SQLM_TOWFAULTCODES_TempRow /= SQLM_TOWFAULTCODES_NilRow THEN
    SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Right2 =
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
FI;
! insert row in free list.!
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2 =
    SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2;
SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2 =
    SQLM_TOWFAULTCODES_OperRow;
! deallocate row.!
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0;
! send failure.!
    SEND towInsRowR WITH
        SQLX_OtherProtected,
! Search failure: Row already exists !
        2+5 <= 8;
    EXIT;
!------------------------------------------------!
!       towInsRowTableBTree !
!------------------------------------------------!
towInsRowTableBTree8)
    SQLM_SYSFAULTCODES_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_SYSFAULTCODES_NilRow = SQLM_SYSFAULTCODES_GuardRow + 1;
! get free row.!
!------------------------------------------------!
!       getFromFreeList !
!------------------------------------------------!
! Get first row from free list !
SQLM_SYSFAULTCODES_WorkRow =
    SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2;
IF SQLM_SYSFAULTCODES_WorkRow /= SQLM_SYSFAULTCODES_NilRow THEN
    SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2 =
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2;
FI;
    IF SQLM_SYSFAULTCODES_WorkRow = SQLM_SYSFAULTCODES_NilRow THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
!  Error: Table full !
            3+9 <= 8;
        EXIT;
    FI;
! allocate row and unpack primary key.!
    SQLM_SYSFAULTCODES_Workrow:SQLC_SYSFAULTCODES_Allocated = 1;
    DO SQLS_SYSFAULTCODES_UnpackKey;
! insert row in insert list (double linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_SYSFAULTCODES_TempRow =
    SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Left2;
IF SQLM_SYSFAULTCODES_TempRow /= SQLM_SYSFAULTCODES_NilRow THEN
    SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Right2 =
        SQLM_SYSFAULTCODES_WorkRow;
FI;
SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2 =
    SQLM_SYSFAULTCODES_TempRow;
SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Left2 =
    SQLM_SYSFAULTCODES_WorkRow;
SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Right2 =
    SQLM_SYSFAULTCODES_GuardRow;
! check if primary key is in insert list, if so jump to error.!
    SQLM_SYSFAULTCODES_OperRow = SQLM_SYSFAULTCODES_GuardRow;
    SQLX_Schedule = 0;
    SQLX_KeyPrefix = 1;
towInsSchLab7)
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towInsSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            7,
            SQLM_SYSFAULTCODES_WorkRow,
            SQLM_SYSFAULTCODES_OperRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            +,
            +,
            +,
            SQLX_KeyPrefix;
        EXIT;
    FI;
    SQLM_SYSFAULTCODES_OperRow =
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
    IF SQLM_SYSFAULTCODES_OperRow /= SQLM_SYSFAULTCODES_NilRow THEN
        IF SQLM_SYSFAULTCODES_OperRow /= SQLM_SYSFAULTCODES_WorkRow THEN
            DO SQLS_SYSFAULTCODES_KeyTest2;
            IF SQLX_KeyTest = 1 GOTO ERRORtowInsRowTableBTree8;
        FI;
        GOTO towInsSchLab7;
    FI;
! check if primary key IS in tree, if so jump to error.!
    SQLM_SYSFAULTCODES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Right2,
        SQLM_SYSFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        82;
    EXIT;
towGetSchLab82)
    SQLM_SYSFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_SYSFAULTCODES_OperRow=SQLX_Operrow;
    IF SQLM_SYSFAULTCODES_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowInsRowTableBTree8;
! set default values and unpack data from D7 to D21.!
    DO SQLS_SYSFAULTCODES_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_SYSFAULTCODES_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_SYSFAULTCODES_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSFAULTCODES_WorkRow;
    EXIT;
ERRORtowInsRowTableBTree8)
    SQLM_SYSFAULTCODES_OperRow = SQLM_SYSFAULTCODES_WorkRow;
    SQLM_SYSFAULTCODES_GuardRow = SQLM_TableReference:SQLM_System;
! remove row from insert list.!
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYSFAULTCODES_TempRow =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Left2 =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
SQLM_SYSFAULTCODES_TempRow =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;

IF SQLM_SYSFAULTCODES_TempRow /= SQLM_SYSFAULTCODES_NilRow THEN
    SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Right2 =
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
FI;
! insert row in free list.!
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2 =
    SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2;
SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2 =
    SQLM_SYSFAULTCODES_OperRow;
! deallocate row.!
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0;
! send failure.!
    SEND towInsRowR WITH
        SQLX_OtherProtected,
! Search failure: Row already exists !
        2+5 <= 8;
    EXIT;
!------------------------------------------------!
!       towInsRowTableBTree !
!------------------------------------------------!
towInsRowTableBTree9)
    SQLM_SYSTEMFIELDS_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_SYSTEMFIELDS_NilRow = SQLM_SYSTEMFIELDS_GuardRow + 1;
! get free row.!
!------------------------------------------------!
!       getFromFreeList !
!------------------------------------------------!
! Get first row from free list !
SQLM_SYSTEMFIELDS_WorkRow =
    SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2;
IF SQLM_SYSTEMFIELDS_WorkRow /= SQLM_SYSTEMFIELDS_NilRow THEN
    SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2 =
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2;
FI;
    IF SQLM_SYSTEMFIELDS_WorkRow = SQLM_SYSTEMFIELDS_NilRow THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
!  Error: Table full !
            3+9 <= 8;
        EXIT;
    FI;
! allocate row and unpack primary key.!
    SQLM_SYSTEMFIELDS_Workrow:SQLC_SYSTEMFIELDS_Allocated = 1;
    DO SQLS_SYSTEMFIELDS_UnpackKey;
! insert row in insert list (double linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_SYSTEMFIELDS_TempRow =
    SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Left2;
IF SQLM_SYSTEMFIELDS_TempRow /= SQLM_SYSTEMFIELDS_NilRow THEN
    SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Right2 =
        SQLM_SYSTEMFIELDS_WorkRow;
FI;
SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2 =
    SQLM_SYSTEMFIELDS_TempRow;
SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Left2 =
    SQLM_SYSTEMFIELDS_WorkRow;
SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Right2 =
    SQLM_SYSTEMFIELDS_GuardRow;
! check if primary key is in insert list, if so jump to error.!
    SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_GuardRow;
    SQLX_Schedule = 0;
    SQLX_KeyPrefix = 1;
towInsSchLab8)
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towInsSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            8,
            SQLM_SYSTEMFIELDS_WorkRow,
            SQLM_SYSTEMFIELDS_OperRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            +,
            +,
            +,
            SQLX_KeyPrefix;
        EXIT;
    FI;
    SQLM_SYSTEMFIELDS_OperRow =
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
    IF SQLM_SYSTEMFIELDS_OperRow /= SQLM_SYSTEMFIELDS_NilRow THEN
        IF SQLM_SYSTEMFIELDS_OperRow /= SQLM_SYSTEMFIELDS_WorkRow THEN
            DO SQLS_SYSTEMFIELDS_KeyTest2;
            IF SQLX_KeyTest = 1 GOTO ERRORtowInsRowTableBTree9;
        FI;
        GOTO towInsSchLab8;
    FI;
! check if primary key IS in tree, if so jump to error.!
    SQLM_SYSTEMFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right2,
        SQLM_SYSTEMFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        83;
    EXIT;
towGetSchLab83)
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow=SQLX_Operrow;
    IF SQLM_SYSTEMFIELDS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowInsRowTableBTree9;
! set default values and unpack data from D7 to D21.!
    DO SQLS_SYSTEMFIELDS_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_SYSTEMFIELDS_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_SYSTEMFIELDS_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSTEMFIELDS_WorkRow;
    EXIT;
ERRORtowInsRowTableBTree9)
    SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_WorkRow;
    SQLM_SYSTEMFIELDS_GuardRow = SQLM_TableReference:SQLM_System;
! remove row from insert list.!
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYSTEMFIELDS_TempRow =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Left2 =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
SQLM_SYSTEMFIELDS_TempRow =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;

IF SQLM_SYSTEMFIELDS_TempRow /= SQLM_SYSTEMFIELDS_NilRow THEN
    SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Right2 =
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
FI;
! insert row in free list.!
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2 =
    SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2;
SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2 =
    SQLM_SYSTEMFIELDS_OperRow;
! deallocate row.!
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0;
! send failure.!
    SEND towInsRowR WITH
        SQLX_OtherProtected,
! Search failure: Row already exists !
        2+5 <= 8;
    EXIT;
!------------------------------------------------!
!       towInsRowTableBTree !
!------------------------------------------------!
towInsRowTableBTree10)
    SQLM_TEST1_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_TEST1_NilRow = SQLM_TEST1_GuardRow + 1;
! get free row.!
!------------------------------------------------!
!       getFromFreeList !
!------------------------------------------------!
! Get first row from free list !
SQLM_TEST1_WorkRow =
    SQLM_TEST1_GuardRow:SQLC_TEST1_Right2;
IF SQLM_TEST1_WorkRow /= SQLM_TEST1_NilRow THEN
    SQLM_TEST1_GuardRow:SQLC_TEST1_Right2 =
        SQLM_TEST1_WorkRow:SQLC_TEST1_Left2;
FI;
    IF SQLM_TEST1_WorkRow = SQLM_TEST1_NilRow THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
!  Error: Table full !
            3+9 <= 8;
        EXIT;
    FI;
! allocate row and unpack primary key.!
    SQLM_TEST1_Workrow:SQLC_TEST1_Allocated = 1;
    DO SQLS_TEST1_UnpackKey;
! insert row in insert list (double linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_TEST1_TempRow =
    SQLM_TEST1_GuardRow:SQLC_TEST1_Left2;
IF SQLM_TEST1_TempRow /= SQLM_TEST1_NilRow THEN
    SQLM_TEST1_TempRow:SQLC_TEST1_Right2 =
        SQLM_TEST1_WorkRow;
FI;
SQLM_TEST1_WorkRow:SQLC_TEST1_Left2 =
    SQLM_TEST1_TempRow;
SQLM_TEST1_GuardRow:SQLC_TEST1_Left2 =
    SQLM_TEST1_WorkRow;
SQLM_TEST1_WorkRow:SQLC_TEST1_Right2 =
    SQLM_TEST1_GuardRow;
! check if primary key is in insert list, if so jump to error.!
    SQLM_TEST1_OperRow = SQLM_TEST1_GuardRow;
    SQLX_Schedule = 0;
    SQLX_KeyPrefix = 2;
towInsSchLab9)
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towInsSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            9,
            SQLM_TEST1_WorkRow,
            SQLM_TEST1_OperRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            +,
            +,
            +,
            SQLX_KeyPrefix;
        EXIT;
    FI;
    SQLM_TEST1_OperRow =
        SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
    IF SQLM_TEST1_OperRow /= SQLM_TEST1_NilRow THEN
        IF SQLM_TEST1_OperRow /= SQLM_TEST1_WorkRow THEN
            DO SQLS_TEST1_KeyTest2;
            IF SQLX_KeyTest = 1 GOTO ERRORtowInsRowTableBTree10;
        FI;
        GOTO towInsSchLab9;
    FI;
! check if primary key IS in tree, if so jump to error.!
    SQLM_TEST1_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TEST1_RootRow:SQLC_TEST1_Right2,
        SQLM_TEST1_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        84;
    EXIT;
towGetSchLab84)
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
    SQLM_TEST1_OperRow=SQLX_Operrow;
    IF SQLM_TEST1_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowInsRowTableBTree10;
! set default values and unpack data from D7 to D21.!
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL3_Null = 1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL4_Data = "xxx";
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL5_Null = 1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL6_Null = 1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL7_Null = 1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Null = 1;
    DO SQLS_TEST1_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_TEST1_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_TEST1_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TEST1_WorkRow;
    EXIT;
ERRORtowInsRowTableBTree10)
    SQLM_TEST1_OperRow = SQLM_TEST1_WorkRow;
    SQLM_TEST1_GuardRow = SQLM_TableReference:SQLM_System;
! remove row from insert list.!
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TEST1_TempRow =
    SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
SQLM_TEST1_TempRow:SQLC_TEST1_Left2 =
    SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
SQLM_TEST1_TempRow =
    SQLM_TEST1_OperRow:SQLC_TEST1_Left2;

IF SQLM_TEST1_TempRow /= SQLM_TEST1_NilRow THEN
    SQLM_TEST1_TempRow:SQLC_TEST1_Right2 =
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
FI;
! insert row in free list.!
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_TEST1_OperRow:SQLC_TEST1_Left2 =
    SQLM_TEST1_GuardRow:SQLC_TEST1_Right2;
SQLM_TEST1_GuardRow:SQLC_TEST1_Right2 =
    SQLM_TEST1_OperRow;
! deallocate row.!
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0;
! send failure.!
    SEND towInsRowR WITH
        SQLX_OtherProtected,
! Search failure: Row already exists !
        2+5 <= 8;
    EXIT;
!------------------------------------------------!
!       towInsSch !
!------------------------------------------------!
    ENTER towInsSch WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLX_ReturnLabel,
        SQLX_WorkRow,
        SQLX_OperRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
,
        +,
        +,
        +,
        SQLX_KeyPrefix;
    SQLX_Schedule = 0;
    CASE SQLM_TableReference IS
    WHEN 0 DO
        SQLM_PROGRAMS_WorkRow = SQLX_WorkRow;
        SQLM_PROGRAMS_OperRow = SQLX_OperRow;
        SQLM_PROGRAMS_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 1 DO
        SQLM_TABLES_WorkRow = SQLX_WorkRow;
        SQLM_TABLES_OperRow = SQLX_OperRow;
        SQLM_TABLES_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 2 DO
        SQLM_FIELDS_WorkRow = SQLX_WorkRow;
        SQLM_FIELDS_OperRow = SQLX_OperRow;
        SQLM_FIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 3 DO
        SQLM_KEYS_WorkRow = SQLX_WorkRow;
        SQLM_KEYS_OperRow = SQLX_OperRow;
        SQLM_KEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 4 DO
        SQLM_KEYFIELDS_WorkRow = SQLX_WorkRow;
        SQLM_KEYFIELDS_OperRow = SQLX_OperRow;
        SQLM_KEYFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 5 DO
        SQLM_FOREIGNKEYS_WorkRow = SQLX_WorkRow;
        SQLM_FOREIGNKEYS_OperRow = SQLX_OperRow;
        SQLM_FOREIGNKEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 6 DO
        SQLM_SYMBOLS_WorkRow = SQLX_WorkRow;
        SQLM_SYMBOLS_OperRow = SQLX_OperRow;
        SQLM_SYMBOLS_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 7 DO
        SQLM_TOWFAULTCODES_WorkRow = SQLX_WorkRow;
        SQLM_TOWFAULTCODES_OperRow = SQLX_OperRow;
        SQLM_TOWFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 8 DO
        SQLM_SYSFAULTCODES_WorkRow = SQLX_WorkRow;
        SQLM_SYSFAULTCODES_OperRow = SQLX_OperRow;
        SQLM_SYSFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 9 DO
        SQLM_SYSTEMFIELDS_WorkRow = SQLX_WorkRow;
        SQLM_SYSTEMFIELDS_OperRow = SQLX_OperRow;
        SQLM_SYSTEMFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 10 DO
        SQLM_TEST1_WorkRow = SQLX_WorkRow;
        SQLM_TEST1_OperRow = SQLX_OperRow;
        SQLM_TEST1_NilRow=SQLM_TableReference:SQLM_System+1;
    OTHERWISE DO;
    ESAC;
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towInsSchLab1;
    WHEN 2 DO GOTO towInsSchLab2;
    WHEN 3 DO GOTO towInsSchLab3;
    WHEN 4 DO GOTO towInsSchLab4;
    WHEN 5 DO GOTO towInsSchLab5;
    WHEN 6 DO GOTO towInsSchLab6;
    WHEN 7 DO GOTO towInsSchLab7;
    WHEN 8 DO GOTO towInsSchLab8;
    WHEN 9 DO GOTO towInsSchLab9;
    OTHERWISE DO ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towChaRow !
!------------------------------------------------!
    ENTER towChaRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    CASE SQLM_TableReference IS
    WHEN 0 DO GOTO towChaRowTable0;
    WHEN 1 DO GOTO towChaRowTable1;
    WHEN 2 DO GOTO towChaRowTable2;
    WHEN 3 DO GOTO towChaRowTable3;
    WHEN 4 DO GOTO towChaRowTable4;
    WHEN 5 DO GOTO towChaRowTable5;
    WHEN 6 DO GOTO towChaRowTable6;
    WHEN 7 DO GOTO towChaRowTable7;
    WHEN 8 DO GOTO towChaRowTable8;
    WHEN 9 DO GOTO towChaRowTable9;
    WHEN 10 DO GOTO towChaRowTable10;
    OTHERWISE DO;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
towChaRowTable0)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towChaRowTableKeyRow0;
    WHEN 1 DO GOTO towChaRowTableKeyCursor0;
    WHEN 2 DO GOTO towChaRowTableKeyBTree0;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow0)
! unpack key (set pOperRow).!
    DO SQLS_PROGRAMS_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_PROGRAMS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_PROGRAMS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree0;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree0;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow43;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow43;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree0;
WORKALLOCATEallocateWorkRow43)
    IF SQLM_PROGRAMS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_PROGRAMS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=1;
    GOTO towChaRowTableKeyContinue0;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor0)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_PROGRAMS_UnPackkey;
    SQLM_PROGRAMS_OperRow =
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_PROGRAMS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_DBnumber2 /=
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_PROGRAMS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree0;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree0;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow44;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow44;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree0;
WORKALLOCATEallocateWorkRow44)
    IF SQLM_PROGRAMS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_PROGRAMS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=1;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Color2 = 1;
    GOTO towChaRowTableKeyContinue0;
!------------------------------------------------!
!       towChaRowTableKeyBTree !
!------------------------------------------------!
towChaRowTableKeyBTree0)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree0;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree0;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow45;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow45;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree0;
WORKALLOCATEallocateWorkRow45)
    IF SQLM_PROGRAMS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_PROGRAMS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=1;
! unpack key into the work row.!
    DO SQLS_PROGRAMS_UnPackKey;
! find an operating row.!
    SQLM_PROGRAMS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Right2,
        SQLM_PROGRAMS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        85;
    EXIT;
towGetSchLab85)
    SQLM_PROGRAMS_WorkRow=SQLX_WorkRow;
    SQLM_PROGRAMS_OperRow=SQLX_Operrow;
! check if row is not allocated, if so deallocate work row and report failure.!
    IF SQLM_PROGRAMS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock > 0 THEN
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
            2+2 <= 8,
! Search failure: Row locked for update or delete !
            SQLM_PROGRAMS_OperRow;
        EXIT;
    FI;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Color2 = 1;
    GOTO towChaRowTableKeyContinue0;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue0)
! lock operating row.!
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock = 1;
! copy each column except primary key components.!
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_NAME_Data =
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_NAME_Data;
! unpack column data.!
    DO SQLS_PROGRAMS_UnPack;
! insert row in insert list (double linked).!
    SQLM_PROGRAMS_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_PROGRAMS_NilRow = SQLM_PROGRAMS_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_PROGRAMS_TempRow =
    SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Left2;
IF SQLM_PROGRAMS_TempRow /= SQLM_PROGRAMS_NilRow THEN
    SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Right2 =
        SQLM_PROGRAMS_WorkRow;
FI;
SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2 =
    SQLM_PROGRAMS_TempRow;
SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Left2 =
    SQLM_PROGRAMS_WorkRow;
SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Right2 =
    SQLM_PROGRAMS_GuardRow;
! send back success.!
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Color2=1;
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_PROGRAMS_OperRow,
        SQLM_PROGRAMS_WorkRow,
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree0)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree0)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
towChaRowTable1)
    CASE SQLX_KeyNumber IS
    WHEN 0,2 DO GOTO towChaRowTableKeyRow1;
    WHEN 1 DO GOTO towChaRowTableKeyCursor1;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow1)
! unpack key (set pOperRow).!
    DO SQLS_TABLES_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_TABLES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TABLES_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree1;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree1;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow46;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow46;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree1;
WORKALLOCATEallocateWorkRow46)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
    GOTO towChaRowTableKeyContinue1;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor1)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_TABLES_UnPackkey;
    SQLM_TABLES_OperRow =
        SQLM_TABLES_WorkRow:SQLC_TABLES_Left3;
! check if a row was not found, if so report failure.!
    IF SQLM_TABLES_WorkRow:SQLC_TABLES_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_TABLES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2 /=
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TABLES_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree1;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree1;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow47;
    FOR FIRST SQLM_TABLES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow47;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree1;
WORKALLOCATEallocateWorkRow47)
    IF SQLM_TABLES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=1;
    GOTO towChaRowTableKeyContinue1;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue1)
! lock operating row.!
    SQLM_TABLES_OperRow:SQLC_TABLES_Lock = 1;
! copy each column except primary key components.!
    SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_NAME_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_BLKREF_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_TABREF_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_DESCR_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_DESCR_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_SAEIDT_Null =
        SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Null;
    SQLM_TABLES_WorkRow:SQLC_TABLES_SAEIDT_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_ESTEPT_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_ESTEPT_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_MAXST_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_MAXST_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_ALLOCST_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_ALLOCST_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_USEDST_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_USEDST_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_SAEIDW_Null =
        SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDW_Null;
    SQLM_TABLES_WorkRow:SQLC_TABLES_SAEIDW_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDW_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_ESTEPW_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_ESTEPW_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_MAXSW_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_MAXSW_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_ALLOCSW_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_ALLOCSW_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_USEDSW_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_USEDSW_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_STATE_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_STATE_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_RAUCAT_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_RAUCAT_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_WAUCAT_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_WAUCAT_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_LOCATE_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_LOCATE_Data;
    SQLM_TABLES_WorkRow:SQLC_TABLES_NOFLTCO_Data =
        SQLM_TABLES_OperRow:SQLC_TABLES_NOFLTCO_Data;
! unpack column data.!
    DO SQLS_TABLES_UnPack;
! insert row in insert list (double linked).!
    SQLM_TABLES_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_TABLES_NilRow = SQLM_TABLES_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_TABLES_TempRow =
    SQLM_TABLES_GuardRow:SQLC_TABLES_Left3;
IF SQLM_TABLES_TempRow /= SQLM_TABLES_NilRow THEN
    SQLM_TABLES_TempRow:SQLC_TABLES_Right3 =
        SQLM_TABLES_WorkRow;
FI;
SQLM_TABLES_WorkRow:SQLC_TABLES_Left3 =
    SQLM_TABLES_TempRow;
SQLM_TABLES_GuardRow:SQLC_TABLES_Left3 =
    SQLM_TABLES_WorkRow;
SQLM_TABLES_WorkRow:SQLC_TABLES_Right3 =
    SQLM_TABLES_GuardRow;
! send back success.!
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLES_OperRow,
        SQLM_TABLES_WorkRow,
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree1)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree1)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
towChaRowTable2)
    CASE SQLX_KeyNumber IS
    WHEN 0,2 DO GOTO towChaRowTableKeyRow2;
    WHEN 1 DO GOTO towChaRowTableKeyCursor2;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow2)
! unpack key (set pOperRow).!
    DO SQLS_FIELDS_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_FIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_FIELDS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree2;
    FOR FIRST SQLM_FIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow48;
    FOR FIRST SQLM_FIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow48;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree2;
WORKALLOCATEallocateWorkRow48)
    IF SQLM_FIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated=1;
    GOTO towChaRowTableKeyContinue2;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor2)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_FIELDS_UnPackkey;
    SQLM_FIELDS_OperRow =
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3;
! check if a row was not found, if so report failure.!
    IF SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_FIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_FIELDS_WorkRow:SQLC_FIELDS_DBnumber2 /=
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_FIELDS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree2;
    FOR FIRST SQLM_FIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow49;
    FOR FIRST SQLM_FIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow49;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree2;
WORKALLOCATEallocateWorkRow49)
    IF SQLM_FIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated=1;
    GOTO towChaRowTableKeyContinue2;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue2)
! lock operating row.!
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock = 1;
! copy each column except primary key components.!
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_NAME_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_NAME_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_TABREF_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_TABREF_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_BLKREF_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_BLKREF_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_FIELDNO_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_FIELDNO_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DESCR_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DESCR_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_VISIBIL_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_VISIBIL_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_PRWIDTH_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_PRWIDTH_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_NULLPER_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_NULLPER_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DATATYP_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DATATYP_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_BADDRES_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_BADDRES_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_MIN_Null =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_MIN_Null;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_MIN_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_MIN_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_MAX_Null =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_MAX_Null;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_MAX_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_MAX_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_SIZE_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_SIZE_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DIDNR_Null =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DIDNR_Null;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DIDNR_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DIDNR_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DIDPOS_Null =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DIDPOS_Null;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DIDPOS_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DIDPOS_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_PCLEAR_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_PCLEAR_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_PRELOAD_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_PRELOAD_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_PDUMP_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_PDUMP_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_PSTATIC_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_PSTATIC_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_VOLATIL_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_VOLATIL_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFBITS_Null =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFBITS_Null;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFBITS_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFBITS_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFSTR_Null =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFSTR_Null;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFSTR_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFSTR_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFNSTR_Null =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFNSTR_Null;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFNSTR_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFNSTR_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Null =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Null;
!------------------------------------------------!
!       copyPackNum !
!------------------------------------------------!

    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.LENGTH =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.LENGTH;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W1 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W1;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W2 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W2;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W3 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W3;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W4 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W4;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W5 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W5;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W6 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W6;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W7 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W7;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFSYMB_Null =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFSYMB_Null;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFSYMB_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFSYMB_Data;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_TROWNO_Null =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_TROWNO_Null;
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_TROWNO_Data =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_TROWNO_Data;
! unpack column data.!
    DO SQLS_FIELDS_UnPack;
! insert row in insert list (double linked).!
    SQLM_FIELDS_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_FIELDS_NilRow = SQLM_FIELDS_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_FIELDS_TempRow =
    SQLM_FIELDS_GuardRow:SQLC_FIELDS_Left3;
IF SQLM_FIELDS_TempRow /= SQLM_FIELDS_NilRow THEN
    SQLM_FIELDS_TempRow:SQLC_FIELDS_Right3 =
        SQLM_FIELDS_WorkRow;
FI;
SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3 =
    SQLM_FIELDS_TempRow;
SQLM_FIELDS_GuardRow:SQLC_FIELDS_Left3 =
    SQLM_FIELDS_WorkRow;
SQLM_FIELDS_WorkRow:SQLC_FIELDS_Right3 =
    SQLM_FIELDS_GuardRow;
! send back success.!
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_FIELDS_OperRow,
        SQLM_FIELDS_WorkRow,
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree2)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree2)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
towChaRowTable3)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towChaRowTableKeyRow3;
    WHEN 1 DO GOTO towChaRowTableKeyCursor3;
    WHEN 2 DO GOTO towChaRowTableKeyBTree3;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow3)
! unpack key (set pOperRow).!
    DO SQLS_KEYS_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_KEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_KEYS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree3;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow50;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow50;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree3;
WORKALLOCATEallocateWorkRow50)
    IF SQLM_KEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=1;
    GOTO towChaRowTableKeyContinue3;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor3)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_KEYS_UnPackkey;
    SQLM_KEYS_OperRow =
        SQLM_KEYS_WorkRow:SQLC_KEYS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_KEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_KEYS_WorkRow:SQLC_KEYS_DBnumber2 /=
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_KEYS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree3;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow51;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow51;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree3;
WORKALLOCATEallocateWorkRow51)
    IF SQLM_KEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=1;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_KEYS_WorkRow:SQLC_KEYS_Color2 = 1;
    GOTO towChaRowTableKeyContinue3;
!------------------------------------------------!
!       towChaRowTableKeyBTree !
!------------------------------------------------!
towChaRowTableKeyBTree3)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree3;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow52;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow52;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree3;
WORKALLOCATEallocateWorkRow52)
    IF SQLM_KEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=1;
! unpack key into the work row.!
    DO SQLS_KEYS_UnPackKey;
! find an operating row.!
    SQLM_KEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right2,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        86;
    EXIT;
towGetSchLab86)
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_OperRow=SQLX_Operrow;
! check if row is not allocated, if so deallocate work row and report failure.!
    IF SQLM_KEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 0 THEN
        SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
            2+2 <= 8,
! Search failure: Row locked for update or delete !
            SQLM_KEYS_OperRow;
        EXIT;
    FI;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_KEYS_WorkRow:SQLC_KEYS_Color2 = 1;
    GOTO towChaRowTableKeyContinue3;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue3)
! lock operating row.!
    SQLM_KEYS_OperRow:SQLC_KEYS_Lock = 1;
! copy each column except primary key components.!
    SQLM_KEYS_WorkRow:SQLC_KEYS_TABREF_Data =
        SQLM_KEYS_OperRow:SQLC_KEYS_TABREF_Data;
    SQLM_KEYS_WorkRow:SQLC_KEYS_BLKREF_Data =
        SQLM_KEYS_OperRow:SQLC_KEYS_BLKREF_Data;
    SQLM_KEYS_WorkRow:SQLC_KEYS_KEYTYPE_Data =
        SQLM_KEYS_OperRow:SQLC_KEYS_KEYTYPE_Data;
! unpack column data.!
    DO SQLS_KEYS_UnPack;
! insert row in insert list (double linked).!
    SQLM_KEYS_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_KEYS_NilRow = SQLM_KEYS_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_KEYS_TempRow =
    SQLM_KEYS_GuardRow:SQLC_KEYS_Left2;
IF SQLM_KEYS_TempRow /= SQLM_KEYS_NilRow THEN
    SQLM_KEYS_TempRow:SQLC_KEYS_Right2 =
        SQLM_KEYS_WorkRow;
FI;
SQLM_KEYS_WorkRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_TempRow;
SQLM_KEYS_GuardRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_WorkRow;
SQLM_KEYS_WorkRow:SQLC_KEYS_Right2 =
    SQLM_KEYS_GuardRow;
! send back success.!
    SQLM_KEYS_WorkRow:SQLC_KEYS_Color2=1;
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYS_OperRow,
        SQLM_KEYS_WorkRow,
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree3)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree3)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
towChaRowTable4)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towChaRowTableKeyRow4;
    WHEN 1 DO GOTO towChaRowTableKeyCursor4;
    WHEN 2 DO GOTO towChaRowTableKeyBTree4;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow4)
! unpack key (set pOperRow).!
    DO SQLS_KEYFIELDS_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_KEYFIELDS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree4;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree4;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow53;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow53;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree4;
WORKALLOCATEallocateWorkRow53)
    IF SQLM_KEYFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=1;
    GOTO towChaRowTableKeyContinue4;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor4)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_KEYFIELDS_UnPackkey;
    SQLM_KEYFIELDS_OperRow =
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_DBnumber2 /=
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_KEYFIELDS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree4;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree4;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow54;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow54;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree4;
WORKALLOCATEallocateWorkRow54)
    IF SQLM_KEYFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=1;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Color2 = 1;
    GOTO towChaRowTableKeyContinue4;
!------------------------------------------------!
!       towChaRowTableKeyBTree !
!------------------------------------------------!
towChaRowTableKeyBTree4)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree4;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree4;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow55;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow55;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree4;
WORKALLOCATEallocateWorkRow55)
    IF SQLM_KEYFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=1;
! unpack key into the work row.!
    DO SQLS_KEYFIELDS_UnPackKey;
! find an operating row.!
    SQLM_KEYFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right2,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        3,
        +,
        87;
    EXIT;
towGetSchLab87)
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_KEYFIELDS_OperRow=SQLX_Operrow;
! check if row is not allocated, if so deallocate work row and report failure.!
    IF SQLM_KEYFIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 0 THEN
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
            2+2 <= 8,
! Search failure: Row locked for update or delete !
            SQLM_KEYFIELDS_OperRow;
        EXIT;
    FI;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Color2 = 1;
    GOTO towChaRowTableKeyContinue4;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue4)
! lock operating row.!
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock = 1;
! copy each column except primary key components.!
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_TABREF_Data =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_TABREF_Data;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_BLKREF_Data =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_BLKREF_Data;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_FROWNO_Data =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_FROWNO_Data;
! unpack column data.!
    DO SQLS_KEYFIELDS_UnPack;
! insert row in insert list (double linked).!
    SQLM_KEYFIELDS_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_KEYFIELDS_NilRow = SQLM_KEYFIELDS_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Left2;
IF SQLM_KEYFIELDS_TempRow /= SQLM_KEYFIELDS_NilRow THEN
    SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Right2 =
        SQLM_KEYFIELDS_WorkRow;
FI;
SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_TempRow;
SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_WorkRow;
SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Right2 =
    SQLM_KEYFIELDS_GuardRow;
! send back success.!
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Color2=1;
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYFIELDS_OperRow,
        SQLM_KEYFIELDS_WorkRow,
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree4)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree4)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
towChaRowTable5)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towChaRowTableKeyRow5;
    WHEN 1 DO GOTO towChaRowTableKeyCursor5;
    WHEN 2 DO GOTO towChaRowTableKeyBTree5;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow5)
! unpack key (set pOperRow).!
    DO SQLS_FOREIGNKEYS_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_FOREIGNKEYS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree5;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree5;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow56;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow56;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree5;
WORKALLOCATEallocateWorkRow56)
    IF SQLM_FOREIGNKEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FOREIGNKEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=1;
    GOTO towChaRowTableKeyContinue5;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor5)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_FOREIGNKEYS_UnPackkey;
    SQLM_FOREIGNKEYS_OperRow =
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_DBnumber2 /=
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_FOREIGNKEYS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree5;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree5;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow57;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow57;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree5;
WORKALLOCATEallocateWorkRow57)
    IF SQLM_FOREIGNKEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FOREIGNKEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=1;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Color2 = 1;
    GOTO towChaRowTableKeyContinue5;
!------------------------------------------------!
!       towChaRowTableKeyBTree !
!------------------------------------------------!
towChaRowTableKeyBTree5)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree5;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree5;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow58;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow58;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree5;
WORKALLOCATEallocateWorkRow58)
    IF SQLM_FOREIGNKEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FOREIGNKEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=1;
! unpack key into the work row.!
    DO SQLS_FOREIGNKEYS_UnPackKey;
! find an operating row.!
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right2,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        88;
    EXIT;
towGetSchLab88)
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Operrow;
! check if row is not allocated, if so deallocate work row and report failure.!
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 0 THEN
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
            2+2 <= 8,
! Search failure: Row locked for update or delete !
            SQLM_FOREIGNKEYS_OperRow;
        EXIT;
    FI;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Color2 = 1;
    GOTO towChaRowTableKeyContinue5;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue5)
! lock operating row.!
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock = 1;
! copy each column except primary key components.!
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_BLKREF_Data =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_BLKREF_Data;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_TABREF_Data =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_TABREF_Data;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_KEYNO_Data =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_KEYNO_Data;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_FTROWNO_Data =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_FTROWNO_Data;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_FTABREF_Data =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_FTABREF_Data;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_FBLKREF_Data =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_FBLKREF_Data;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_COND_Data =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_COND_Data;
! unpack column data.!
    DO SQLS_FOREIGNKEYS_UnPack;
! insert row in insert list (double linked).!
    SQLM_FOREIGNKEYS_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_FOREIGNKEYS_NilRow = SQLM_FOREIGNKEYS_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Left2;
IF SQLM_FOREIGNKEYS_TempRow /= SQLM_FOREIGNKEYS_NilRow THEN
    SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Right2 =
        SQLM_FOREIGNKEYS_WorkRow;
FI;
SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_TempRow;
SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_WorkRow;
SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Right2 =
    SQLM_FOREIGNKEYS_GuardRow;
! send back success.!
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Color2=1;
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_WorkRow,
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree5)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree5)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
towChaRowTable6)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towChaRowTableKeyRow6;
    WHEN 1 DO GOTO towChaRowTableKeyCursor6;
    WHEN 2 DO GOTO towChaRowTableKeyBTree6;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow6)
! unpack key (set pOperRow).!
    DO SQLS_SYMBOLS_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYMBOLS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_SYMBOLS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree6;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree6;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow59;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow59;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree6;
WORKALLOCATEallocateWorkRow59)
    IF SQLM_SYMBOLS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYMBOLS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=1;
    GOTO towChaRowTableKeyContinue6;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor6)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_SYMBOLS_UnPackkey;
    SQLM_SYMBOLS_OperRow =
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYMBOLS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_DBnumber2 /=
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_SYMBOLS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree6;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree6;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow60;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow60;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree6;
WORKALLOCATEallocateWorkRow60)
    IF SQLM_SYMBOLS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYMBOLS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=1;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Color2 = 1;
    GOTO towChaRowTableKeyContinue6;
!------------------------------------------------!
!       towChaRowTableKeyBTree !
!------------------------------------------------!
towChaRowTableKeyBTree6)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree6;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree6;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow61;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow61;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree6;
WORKALLOCATEallocateWorkRow61)
    IF SQLM_SYMBOLS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYMBOLS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=1;
! unpack key into the work row.!
    DO SQLS_SYMBOLS_UnPackKey;
! find an operating row.!
    SQLM_SYMBOLS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right2,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        89;
    EXIT;
towGetSchLab89)
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    SQLM_SYMBOLS_OperRow=SQLX_Operrow;
! check if row is not allocated, if so deallocate work row and report failure.!
    IF SQLM_SYMBOLS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 0 THEN
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
            2+2 <= 8,
! Search failure: Row locked for update or delete !
            SQLM_SYMBOLS_OperRow;
        EXIT;
    FI;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Color2 = 1;
    GOTO towChaRowTableKeyContinue6;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue6)
! lock operating row.!
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock = 1;
! copy each column except primary key components.!
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_SYMVAL_Data =
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_SYMVAL_Data;
! unpack column data.!
    DO SQLS_SYMBOLS_UnPack;
! insert row in insert list (double linked).!
    SQLM_SYMBOLS_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_SYMBOLS_NilRow = SQLM_SYMBOLS_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Left2;
IF SQLM_SYMBOLS_TempRow /= SQLM_SYMBOLS_NilRow THEN
    SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Right2 =
        SQLM_SYMBOLS_WorkRow;
FI;
SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_TempRow;
SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_WorkRow;
SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Right2 =
    SQLM_SYMBOLS_GuardRow;
! send back success.!
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Color2=1;
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYMBOLS_OperRow,
        SQLM_SYMBOLS_WorkRow,
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree6)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree6)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
towChaRowTable7)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towChaRowTableKeyRow7;
    WHEN 1 DO GOTO towChaRowTableKeyCursor7;
    WHEN 2 DO GOTO towChaRowTableKeyBTree7;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow7)
! unpack key (set pOperRow).!
    DO SQLS_TOWFAULTCODES_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TOWFAULTCODES_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree7;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree7;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow62;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow62;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree7;
WORKALLOCATEallocateWorkRow62)
    IF SQLM_TOWFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TOWFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=1;
    GOTO towChaRowTableKeyContinue7;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor7)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_TOWFAULTCODES_UnPackkey;
    SQLM_TOWFAULTCODES_OperRow =
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_DBnumber2 /=
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TOWFAULTCODES_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree7;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree7;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow63;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow63;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree7;
WORKALLOCATEallocateWorkRow63)
    IF SQLM_TOWFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TOWFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=1;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Color2 = 1;
    GOTO towChaRowTableKeyContinue7;
!------------------------------------------------!
!       towChaRowTableKeyBTree !
!------------------------------------------------!
towChaRowTableKeyBTree7)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree7;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree7;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow64;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow64;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree7;
WORKALLOCATEallocateWorkRow64)
    IF SQLM_TOWFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TOWFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=1;
! unpack key into the work row.!
    DO SQLS_TOWFAULTCODES_UnPackKey;
! find an operating row.!
    SQLM_TOWFAULTCODES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Right2,
        SQLM_TOWFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        90;
    EXIT;
towGetSchLab90)
    SQLM_TOWFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_TOWFAULTCODES_OperRow=SQLX_Operrow;
! check if row is not allocated, if so deallocate work row and report failure.!
    IF SQLM_TOWFAULTCODES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock > 0 THEN
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
            2+2 <= 8,
! Search failure: Row locked for update or delete !
            SQLM_TOWFAULTCODES_OperRow;
        EXIT;
    FI;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Color2 = 1;
    GOTO towChaRowTableKeyContinue7;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue7)
! lock operating row.!
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock = 1;
! copy each column except primary key components.!
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_FLTTEXT_Data =
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_FLTTEXT_Data;
! unpack column data.!
    DO SQLS_TOWFAULTCODES_UnPack;
! insert row in insert list (double linked).!
    SQLM_TOWFAULTCODES_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_TOWFAULTCODES_NilRow = SQLM_TOWFAULTCODES_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_TOWFAULTCODES_TempRow =
    SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Left2;
IF SQLM_TOWFAULTCODES_TempRow /= SQLM_TOWFAULTCODES_NilRow THEN
    SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Right2 =
        SQLM_TOWFAULTCODES_WorkRow;
FI;
SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2 =
    SQLM_TOWFAULTCODES_TempRow;
SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Left2 =
    SQLM_TOWFAULTCODES_WorkRow;
SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Right2 =
    SQLM_TOWFAULTCODES_GuardRow;
! send back success.!
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Color2=1;
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TOWFAULTCODES_OperRow,
        SQLM_TOWFAULTCODES_WorkRow,
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree7)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree7)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
towChaRowTable8)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towChaRowTableKeyRow8;
    WHEN 1 DO GOTO towChaRowTableKeyCursor8;
    WHEN 2 DO GOTO towChaRowTableKeyBTree8;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow8)
! unpack key (set pOperRow).!
    DO SQLS_SYSFAULTCODES_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_SYSFAULTCODES_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree8;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree8;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow65;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow65;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree8;
WORKALLOCATEallocateWorkRow65)
    IF SQLM_SYSFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=1;
    GOTO towChaRowTableKeyContinue8;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor8)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_SYSFAULTCODES_UnPackkey;
    SQLM_SYSFAULTCODES_OperRow =
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_DBnumber2 /=
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_SYSFAULTCODES_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree8;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree8;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow66;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow66;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree8;
WORKALLOCATEallocateWorkRow66)
    IF SQLM_SYSFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=1;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Color2 = 1;
    GOTO towChaRowTableKeyContinue8;
!------------------------------------------------!
!       towChaRowTableKeyBTree !
!------------------------------------------------!
towChaRowTableKeyBTree8)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree8;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree8;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow67;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow67;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree8;
WORKALLOCATEallocateWorkRow67)
    IF SQLM_SYSFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=1;
! unpack key into the work row.!
    DO SQLS_SYSFAULTCODES_UnPackKey;
! find an operating row.!
    SQLM_SYSFAULTCODES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Right2,
        SQLM_SYSFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        91;
    EXIT;
towGetSchLab91)
    SQLM_SYSFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_SYSFAULTCODES_OperRow=SQLX_Operrow;
! check if row is not allocated, if so deallocate work row and report failure.!
    IF SQLM_SYSFAULTCODES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock > 0 THEN
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
            2+2 <= 8,
! Search failure: Row locked for update or delete !
            SQLM_SYSFAULTCODES_OperRow;
        EXIT;
    FI;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Color2 = 1;
    GOTO towChaRowTableKeyContinue8;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue8)
! lock operating row.!
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock = 1;
! copy each column except primary key components.!
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_FLTTEXT_Data =
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_FLTTEXT_Data;
! unpack column data.!
    DO SQLS_SYSFAULTCODES_UnPack;
! insert row in insert list (double linked).!
    SQLM_SYSFAULTCODES_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_SYSFAULTCODES_NilRow = SQLM_SYSFAULTCODES_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_SYSFAULTCODES_TempRow =
    SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Left2;
IF SQLM_SYSFAULTCODES_TempRow /= SQLM_SYSFAULTCODES_NilRow THEN
    SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Right2 =
        SQLM_SYSFAULTCODES_WorkRow;
FI;
SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2 =
    SQLM_SYSFAULTCODES_TempRow;
SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Left2 =
    SQLM_SYSFAULTCODES_WorkRow;
SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Right2 =
    SQLM_SYSFAULTCODES_GuardRow;
! send back success.!
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Color2=1;
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSFAULTCODES_OperRow,
        SQLM_SYSFAULTCODES_WorkRow,
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree8)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree8)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
towChaRowTable9)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towChaRowTableKeyRow9;
    WHEN 1 DO GOTO towChaRowTableKeyCursor9;
    WHEN 2 DO GOTO towChaRowTableKeyBTree9;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow9)
! unpack key (set pOperRow).!
    DO SQLS_SYSTEMFIELDS_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_SYSTEMFIELDS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree9;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree9;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow68;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow68;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree9;
WORKALLOCATEallocateWorkRow68)
    IF SQLM_SYSTEMFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSTEMFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=1;
    GOTO towChaRowTableKeyContinue9;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor9)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_SYSTEMFIELDS_UnPackkey;
    SQLM_SYSTEMFIELDS_OperRow =
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_DBnumber2 /=
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_SYSTEMFIELDS_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree9;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree9;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow69;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow69;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree9;
WORKALLOCATEallocateWorkRow69)
    IF SQLM_SYSTEMFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSTEMFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=1;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Color2 = 1;
    GOTO towChaRowTableKeyContinue9;
!------------------------------------------------!
!       towChaRowTableKeyBTree !
!------------------------------------------------!
towChaRowTableKeyBTree9)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree9;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree9;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow70;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow70;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree9;
WORKALLOCATEallocateWorkRow70)
    IF SQLM_SYSTEMFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSTEMFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=1;
! unpack key into the work row.!
    DO SQLS_SYSTEMFIELDS_UnPackKey;
! find an operating row.!
    SQLM_SYSTEMFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right2,
        SQLM_SYSTEMFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        92;
    EXIT;
towGetSchLab92)
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow=SQLX_Operrow;
! check if row is not allocated, if so deallocate work row and report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock > 0 THEN
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
            2+2 <= 8,
! Search failure: Row locked for update or delete !
            SQLM_SYSTEMFIELDS_OperRow;
        EXIT;
    FI;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Color2 = 1;
    GOTO towChaRowTableKeyContinue9;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue9)
! lock operating row.!
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock = 1;
! copy each column except primary key components.!
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_ROWGEN_Data =
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_ROWGEN_Data;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_LOCK_Data =
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_LOCK_Data;
! unpack column data.!
    DO SQLS_SYSTEMFIELDS_UnPack;
! insert row in insert list (double linked).!
    SQLM_SYSTEMFIELDS_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_SYSTEMFIELDS_NilRow = SQLM_SYSTEMFIELDS_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_SYSTEMFIELDS_TempRow =
    SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Left2;
IF SQLM_SYSTEMFIELDS_TempRow /= SQLM_SYSTEMFIELDS_NilRow THEN
    SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Right2 =
        SQLM_SYSTEMFIELDS_WorkRow;
FI;
SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2 =
    SQLM_SYSTEMFIELDS_TempRow;
SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Left2 =
    SQLM_SYSTEMFIELDS_WorkRow;
SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Right2 =
    SQLM_SYSTEMFIELDS_GuardRow;
! send back success.!
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Color2=1;
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSTEMFIELDS_OperRow,
        SQLM_SYSTEMFIELDS_WorkRow,
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree9)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree9)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
towChaRowTable10)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towChaRowTableKeyRow10;
    WHEN 1 DO GOTO towChaRowTableKeyCursor10;
    WHEN 2 DO GOTO towChaRowTableKeyBTree10;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow10)
! unpack key (set pOperRow).!
    DO SQLS_TEST1_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_TEST1_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TEST1_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree10;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree10;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow71;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow71;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree10;
WORKALLOCATEallocateWorkRow71)
    IF SQLM_TEST1_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TEST1_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=1;
    GOTO towChaRowTableKeyContinue10;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor10)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_TEST1_UnPackkey;
    SQLM_TEST1_OperRow =
        SQLM_TEST1_WorkRow:SQLC_TEST1_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_TEST1_WorkRow:SQLC_TEST1_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_TEST1_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_TEST1_WorkRow:SQLC_TEST1_DBnumber2 /=
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TEST1_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree10;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree10;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow72;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow72;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree10;
WORKALLOCATEallocateWorkRow72)
    IF SQLM_TEST1_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TEST1_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=1;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_TEST1_WorkRow:SQLC_TEST1_Color2 = 1;
    GOTO towChaRowTableKeyContinue10;
!------------------------------------------------!
!       towChaRowTableKeyBTree !
!------------------------------------------------!
towChaRowTableKeyBTree10)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree10;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree10;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow73;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow73;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree10;
WORKALLOCATEallocateWorkRow73)
    IF SQLM_TEST1_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TEST1_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=1;
! unpack key into the work row.!
    DO SQLS_TEST1_UnPackKey;
! find an operating row.!
    SQLM_TEST1_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TEST1_RootRow:SQLC_TEST1_Right2,
        SQLM_TEST1_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        93;
    EXIT;
towGetSchLab93)
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
    SQLM_TEST1_OperRow=SQLX_Operrow;
! check if row is not allocated, if so deallocate work row and report failure.!
    IF SQLM_TEST1_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Lock > 0 THEN
        SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
            2+2 <= 8,
! Search failure: Row locked for update or delete !
            SQLM_TEST1_OperRow;
        EXIT;
    FI;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_TEST1_WorkRow:SQLC_TEST1_Color2 = 1;
    GOTO towChaRowTableKeyContinue10;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue10)
! lock operating row.!
    SQLM_TEST1_OperRow:SQLC_TEST1_Lock = 1;
! copy each column except primary key components.!
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL3_Null =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL3_Null;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL3_Data =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL3_Data;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL4_Data =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL4_Data;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL5_Null =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL5_Null;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL5_Data =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL5_Data;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL6_Null =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL6_Null;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL6_Data =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL6_Data;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL7_Null =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL7_Null;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL7_Data =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL7_Data;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Null =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Null;
!------------------------------------------------!
!       copyPackNum !
!------------------------------------------------!

    SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.LENGTH =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.LENGTH;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W1 =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W2 =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W2;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W3 =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W3;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W4 =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W4;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W5 =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W5;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W6 =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W6;
    SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W7 =
        SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W7;
! unpack column data.!
    DO SQLS_TEST1_UnPack;
! insert row in insert list (double linked).!
    SQLM_TEST1_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_TEST1_NilRow = SQLM_TEST1_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_TEST1_TempRow =
    SQLM_TEST1_GuardRow:SQLC_TEST1_Left2;
IF SQLM_TEST1_TempRow /= SQLM_TEST1_NilRow THEN
    SQLM_TEST1_TempRow:SQLC_TEST1_Right2 =
        SQLM_TEST1_WorkRow;
FI;
SQLM_TEST1_WorkRow:SQLC_TEST1_Left2 =
    SQLM_TEST1_TempRow;
SQLM_TEST1_GuardRow:SQLC_TEST1_Left2 =
    SQLM_TEST1_WorkRow;
SQLM_TEST1_WorkRow:SQLC_TEST1_Right2 =
    SQLM_TEST1_GuardRow;
! send back success.!
    SQLM_TEST1_WorkRow:SQLC_TEST1_Color2=1;
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TEST1_OperRow,
        SQLM_TEST1_WorkRow,
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree10)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree10)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRow !
!------------------------------------------------!
    ENTER towDelRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +,
        +,
        +
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    CASE SQLM_TableReference IS
    WHEN 0 DO GOTO towDelRowTable0;
    WHEN 1 DO GOTO towDelRowTable1;
    WHEN 2 DO GOTO towDelRowTable2;
    WHEN 3 DO GOTO towDelRowTable3;
    WHEN 4 DO GOTO towDelRowTable4;
    WHEN 5 DO GOTO towDelRowTable5;
    WHEN 6 DO GOTO towDelRowTable6;
    WHEN 7 DO GOTO towDelRowTable7;
    WHEN 8 DO GOTO towDelRowTable8;
    WHEN 9 DO GOTO towDelRowTable9;
    WHEN 10 DO GOTO towDelRowTable10;
    OTHERWISE DO;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
towDelRowTable0)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towDelRowTableKeyRow0;
    WHEN 1 DO GOTO towDelRowTableKeyCursor0;
    WHEN 2 DO GOTO towDelRowTableKeyBTree0;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow0)
! unpack key (set pOperRow).!
    DO SQLS_PROGRAMS_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_PROGRAMS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue0;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor0)
! unpack key (set pOperRow).!
    DO SQLS_PROGRAMS_UnPackkey;
    SQLM_PROGRAMS_OperRow =
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_PROGRAMS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_DBnumber2 /=
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue0;
!------------------------------------------------!
!       towDelRowTableKeyBTree !
!------------------------------------------------!
towDelRowTableKeyBTree0)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowDelRowTableKeyBTree0;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowDelRowTableKeyBTree0;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow74;
    FOR FIRST SQLM_PROGRAMS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow74;
!
$ We should never get here
!
    GOTO WORKFULLtowDelRowTableKeyBTree0;
WORKALLOCATEallocateWorkRow74)
    IF SQLM_PROGRAMS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_PROGRAMS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=1;
! unpack key into work row.!
    DO SQLS_PROGRAMS_UnPackKey;
! find an operating row.!
    SQLM_PROGRAMS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Right2,
        SQLM_PROGRAMS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        94;
    EXIT;
towGetSchLab94)
    SQLM_PROGRAMS_WorkRow=SQLX_WorkRow;
    SQLM_PROGRAMS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if a row is not found, if so report failure.!
    IF SQLM_PROGRAMS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue0;

! Work area is locked !
WORKLOCKtowDelRowTableKeyBTree0)
    SEND towdelRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused!
        3 + 18 <= 8;
    EXIT;

! Work area is full!
WORKFULLtowDelRowTableKeyBTree0)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue0)
! check if row is locked, if so report failure.!
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_PROGRAMS_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_PROGRAMS_OperRow;
    EXIT;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
towDelRowTable1)
    CASE SQLX_KeyNumber IS
    WHEN 0,2 DO GOTO towDelRowTableKeyRow1;
    WHEN 1 DO GOTO towDelRowTableKeyCursor1;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow1)
! unpack key (set pOperRow).!
    DO SQLS_TABLES_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_TABLES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue1;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor1)
! unpack key (set pOperRow).!
    DO SQLS_TABLES_UnPackkey;
    SQLM_TABLES_OperRow =
        SQLM_TABLES_WorkRow:SQLC_TABLES_Left3;
! check if a row was not found, if so report failure.!
    IF SQLM_TABLES_WorkRow:SQLC_TABLES_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_TABLES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2 /=
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue1;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue1)
! check if row is locked, if so report failure.!
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TABLES_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_TABLES_OperRow:SQLC_TABLES_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLES_OperRow;
    EXIT;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
towDelRowTable2)
    CASE SQLX_KeyNumber IS
    WHEN 0,2 DO GOTO towDelRowTableKeyRow2;
    WHEN 1 DO GOTO towDelRowTableKeyCursor2;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow2)
! unpack key (set pOperRow).!
    DO SQLS_FIELDS_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_FIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue2;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor2)
! unpack key (set pOperRow).!
    DO SQLS_FIELDS_UnPackkey;
    SQLM_FIELDS_OperRow =
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3;
! check if a row was not found, if so report failure.!
    IF SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_FIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_FIELDS_WorkRow:SQLC_FIELDS_DBnumber2 /=
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue2;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue2)
! check if row is locked, if so report failure.!
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_FIELDS_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_FIELDS_OperRow;
    EXIT;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
towDelRowTable3)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towDelRowTableKeyRow3;
    WHEN 1 DO GOTO towDelRowTableKeyCursor3;
    WHEN 2 DO GOTO towDelRowTableKeyBTree3;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow3)
! unpack key (set pOperRow).!
    DO SQLS_KEYS_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_KEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue3;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor3)
! unpack key (set pOperRow).!
    DO SQLS_KEYS_UnPackkey;
    SQLM_KEYS_OperRow =
        SQLM_KEYS_WorkRow:SQLC_KEYS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_KEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_KEYS_WorkRow:SQLC_KEYS_DBnumber2 /=
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue3;
!------------------------------------------------!
!       towDelRowTableKeyBTree !
!------------------------------------------------!
towDelRowTableKeyBTree3)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowDelRowTableKeyBTree3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowDelRowTableKeyBTree3;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow75;
    FOR FIRST SQLM_KEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow75;
!
$ We should never get here
!
    GOTO WORKFULLtowDelRowTableKeyBTree3;
WORKALLOCATEallocateWorkRow75)
    IF SQLM_KEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=1;
! unpack key into work row.!
    DO SQLS_KEYS_UnPackKey;
! find an operating row.!
    SQLM_KEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right2,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        95;
    EXIT;
towGetSchLab95)
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if a row is not found, if so report failure.!
    IF SQLM_KEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue3;

! Work area is locked !
WORKLOCKtowDelRowTableKeyBTree3)
    SEND towdelRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused!
        3 + 18 <= 8;
    EXIT;

! Work area is full!
WORKFULLtowDelRowTableKeyBTree3)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue3)
! check if row is locked, if so report failure.!
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_KEYS_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_KEYS_OperRow:SQLC_KEYS_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYS_OperRow;
    EXIT;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
towDelRowTable4)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towDelRowTableKeyRow4;
    WHEN 1 DO GOTO towDelRowTableKeyCursor4;
    WHEN 2 DO GOTO towDelRowTableKeyBTree4;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow4)
! unpack key (set pOperRow).!
    DO SQLS_KEYFIELDS_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue4;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor4)
! unpack key (set pOperRow).!
    DO SQLS_KEYFIELDS_UnPackkey;
    SQLM_KEYFIELDS_OperRow =
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_DBnumber2 /=
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue4;
!------------------------------------------------!
!       towDelRowTableKeyBTree !
!------------------------------------------------!
towDelRowTableKeyBTree4)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowDelRowTableKeyBTree4;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowDelRowTableKeyBTree4;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow76;
    FOR FIRST SQLM_KEYFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow76;
!
$ We should never get here
!
    GOTO WORKFULLtowDelRowTableKeyBTree4;
WORKALLOCATEallocateWorkRow76)
    IF SQLM_KEYFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_KEYFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=1;
! unpack key into work row.!
    DO SQLS_KEYFIELDS_UnPackKey;
! find an operating row.!
    SQLM_KEYFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right2,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        3,
        +,
        96;
    EXIT;
towGetSchLab96)
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_KEYFIELDS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if a row is not found, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue4;

! Work area is locked !
WORKLOCKtowDelRowTableKeyBTree4)
    SEND towdelRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused!
        3 + 18 <= 8;
    EXIT;

! Work area is full!
WORKFULLtowDelRowTableKeyBTree4)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue4)
! check if row is locked, if so report failure.!
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_KEYFIELDS_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_KEYFIELDS_OperRow;
    EXIT;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
towDelRowTable5)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towDelRowTableKeyRow5;
    WHEN 1 DO GOTO towDelRowTableKeyCursor5;
    WHEN 2 DO GOTO towDelRowTableKeyBTree5;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow5)
! unpack key (set pOperRow).!
    DO SQLS_FOREIGNKEYS_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue5;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor5)
! unpack key (set pOperRow).!
    DO SQLS_FOREIGNKEYS_UnPackkey;
    SQLM_FOREIGNKEYS_OperRow =
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_DBnumber2 /=
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue5;
!------------------------------------------------!
!       towDelRowTableKeyBTree !
!------------------------------------------------!
towDelRowTableKeyBTree5)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowDelRowTableKeyBTree5;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowDelRowTableKeyBTree5;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow77;
    FOR FIRST SQLM_FOREIGNKEYS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow77;
!
$ We should never get here
!
    GOTO WORKFULLtowDelRowTableKeyBTree5;
WORKALLOCATEallocateWorkRow77)
    IF SQLM_FOREIGNKEYS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_FOREIGNKEYS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=1;
! unpack key into work row.!
    DO SQLS_FOREIGNKEYS_UnPackKey;
! find an operating row.!
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right2,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        97;
    EXIT;
towGetSchLab97)
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if a row is not found, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue5;

! Work area is locked !
WORKLOCKtowDelRowTableKeyBTree5)
    SEND towdelRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused!
        3 + 18 <= 8;
    EXIT;

! Work area is full!
WORKFULLtowDelRowTableKeyBTree5)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue5)
! check if row is locked, if so report failure.!
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_FOREIGNKEYS_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_FOREIGNKEYS_OperRow;
    EXIT;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
towDelRowTable6)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towDelRowTableKeyRow6;
    WHEN 1 DO GOTO towDelRowTableKeyCursor6;
    WHEN 2 DO GOTO towDelRowTableKeyBTree6;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow6)
! unpack key (set pOperRow).!
    DO SQLS_SYMBOLS_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYMBOLS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue6;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor6)
! unpack key (set pOperRow).!
    DO SQLS_SYMBOLS_UnPackkey;
    SQLM_SYMBOLS_OperRow =
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYMBOLS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_DBnumber2 /=
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue6;
!------------------------------------------------!
!       towDelRowTableKeyBTree !
!------------------------------------------------!
towDelRowTableKeyBTree6)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowDelRowTableKeyBTree6;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowDelRowTableKeyBTree6;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow78;
    FOR FIRST SQLM_SYMBOLS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow78;
!
$ We should never get here
!
    GOTO WORKFULLtowDelRowTableKeyBTree6;
WORKALLOCATEallocateWorkRow78)
    IF SQLM_SYMBOLS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYMBOLS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=1;
! unpack key into work row.!
    DO SQLS_SYMBOLS_UnPackKey;
! find an operating row.!
    SQLM_SYMBOLS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right2,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        98;
    EXIT;
towGetSchLab98)
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    SQLM_SYMBOLS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if a row is not found, if so report failure.!
    IF SQLM_SYMBOLS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue6;

! Work area is locked !
WORKLOCKtowDelRowTableKeyBTree6)
    SEND towdelRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused!
        3 + 18 <= 8;
    EXIT;

! Work area is full!
WORKFULLtowDelRowTableKeyBTree6)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue6)
! check if row is locked, if so report failure.!
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_SYMBOLS_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYMBOLS_OperRow;
    EXIT;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
towDelRowTable7)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towDelRowTableKeyRow7;
    WHEN 1 DO GOTO towDelRowTableKeyCursor7;
    WHEN 2 DO GOTO towDelRowTableKeyBTree7;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow7)
! unpack key (set pOperRow).!
    DO SQLS_TOWFAULTCODES_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue7;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor7)
! unpack key (set pOperRow).!
    DO SQLS_TOWFAULTCODES_UnPackkey;
    SQLM_TOWFAULTCODES_OperRow =
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_DBnumber2 /=
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue7;
!------------------------------------------------!
!       towDelRowTableKeyBTree !
!------------------------------------------------!
towDelRowTableKeyBTree7)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowDelRowTableKeyBTree7;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowDelRowTableKeyBTree7;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow79;
    FOR FIRST SQLM_TOWFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow79;
!
$ We should never get here
!
    GOTO WORKFULLtowDelRowTableKeyBTree7;
WORKALLOCATEallocateWorkRow79)
    IF SQLM_TOWFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TOWFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=1;
! unpack key into work row.!
    DO SQLS_TOWFAULTCODES_UnPackKey;
! find an operating row.!
    SQLM_TOWFAULTCODES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Right2,
        SQLM_TOWFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        99;
    EXIT;
towGetSchLab99)
    SQLM_TOWFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_TOWFAULTCODES_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if a row is not found, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue7;

! Work area is locked !
WORKLOCKtowDelRowTableKeyBTree7)
    SEND towdelRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused!
        3 + 18 <= 8;
    EXIT;

! Work area is full!
WORKFULLtowDelRowTableKeyBTree7)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue7)
! check if row is locked, if so report failure.!
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TOWFAULTCODES_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TOWFAULTCODES_OperRow;
    EXIT;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
towDelRowTable8)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towDelRowTableKeyRow8;
    WHEN 1 DO GOTO towDelRowTableKeyCursor8;
    WHEN 2 DO GOTO towDelRowTableKeyBTree8;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow8)
! unpack key (set pOperRow).!
    DO SQLS_SYSFAULTCODES_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue8;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor8)
! unpack key (set pOperRow).!
    DO SQLS_SYSFAULTCODES_UnPackkey;
    SQLM_SYSFAULTCODES_OperRow =
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_DBnumber2 /=
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue8;
!------------------------------------------------!
!       towDelRowTableKeyBTree !
!------------------------------------------------!
towDelRowTableKeyBTree8)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowDelRowTableKeyBTree8;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowDelRowTableKeyBTree8;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow80;
    FOR FIRST SQLM_SYSFAULTCODES_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow80;
!
$ We should never get here
!
    GOTO WORKFULLtowDelRowTableKeyBTree8;
WORKALLOCATEallocateWorkRow80)
    IF SQLM_SYSFAULTCODES_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSFAULTCODES_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=1;
! unpack key into work row.!
    DO SQLS_SYSFAULTCODES_UnPackKey;
! find an operating row.!
    SQLM_SYSFAULTCODES_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Right2,
        SQLM_SYSFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        100;
    EXIT;
towGetSchLab100)
    SQLM_SYSFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_SYSFAULTCODES_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if a row is not found, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue8;

! Work area is locked !
WORKLOCKtowDelRowTableKeyBTree8)
    SEND towdelRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused!
        3 + 18 <= 8;
    EXIT;

! Work area is full!
WORKFULLtowDelRowTableKeyBTree8)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue8)
! check if row is locked, if so report failure.!
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_SYSFAULTCODES_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSFAULTCODES_OperRow;
    EXIT;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
towDelRowTable9)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towDelRowTableKeyRow9;
    WHEN 1 DO GOTO towDelRowTableKeyCursor9;
    WHEN 2 DO GOTO towDelRowTableKeyBTree9;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow9)
! unpack key (set pOperRow).!
    DO SQLS_SYSTEMFIELDS_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue9;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor9)
! unpack key (set pOperRow).!
    DO SQLS_SYSTEMFIELDS_UnPackkey;
    SQLM_SYSTEMFIELDS_OperRow =
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_DBnumber2 /=
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue9;
!------------------------------------------------!
!       towDelRowTableKeyBTree !
!------------------------------------------------!
towDelRowTableKeyBTree9)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowDelRowTableKeyBTree9;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowDelRowTableKeyBTree9;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow81;
    FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow81;
!
$ We should never get here
!
    GOTO WORKFULLtowDelRowTableKeyBTree9;
WORKALLOCATEallocateWorkRow81)
    IF SQLM_SYSTEMFIELDS_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_SYSTEMFIELDS_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=1;
! unpack key into work row.!
    DO SQLS_SYSTEMFIELDS_UnPackKey;
! find an operating row.!
    SQLM_SYSTEMFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right2,
        SQLM_SYSTEMFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        101;
    EXIT;
towGetSchLab101)
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if a row is not found, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue9;

! Work area is locked !
WORKLOCKtowDelRowTableKeyBTree9)
    SEND towdelRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused!
        3 + 18 <= 8;
    EXIT;

! Work area is full!
WORKFULLtowDelRowTableKeyBTree9)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue9)
! check if row is locked, if so report failure.!
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_SYSTEMFIELDS_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_SYSTEMFIELDS_OperRow;
    EXIT;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
towDelRowTable10)
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towDelRowTableKeyRow10;
    WHEN 1 DO GOTO towDelRowTableKeyCursor10;
    WHEN 2 DO GOTO towDelRowTableKeyBTree10;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow10)
! unpack key (set pOperRow).!
    DO SQLS_TEST1_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_TEST1_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue10;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor10)
! unpack key (set pOperRow).!
    DO SQLS_TEST1_UnPackkey;
    SQLM_TEST1_OperRow =
        SQLM_TEST1_WorkRow:SQLC_TEST1_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_TEST1_WorkRow:SQLC_TEST1_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_TEST1_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_TEST1_WorkRow:SQLC_TEST1_DBnumber2 /=
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue10;
!------------------------------------------------!
!       towDelRowTableKeyBTree !
!------------------------------------------------!
towDelRowTableKeyBTree10)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowDelRowTableKeyBTree10;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowDelRowTableKeyBTree10;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow82;
    FOR FIRST SQLM_TEST1_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow82;
!
$ We should never get here
!
    GOTO WORKFULLtowDelRowTableKeyBTree10;
WORKALLOCATEallocateWorkRow82)
    IF SQLM_TEST1_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TEST1_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=1;
! unpack key into work row.!
    DO SQLS_TEST1_UnPackKey;
! find an operating row.!
    SQLM_TEST1_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TEST1_RootRow:SQLC_TEST1_Right2,
        SQLM_TEST1_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        2,
        +,
        102;
    EXIT;
towGetSchLab102)
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
    SQLM_TEST1_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if a row is not found, if so report failure.!
    IF SQLM_TEST1_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue10;

! Work area is locked !
WORKLOCKtowDelRowTableKeyBTree10)
    SEND towdelRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused!
        3 + 18 <= 8;
    EXIT;

! Work area is full!
WORKFULLtowDelRowTableKeyBTree10)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue10)
! check if row is locked, if so report failure.!
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TEST1_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_TEST1_OperRow:SQLC_TEST1_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TEST1_OperRow;
    EXIT;
!------------------------------------------------!
!       towLetFld !
!------------------------------------------------!
    ENTER towLetFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow,
        +,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_PROGRAMS_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_PROGRAMS_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 1 DO
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_TABLES_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_TABLES_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 2 DO
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_FIELDS_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_FIELDS_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 3 DO
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_KEYS_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_KEYS_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 4 DO
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_KEYFIELDS_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_KEYFIELDS_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 5 DO
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_FOREIGNKEYS_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_FOREIGNKEYS_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 6 DO
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_SYMBOLS_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_SYMBOLS_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 7 DO
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_TOWFAULTCODES_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_TOWFAULTCODES_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 8 DO
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_SYSFAULTCODES_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_SYSFAULTCODES_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 9 DO
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_SYSTEMFIELDS_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_SYSTEMFIELDS_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 10 DO
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_TEST1_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_TEST1_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    OTHERWISE DO;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towLetFldFK !
!------------------------------------------------!
    ENTER towLetFldFK WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow,
        SQLX_KeyNumber;
    CASE SQLM_TableReference IS
    WHEN 2 DO
!------------------------------------------------!
!       towLetFldFKTable !
!------------------------------------------------!
    SQLM_FIELDS_WorkRow = SQLX_WorkRow;
    CASE SQLX_KeyNumber IS
    WHEN 5 DO
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_TROWNO_Null = 1;
    OTHERWISE DO;
    ESAC;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    WHEN 3 DO
!------------------------------------------------!
!       towLetFldFKTable !
!------------------------------------------------!
    SQLM_KEYS_WorkRow = SQLX_WorkRow;
    CASE SQLX_KeyNumber IS
    WHEN 4 DO
        SQLM_KEYS_WorkRow:SQLC_KEYS_TROWNO_Data = 1;
    OTHERWISE DO;
    ESAC;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
    OTHERWISE DO;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towVerRow !
!------------------------------------------------!
    ENTER towVerRow WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow;
    CASE SQLM_TableReference IS
    WHEN 0 DO GOTO towVerRowTable0;
    WHEN 1 DO GOTO towVerRowTable1;
    WHEN 2 DO GOTO towVerRowTable2;
    WHEN 3 DO GOTO towVerRowTable3;
    WHEN 4 DO GOTO towVerRowTable4;
    WHEN 5 DO GOTO towVerRowTable5;
    WHEN 6 DO GOTO towVerRowTable6;
    WHEN 7 DO GOTO towVerRowTable7;
    WHEN 8 DO GOTO towVerRowTable8;
    WHEN 9 DO GOTO towVerRowTable9;
    WHEN 10 DO GOTO towVerRowTable10;
    OTHERWISE DO
        SEND towVerRowR WITH
            SQLX_OtherProtected,
            0;
        EXIT;
    ESAC;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable0)
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable0;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! Check columns !
    SQLM_PROGRAMS_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_BLKREF_Data >= 1
        GOTO CONTINUE1towVerRowTable0;


    GOTO FAILUREtowVerRowTable0;
FAILUREtowVerRowTable0)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable0)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable1)
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable1;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! check alternate keys in insert list !
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow=SQLM_TableReference:SQLM_System;
    SQLM_TABLES_NilRow=SQLM_TABLES_OperRow+1;
    SQLX_Schedule=0;
LOOP1towVerRowTable1)
    SQLM_TABLES_OperRow=SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
    IF SQLM_TABLES_OperRow = SQLM_TABLES_NilRow GOTO END1towVerRowTable1;
    IF SQLM_TABLES_OperRow = SQLX_OperRow GOTO LOOP1towVerRowTable1;
    IF SQLM_TABLES_OperRow = SQLX_WorkRow GOTO LOOP1towVerRowTable1;
    SQLX_KeyNumber=2;
LOOP2towVerRowTable1)
    SQLX_KeyNumber=SQLX_KeyNumber+1;
towVerSchLab1)
    CASE SQLX_KeyNumber IS
    WHEN 3 DO
        SQLX_Schedule=SQLX_Schedule+1;
        IF SQLX_Schedule > 16 THEN
            SEND towVerSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLX_OtherBlock,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLM_TABLES_OperRow,
                SQLX_KeyNumber,
                1;
            EXIT;
        FI;
        SQLX_KeyPrefix=2;
        DO SQLS_TABLES_KeyTest3;
    WHEN 4 DO GOTO LOOP1towVerRowTable1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    IF SQLX_KeyTest = 1 GOTO ERRORtowVerRowTable;
    GOTO LOOP2towVerRowTable1;
END1towVerRowTable1)
! check IF alternate key IS in btree !
    SQLM_TABLES_OperRow=SQLX_OperRow;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    IF SQLX_KeyOperation=1 THEN
        SQLX_KeyPrefix=2;
        DO SQLS_TABLES_KeyTest3;
! used later in commit !
        SQLM_TABLES_WorkRow:SQLC_TABLES_Color3=SQLX_KeyTest;
        IF SQLX_KeyTest=1 GOTO CONTINUE2towVerRowTable1_3;
    FI;
    SQLM_TABLES_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        3,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        SQLX_WorkRow,
        SQLX_KeyOperation, ! use DR5 !
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        2,
        SQLX_OperRow,
        103;
    EXIT;
towGetSchLab103)
    SQLX_KeyOperation = SQLX_DR5;
    SQLM_TABLES_OperRow=SQLX_OperRow;
    SQLX_OperRow=SQLX_RightTurn;
    IF SQLM_TABLES_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowVerRowTable;
CONTINUE2towVerRowTable1_3)
! Check columns !
    SQLM_TABLES_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_WAUCAT_Data > 63
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_USEDSW_Data > 65531
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_USEDST_Data > 65531
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!



    IF SQLM_TABLES_OperRow:
            SQLC_TABLES_SAEIDW_Null = 1
        GOTO FAILUREtowVerRowTable1;




    IF SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDW_Data > 999
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_NOFLTCO_Data > 64
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_RAUCAT_Data > 63
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!



    IF SQLM_TABLES_OperRow:
            SQLC_TABLES_SAEIDT_Null = 1
        GOTO FAILUREtowVerRowTable1;




    IF SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Data > 999
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data > 4095
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_MAXSW_Data > 65531
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_ESTEPW_Data < 1
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_ESTEPW_Data > 65531
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_MAXST_Data > 65531
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_ESTEPT_Data < 1
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_ESTEPT_Data > 65531
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_ALLOCSW_Data > 65531
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_ALLOCST_Data > 65531
        GOTO FAILUREtowVerRowTable1;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLES_OperRow:SQLC_TABLES_BLKREF_Data < 1
        GOTO FAILUREtowVerRowTable1;


    GOTO CONTINUE1towVerRowTable1;
FAILUREtowVerRowTable1)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable1)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable2)
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable2;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! check alternate keys in insert list !
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    SQLM_FIELDS_OperRow=SQLM_TableReference:SQLM_System;
    SQLM_FIELDS_NilRow=SQLM_FIELDS_OperRow+1;
    SQLX_Schedule=0;
LOOP1towVerRowTable2)
    SQLM_FIELDS_OperRow=SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
    IF SQLM_FIELDS_OperRow = SQLM_FIELDS_NilRow GOTO END1towVerRowTable2;
    IF SQLM_FIELDS_OperRow = SQLX_OperRow GOTO LOOP1towVerRowTable2;
    IF SQLM_FIELDS_OperRow = SQLX_WorkRow GOTO LOOP1towVerRowTable2;
    SQLX_KeyNumber=2;
LOOP2towVerRowTable2)
    SQLX_KeyNumber=SQLX_KeyNumber+1;
towVerSchLab2)
    CASE SQLX_KeyNumber IS
    WHEN 3 DO
        SQLX_Schedule=SQLX_Schedule+1;
        IF SQLX_Schedule > 16 THEN
            SEND towVerSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLX_OtherBlock,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLM_FIELDS_OperRow,
                SQLX_KeyNumber,
                2;
            EXIT;
        FI;
        SQLX_KeyPrefix=3;
        DO SQLS_FIELDS_KeyTest3;
    WHEN 4 DO
        SQLX_Schedule=SQLX_Schedule+1;
        IF SQLX_Schedule > 17 THEN
            SEND towVerSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLX_OtherBlock,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLM_FIELDS_OperRow,
                SQLX_KeyNumber,
                2;
            EXIT;
        FI;
        SQLX_KeyPrefix=3;
        DO SQLS_FIELDS_KeyTest4;
    WHEN 5 DO GOTO LOOP1towVerRowTable2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    IF SQLX_KeyTest = 1 GOTO ERRORtowVerRowTable;
    GOTO LOOP2towVerRowTable2;
END1towVerRowTable2)
! check IF alternate key IS in btree !
    SQLM_FIELDS_OperRow=SQLX_OperRow;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    IF SQLX_KeyOperation=1 THEN
        SQLX_KeyPrefix=3;
        DO SQLS_FIELDS_KeyTest3;
! used later in commit !
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Color3=SQLX_KeyTest;
        IF SQLX_KeyTest=1 GOTO CONTINUE2towVerRowTable2_3;
    FI;
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        3,
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right3,
        SQLX_WorkRow,
        SQLX_KeyOperation, ! use DR5 !
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        3,
        SQLX_OperRow,
        104;
    EXIT;
towGetSchLab104)
    SQLX_KeyOperation = SQLX_DR5;
    SQLM_FIELDS_OperRow=SQLX_OperRow;
    SQLX_OperRow=SQLX_RightTurn;
    IF SQLM_FIELDS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowVerRowTable;
CONTINUE2towVerRowTable2_3)
    SQLM_FIELDS_OperRow=SQLX_OperRow;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    IF SQLX_KeyOperation=1 THEN
        SQLX_KeyPrefix=3;
        DO SQLS_FIELDS_KeyTest4;
! used later in commit !
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_Color4=SQLX_KeyTest;
        IF SQLX_KeyTest=1 GOTO CONTINUE2towVerRowTable2_4;
    FI;
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        4,
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right4,
        SQLX_WorkRow,
        SQLX_KeyOperation, ! use DR5 !
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        3,
        SQLX_OperRow,
        105;
    EXIT;
towGetSchLab105)
    SQLX_KeyOperation = SQLX_DR5;
    SQLM_FIELDS_OperRow=SQLX_OperRow;
    SQLX_OperRow=SQLX_RightTurn;
    IF SQLM_FIELDS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowVerRowTable;
CONTINUE2towVerRowTable2_4)
! Check columns !
    SQLM_FIELDS_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!



    IF SQLM_FIELDS_OperRow:
            SQLC_FIELDS_TROWNO_Null = 1
        GOTO FAILUREtowVerRowTable2;




    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_TROWNO_Data > 65531
        GOTO FAILUREtowVerRowTable2;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_PRWIDTH_Data < 1
        GOTO FAILUREtowVerRowTable2;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_PRWIDTH_Data > 63
        GOTO FAILUREtowVerRowTable2;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_TABREF_Data > 4095
        GOTO FAILUREtowVerRowTable2;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_FIELDNO_Data < 1
        GOTO FAILUREtowVerRowTable2;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_FIELDNO_Data > 4096
        GOTO FAILUREtowVerRowTable2;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_BADDRES_Data < 1
        GOTO FAILUREtowVerRowTable2;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_BADDRES_Data > 4095
        GOTO FAILUREtowVerRowTable2;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_BLKREF_Data < 1
        GOTO FAILUREtowVerRowTable2;


    GOTO CONTINUE1towVerRowTable2;
FAILUREtowVerRowTable2)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable2)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable3)
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable3;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! check alternate keys in insert list !
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_OperRow=SQLM_TableReference:SQLM_System;
    SQLM_KEYS_NilRow=SQLM_KEYS_OperRow+1;
    SQLX_Schedule=0;
LOOP1towVerRowTable3)
    SQLM_KEYS_OperRow=SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
    IF SQLM_KEYS_OperRow = SQLM_KEYS_NilRow GOTO END1towVerRowTable3;
    IF SQLM_KEYS_OperRow = SQLX_OperRow GOTO LOOP1towVerRowTable3;
    IF SQLM_KEYS_OperRow = SQLX_WorkRow GOTO LOOP1towVerRowTable3;
    SQLX_KeyNumber=2;
LOOP2towVerRowTable3)
    SQLX_KeyNumber=SQLX_KeyNumber+1;
towVerSchLab3)
    CASE SQLX_KeyNumber IS
    WHEN 3 DO
        SQLX_Schedule=SQLX_Schedule+1;
        IF SQLX_Schedule > 17 THEN
            SEND towVerSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLX_OtherBlock,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLM_KEYS_OperRow,
                SQLX_KeyNumber,
                3;
            EXIT;
        FI;
        SQLX_KeyPrefix=3;
        DO SQLS_KEYS_KeyTest3;
    WHEN 4 DO GOTO LOOP1towVerRowTable3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    IF SQLX_KeyTest = 1 GOTO ERRORtowVerRowTable;
    GOTO LOOP2towVerRowTable3;
END1towVerRowTable3)
! check IF alternate key IS in btree !
    SQLM_KEYS_OperRow=SQLX_OperRow;
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    IF SQLX_KeyOperation=1 THEN
        SQLX_KeyPrefix=3;
        DO SQLS_KEYS_KeyTest3;
! used later in commit !
        SQLM_KEYS_WorkRow:SQLC_KEYS_Color3=SQLX_KeyTest;
        IF SQLX_KeyTest=1 GOTO CONTINUE2towVerRowTable3_3;
    FI;
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        3,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right3,
        SQLX_WorkRow,
        SQLX_KeyOperation, ! use DR5 !
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        3,
        SQLX_OperRow,
        106;
    EXIT;
towGetSchLab106)
    SQLX_KeyOperation = SQLX_DR5;
    SQLM_KEYS_OperRow=SQLX_OperRow;
    SQLX_OperRow=SQLX_RightTurn;
    IF SQLM_KEYS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowVerRowTable;
CONTINUE2towVerRowTable3_3)
! Check columns !
    SQLM_KEYS_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_KEYS_OperRow:SQLC_KEYS_TABREF_Data > 4095
        GOTO FAILUREtowVerRowTable3;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_KEYS_OperRow:SQLC_KEYS_BLKREF_Data < 1
        GOTO FAILUREtowVerRowTable3;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_KEYS_OperRow:SQLC_KEYS_TROWNO_Data > 65531
        GOTO FAILUREtowVerRowTable3;


    GOTO CONTINUE1towVerRowTable3;
FAILUREtowVerRowTable3)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable3)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable4)
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable4;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! check alternate keys in insert list !
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_KEYFIELDS_OperRow=SQLM_TableReference:SQLM_System;
    SQLM_KEYFIELDS_NilRow=SQLM_KEYFIELDS_OperRow+1;
    SQLX_Schedule=0;
LOOP1towVerRowTable4)
    SQLM_KEYFIELDS_OperRow=SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
    IF SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_NilRow GOTO END1towVerRowTable4;
    IF SQLM_KEYFIELDS_OperRow = SQLX_OperRow GOTO LOOP1towVerRowTable4;
    IF SQLM_KEYFIELDS_OperRow = SQLX_WorkRow GOTO LOOP1towVerRowTable4;
    SQLX_KeyNumber=2;
LOOP2towVerRowTable4)
    SQLX_KeyNumber=SQLX_KeyNumber+1;
towVerSchLab4)
    CASE SQLX_KeyNumber IS
    WHEN 3 DO
        SQLX_Schedule=SQLX_Schedule+1;
        IF SQLX_Schedule > 16 THEN
            SEND towVerSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLX_OtherBlock,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLM_KEYFIELDS_OperRow,
                SQLX_KeyNumber,
                4;
            EXIT;
        FI;
        SQLX_KeyPrefix=4;
        DO SQLS_KEYFIELDS_KeyTest3;
    WHEN 4 DO GOTO LOOP1towVerRowTable4;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    IF SQLX_KeyTest = 1 GOTO ERRORtowVerRowTable;
    GOTO LOOP2towVerRowTable4;
END1towVerRowTable4)
! check IF alternate key IS in btree !
    SQLM_KEYFIELDS_OperRow=SQLX_OperRow;
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    IF SQLX_KeyOperation=1 THEN
        SQLX_KeyPrefix=4;
        DO SQLS_KEYFIELDS_KeyTest3;
! used later in commit !
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Color3=SQLX_KeyTest;
        IF SQLX_KeyTest=1 GOTO CONTINUE2towVerRowTable4_3;
    FI;
    SQLM_KEYFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        3,
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right3,
        SQLX_WorkRow,
        SQLX_KeyOperation, ! use DR5 !
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        4,
        SQLX_OperRow,
        107;
    EXIT;
towGetSchLab107)
    SQLX_KeyOperation = SQLX_DR5;
    SQLM_KEYFIELDS_OperRow=SQLX_OperRow;
    SQLX_OperRow=SQLX_RightTurn;
    IF SQLM_KEYFIELDS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowVerRowTable;
CONTINUE2towVerRowTable4_3)
! Check columns !
    SQLM_KEYFIELDS_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_TABREF_Data > 4095
        GOTO FAILUREtowVerRowTable4;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_FROWNO_Data > 65531
        GOTO FAILUREtowVerRowTable4;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_COMPNO_Data < 1
        GOTO FAILUREtowVerRowTable4;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_COMPNO_Data > 16
        GOTO FAILUREtowVerRowTable4;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_BLKREF_Data < 1
        GOTO FAILUREtowVerRowTable4;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_TROWNO_Data > 65531
        GOTO FAILUREtowVerRowTable4;


    GOTO CONTINUE1towVerRowTable4;
FAILUREtowVerRowTable4)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable4)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable5)
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable5;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! check alternate keys in insert list !
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow=SQLM_TableReference:SQLM_System;
    SQLM_FOREIGNKEYS_NilRow=SQLM_FOREIGNKEYS_OperRow+1;
    SQLX_Schedule=0;
LOOP1towVerRowTable5)
    SQLM_FOREIGNKEYS_OperRow=SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow GOTO END1towVerRowTable5;
    IF SQLM_FOREIGNKEYS_OperRow = SQLX_OperRow GOTO LOOP1towVerRowTable5;
    IF SQLM_FOREIGNKEYS_OperRow = SQLX_WorkRow GOTO LOOP1towVerRowTable5;
    SQLX_KeyNumber=2;
LOOP2towVerRowTable5)
    SQLX_KeyNumber=SQLX_KeyNumber+1;
towVerSchLab5)
    CASE SQLX_KeyNumber IS
    WHEN 3 DO
        SQLX_Schedule=SQLX_Schedule+1;
        IF SQLX_Schedule > 17 THEN
            SEND towVerSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLX_OtherBlock,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLM_FOREIGNKEYS_OperRow,
                SQLX_KeyNumber,
                5;
            EXIT;
        FI;
        SQLX_KeyPrefix=3;
        DO SQLS_FOREIGNKEYS_KeyTest3;
    WHEN 4 DO GOTO LOOP1towVerRowTable5;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    IF SQLX_KeyTest = 1 GOTO ERRORtowVerRowTable;
    GOTO LOOP2towVerRowTable5;
END1towVerRowTable5)
! check IF alternate key IS in btree !
    SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    IF SQLX_KeyOperation=1 THEN
        SQLX_KeyPrefix=3;
        DO SQLS_FOREIGNKEYS_KeyTest3;
! used later in commit !
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Color3=SQLX_KeyTest;
        IF SQLX_KeyTest=1 GOTO CONTINUE2towVerRowTable5_3;
    FI;
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        3,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right3,
        SQLX_WorkRow,
        SQLX_KeyOperation, ! use DR5 !
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        3,
        SQLX_OperRow,
        108;
    EXIT;
towGetSchLab108)
    SQLX_KeyOperation = SQLX_DR5;
    SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
    SQLX_OperRow=SQLX_RightTurn;
    IF SQLM_FOREIGNKEYS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowVerRowTable;
CONTINUE2towVerRowTable5_3)
! Check columns !
    SQLM_FOREIGNKEYS_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_TABREF_Data > 4095
        GOTO FAILUREtowVerRowTable5;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_FBLKREF_Data < 1
        GOTO FAILUREtowVerRowTable5;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_FTABREF_Data > 4095
        GOTO FAILUREtowVerRowTable5;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_FTROWNO_Data > 65531
        GOTO FAILUREtowVerRowTable5;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_BLKREF_Data < 1
        GOTO FAILUREtowVerRowTable5;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_TROWNO_Data > 65531
        GOTO FAILUREtowVerRowTable5;


    GOTO CONTINUE1towVerRowTable5;
FAILUREtowVerRowTable5)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable5)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable6)
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable6;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! check alternate keys in insert list !
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    SQLM_SYMBOLS_OperRow=SQLM_TableReference:SQLM_System;
    SQLM_SYMBOLS_NilRow=SQLM_SYMBOLS_OperRow+1;
    SQLX_Schedule=0;
LOOP1towVerRowTable6)
    SQLM_SYMBOLS_OperRow=SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
    IF SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_NilRow GOTO END1towVerRowTable6;
    IF SQLM_SYMBOLS_OperRow = SQLX_OperRow GOTO LOOP1towVerRowTable6;
    IF SQLM_SYMBOLS_OperRow = SQLX_WorkRow GOTO LOOP1towVerRowTable6;
    SQLX_KeyNumber=2;
LOOP2towVerRowTable6)
    SQLX_KeyNumber=SQLX_KeyNumber+1;
towVerSchLab6)
    CASE SQLX_KeyNumber IS
    WHEN 3 DO
        SQLX_Schedule=SQLX_Schedule+1;
        IF SQLX_Schedule > 17 THEN
            SEND towVerSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLX_OtherBlock,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLM_SYMBOLS_OperRow,
                SQLX_KeyNumber,
                6;
            EXIT;
        FI;
        SQLX_KeyPrefix=2;
        DO SQLS_SYMBOLS_KeyTest3;
    WHEN 4 DO GOTO LOOP1towVerRowTable6;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    IF SQLX_KeyTest = 1 GOTO ERRORtowVerRowTable;
    GOTO LOOP2towVerRowTable6;
END1towVerRowTable6)
! check IF alternate key IS in btree !
    SQLM_SYMBOLS_OperRow=SQLX_OperRow;
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    IF SQLX_KeyOperation=1 THEN
        SQLX_KeyPrefix=2;
        DO SQLS_SYMBOLS_KeyTest3;
! used later in commit !
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Color3=SQLX_KeyTest;
        IF SQLX_KeyTest=1 GOTO CONTINUE2towVerRowTable6_3;
    FI;
    SQLM_SYMBOLS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        3,
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right3,
        SQLX_WorkRow,
        SQLX_KeyOperation, ! use DR5 !
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        2,
        SQLX_OperRow,
        109;
    EXIT;
towGetSchLab109)
    SQLX_KeyOperation = SQLX_DR5;
    SQLM_SYMBOLS_OperRow=SQLX_OperRow;
    SQLX_OperRow=SQLX_RightTurn;
    IF SQLM_SYMBOLS_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowVerRowTable;
CONTINUE2towVerRowTable6_3)
! Check columns !
    SQLM_SYMBOLS_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_FROWNO_Data =< 65531
        GOTO CONTINUE1towVerRowTable6;


    GOTO FAILUREtowVerRowTable6;
FAILUREtowVerRowTable6)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable6)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable7)
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable7;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! Check columns !
    SQLM_TOWFAULTCODES_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_FAULTNO_Data < 1
        GOTO FAILUREtowVerRowTable7;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_TROWNO_Data > 65531
        GOTO FAILUREtowVerRowTable7;


    GOTO CONTINUE1towVerRowTable7;
FAILUREtowVerRowTable7)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable7)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable8)
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable8;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! Check columns !
    SQLM_SYSFAULTCODES_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_FAULTNO_Data < 256
        GOTO FAILUREtowVerRowTable8;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_FAULTNO_Data > 511
        GOTO FAILUREtowVerRowTable8;


    GOTO CONTINUE1towVerRowTable8;
FAILUREtowVerRowTable8)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable8)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable9)
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable9;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! Check columns !
    SQLM_SYSTEMFIELDS_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_LOCK_Data < 1
        GOTO FAILUREtowVerRowTable9;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_LOCK_Data > 4095
        GOTO FAILUREtowVerRowTable9;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_ROWGEN_Data < 1
        GOTO FAILUREtowVerRowTable9;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_ROWGEN_Data > 4095
        GOTO FAILUREtowVerRowTable9;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_TROWNO_Data > 65531
        GOTO FAILUREtowVerRowTable9;


    GOTO CONTINUE1towVerRowTable9;
FAILUREtowVerRowTable9)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable9)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable10)
! execute user defined code !
!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat73;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat73;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat73;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat73;
PROTECTEDALLOCATEDbeginStat73)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat73)
ENABLE INTERRUPT;
! Error: Protected region congestion, too many simultaneous users !
    IF SQLCODE = 3 + 17 <= 8 THEN
        SEND towVerRowR WITH
            SQLX_OtherProtected,
            SQLCODE;
        EXIT;
    FI;
    PROTECTEDP:SQLLOCALCODE=0;
    PROTECTEDP:SQLBLOCK=SQLX_OtherBlock;
    PROTECTEDP:SQLOPERATION=SQLX_KeyOperation;
    PROTECTEDP:SQLX_SQLPROTECTED=SQLX_OtherProtected;
    PROTECTEDP:SQLX_SQLTABLEREFERENCE=SQLM_TableReference;
    PROTECTEDP:SQLX_SQLOPERROW=SQLX_OperRow;
    PROTECTEDP:SQLX_SQLWORKROW=SQLX_WorkRow;
    DO XX;
    SQLX_OtherBlock=PROTECTEDP:SQLBLOCK;
    SQLX_KeyOperation=PROTECTEDP:SQLOPERATION;
    SQLX_OtherProtected=PROTECTEDP:SQLX_SQLPROTECTED;
    SQLM_TableReference=PROTECTEDP:SQLX_SQLTABLEREFERENCE;
    SQLX_OperRow=PROTECTEDP:SQLX_SQLOPERROW;
    SQLX_WorkRow=PROTECTEDP:SQLX_SQLWORKROW;
    SQLX_Code=PROTECTEDP:SQLLOCALCODE;
!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_EXTENSIVETABS_Cursor=0;
    IF PROTECTEDP:SQLM_FINDFK_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDFK_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEWTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDORDNO_Cursor=0;
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDTROWNO_Cursor=0;
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor=0;
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETTROWNO_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=9;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab9)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;
    IF SQLX_Code /= 0 THEN
        SEND towVerRowR WITH
            SQLX_OtherProtected,
! Table local status code: !
            4 + SQLX_Code <= 8;
        EXIT;
    FI;
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable10;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! Check columns !
    SQLM_TEST1_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!





    IF SQLM_TEST1_OperRow:SQLC_TEST1_COL2_Data > 4
        GOTO SQLL_0;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!
SQLL_2)





    DO SQLS_CmpString1;
    IF SQLX_KeyTest < 1 GOTO SQLL_2;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!





    IF D /= - 4
        GOTO SQLL_2;

    GOTO SQLL_0;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!
SQLL_1)







    DO SQLS_CmpString2;
    IF SQLX_KeyTest >= 1 GOTO FAILUREtowVerRowTable10;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!
SQLL_0)



    IF SQLM_TEST1_OperRow:
            SQLC_TEST1_COL3_Null = 1
        GOTO FAILUREtowVerRowTable10;




    IF SQLM_TEST1_OperRow:SQLC_TEST1_COL3_Data < 0
        GOTO FAILUREtowVerRowTable10;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TEST1_OperRow:SQLC_TEST1_COL2_Data < 0
        GOTO FAILUREtowVerRowTable10;


    GOTO CONTINUE1towVerRowTable10;
FAILUREtowVerRowTable10)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable10)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
ERRORtowVerRowTable)
! Send back uniqness error !
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Uniqueness constraint failure !
        3 + 3 <= 8;
    EXIT;
!------------------------------------------------!
!       towVerSch !
!------------------------------------------------!
    ENTER towVerSch WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_TempRow,
        SQLX_KeyNumber,
        SQLX_ReturnLabel;
    SQLX_Schedule=0;
    CASE SQLM_TableReference IS
    WHEN 1 DO
        SQLM_TABLES_WorkRow=SQLX_WorkRow;
        SQLM_TABLES_OperRow=SQLX_TempRow;
        SQLM_TABLES_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 2 DO
        SQLM_FIELDS_WorkRow=SQLX_WorkRow;
        SQLM_FIELDS_OperRow=SQLX_TempRow;
        SQLM_FIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 3 DO
        SQLM_KEYS_WorkRow=SQLX_WorkRow;
        SQLM_KEYS_OperRow=SQLX_TempRow;
        SQLM_KEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 4 DO
        SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
        SQLM_KEYFIELDS_OperRow=SQLX_TempRow;
        SQLM_KEYFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 5 DO
        SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
        SQLM_FOREIGNKEYS_OperRow=SQLX_TempRow;
        SQLM_FOREIGNKEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    WHEN 6 DO
        SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
        SQLM_SYMBOLS_OperRow=SQLX_TempRow;
        SQLM_SYMBOLS_NilRow=SQLM_TableReference:SQLM_System+1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towVerSchLab1;
    WHEN 2 DO GOTO towVerSchLab2;
    WHEN 3 DO GOTO towVerSchLab3;
    WHEN 4 DO GOTO towVerSchLab4;
    WHEN 5 DO GOTO towVerSchLab5;
    WHEN 6 DO GOTO towVerSchLab6;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComRow !
!------------------------------------------------!
    ENTER towComRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2;
    CASE SQLM_TableReference IS
    WHEN 0 DO GOTO towComRowTable0;
    WHEN 1 DO GOTO towComRowTable1;
    WHEN 2 DO GOTO towComRowTable2;
    WHEN 3 DO GOTO towComRowTable3;
    WHEN 4 DO GOTO towComRowTable4;
    WHEN 5 DO GOTO towComRowTable5;
    WHEN 6 DO GOTO towComRowTable6;
    WHEN 7 DO GOTO towComRowTable7;
    WHEN 8 DO GOTO towComRowTable8;
    WHEN 9 DO GOTO towComRowTable9;
    WHEN 10 DO GOTO towComRowTable10;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
towComRowTable0)
    SQLM_PROGRAMS_OperRow=SQLX_OperRow;
    SQLM_PROGRAMS_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab1;
    SQLM_PROGRAMS_WorkRow=SQLX_WorkRow;
    IF SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Color2=1
        GOTO LABEL2towComRowTable0_2;
! wait until no one is locking the tree !
towComSchLab1)
    SQLM_PROGRAMS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_PROGRAMS_NilRow=SQLM_PROGRAMS_RootRow-1;
    IF SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Left2=SQLM_PROGRAMS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            1;
        EXIT;
    FI;
    SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Left2=SQLM_PROGRAMS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab1;
    SQLM_PROGRAMS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        1,
        1,
        +,
        SQLM_PROGRAMS_RootRow,
        SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Right2,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab1)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable0_2;
    SQLM_PROGRAMS_OperRow=SQLX_OperRow;
    SQLM_PROGRAMS_WorkRow=SQLX_WorkRow;
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_BLKREF_Data=
        SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_BLKREF_Data;
LABEL1towComRowTable0_2)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab1;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        1,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab1)
    SQLM_PROGRAMS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Left2=0;
LABEL2towComRowTable0_2)
    SQLM_PROGRAMS_OperRow=SQLX_OperRow;
    SQLM_PROGRAMS_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber1 = SQLX_DBnumber1;
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_PROGRAMS_OperRow=SQLX_WorkRow;
        SQLM_PROGRAMS_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_PROGRAMS_TempRow =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Left2 =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
SQLM_PROGRAMS_TempRow =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;

IF SQLM_PROGRAMS_TempRow /= SQLM_PROGRAMS_NilRow THEN
    SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Right2 =
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
FI;
        SQLM_PROGRAMS_OperRow=SQLX_WorkRow;
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_NAME_Data=
            SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_NAME_Data;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber1 = SQLX_DBnumber1;
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated=0;
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable0;
towComSchLab2)
    IF SQLM_PROGRAMS_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_PROGRAMS_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_PROGRAMS_WorkRow > 24000 THEN
            FOR FIRST SQLM_PROGRAMS_WorkRow
                FROM SQLM_PROGRAMS_WorkRow-1
                UNTIL SQLM_PROGRAMS_WorkRow-24000
                WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 1
                GOTO FOUNDtowComRowTable0;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                2;
            EXIT;
        ELSE
            FOR FIRST SQLM_PROGRAMS_WorkRow
                FROM SQLM_PROGRAMS_WorkRow-1
                WHERE SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated = 1
                GOTO FOUNDtowComRowTable0;
            SQLM_PROGRAMS_WorkRow=0;
        FI;
FOUNDtowComRowTable0)
        SQLM_TableReference:SQLM_TableLast=SQLM_PROGRAMS_WorkRow;
    FI;
CONTINUEtowComRowTable0)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
towComRowTable1)
    SQLM_TABLES_OperRow=SQLX_OperRow;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
! wait until no one is locking the tree !
towComSchLab3)
    SQLM_TABLES_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TABLES_NilRow=SQLM_TABLES_RootRow-1;
    IF SQLM_TABLES_RootRow:SQLC_TABLES_Left4=SQLM_TABLES_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            3;
        EXIT;
    FI;
    SQLM_TABLES_RootRow:SQLC_TABLES_Left4=SQLM_TABLES_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab2;
    SQLM_TABLES_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        4,
        2,
        1,
        +,
        SQLM_TABLES_RootRow,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right4,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab2)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable1_4;
    SQLM_TABLES_OperRow=SQLX_OperRow;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_BLKREF_Data=
        SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data;
LABEL1towComRowTable1_4)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab2;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        4,
        2,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab2)
    SQLM_TABLES_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TABLES_RootRow:SQLC_TABLES_Left4=0;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab4;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    IF SQLM_TABLES_WorkRow:SQLC_TABLES_Color3=1
        GOTO LABEL2towComRowTable1_3;
! wait until no one is locking the tree !
towComSchLab4)
    SQLM_TABLES_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TABLES_NilRow=SQLM_TABLES_RootRow-1;
    IF SQLM_TABLES_RootRow:SQLC_TABLES_Left3=SQLM_TABLES_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            4;
        EXIT;
    FI;
    SQLM_TABLES_RootRow:SQLC_TABLES_Left3=SQLM_TABLES_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab3;
    SQLM_TABLES_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        3,
        2,
        +,
        SQLM_TABLES_RootRow,
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab3)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable1_3;
    SQLM_TABLES_OperRow=SQLX_OperRow;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_OperRow:SQLC_TABLES_NAME_Data=
        SQLM_TABLES_WorkRow:SQLC_TABLES_NAME_Data;
    SQLM_TABLES_OperRow:SQLC_TABLES_BLKREF_Data=
        SQLM_TABLES_WorkRow:SQLC_TABLES_BLKREF_Data;
LABEL1towComRowTable1_3)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab3;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        3,
        2,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab3)
    SQLM_TABLES_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TABLES_RootRow:SQLC_TABLES_Left3=0;
LABEL2towComRowTable1_3)
    SQLM_TABLES_OperRow=SQLX_OperRow;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber1 = SQLX_DBnumber1;
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_TABLES_OperRow=SQLX_WorkRow;
        SQLM_TABLES_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TABLES_TempRow =
    SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
SQLM_TABLES_TempRow:SQLC_TABLES_Left3 =
    SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
SQLM_TABLES_TempRow =
    SQLM_TABLES_OperRow:SQLC_TABLES_Left3;

IF SQLM_TABLES_TempRow /= SQLM_TABLES_NilRow THEN
    SQLM_TABLES_TempRow:SQLC_TABLES_Right3 =
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
FI;
        SQLM_TABLES_OperRow=SQLX_WorkRow;
        SQLM_TABLES_OperRow:SQLC_TABLES_TABREF_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_TABREF_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_DESCR_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_DESCR_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Null=
            SQLM_TABLES_WorkRow:SQLC_TABLES_SAEIDT_Null;
        SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDT_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_SAEIDT_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_ESTEPT_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_ESTEPT_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_MAXST_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_MAXST_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_ALLOCST_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_ALLOCST_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_USEDST_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_USEDST_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDW_Null=
            SQLM_TABLES_WorkRow:SQLC_TABLES_SAEIDW_Null;
        SQLM_TABLES_OperRow:SQLC_TABLES_SAEIDW_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_SAEIDW_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_ESTEPW_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_ESTEPW_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_MAXSW_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_MAXSW_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_ALLOCSW_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_ALLOCSW_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_USEDSW_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_USEDSW_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_STATE_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_STATE_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_RAUCAT_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_RAUCAT_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_WAUCAT_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_WAUCAT_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_LOCATE_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_LOCATE_Data;
        SQLM_TABLES_OperRow:SQLC_TABLES_NOFLTCO_Data=
            SQLM_TABLES_WorkRow:SQLC_TABLES_NOFLTCO_Data;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber1 = SQLX_DBnumber1;
        SQLM_TABLES_OperRow:SQLC_TABLES_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_TABLES_OperRow:SQLC_TABLES_Allocated=0;
        SQLM_TABLES_OperRow:SQLC_TABLES_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable1;
towComSchLab5)
    IF SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_TABLES_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_TABLES_WorkRow > 24000 THEN
            FOR FIRST SQLM_TABLES_WorkRow
                FROM SQLM_TABLES_WorkRow-1
                UNTIL SQLM_TABLES_WorkRow-24000
                WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 1
                GOTO FOUNDtowComRowTable1;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                5;
            EXIT;
        ELSE
            FOR FIRST SQLM_TABLES_WorkRow
                FROM SQLM_TABLES_WorkRow-1
                WHERE SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated = 1
                GOTO FOUNDtowComRowTable1;
            SQLM_TABLES_WorkRow=0;
        FI;
FOUNDtowComRowTable1)
        SQLM_TableReference:SQLM_TableLast=SQLM_TABLES_WorkRow;
    FI;
CONTINUEtowComRowTable1)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
towComRowTable2)
    SQLM_FIELDS_OperRow=SQLX_OperRow;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
! wait until no one is locking the tree !
towComSchLab6)
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FIELDS_NilRow=SQLM_FIELDS_RootRow-1;
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Left5=SQLM_FIELDS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            6;
        EXIT;
    FI;
    SQLM_FIELDS_RootRow:SQLC_FIELDS_Left5=SQLM_FIELDS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab4;
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        5,
        4,
        1,
        +,
        SQLM_FIELDS_RootRow,
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right5,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab4)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable2_5;
    SQLM_FIELDS_OperRow=SQLX_OperRow;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_TROWNO_Null=
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_TROWNO_Null;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_TROWNO_Data=
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_TROWNO_Data;
LABEL1towComRowTable2_5)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab4;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        5,
        4,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab4)
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FIELDS_RootRow:SQLC_FIELDS_Left5=0;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab7;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    IF SQLM_FIELDS_WorkRow:SQLC_FIELDS_Color4=1
        GOTO LABEL2towComRowTable2_4;
! wait until no one is locking the tree !
towComSchLab7)
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FIELDS_NilRow=SQLM_FIELDS_RootRow-1;
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Left4=SQLM_FIELDS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            7;
        EXIT;
    FI;
    SQLM_FIELDS_RootRow:SQLC_FIELDS_Left4=SQLM_FIELDS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab5;
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        4,
        5,
        3,
        +,
        SQLM_FIELDS_RootRow,
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right4,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab5)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable2_4;
    SQLM_FIELDS_OperRow=SQLX_OperRow;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_TABREF_Data=
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_TABREF_Data;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_BLKREF_Data=
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_BLKREF_Data;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_FIELDNO_Data=
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_FIELDNO_Data;
LABEL1towComRowTable2_4)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab5;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        4,
        5,
        3,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab5)
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FIELDS_RootRow:SQLC_FIELDS_Left4=0;
LABEL2towComRowTable2_4)
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab8;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    IF SQLM_FIELDS_WorkRow:SQLC_FIELDS_Color3=1
        GOTO LABEL2towComRowTable2_3;
! wait until no one is locking the tree !
towComSchLab8)
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FIELDS_NilRow=SQLM_FIELDS_RootRow-1;
    IF SQLM_FIELDS_RootRow:SQLC_FIELDS_Left3=SQLM_FIELDS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            8;
        EXIT;
    FI;
    SQLM_FIELDS_RootRow:SQLC_FIELDS_Left3=SQLM_FIELDS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab6;
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        6,
        3,
        +,
        SQLM_FIELDS_RootRow,
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right3,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab6)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable2_3;
    SQLM_FIELDS_OperRow=SQLX_OperRow;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_NAME_Data=
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_NAME_Data;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_TABREF_Data=
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_TABREF_Data;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_BLKREF_Data=
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_BLKREF_Data;
LABEL1towComRowTable2_3)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab6;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        6,
        3,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab6)
    SQLM_FIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FIELDS_RootRow:SQLC_FIELDS_Left3=0;
LABEL2towComRowTable2_3)
    SQLM_FIELDS_OperRow=SQLX_OperRow;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber1 = SQLX_DBnumber1;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_FIELDS_OperRow=SQLX_WorkRow;
        SQLM_FIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_FIELDS_TempRow =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
SQLM_FIELDS_TempRow:SQLC_FIELDS_Left3 =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
SQLM_FIELDS_TempRow =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;

IF SQLM_FIELDS_TempRow /= SQLM_FIELDS_NilRow THEN
    SQLM_FIELDS_TempRow:SQLC_FIELDS_Right3 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
FI;
        SQLM_FIELDS_OperRow=SQLX_WorkRow;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DESCR_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DESCR_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_VISIBIL_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_VISIBIL_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_PRWIDTH_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_PRWIDTH_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_NULLPER_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_NULLPER_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DATATYP_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DATATYP_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_BADDRES_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_BADDRES_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_MIN_Null=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_MIN_Null;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_MIN_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_MIN_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_MAX_Null=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_MAX_Null;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_MAX_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_MAX_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_SIZE_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_SIZE_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DIDNR_Null=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DIDNR_Null;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DIDNR_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DIDNR_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DIDPOS_Null=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DIDPOS_Null;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DIDPOS_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DIDPOS_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_PCLEAR_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_PCLEAR_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_PRELOAD_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_PRELOAD_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_PDUMP_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_PDUMP_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_PSTATIC_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_PSTATIC_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_VOLATIL_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_VOLATIL_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFBITS_Null=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFBITS_Null;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFBITS_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFBITS_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFSTR_Null=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFSTR_Null;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFSTR_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFSTR_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFNSTR_Null=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFNSTR_Null;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFNSTR_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFNSTR_Data;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Null=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Null;
!------------------------------------------------!
!       copyPackNum !
!------------------------------------------------!

    SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.LENGTH =
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.LENGTH;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W1 =
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W1;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W2 =
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W2;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W3 =
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W3;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W4 =
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W4;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W5 =
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W5;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W6 =
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W6;
    SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFPNS_Data.W7 =
        SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFPNS_Data.W7;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFSYMB_Null=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFSYMB_Null;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DEFSYMB_Data=
            SQLM_FIELDS_WorkRow:SQLC_FIELDS_DEFSYMB_Data;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber1 = SQLX_DBnumber1;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated=0;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable2;
towComSchLab9)
    IF SQLM_FIELDS_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_FIELDS_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_FIELDS_WorkRow > 24000 THEN
            FOR FIRST SQLM_FIELDS_WorkRow
                FROM SQLM_FIELDS_WorkRow-1
                UNTIL SQLM_FIELDS_WorkRow-24000
                WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 1
                GOTO FOUNDtowComRowTable2;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                9;
            EXIT;
        ELSE
            FOR FIRST SQLM_FIELDS_WorkRow
                FROM SQLM_FIELDS_WorkRow-1
                WHERE SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated = 1
                GOTO FOUNDtowComRowTable2;
            SQLM_FIELDS_WorkRow=0;
        FI;
FOUNDtowComRowTable2)
        SQLM_TableReference:SQLM_TableLast=SQLM_FIELDS_WorkRow;
    FI;
CONTINUEtowComRowTable2)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
towComRowTable3)
    SQLM_KEYS_OperRow=SQLX_OperRow;
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
! wait until no one is locking the tree !
towComSchLab10)
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_KEYS_NilRow=SQLM_KEYS_RootRow-1;
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Left4=SQLM_KEYS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            10;
        EXIT;
    FI;
    SQLM_KEYS_RootRow:SQLC_KEYS_Left4=SQLM_KEYS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab7;
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        4,
        7,
        1,
        +,
        SQLM_KEYS_RootRow,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right4,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab7)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable3_4;
    SQLM_KEYS_OperRow=SQLX_OperRow;
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_TROWNO_Data=
        SQLM_KEYS_WorkRow:SQLC_KEYS_TROWNO_Data;
LABEL1towComRowTable3_4)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab7;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        4,
        7,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab7)
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_KEYS_RootRow:SQLC_KEYS_Left4=0;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab11;
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    IF SQLM_KEYS_WorkRow:SQLC_KEYS_Color3=1
        GOTO LABEL2towComRowTable3_3;
! wait until no one is locking the tree !
towComSchLab11)
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_KEYS_NilRow=SQLM_KEYS_RootRow-1;
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Left3=SQLM_KEYS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            11;
        EXIT;
    FI;
    SQLM_KEYS_RootRow:SQLC_KEYS_Left3=SQLM_KEYS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab8;
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        8,
        3,
        +,
        SQLM_KEYS_RootRow,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right3,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab8)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable3_3;
    SQLM_KEYS_OperRow=SQLX_OperRow;
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_BLKREF_Data=
        SQLM_KEYS_WorkRow:SQLC_KEYS_BLKREF_Data;
    SQLM_KEYS_OperRow:SQLC_KEYS_TABREF_Data=
        SQLM_KEYS_WorkRow:SQLC_KEYS_TABREF_Data;
    SQLM_KEYS_OperRow:SQLC_KEYS_KEYNO_Data=
        SQLM_KEYS_WorkRow:SQLC_KEYS_KEYNO_Data;
LABEL1towComRowTable3_3)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab8;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        8,
        3,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab8)
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_KEYS_RootRow:SQLC_KEYS_Left3=0;
LABEL2towComRowTable3_3)
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab12;
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    IF SQLM_KEYS_WorkRow:SQLC_KEYS_Color2=1
        GOTO LABEL2towComRowTable3_2;
! wait until no one is locking the tree !
towComSchLab12)
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_KEYS_NilRow=SQLM_KEYS_RootRow-1;
    IF SQLM_KEYS_RootRow:SQLC_KEYS_Left2=SQLM_KEYS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            12;
        EXIT;
    FI;
    SQLM_KEYS_RootRow:SQLC_KEYS_Left2=SQLM_KEYS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab9;
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        9,
        2,
        +,
        SQLM_KEYS_RootRow,
        SQLM_KEYS_RootRow:SQLC_KEYS_Right2,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab9)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable3_2;
    SQLM_KEYS_OperRow=SQLX_OperRow;
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_OperRow:SQLC_KEYS_TROWNO_Data=
        SQLM_KEYS_WorkRow:SQLC_KEYS_TROWNO_Data;
    SQLM_KEYS_OperRow:SQLC_KEYS_KEYNO_Data=
        SQLM_KEYS_WorkRow:SQLC_KEYS_KEYNO_Data;
LABEL1towComRowTable3_2)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab9;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        9,
        2,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab9)
    SQLM_KEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_KEYS_RootRow:SQLC_KEYS_Left2=0;
LABEL2towComRowTable3_2)
    SQLM_KEYS_OperRow=SQLX_OperRow;
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber1 = SQLX_DBnumber1;
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_KEYS_OperRow=SQLX_WorkRow;
        SQLM_KEYS_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_KEYS_TempRow =
    SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
SQLM_KEYS_TempRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
SQLM_KEYS_TempRow =
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;

IF SQLM_KEYS_TempRow /= SQLM_KEYS_NilRow THEN
    SQLM_KEYS_TempRow:SQLC_KEYS_Right2 =
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
FI;
        SQLM_KEYS_OperRow=SQLX_WorkRow;
        SQLM_KEYS_OperRow:SQLC_KEYS_KEYTYPE_Data=
            SQLM_KEYS_WorkRow:SQLC_KEYS_KEYTYPE_Data;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber1 = SQLX_DBnumber1;
        SQLM_KEYS_OperRow:SQLC_KEYS_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_KEYS_OperRow:SQLC_KEYS_Allocated=0;
        SQLM_KEYS_OperRow:SQLC_KEYS_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable3;
towComSchLab13)
    IF SQLM_KEYS_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_KEYS_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_KEYS_WorkRow > 24000 THEN
            FOR FIRST SQLM_KEYS_WorkRow
                FROM SQLM_KEYS_WorkRow-1
                UNTIL SQLM_KEYS_WorkRow-24000
                WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 1
                GOTO FOUNDtowComRowTable3;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                13;
            EXIT;
        ELSE
            FOR FIRST SQLM_KEYS_WorkRow
                FROM SQLM_KEYS_WorkRow-1
                WHERE SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated = 1
                GOTO FOUNDtowComRowTable3;
            SQLM_KEYS_WorkRow=0;
        FI;
FOUNDtowComRowTable3)
        SQLM_TableReference:SQLM_TableLast=SQLM_KEYS_WorkRow;
    FI;
CONTINUEtowComRowTable3)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
towComRowTable4)
    SQLM_KEYFIELDS_OperRow=SQLX_OperRow;
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab14;
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    IF SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Color3=1
        GOTO LABEL2towComRowTable4_3;
! wait until no one is locking the tree !
towComSchLab14)
    SQLM_KEYFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_KEYFIELDS_NilRow=SQLM_KEYFIELDS_RootRow-1;
    IF SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left3=SQLM_KEYFIELDS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            14;
        EXIT;
    FI;
    SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left3=SQLM_KEYFIELDS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab10;
    SQLM_KEYFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        10,
        4,
        +,
        SQLM_KEYFIELDS_RootRow,
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right3,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab10)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable4_3;
    SQLM_KEYFIELDS_OperRow=SQLX_OperRow;
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_BLKREF_Data=
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_BLKREF_Data;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_TABREF_Data=
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_TABREF_Data;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_KEYNO_Data=
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_KEYNO_Data;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_COMPNO_Data=
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_COMPNO_Data;
LABEL1towComRowTable4_3)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab10;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        10,
        4,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab10)
    SQLM_KEYFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left3=0;
LABEL2towComRowTable4_3)
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab15;
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    IF SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Color2=1
        GOTO LABEL2towComRowTable4_2;
! wait until no one is locking the tree !
towComSchLab15)
    SQLM_KEYFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_KEYFIELDS_NilRow=SQLM_KEYFIELDS_RootRow-1;
    IF SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left2=SQLM_KEYFIELDS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            15;
        EXIT;
    FI;
    SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left2=SQLM_KEYFIELDS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab11;
    SQLM_KEYFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        11,
        3,
        +,
        SQLM_KEYFIELDS_RootRow,
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right2,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab11)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable4_2;
    SQLM_KEYFIELDS_OperRow=SQLX_OperRow;
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_TROWNO_Data=
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_TROWNO_Data;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_KEYNO_Data=
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_KEYNO_Data;
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_COMPNO_Data=
        SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_COMPNO_Data;
LABEL1towComRowTable4_2)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab11;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        11,
        3,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab11)
    SQLM_KEYFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Left2=0;
LABEL2towComRowTable4_2)
    SQLM_KEYFIELDS_OperRow=SQLX_OperRow;
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber1 = SQLX_DBnumber1;
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_KEYFIELDS_OperRow=SQLX_WorkRow;
        SQLM_KEYFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;

IF SQLM_KEYFIELDS_TempRow /= SQLM_KEYFIELDS_NilRow THEN
    SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Right2 =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
FI;
        SQLM_KEYFIELDS_OperRow=SQLX_WorkRow;
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_FROWNO_Data=
            SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_FROWNO_Data;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber1 = SQLX_DBnumber1;
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated=0;
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable4;
towComSchLab16)
    IF SQLM_KEYFIELDS_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_KEYFIELDS_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_KEYFIELDS_WorkRow > 24000 THEN
            FOR FIRST SQLM_KEYFIELDS_WorkRow
                FROM SQLM_KEYFIELDS_WorkRow-1
                UNTIL SQLM_KEYFIELDS_WorkRow-24000
                WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 1
                GOTO FOUNDtowComRowTable4;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                16;
            EXIT;
        ELSE
            FOR FIRST SQLM_KEYFIELDS_WorkRow
                FROM SQLM_KEYFIELDS_WorkRow-1
                WHERE SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated = 1
                GOTO FOUNDtowComRowTable4;
            SQLM_KEYFIELDS_WorkRow=0;
        FI;
FOUNDtowComRowTable4)
        SQLM_TableReference:SQLM_TableLast=SQLM_KEYFIELDS_WorkRow;
    FI;
CONTINUEtowComRowTable4)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
towComRowTable5)
    SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
! wait until no one is locking the tree !
towComSchLab17)
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_NilRow=SQLM_FOREIGNKEYS_RootRow-1;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left5=SQLM_FOREIGNKEYS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            17;
        EXIT;
    FI;
    SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left5=SQLM_FOREIGNKEYS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab12;
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        5,
        12,
        1,
        +,
        SQLM_FOREIGNKEYS_RootRow,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right5,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab12)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable5_5;
    SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_FTROWNO_Data=
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_FTROWNO_Data;
LABEL1towComRowTable5_5)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab12;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        5,
        12,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab12)
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left5=0;
! test if we need to update key (only update) !
! wait until no one is locking the tree !
towComSchLab18)
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_NilRow=SQLM_FOREIGNKEYS_RootRow-1;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left4=SQLM_FOREIGNKEYS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            18;
        EXIT;
    FI;
    SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left4=SQLM_FOREIGNKEYS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab13;
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        4,
        13,
        1,
        +,
        SQLM_FOREIGNKEYS_RootRow,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right4,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab13)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable5_4;
    SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_TROWNO_Data=
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_TROWNO_Data;
LABEL1towComRowTable5_4)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab13;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        4,
        13,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab13)
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left4=0;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab19;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    IF SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Color3=1
        GOTO LABEL2towComRowTable5_3;
! wait until no one is locking the tree !
towComSchLab19)
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_NilRow=SQLM_FOREIGNKEYS_RootRow-1;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left3=SQLM_FOREIGNKEYS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            19;
        EXIT;
    FI;
    SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left3=SQLM_FOREIGNKEYS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab14;
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        14,
        3,
        +,
        SQLM_FOREIGNKEYS_RootRow,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right3,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab14)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable5_3;
    SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_ORDNO_Data=
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_ORDNO_Data;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_BLKREF_Data=
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_BLKREF_Data;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_TABREF_Data=
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_TABREF_Data;
LABEL1towComRowTable5_3)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab14;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        14,
        3,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab14)
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left3=0;
LABEL2towComRowTable5_3)
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab20;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    IF SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Color2=1
        GOTO LABEL2towComRowTable5_2;
! wait until no one is locking the tree !
towComSchLab20)
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_NilRow=SQLM_FOREIGNKEYS_RootRow-1;
    IF SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left2=SQLM_FOREIGNKEYS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            20;
        EXIT;
    FI;
    SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left2=SQLM_FOREIGNKEYS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab15;
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        15,
        2,
        +,
        SQLM_FOREIGNKEYS_RootRow,
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right2,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab15)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable5_2;
    SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_TROWNO_Data=
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_TROWNO_Data;
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_ORDNO_Data=
        SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_ORDNO_Data;
LABEL1towComRowTable5_2)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab15;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        15,
        2,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab15)
    SQLM_FOREIGNKEYS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Left2=0;
LABEL2towComRowTable5_2)
    SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber1 = SQLX_DBnumber1;
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_FOREIGNKEYS_OperRow=SQLX_WorkRow;
        SQLM_FOREIGNKEYS_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;

IF SQLM_FOREIGNKEYS_TempRow /= SQLM_FOREIGNKEYS_NilRow THEN
    SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Right2 =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
FI;
        SQLM_FOREIGNKEYS_OperRow=SQLX_WorkRow;
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_KEYNO_Data=
            SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_KEYNO_Data;
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_FTABREF_Data=
            SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_FTABREF_Data;
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_FBLKREF_Data=
            SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_FBLKREF_Data;
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_COND_Data=
            SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_COND_Data;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber1 = SQLX_DBnumber1;
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated=0;
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable5;
towComSchLab21)
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_FOREIGNKEYS_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_FOREIGNKEYS_WorkRow > 24000 THEN
            FOR FIRST SQLM_FOREIGNKEYS_WorkRow
                FROM SQLM_FOREIGNKEYS_WorkRow-1
                UNTIL SQLM_FOREIGNKEYS_WorkRow-24000
                WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 1
                GOTO FOUNDtowComRowTable5;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                21;
            EXIT;
        ELSE
            FOR FIRST SQLM_FOREIGNKEYS_WorkRow
                FROM SQLM_FOREIGNKEYS_WorkRow-1
                WHERE SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated = 1
                GOTO FOUNDtowComRowTable5;
            SQLM_FOREIGNKEYS_WorkRow=0;
        FI;
FOUNDtowComRowTable5)
        SQLM_TableReference:SQLM_TableLast=SQLM_FOREIGNKEYS_WorkRow;
    FI;
CONTINUEtowComRowTable5)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
towComRowTable6)
    SQLM_SYMBOLS_OperRow=SQLX_OperRow;
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab22;
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    IF SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Color3=1
        GOTO LABEL2towComRowTable6_3;
! wait until no one is locking the tree !
towComSchLab22)
    SQLM_SYMBOLS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_SYMBOLS_NilRow=SQLM_SYMBOLS_RootRow-1;
    IF SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left3=SQLM_SYMBOLS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            22;
        EXIT;
    FI;
    SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left3=SQLM_SYMBOLS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab16;
    SQLM_SYMBOLS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        16,
        2,
        +,
        SQLM_SYMBOLS_RootRow,
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right3,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab16)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable6_3;
    SQLM_SYMBOLS_OperRow=SQLX_OperRow;
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_FROWNO_Data=
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_FROWNO_Data;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_SYMVAL_Data=
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_SYMVAL_Data;
LABEL1towComRowTable6_3)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab16;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        16,
        2,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab16)
    SQLM_SYMBOLS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left3=0;
LABEL2towComRowTable6_3)
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab23;
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    IF SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Color2=1
        GOTO LABEL2towComRowTable6_2;
! wait until no one is locking the tree !
towComSchLab23)
    SQLM_SYMBOLS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_SYMBOLS_NilRow=SQLM_SYMBOLS_RootRow-1;
    IF SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left2=SQLM_SYMBOLS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            23;
        EXIT;
    FI;
    SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left2=SQLM_SYMBOLS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab17;
    SQLM_SYMBOLS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        17,
        2,
        +,
        SQLM_SYMBOLS_RootRow,
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right2,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab17)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable6_2;
    SQLM_SYMBOLS_OperRow=SQLX_OperRow;
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_FROWNO_Data=
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_FROWNO_Data;
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_SYMBOL_Data=
        SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_SYMBOL_Data;
LABEL1towComRowTable6_2)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab17;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        17,
        2,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab17)
    SQLM_SYMBOLS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Left2=0;
LABEL2towComRowTable6_2)
    SQLM_SYMBOLS_OperRow=SQLX_OperRow;
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber1 = SQLX_DBnumber1;
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_SYMBOLS_OperRow=SQLX_WorkRow;
        SQLM_SYMBOLS_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;

IF SQLM_SYMBOLS_TempRow /= SQLM_SYMBOLS_NilRow THEN
    SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Right2 =
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
FI;
        SQLM_SYMBOLS_OperRow=SQLX_WorkRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber1 = SQLX_DBnumber1;
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated=0;
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable6;
towComSchLab24)
    IF SQLM_SYMBOLS_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_SYMBOLS_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_SYMBOLS_WorkRow > 24000 THEN
            FOR FIRST SQLM_SYMBOLS_WorkRow
                FROM SQLM_SYMBOLS_WorkRow-1
                UNTIL SQLM_SYMBOLS_WorkRow-24000
                WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 1
                GOTO FOUNDtowComRowTable6;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                24;
            EXIT;
        ELSE
            FOR FIRST SQLM_SYMBOLS_WorkRow
                FROM SQLM_SYMBOLS_WorkRow-1
                WHERE SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated = 1
                GOTO FOUNDtowComRowTable6;
            SQLM_SYMBOLS_WorkRow=0;
        FI;
FOUNDtowComRowTable6)
        SQLM_TableReference:SQLM_TableLast=SQLM_SYMBOLS_WorkRow;
    FI;
CONTINUEtowComRowTable6)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
towComRowTable7)
    SQLM_TOWFAULTCODES_OperRow=SQLX_OperRow;
    SQLM_TOWFAULTCODES_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab25;
    SQLM_TOWFAULTCODES_WorkRow=SQLX_WorkRow;
    IF SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Color2=1
        GOTO LABEL2towComRowTable7_2;
! wait until no one is locking the tree !
towComSchLab25)
    SQLM_TOWFAULTCODES_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TOWFAULTCODES_NilRow=SQLM_TOWFAULTCODES_RootRow-1;
    IF SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Left2=SQLM_TOWFAULTCODES_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            25;
        EXIT;
    FI;
    SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Left2=SQLM_TOWFAULTCODES_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab18;
    SQLM_TOWFAULTCODES_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        18,
        2,
        +,
        SQLM_TOWFAULTCODES_RootRow,
        SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Right2,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab18)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable7_2;
    SQLM_TOWFAULTCODES_OperRow=SQLX_OperRow;
    SQLM_TOWFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_TROWNO_Data=
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_TROWNO_Data;
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_FAULTNO_Data=
        SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_FAULTNO_Data;
LABEL1towComRowTable7_2)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab18;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        18,
        2,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab18)
    SQLM_TOWFAULTCODES_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Left2=0;
LABEL2towComRowTable7_2)
    SQLM_TOWFAULTCODES_OperRow=SQLX_OperRow;
    SQLM_TOWFAULTCODES_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber1 = SQLX_DBnumber1;
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_TOWFAULTCODES_OperRow=SQLX_WorkRow;
        SQLM_TOWFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TOWFAULTCODES_TempRow =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Left2 =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
SQLM_TOWFAULTCODES_TempRow =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;

IF SQLM_TOWFAULTCODES_TempRow /= SQLM_TOWFAULTCODES_NilRow THEN
    SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Right2 =
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
FI;
        SQLM_TOWFAULTCODES_OperRow=SQLX_WorkRow;
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_FLTTEXT_Data=
            SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_FLTTEXT_Data;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber1 = SQLX_DBnumber1;
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated=0;
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable7;
towComSchLab26)
    IF SQLM_TOWFAULTCODES_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_TOWFAULTCODES_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_TOWFAULTCODES_WorkRow > 24000 THEN
            FOR FIRST SQLM_TOWFAULTCODES_WorkRow
                FROM SQLM_TOWFAULTCODES_WorkRow-1
                UNTIL SQLM_TOWFAULTCODES_WorkRow-24000
                WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 1
                GOTO FOUNDtowComRowTable7;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                26;
            EXIT;
        ELSE
            FOR FIRST SQLM_TOWFAULTCODES_WorkRow
                FROM SQLM_TOWFAULTCODES_WorkRow-1
                WHERE SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated = 1
                GOTO FOUNDtowComRowTable7;
            SQLM_TOWFAULTCODES_WorkRow=0;
        FI;
FOUNDtowComRowTable7)
        SQLM_TableReference:SQLM_TableLast=SQLM_TOWFAULTCODES_WorkRow;
    FI;
CONTINUEtowComRowTable7)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
towComRowTable8)
    SQLM_SYSFAULTCODES_OperRow=SQLX_OperRow;
    SQLM_SYSFAULTCODES_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab27;
    SQLM_SYSFAULTCODES_WorkRow=SQLX_WorkRow;
    IF SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Color2=1
        GOTO LABEL2towComRowTable8_2;
! wait until no one is locking the tree !
towComSchLab27)
    SQLM_SYSFAULTCODES_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_SYSFAULTCODES_NilRow=SQLM_SYSFAULTCODES_RootRow-1;
    IF SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Left2=SQLM_SYSFAULTCODES_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            27;
        EXIT;
    FI;
    SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Left2=SQLM_SYSFAULTCODES_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab19;
    SQLM_SYSFAULTCODES_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        19,
        1,
        +,
        SQLM_SYSFAULTCODES_RootRow,
        SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Right2,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab19)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable8_2;
    SQLM_SYSFAULTCODES_OperRow=SQLX_OperRow;
    SQLM_SYSFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_FAULTNO_Data=
        SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_FAULTNO_Data;
LABEL1towComRowTable8_2)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab19;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        19,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab19)
    SQLM_SYSFAULTCODES_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Left2=0;
LABEL2towComRowTable8_2)
    SQLM_SYSFAULTCODES_OperRow=SQLX_OperRow;
    SQLM_SYSFAULTCODES_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber1 = SQLX_DBnumber1;
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_SYSFAULTCODES_OperRow=SQLX_WorkRow;
        SQLM_SYSFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYSFAULTCODES_TempRow =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Left2 =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
SQLM_SYSFAULTCODES_TempRow =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;

IF SQLM_SYSFAULTCODES_TempRow /= SQLM_SYSFAULTCODES_NilRow THEN
    SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Right2 =
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
FI;
        SQLM_SYSFAULTCODES_OperRow=SQLX_WorkRow;
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_FLTTEXT_Data=
            SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_FLTTEXT_Data;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber1 = SQLX_DBnumber1;
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated=0;
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable8;
towComSchLab28)
    IF SQLM_SYSFAULTCODES_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_SYSFAULTCODES_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_SYSFAULTCODES_WorkRow > 24000 THEN
            FOR FIRST SQLM_SYSFAULTCODES_WorkRow
                FROM SQLM_SYSFAULTCODES_WorkRow-1
                UNTIL SQLM_SYSFAULTCODES_WorkRow-24000
                WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 1
                GOTO FOUNDtowComRowTable8;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                28;
            EXIT;
        ELSE
            FOR FIRST SQLM_SYSFAULTCODES_WorkRow
                FROM SQLM_SYSFAULTCODES_WorkRow-1
                WHERE SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated = 1
                GOTO FOUNDtowComRowTable8;
            SQLM_SYSFAULTCODES_WorkRow=0;
        FI;
FOUNDtowComRowTable8)
        SQLM_TableReference:SQLM_TableLast=SQLM_SYSFAULTCODES_WorkRow;
    FI;
CONTINUEtowComRowTable8)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
towComRowTable9)
    SQLM_SYSTEMFIELDS_OperRow=SQLX_OperRow;
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
! wait until no one is locking the tree !
towComSchLab29)
    SQLM_SYSTEMFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_SYSTEMFIELDS_NilRow=SQLM_SYSTEMFIELDS_RootRow-1;
    IF SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left3=SQLM_SYSTEMFIELDS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            29;
        EXIT;
    FI;
    SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left3=SQLM_SYSTEMFIELDS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab20;
    SQLM_SYSTEMFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        20,
        1,
        +,
        SQLM_SYSTEMFIELDS_RootRow,
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right3,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab20)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable9_3;
    SQLM_SYSTEMFIELDS_OperRow=SQLX_OperRow;
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_TROWNO_Data=
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_TROWNO_Data;
LABEL1towComRowTable9_3)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab20;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        20,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab20)
    SQLM_SYSTEMFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left3=0;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab30;
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
    IF SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Color2=1
        GOTO LABEL2towComRowTable9_2;
! wait until no one is locking the tree !
towComSchLab30)
    SQLM_SYSTEMFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_SYSTEMFIELDS_NilRow=SQLM_SYSTEMFIELDS_RootRow-1;
    IF SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left2=SQLM_SYSTEMFIELDS_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            30;
        EXIT;
    FI;
    SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left2=SQLM_SYSTEMFIELDS_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab21;
    SQLM_SYSTEMFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        21,
        1,
        +,
        SQLM_SYSTEMFIELDS_RootRow,
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right2,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab21)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable9_2;
    SQLM_SYSTEMFIELDS_OperRow=SQLX_OperRow;
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_TROWNO_Data=
        SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_TROWNO_Data;
LABEL1towComRowTable9_2)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab21;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        21,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab21)
    SQLM_SYSTEMFIELDS_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Left2=0;
LABEL2towComRowTable9_2)
    SQLM_SYSTEMFIELDS_OperRow=SQLX_OperRow;
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber1 = SQLX_DBnumber1;
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_SYSTEMFIELDS_OperRow=SQLX_WorkRow;
        SQLM_SYSTEMFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYSTEMFIELDS_TempRow =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Left2 =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
SQLM_SYSTEMFIELDS_TempRow =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;

IF SQLM_SYSTEMFIELDS_TempRow /= SQLM_SYSTEMFIELDS_NilRow THEN
    SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Right2 =
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
FI;
        SQLM_SYSTEMFIELDS_OperRow=SQLX_WorkRow;
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_ROWGEN_Data=
            SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_ROWGEN_Data;
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_LOCK_Data=
            SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_LOCK_Data;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber1 = SQLX_DBnumber1;
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated=0;
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable9;
towComSchLab31)
    IF SQLM_SYSTEMFIELDS_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_SYSTEMFIELDS_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_SYSTEMFIELDS_WorkRow > 24000 THEN
            FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
                FROM SQLM_SYSTEMFIELDS_WorkRow-1
                UNTIL SQLM_SYSTEMFIELDS_WorkRow-24000
                WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 1
                GOTO FOUNDtowComRowTable9;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                31;
            EXIT;
        ELSE
            FOR FIRST SQLM_SYSTEMFIELDS_WorkRow
                FROM SQLM_SYSTEMFIELDS_WorkRow-1
                WHERE SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated = 1
                GOTO FOUNDtowComRowTable9;
            SQLM_SYSTEMFIELDS_WorkRow=0;
        FI;
FOUNDtowComRowTable9)
        SQLM_TableReference:SQLM_TableLast=SQLM_SYSTEMFIELDS_WorkRow;
    FI;
CONTINUEtowComRowTable9)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
towComRowTable10)
    SQLM_TEST1_OperRow=SQLX_OperRow;
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
! wait until no one is locking the tree !
towComSchLab32)
    SQLM_TEST1_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TEST1_NilRow=SQLM_TEST1_RootRow-1;
    IF SQLM_TEST1_RootRow:SQLC_TEST1_Left3=SQLM_TEST1_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            32;
        EXIT;
    FI;
    SQLM_TEST1_RootRow:SQLC_TEST1_Left3=SQLM_TEST1_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab22;
    SQLM_TEST1_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        22,
        1,
        +,
        SQLM_TEST1_RootRow,
        SQLM_TEST1_RootRow:SQLC_TEST1_Right3,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab22)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable10_3;
    SQLM_TEST1_OperRow=SQLX_OperRow;
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL5_Null=
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL5_Null;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL5_Data=
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL5_Data;
LABEL1towComRowTable10_3)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab22;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        22,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab22)
    SQLM_TEST1_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TEST1_RootRow:SQLC_TEST1_Left3=0;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab33;
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
    IF SQLM_TEST1_WorkRow:SQLC_TEST1_Color2=1
        GOTO LABEL2towComRowTable10_2;
! wait until no one is locking the tree !
towComSchLab33)
    SQLM_TEST1_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TEST1_NilRow=SQLM_TEST1_RootRow-1;
    IF SQLM_TEST1_RootRow:SQLC_TEST1_Left2=SQLM_TEST1_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            33;
        EXIT;
    FI;
    SQLM_TEST1_RootRow:SQLC_TEST1_Left2=SQLM_TEST1_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab23;
    SQLM_TEST1_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        23,
        2,
        +,
        SQLM_TEST1_RootRow,
        SQLM_TEST1_RootRow:SQLC_TEST1_Right2,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab23)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable10_2;
    SQLM_TEST1_OperRow=SQLX_OperRow;
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL1_Data=
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL1_Data;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL2_Data=
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL2_Data;
LABEL1towComRowTable10_2)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab23;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        23,
        2,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab23)
    SQLM_TEST1_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TEST1_RootRow:SQLC_TEST1_Left2=0;
LABEL2towComRowTable10_2)
    SQLM_TEST1_OperRow=SQLX_OperRow;
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber1 = SQLX_DBnumber1;
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_TEST1_OperRow=SQLX_WorkRow;
        SQLM_TEST1_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TEST1_TempRow =
    SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
SQLM_TEST1_TempRow:SQLC_TEST1_Left2 =
    SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
SQLM_TEST1_TempRow =
    SQLM_TEST1_OperRow:SQLC_TEST1_Left2;

IF SQLM_TEST1_TempRow /= SQLM_TEST1_NilRow THEN
    SQLM_TEST1_TempRow:SQLC_TEST1_Right2 =
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
FI;
        SQLM_TEST1_OperRow=SQLX_WorkRow;
        SQLM_TEST1_OperRow:SQLC_TEST1_COL3_Null=
            SQLM_TEST1_WorkRow:SQLC_TEST1_COL3_Null;
        SQLM_TEST1_OperRow:SQLC_TEST1_COL3_Data=
            SQLM_TEST1_WorkRow:SQLC_TEST1_COL3_Data;
        SQLM_TEST1_OperRow:SQLC_TEST1_COL4_Data=
            SQLM_TEST1_WorkRow:SQLC_TEST1_COL4_Data;
        SQLM_TEST1_OperRow:SQLC_TEST1_COL6_Null=
            SQLM_TEST1_WorkRow:SQLC_TEST1_COL6_Null;
        SQLM_TEST1_OperRow:SQLC_TEST1_COL6_Data=
            SQLM_TEST1_WorkRow:SQLC_TEST1_COL6_Data;
        SQLM_TEST1_OperRow:SQLC_TEST1_COL7_Null=
            SQLM_TEST1_WorkRow:SQLC_TEST1_COL7_Null;
        SQLM_TEST1_OperRow:SQLC_TEST1_COL7_Data=
            SQLM_TEST1_WorkRow:SQLC_TEST1_COL7_Data;
        SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Null=
            SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Null;
!------------------------------------------------!
!       copyPackNum !
!------------------------------------------------!

    SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.LENGTH =
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.LENGTH;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W1 =
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W1;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W2 =
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W2;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W3 =
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W3;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W4 =
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W4;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W5 =
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W5;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W6 =
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W6;
    SQLM_TEST1_OperRow:SQLC_TEST1_COL8_Data.W7 =
        SQLM_TEST1_WorkRow:SQLC_TEST1_COL8_Data.W7;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber1 = SQLX_DBnumber1;
        SQLM_TEST1_OperRow:SQLC_TEST1_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_TEST1_OperRow:SQLC_TEST1_Allocated=0;
        SQLM_TEST1_OperRow:SQLC_TEST1_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable10;
towComSchLab34)
    IF SQLM_TEST1_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_TEST1_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_TEST1_WorkRow > 24000 THEN
            FOR FIRST SQLM_TEST1_WorkRow
                FROM SQLM_TEST1_WorkRow-1
                UNTIL SQLM_TEST1_WorkRow-24000
                WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 1
                GOTO FOUNDtowComRowTable10;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                34;
            EXIT;
        ELSE
            FOR FIRST SQLM_TEST1_WorkRow
                FROM SQLM_TEST1_WorkRow-1
                WHERE SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated = 1
                GOTO FOUNDtowComRowTable10;
            SQLM_TEST1_WorkRow=0;
        FI;
FOUNDtowComRowTable10)
        SQLM_TableReference:SQLM_TableLast=SQLM_TEST1_WorkRow;
    FI;
CONTINUEtowComRowTable10)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComSch !
!------------------------------------------------!
    ENTER towComSch WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        SQLX_ReturnLabel;
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComSchLab1;
    WHEN 2 DO GOTO towComSchLab2;
    WHEN 3 DO GOTO towComSchLab3;
    WHEN 4 DO GOTO towComSchLab4;
    WHEN 5 DO GOTO towComSchLab5;
    WHEN 6 DO GOTO towComSchLab6;
    WHEN 7 DO GOTO towComSchLab7;
    WHEN 8 DO GOTO towComSchLab8;
    WHEN 9 DO GOTO towComSchLab9;
    WHEN 10 DO GOTO towComSchLab10;
    WHEN 11 DO GOTO towComSchLab11;
    WHEN 12 DO GOTO towComSchLab12;
    WHEN 13 DO GOTO towComSchLab13;
    WHEN 14 DO GOTO towComSchLab14;
    WHEN 15 DO GOTO towComSchLab15;
    WHEN 16 DO GOTO towComSchLab16;
    WHEN 17 DO GOTO towComSchLab17;
    WHEN 18 DO GOTO towComSchLab18;
    WHEN 19 DO GOTO towComSchLab19;
    WHEN 20 DO GOTO towComSchLab20;
    WHEN 21 DO GOTO towComSchLab21;
    WHEN 22 DO GOTO towComSchLab22;
    WHEN 23 DO GOTO towComSchLab23;
    WHEN 24 DO GOTO towComSchLab24;
    WHEN 25 DO GOTO towComSchLab25;
    WHEN 26 DO GOTO towComSchLab26;
    WHEN 27 DO GOTO towComSchLab27;
    WHEN 28 DO GOTO towComSchLab28;
    WHEN 29 DO GOTO towComSchLab29;
    WHEN 30 DO GOTO towComSchLab30;
    WHEN 31 DO GOTO towComSchLab31;
    WHEN 32 DO GOTO towComSchLab32;
    WHEN 33 DO GOTO towComSchLab33;
    WHEN 34 DO GOTO towComSchLab34;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKey !
!------------------------------------------------!
    ENTER towComInsKey WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        SQLX_KeyNumber,
        SQLX_ReturnLabel,
        SQLX_KeyPrefix,
        SQLX_GrandGrandFather,
        SQLX_GrandFather,
        SQLX_Father,
        SQLX_Current;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
! Setup pointers and clear loop counter. !
    SQLM_PROGRAMS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_PROGRAMS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_PROGRAMS_GrandFather=SQLX_GrandFather;
    SQLM_PROGRAMS_Father=SQLX_Father;
    SQLM_PROGRAMS_OperRow=SQLX_Current;
    SQLM_PROGRAMS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_PROGRAMS_OperRow = SQLM_PROGRAMS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey0_2;
    FI;
LOOPtowComInsKeyTableKey0_2)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_PROGRAMS_GrandGrandFather,
            SQLM_PROGRAMS_GrandFather,
            SQLM_PROGRAMS_Father,
            SQLM_PROGRAMS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_PROGRAMS_OperRow = SQLM_PROGRAMS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey0_2;
! Test key to be inserted against 'root' node. !
    DO SQLS_PROGRAMS_KeyTest2;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey0_2;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey0_2)
    SQLM_PROGRAMS_GrandGrandFather = SQLM_PROGRAMS_GrandFather;
    SQLM_PROGRAMS_GrandFather = SQLM_PROGRAMS_Father;
    SQLM_PROGRAMS_Father = SQLM_PROGRAMS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_PROGRAMS_OperRow = SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
    ELSE
        SQLM_PROGRAMS_OperRow = SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_PROGRAMS_TempRow = SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
    IF SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2 = 0 THEN
        SQLM_PROGRAMS_TempRow = SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
        IF SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2 = 0 THEN
! Top of a 4-node. !
            IF SQLM_PROGRAMS_OperRow = SQLM_PROGRAMS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_PROGRAMS_OperRow=SQLM_PROGRAMS_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_PROGRAMS_TempRow =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Left2 =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
SQLM_PROGRAMS_TempRow =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;

IF SQLM_PROGRAMS_TempRow /= SQLM_PROGRAMS_NilRow THEN
    SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Right2 =
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
FI;
                SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2 = 0;
                SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2  =
                    SQLM_PROGRAMS_NilRow;
                SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2 =
                    SQLM_PROGRAMS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_PROGRAMS_WorkRow = SQLM_PROGRAMS_Father;
                DO SQLS_PROGRAMS_KeyTest2;
DISABLE INTERRUPT;
                SQLM_PROGRAMS_WorkRow = SQLM_PROGRAMS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2 =
                        SQLM_PROGRAMS_OperRow;
                ELSE
                    SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2 =
                        SQLM_PROGRAMS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_PROGRAMS_TempRow =
                    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
                SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2 = 1;
                SQLM_PROGRAMS_TempRow =
                    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
                SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2 = 1;
                SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Color2 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Left2 =
                   SQLM_PROGRAMS_Father
                THEN
                    IF SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2 =
                       SQLM_PROGRAMS_OperRow
                    THEN
! Double rotation !
                        SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2 =
                            SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
                        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2 =
                            SQLM_PROGRAMS_Father;
                        SQLM_PROGRAMS_Father =
                            SQLM_PROGRAMS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Left2 =
                        SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2;
                    SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2 =
                        SQLM_PROGRAMS_GrandFather;
                ELSE
                    IF SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2 =
                        SQLM_PROGRAMS_OperRow
                    THEN
! Double rotation !
                        SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2 =
                            SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
                        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2 =
                            SQLM_PROGRAMS_Father;
                        SQLM_PROGRAMS_Father =
                            SQLM_PROGRAMS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Right2 =
                        SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2;
                    SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2 =
                        SQLM_PROGRAMS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_PROGRAMS_TempRow =
                    SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2;
                SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2 = 0;
                SQLM_PROGRAMS_TempRow =
                    SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2;
                SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2 = 0;
                SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Color2 = 1;
! Relink nodes !
                IF SQLM_PROGRAMS_GrandGrandFather:SQLC_PROGRAMS_Right2 =
                    SQLM_PROGRAMS_GrandFather
                THEN
                    SQLM_PROGRAMS_GrandGrandFather:SQLC_PROGRAMS_Right2 =
                        SQLM_PROGRAMS_Father;
                ELSE
                    SQLM_PROGRAMS_GrandGrandFather:SQLC_PROGRAMS_Left2 =
                        SQLM_PROGRAMS_Father;
                FI;
                SQLM_PROGRAMS_GrandFather =
                    SQLM_PROGRAMS_Father;
                SQLM_PROGRAMS_OperRow =
                    SQLM_PROGRAMS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey0_2;
! Aftermath !
ENDLOOPtowComInsKeyTableKey0_2)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_PROGRAMS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_PROGRAMS_TempRow =
        SQLM_PROGRAMS_RootRow:SQLC_PROGRAMS_Right2;
    SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 1 DO
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 3 DO GOTO towComInsKeyTableKey1_3;
    WHEN 4 DO GOTO towComInsKeyTableKey1_4;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey1_3)
! Setup pointers and clear loop counter. !
    SQLM_TABLES_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_TABLES_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_TABLES_GrandFather=SQLX_GrandFather;
    SQLM_TABLES_Father=SQLX_Father;
    SQLM_TABLES_OperRow=SQLX_Current;
    SQLM_TABLES_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_TABLES_OperRow = SQLM_TABLES_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey1_3;
    FI;
LOOPtowComInsKeyTableKey1_3)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TABLES_GrandGrandFather,
            SQLM_TABLES_GrandFather,
            SQLM_TABLES_Father,
            SQLM_TABLES_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_TABLES_OperRow = SQLM_TABLES_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey1_3;
! Test key to be inserted against 'root' node. !
    DO SQLS_TABLES_KeyTest3;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey1_3;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey1_3)
    SQLM_TABLES_GrandGrandFather = SQLM_TABLES_GrandFather;
    SQLM_TABLES_GrandFather = SQLM_TABLES_Father;
    SQLM_TABLES_Father = SQLM_TABLES_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TABLES_OperRow = SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
    ELSE
        SQLM_TABLES_OperRow = SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_TABLES_TempRow = SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
    IF SQLM_TABLES_TempRow:SQLC_TABLES_Color3 = 0 THEN
        SQLM_TABLES_TempRow = SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
        IF SQLM_TABLES_TempRow:SQLC_TABLES_Color3 = 0 THEN
! Top of a 4-node. !
            IF SQLM_TABLES_OperRow = SQLM_TABLES_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_TABLES_OperRow=SQLM_TABLES_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TABLES_TempRow =
    SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
SQLM_TABLES_TempRow:SQLC_TABLES_Left3 =
    SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
SQLM_TABLES_TempRow =
    SQLM_TABLES_OperRow:SQLC_TABLES_Left3;

IF SQLM_TABLES_TempRow /= SQLM_TABLES_NilRow THEN
    SQLM_TABLES_TempRow:SQLC_TABLES_Right3 =
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
FI;
                SQLM_TABLES_OperRow:SQLC_TABLES_Color3 = 0;
                SQLM_TABLES_OperRow:SQLC_TABLES_Left3  =
                    SQLM_TABLES_NilRow;
                SQLM_TABLES_OperRow:SQLC_TABLES_Right3 =
                    SQLM_TABLES_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_TABLES_WorkRow = SQLM_TABLES_Father;
                DO SQLS_TABLES_KeyTest3;
DISABLE INTERRUPT;
                SQLM_TABLES_WorkRow = SQLM_TABLES_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_TABLES_Father:SQLC_TABLES_Left3 =
                        SQLM_TABLES_OperRow;
                ELSE
                    SQLM_TABLES_Father:SQLC_TABLES_Right3 =
                        SQLM_TABLES_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_TABLES_TempRow =
                    SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color3 = 1;
                SQLM_TABLES_TempRow =
                    SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color3 = 1;
                SQLM_TABLES_OperRow:SQLC_TABLES_Color3 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_TABLES_Father:SQLC_TABLES_Color3 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_TABLES_GrandFather:SQLC_TABLES_Left3 =
                   SQLM_TABLES_Father
                THEN
                    IF SQLM_TABLES_Father:SQLC_TABLES_Right3 =
                       SQLM_TABLES_OperRow
                    THEN
! Double rotation !
                        SQLM_TABLES_Father:SQLC_TABLES_Right3 =
                            SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
                        SQLM_TABLES_OperRow:SQLC_TABLES_Left3 =
                            SQLM_TABLES_Father;
                        SQLM_TABLES_Father =
                            SQLM_TABLES_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TABLES_GrandFather:SQLC_TABLES_Left3 =
                        SQLM_TABLES_Father:SQLC_TABLES_Right3;
                    SQLM_TABLES_Father:SQLC_TABLES_Right3 =
                        SQLM_TABLES_GrandFather;
                ELSE
                    IF SQLM_TABLES_Father:SQLC_TABLES_Left3 =
                        SQLM_TABLES_OperRow
                    THEN
! Double rotation !
                        SQLM_TABLES_Father:SQLC_TABLES_Left3 =
                            SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
                        SQLM_TABLES_OperRow:SQLC_TABLES_Right3 =
                            SQLM_TABLES_Father;
                        SQLM_TABLES_Father =
                            SQLM_TABLES_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TABLES_GrandFather:SQLC_TABLES_Right3 =
                        SQLM_TABLES_Father:SQLC_TABLES_Left3;
                    SQLM_TABLES_Father:SQLC_TABLES_Left3 =
                        SQLM_TABLES_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_TABLES_TempRow =
                    SQLM_TABLES_Father:SQLC_TABLES_Left3;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color3 = 0;
                SQLM_TABLES_TempRow =
                    SQLM_TABLES_Father:SQLC_TABLES_Right3;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color3 = 0;
                SQLM_TABLES_Father:SQLC_TABLES_Color3 = 1;
! Relink nodes !
                IF SQLM_TABLES_GrandGrandFather:SQLC_TABLES_Right3 =
                    SQLM_TABLES_GrandFather
                THEN
                    SQLM_TABLES_GrandGrandFather:SQLC_TABLES_Right3 =
                        SQLM_TABLES_Father;
                ELSE
                    SQLM_TABLES_GrandGrandFather:SQLC_TABLES_Left3 =
                        SQLM_TABLES_Father;
                FI;
                SQLM_TABLES_GrandFather =
                    SQLM_TABLES_Father;
                SQLM_TABLES_OperRow =
                    SQLM_TABLES_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey1_3;
! Aftermath !
ENDLOOPtowComInsKeyTableKey1_3)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_TABLES_TempRow =
        SQLM_TABLES_RootRow:SQLC_TABLES_Right3;
    SQLM_TABLES_TempRow:SQLC_TABLES_Color3 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey1_4)
! Setup pointers and clear loop counter. !
    SQLM_TABLES_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_TABLES_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_TABLES_GrandFather=SQLX_GrandFather;
    SQLM_TABLES_Father=SQLX_Father;
    SQLM_TABLES_OperRow=SQLX_Current;
    SQLM_TABLES_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_TABLES_OperRow = SQLM_TABLES_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey1_4;
    FI;
LOOPtowComInsKeyTableKey1_4)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TABLES_GrandGrandFather,
            SQLM_TABLES_GrandFather,
            SQLM_TABLES_Father,
            SQLM_TABLES_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_TABLES_OperRow = SQLM_TABLES_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey1_4;
! Test key to be inserted against 'root' node. !
    DO SQLS_TABLES_KeyTest4;
    IF SQLX_KeyTest = 1 THEN
! If key exist, abort. !
        IF SQLM_TABLES_OperRow = SQLM_TABLES_WorkRow GOTO ENDLOOPtowComInsKeyTableKey1_4;
        IF SQLM_TABLES_OperRow > SQLM_TABLES_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey1_4)
    SQLM_TABLES_GrandGrandFather = SQLM_TABLES_GrandFather;
    SQLM_TABLES_GrandFather = SQLM_TABLES_Father;
    SQLM_TABLES_Father = SQLM_TABLES_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TABLES_OperRow = SQLM_TABLES_OperRow:SQLC_TABLES_Left4;
    ELSE
        SQLM_TABLES_OperRow = SQLM_TABLES_OperRow:SQLC_TABLES_Right4;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_TABLES_TempRow = SQLM_TABLES_OperRow:SQLC_TABLES_Left4;
    IF SQLM_TABLES_TempRow:SQLC_TABLES_Color4 = 0 THEN
        SQLM_TABLES_TempRow = SQLM_TABLES_OperRow:SQLC_TABLES_Right4;
        IF SQLM_TABLES_TempRow:SQLC_TABLES_Color4 = 0 THEN
! Top of a 4-node. !
            IF SQLM_TABLES_OperRow = SQLM_TABLES_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_TABLES_OperRow=SQLM_TABLES_WorkRow;
                SQLM_TABLES_OperRow:SQLC_TABLES_Color4 = 0;
                SQLM_TABLES_OperRow:SQLC_TABLES_Left4  =
                    SQLM_TABLES_NilRow;
                SQLM_TABLES_OperRow:SQLC_TABLES_Right4 =
                    SQLM_TABLES_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_TABLES_WorkRow = SQLM_TABLES_Father;
                DO SQLS_TABLES_KeyTest4;
                IF SQLX_KeyTest = 1 THEN
                    IF SQLM_TABLES_OperRow > SQLM_TABLES_WorkRow THEN
                        SQLX_KeyTest = 2;
                    ELSE
                        SQLX_KeyTest = 0;
                    FI;
                FI;
DISABLE INTERRUPT;
                SQLM_TABLES_WorkRow = SQLM_TABLES_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_TABLES_Father:SQLC_TABLES_Left4 =
                        SQLM_TABLES_OperRow;
                ELSE
                    SQLM_TABLES_Father:SQLC_TABLES_Right4 =
                        SQLM_TABLES_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_TABLES_TempRow =
                    SQLM_TABLES_OperRow:SQLC_TABLES_Left4;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color4 = 1;
                SQLM_TABLES_TempRow =
                    SQLM_TABLES_OperRow:SQLC_TABLES_Right4;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color4 = 1;
                SQLM_TABLES_OperRow:SQLC_TABLES_Color4 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_TABLES_Father:SQLC_TABLES_Color4 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_TABLES_GrandFather:SQLC_TABLES_Left4 =
                   SQLM_TABLES_Father
                THEN
                    IF SQLM_TABLES_Father:SQLC_TABLES_Right4 =
                       SQLM_TABLES_OperRow
                    THEN
! Double rotation !
                        SQLM_TABLES_Father:SQLC_TABLES_Right4 =
                            SQLM_TABLES_OperRow:SQLC_TABLES_Left4;
                        SQLM_TABLES_OperRow:SQLC_TABLES_Left4 =
                            SQLM_TABLES_Father;
                        SQLM_TABLES_Father =
                            SQLM_TABLES_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TABLES_GrandFather:SQLC_TABLES_Left4 =
                        SQLM_TABLES_Father:SQLC_TABLES_Right4;
                    SQLM_TABLES_Father:SQLC_TABLES_Right4 =
                        SQLM_TABLES_GrandFather;
                ELSE
                    IF SQLM_TABLES_Father:SQLC_TABLES_Left4 =
                        SQLM_TABLES_OperRow
                    THEN
! Double rotation !
                        SQLM_TABLES_Father:SQLC_TABLES_Left4 =
                            SQLM_TABLES_OperRow:SQLC_TABLES_Right4;
                        SQLM_TABLES_OperRow:SQLC_TABLES_Right4 =
                            SQLM_TABLES_Father;
                        SQLM_TABLES_Father =
                            SQLM_TABLES_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TABLES_GrandFather:SQLC_TABLES_Right4 =
                        SQLM_TABLES_Father:SQLC_TABLES_Left4;
                    SQLM_TABLES_Father:SQLC_TABLES_Left4 =
                        SQLM_TABLES_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_TABLES_TempRow =
                    SQLM_TABLES_Father:SQLC_TABLES_Left4;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color4 = 0;
                SQLM_TABLES_TempRow =
                    SQLM_TABLES_Father:SQLC_TABLES_Right4;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color4 = 0;
                SQLM_TABLES_Father:SQLC_TABLES_Color4 = 1;
! Relink nodes !
                IF SQLM_TABLES_GrandGrandFather:SQLC_TABLES_Right4 =
                    SQLM_TABLES_GrandFather
                THEN
                    SQLM_TABLES_GrandGrandFather:SQLC_TABLES_Right4 =
                        SQLM_TABLES_Father;
                ELSE
                    SQLM_TABLES_GrandGrandFather:SQLC_TABLES_Left4 =
                        SQLM_TABLES_Father;
                FI;
                SQLM_TABLES_GrandFather =
                    SQLM_TABLES_Father;
                SQLM_TABLES_OperRow =
                    SQLM_TABLES_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey1_4;
! Aftermath !
ENDLOOPtowComInsKeyTableKey1_4)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_TABLES_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_TABLES_TempRow =
        SQLM_TABLES_RootRow:SQLC_TABLES_Right4;
    SQLM_TABLES_TempRow:SQLC_TABLES_Color4 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 2 DO
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 3 DO GOTO towComInsKeyTableKey2_3;
    WHEN 4 DO GOTO towComInsKeyTableKey2_4;
    WHEN 5 DO GOTO towComInsKeyTableKey2_5;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey2_3)
! Setup pointers and clear loop counter. !
    SQLM_FIELDS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_FIELDS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_FIELDS_GrandFather=SQLX_GrandFather;
    SQLM_FIELDS_Father=SQLX_Father;
    SQLM_FIELDS_OperRow=SQLX_Current;
    SQLM_FIELDS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_FIELDS_OperRow = SQLM_FIELDS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey2_3;
    FI;
LOOPtowComInsKeyTableKey2_3)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FIELDS_GrandGrandFather,
            SQLM_FIELDS_GrandFather,
            SQLM_FIELDS_Father,
            SQLM_FIELDS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_FIELDS_OperRow = SQLM_FIELDS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey2_3;
! Test key to be inserted against 'root' node. !
    DO SQLS_FIELDS_KeyTest3;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey2_3;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey2_3)
    SQLM_FIELDS_GrandGrandFather = SQLM_FIELDS_GrandFather;
    SQLM_FIELDS_GrandFather = SQLM_FIELDS_Father;
    SQLM_FIELDS_Father = SQLM_FIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FIELDS_OperRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
    ELSE
        SQLM_FIELDS_OperRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_FIELDS_TempRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
    IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3 = 0 THEN
        SQLM_FIELDS_TempRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
        IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3 = 0 THEN
! Top of a 4-node. !
            IF SQLM_FIELDS_OperRow = SQLM_FIELDS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_FIELDS_OperRow=SQLM_FIELDS_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_FIELDS_TempRow =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
SQLM_FIELDS_TempRow:SQLC_FIELDS_Left3 =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
SQLM_FIELDS_TempRow =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;

IF SQLM_FIELDS_TempRow /= SQLM_FIELDS_NilRow THEN
    SQLM_FIELDS_TempRow:SQLC_FIELDS_Right3 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
FI;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3 = 0;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3  =
                    SQLM_FIELDS_NilRow;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3 =
                    SQLM_FIELDS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_FIELDS_WorkRow = SQLM_FIELDS_Father;
                DO SQLS_FIELDS_KeyTest3;
DISABLE INTERRUPT;
                SQLM_FIELDS_WorkRow = SQLM_FIELDS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_FIELDS_Father:SQLC_FIELDS_Left3 =
                        SQLM_FIELDS_OperRow;
                ELSE
                    SQLM_FIELDS_Father:SQLC_FIELDS_Right3 =
                        SQLM_FIELDS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3 = 1;
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3 = 1;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_FIELDS_Father:SQLC_FIELDS_Color3 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left3 =
                   SQLM_FIELDS_Father
                THEN
                    IF SQLM_FIELDS_Father:SQLC_FIELDS_Right3 =
                       SQLM_FIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_FIELDS_Father:SQLC_FIELDS_Right3 =
                            SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
                        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3 =
                            SQLM_FIELDS_Father;
                        SQLM_FIELDS_Father =
                            SQLM_FIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left3 =
                        SQLM_FIELDS_Father:SQLC_FIELDS_Right3;
                    SQLM_FIELDS_Father:SQLC_FIELDS_Right3 =
                        SQLM_FIELDS_GrandFather;
                ELSE
                    IF SQLM_FIELDS_Father:SQLC_FIELDS_Left3 =
                        SQLM_FIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_FIELDS_Father:SQLC_FIELDS_Left3 =
                            SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
                        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3 =
                            SQLM_FIELDS_Father;
                        SQLM_FIELDS_Father =
                            SQLM_FIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right3 =
                        SQLM_FIELDS_Father:SQLC_FIELDS_Left3;
                    SQLM_FIELDS_Father:SQLC_FIELDS_Left3 =
                        SQLM_FIELDS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_Father:SQLC_FIELDS_Left3;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3 = 0;
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_Father:SQLC_FIELDS_Right3;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3 = 0;
                SQLM_FIELDS_Father:SQLC_FIELDS_Color3 = 1;
! Relink nodes !
                IF SQLM_FIELDS_GrandGrandFather:SQLC_FIELDS_Right3 =
                    SQLM_FIELDS_GrandFather
                THEN
                    SQLM_FIELDS_GrandGrandFather:SQLC_FIELDS_Right3 =
                        SQLM_FIELDS_Father;
                ELSE
                    SQLM_FIELDS_GrandGrandFather:SQLC_FIELDS_Left3 =
                        SQLM_FIELDS_Father;
                FI;
                SQLM_FIELDS_GrandFather =
                    SQLM_FIELDS_Father;
                SQLM_FIELDS_OperRow =
                    SQLM_FIELDS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey2_3;
! Aftermath !
ENDLOOPtowComInsKeyTableKey2_3)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_FIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_FIELDS_TempRow =
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right3;
    SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey2_4)
! Setup pointers and clear loop counter. !
    SQLM_FIELDS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_FIELDS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_FIELDS_GrandFather=SQLX_GrandFather;
    SQLM_FIELDS_Father=SQLX_Father;
    SQLM_FIELDS_OperRow=SQLX_Current;
    SQLM_FIELDS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_FIELDS_OperRow = SQLM_FIELDS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey2_4;
    FI;
LOOPtowComInsKeyTableKey2_4)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FIELDS_GrandGrandFather,
            SQLM_FIELDS_GrandFather,
            SQLM_FIELDS_Father,
            SQLM_FIELDS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_FIELDS_OperRow = SQLM_FIELDS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey2_4;
! Test key to be inserted against 'root' node. !
    DO SQLS_FIELDS_KeyTest4;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey2_4;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey2_4)
    SQLM_FIELDS_GrandGrandFather = SQLM_FIELDS_GrandFather;
    SQLM_FIELDS_GrandFather = SQLM_FIELDS_Father;
    SQLM_FIELDS_Father = SQLM_FIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FIELDS_OperRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4;
    ELSE
        SQLM_FIELDS_OperRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_FIELDS_TempRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4;
    IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4 = 0 THEN
        SQLM_FIELDS_TempRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4;
        IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4 = 0 THEN
! Top of a 4-node. !
            IF SQLM_FIELDS_OperRow = SQLM_FIELDS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_FIELDS_OperRow=SQLM_FIELDS_WorkRow;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4 = 0;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4  =
                    SQLM_FIELDS_NilRow;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4 =
                    SQLM_FIELDS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_FIELDS_WorkRow = SQLM_FIELDS_Father;
                DO SQLS_FIELDS_KeyTest4;
DISABLE INTERRUPT;
                SQLM_FIELDS_WorkRow = SQLM_FIELDS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_FIELDS_Father:SQLC_FIELDS_Left4 =
                        SQLM_FIELDS_OperRow;
                ELSE
                    SQLM_FIELDS_Father:SQLC_FIELDS_Right4 =
                        SQLM_FIELDS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4 = 1;
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4 = 1;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_FIELDS_Father:SQLC_FIELDS_Color4 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left4 =
                   SQLM_FIELDS_Father
                THEN
                    IF SQLM_FIELDS_Father:SQLC_FIELDS_Right4 =
                       SQLM_FIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_FIELDS_Father:SQLC_FIELDS_Right4 =
                            SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4;
                        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4 =
                            SQLM_FIELDS_Father;
                        SQLM_FIELDS_Father =
                            SQLM_FIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left4 =
                        SQLM_FIELDS_Father:SQLC_FIELDS_Right4;
                    SQLM_FIELDS_Father:SQLC_FIELDS_Right4 =
                        SQLM_FIELDS_GrandFather;
                ELSE
                    IF SQLM_FIELDS_Father:SQLC_FIELDS_Left4 =
                        SQLM_FIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_FIELDS_Father:SQLC_FIELDS_Left4 =
                            SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4;
                        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4 =
                            SQLM_FIELDS_Father;
                        SQLM_FIELDS_Father =
                            SQLM_FIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right4 =
                        SQLM_FIELDS_Father:SQLC_FIELDS_Left4;
                    SQLM_FIELDS_Father:SQLC_FIELDS_Left4 =
                        SQLM_FIELDS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_Father:SQLC_FIELDS_Left4;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4 = 0;
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_Father:SQLC_FIELDS_Right4;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4 = 0;
                SQLM_FIELDS_Father:SQLC_FIELDS_Color4 = 1;
! Relink nodes !
                IF SQLM_FIELDS_GrandGrandFather:SQLC_FIELDS_Right4 =
                    SQLM_FIELDS_GrandFather
                THEN
                    SQLM_FIELDS_GrandGrandFather:SQLC_FIELDS_Right4 =
                        SQLM_FIELDS_Father;
                ELSE
                    SQLM_FIELDS_GrandGrandFather:SQLC_FIELDS_Left4 =
                        SQLM_FIELDS_Father;
                FI;
                SQLM_FIELDS_GrandFather =
                    SQLM_FIELDS_Father;
                SQLM_FIELDS_OperRow =
                    SQLM_FIELDS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey2_4;
! Aftermath !
ENDLOOPtowComInsKeyTableKey2_4)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_FIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_FIELDS_TempRow =
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right4;
    SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey2_5)
! Setup pointers and clear loop counter. !
    SQLM_FIELDS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_FIELDS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_FIELDS_GrandFather=SQLX_GrandFather;
    SQLM_FIELDS_Father=SQLX_Father;
    SQLM_FIELDS_OperRow=SQLX_Current;
    SQLM_FIELDS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_FIELDS_OperRow = SQLM_FIELDS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey2_5;
    FI;
LOOPtowComInsKeyTableKey2_5)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FIELDS_GrandGrandFather,
            SQLM_FIELDS_GrandFather,
            SQLM_FIELDS_Father,
            SQLM_FIELDS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_FIELDS_OperRow = SQLM_FIELDS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey2_5;
! Test key to be inserted against 'root' node. !
    DO SQLS_FIELDS_KeyTest5;
    IF SQLX_KeyTest = 1 THEN
! If key exist, abort. !
        IF SQLM_FIELDS_OperRow = SQLM_FIELDS_WorkRow GOTO ENDLOOPtowComInsKeyTableKey2_5;
        IF SQLM_FIELDS_OperRow > SQLM_FIELDS_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey2_5)
    SQLM_FIELDS_GrandGrandFather = SQLM_FIELDS_GrandFather;
    SQLM_FIELDS_GrandFather = SQLM_FIELDS_Father;
    SQLM_FIELDS_Father = SQLM_FIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FIELDS_OperRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5;
    ELSE
        SQLM_FIELDS_OperRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_FIELDS_TempRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5;
    IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5 = 0 THEN
        SQLM_FIELDS_TempRow = SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5;
        IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5 = 0 THEN
! Top of a 4-node. !
            IF SQLM_FIELDS_OperRow = SQLM_FIELDS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_FIELDS_OperRow=SQLM_FIELDS_WorkRow;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5 = 0;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5  =
                    SQLM_FIELDS_NilRow;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5 =
                    SQLM_FIELDS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_FIELDS_WorkRow = SQLM_FIELDS_Father;
                DO SQLS_FIELDS_KeyTest5;
                IF SQLX_KeyTest = 1 THEN
                    IF SQLM_FIELDS_OperRow > SQLM_FIELDS_WorkRow THEN
                        SQLX_KeyTest = 2;
                    ELSE
                        SQLX_KeyTest = 0;
                    FI;
                FI;
DISABLE INTERRUPT;
                SQLM_FIELDS_WorkRow = SQLM_FIELDS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_FIELDS_Father:SQLC_FIELDS_Left5 =
                        SQLM_FIELDS_OperRow;
                ELSE
                    SQLM_FIELDS_Father:SQLC_FIELDS_Right5 =
                        SQLM_FIELDS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5 = 1;
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5 = 1;
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_FIELDS_Father:SQLC_FIELDS_Color5 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left5 =
                   SQLM_FIELDS_Father
                THEN
                    IF SQLM_FIELDS_Father:SQLC_FIELDS_Right5 =
                       SQLM_FIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_FIELDS_Father:SQLC_FIELDS_Right5 =
                            SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5;
                        SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5 =
                            SQLM_FIELDS_Father;
                        SQLM_FIELDS_Father =
                            SQLM_FIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left5 =
                        SQLM_FIELDS_Father:SQLC_FIELDS_Right5;
                    SQLM_FIELDS_Father:SQLC_FIELDS_Right5 =
                        SQLM_FIELDS_GrandFather;
                ELSE
                    IF SQLM_FIELDS_Father:SQLC_FIELDS_Left5 =
                        SQLM_FIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_FIELDS_Father:SQLC_FIELDS_Left5 =
                            SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5;
                        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5 =
                            SQLM_FIELDS_Father;
                        SQLM_FIELDS_Father =
                            SQLM_FIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right5 =
                        SQLM_FIELDS_Father:SQLC_FIELDS_Left5;
                    SQLM_FIELDS_Father:SQLC_FIELDS_Left5 =
                        SQLM_FIELDS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_Father:SQLC_FIELDS_Left5;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5 = 0;
                SQLM_FIELDS_TempRow =
                    SQLM_FIELDS_Father:SQLC_FIELDS_Right5;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5 = 0;
                SQLM_FIELDS_Father:SQLC_FIELDS_Color5 = 1;
! Relink nodes !
                IF SQLM_FIELDS_GrandGrandFather:SQLC_FIELDS_Right5 =
                    SQLM_FIELDS_GrandFather
                THEN
                    SQLM_FIELDS_GrandGrandFather:SQLC_FIELDS_Right5 =
                        SQLM_FIELDS_Father;
                ELSE
                    SQLM_FIELDS_GrandGrandFather:SQLC_FIELDS_Left5 =
                        SQLM_FIELDS_Father;
                FI;
                SQLM_FIELDS_GrandFather =
                    SQLM_FIELDS_Father;
                SQLM_FIELDS_OperRow =
                    SQLM_FIELDS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey2_5;
! Aftermath !
ENDLOOPtowComInsKeyTableKey2_5)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_FIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_FIELDS_TempRow =
        SQLM_FIELDS_RootRow:SQLC_FIELDS_Right5;
    SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 3 DO
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComInsKeyTableKey3_2;
    WHEN 3 DO GOTO towComInsKeyTableKey3_3;
    WHEN 4 DO GOTO towComInsKeyTableKey3_4;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey3_2)
! Setup pointers and clear loop counter. !
    SQLM_KEYS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_KEYS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_KEYS_GrandFather=SQLX_GrandFather;
    SQLM_KEYS_Father=SQLX_Father;
    SQLM_KEYS_OperRow=SQLX_Current;
    SQLM_KEYS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_KEYS_OperRow = SQLM_KEYS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey3_2;
    FI;
LOOPtowComInsKeyTableKey3_2)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_KEYS_GrandGrandFather,
            SQLM_KEYS_GrandFather,
            SQLM_KEYS_Father,
            SQLM_KEYS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_KEYS_OperRow = SQLM_KEYS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey3_2;
! Test key to be inserted against 'root' node. !
    DO SQLS_KEYS_KeyTest2;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey3_2;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey3_2)
    SQLM_KEYS_GrandGrandFather = SQLM_KEYS_GrandFather;
    SQLM_KEYS_GrandFather = SQLM_KEYS_Father;
    SQLM_KEYS_Father = SQLM_KEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_KEYS_OperRow = SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
    ELSE
        SQLM_KEYS_OperRow = SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_KEYS_TempRow = SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
    IF SQLM_KEYS_TempRow:SQLC_KEYS_Color2 = 0 THEN
        SQLM_KEYS_TempRow = SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
        IF SQLM_KEYS_TempRow:SQLC_KEYS_Color2 = 0 THEN
! Top of a 4-node. !
            IF SQLM_KEYS_OperRow = SQLM_KEYS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_KEYS_OperRow=SQLM_KEYS_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_KEYS_TempRow =
    SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
SQLM_KEYS_TempRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
SQLM_KEYS_TempRow =
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;

IF SQLM_KEYS_TempRow /= SQLM_KEYS_NilRow THEN
    SQLM_KEYS_TempRow:SQLC_KEYS_Right2 =
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
FI;
                SQLM_KEYS_OperRow:SQLC_KEYS_Color2 = 0;
                SQLM_KEYS_OperRow:SQLC_KEYS_Left2  =
                    SQLM_KEYS_NilRow;
                SQLM_KEYS_OperRow:SQLC_KEYS_Right2 =
                    SQLM_KEYS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_KEYS_WorkRow = SQLM_KEYS_Father;
                DO SQLS_KEYS_KeyTest2;
DISABLE INTERRUPT;
                SQLM_KEYS_WorkRow = SQLM_KEYS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_KEYS_Father:SQLC_KEYS_Left2 =
                        SQLM_KEYS_OperRow;
                ELSE
                    SQLM_KEYS_Father:SQLC_KEYS_Right2 =
                        SQLM_KEYS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color2 = 1;
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color2 = 1;
                SQLM_KEYS_OperRow:SQLC_KEYS_Color2 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_KEYS_Father:SQLC_KEYS_Color2 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left2 =
                   SQLM_KEYS_Father
                THEN
                    IF SQLM_KEYS_Father:SQLC_KEYS_Right2 =
                       SQLM_KEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_KEYS_Father:SQLC_KEYS_Right2 =
                            SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
                        SQLM_KEYS_OperRow:SQLC_KEYS_Left2 =
                            SQLM_KEYS_Father;
                        SQLM_KEYS_Father =
                            SQLM_KEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_KEYS_GrandFather:SQLC_KEYS_Left2 =
                        SQLM_KEYS_Father:SQLC_KEYS_Right2;
                    SQLM_KEYS_Father:SQLC_KEYS_Right2 =
                        SQLM_KEYS_GrandFather;
                ELSE
                    IF SQLM_KEYS_Father:SQLC_KEYS_Left2 =
                        SQLM_KEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_KEYS_Father:SQLC_KEYS_Left2 =
                            SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
                        SQLM_KEYS_OperRow:SQLC_KEYS_Right2 =
                            SQLM_KEYS_Father;
                        SQLM_KEYS_Father =
                            SQLM_KEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_KEYS_GrandFather:SQLC_KEYS_Right2 =
                        SQLM_KEYS_Father:SQLC_KEYS_Left2;
                    SQLM_KEYS_Father:SQLC_KEYS_Left2 =
                        SQLM_KEYS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_Father:SQLC_KEYS_Left2;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color2 = 0;
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_Father:SQLC_KEYS_Right2;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color2 = 0;
                SQLM_KEYS_Father:SQLC_KEYS_Color2 = 1;
! Relink nodes !
                IF SQLM_KEYS_GrandGrandFather:SQLC_KEYS_Right2 =
                    SQLM_KEYS_GrandFather
                THEN
                    SQLM_KEYS_GrandGrandFather:SQLC_KEYS_Right2 =
                        SQLM_KEYS_Father;
                ELSE
                    SQLM_KEYS_GrandGrandFather:SQLC_KEYS_Left2 =
                        SQLM_KEYS_Father;
                FI;
                SQLM_KEYS_GrandFather =
                    SQLM_KEYS_Father;
                SQLM_KEYS_OperRow =
                    SQLM_KEYS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey3_2;
! Aftermath !
ENDLOOPtowComInsKeyTableKey3_2)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_KEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_KEYS_TempRow =
        SQLM_KEYS_RootRow:SQLC_KEYS_Right2;
    SQLM_KEYS_TempRow:SQLC_KEYS_Color2 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey3_3)
! Setup pointers and clear loop counter. !
    SQLM_KEYS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_KEYS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_KEYS_GrandFather=SQLX_GrandFather;
    SQLM_KEYS_Father=SQLX_Father;
    SQLM_KEYS_OperRow=SQLX_Current;
    SQLM_KEYS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_KEYS_OperRow = SQLM_KEYS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey3_3;
    FI;
LOOPtowComInsKeyTableKey3_3)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_KEYS_GrandGrandFather,
            SQLM_KEYS_GrandFather,
            SQLM_KEYS_Father,
            SQLM_KEYS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_KEYS_OperRow = SQLM_KEYS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey3_3;
! Test key to be inserted against 'root' node. !
    DO SQLS_KEYS_KeyTest3;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey3_3;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey3_3)
    SQLM_KEYS_GrandGrandFather = SQLM_KEYS_GrandFather;
    SQLM_KEYS_GrandFather = SQLM_KEYS_Father;
    SQLM_KEYS_Father = SQLM_KEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_KEYS_OperRow = SQLM_KEYS_OperRow:SQLC_KEYS_Left3;
    ELSE
        SQLM_KEYS_OperRow = SQLM_KEYS_OperRow:SQLC_KEYS_Right3;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_KEYS_TempRow = SQLM_KEYS_OperRow:SQLC_KEYS_Left3;
    IF SQLM_KEYS_TempRow:SQLC_KEYS_Color3 = 0 THEN
        SQLM_KEYS_TempRow = SQLM_KEYS_OperRow:SQLC_KEYS_Right3;
        IF SQLM_KEYS_TempRow:SQLC_KEYS_Color3 = 0 THEN
! Top of a 4-node. !
            IF SQLM_KEYS_OperRow = SQLM_KEYS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_KEYS_OperRow=SQLM_KEYS_WorkRow;
                SQLM_KEYS_OperRow:SQLC_KEYS_Color3 = 0;
                SQLM_KEYS_OperRow:SQLC_KEYS_Left3  =
                    SQLM_KEYS_NilRow;
                SQLM_KEYS_OperRow:SQLC_KEYS_Right3 =
                    SQLM_KEYS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_KEYS_WorkRow = SQLM_KEYS_Father;
                DO SQLS_KEYS_KeyTest3;
DISABLE INTERRUPT;
                SQLM_KEYS_WorkRow = SQLM_KEYS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_KEYS_Father:SQLC_KEYS_Left3 =
                        SQLM_KEYS_OperRow;
                ELSE
                    SQLM_KEYS_Father:SQLC_KEYS_Right3 =
                        SQLM_KEYS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_OperRow:SQLC_KEYS_Left3;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color3 = 1;
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_OperRow:SQLC_KEYS_Right3;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color3 = 1;
                SQLM_KEYS_OperRow:SQLC_KEYS_Color3 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_KEYS_Father:SQLC_KEYS_Color3 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left3 =
                   SQLM_KEYS_Father
                THEN
                    IF SQLM_KEYS_Father:SQLC_KEYS_Right3 =
                       SQLM_KEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_KEYS_Father:SQLC_KEYS_Right3 =
                            SQLM_KEYS_OperRow:SQLC_KEYS_Left3;
                        SQLM_KEYS_OperRow:SQLC_KEYS_Left3 =
                            SQLM_KEYS_Father;
                        SQLM_KEYS_Father =
                            SQLM_KEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_KEYS_GrandFather:SQLC_KEYS_Left3 =
                        SQLM_KEYS_Father:SQLC_KEYS_Right3;
                    SQLM_KEYS_Father:SQLC_KEYS_Right3 =
                        SQLM_KEYS_GrandFather;
                ELSE
                    IF SQLM_KEYS_Father:SQLC_KEYS_Left3 =
                        SQLM_KEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_KEYS_Father:SQLC_KEYS_Left3 =
                            SQLM_KEYS_OperRow:SQLC_KEYS_Right3;
                        SQLM_KEYS_OperRow:SQLC_KEYS_Right3 =
                            SQLM_KEYS_Father;
                        SQLM_KEYS_Father =
                            SQLM_KEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_KEYS_GrandFather:SQLC_KEYS_Right3 =
                        SQLM_KEYS_Father:SQLC_KEYS_Left3;
                    SQLM_KEYS_Father:SQLC_KEYS_Left3 =
                        SQLM_KEYS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_Father:SQLC_KEYS_Left3;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color3 = 0;
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_Father:SQLC_KEYS_Right3;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color3 = 0;
                SQLM_KEYS_Father:SQLC_KEYS_Color3 = 1;
! Relink nodes !
                IF SQLM_KEYS_GrandGrandFather:SQLC_KEYS_Right3 =
                    SQLM_KEYS_GrandFather
                THEN
                    SQLM_KEYS_GrandGrandFather:SQLC_KEYS_Right3 =
                        SQLM_KEYS_Father;
                ELSE
                    SQLM_KEYS_GrandGrandFather:SQLC_KEYS_Left3 =
                        SQLM_KEYS_Father;
                FI;
                SQLM_KEYS_GrandFather =
                    SQLM_KEYS_Father;
                SQLM_KEYS_OperRow =
                    SQLM_KEYS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey3_3;
! Aftermath !
ENDLOOPtowComInsKeyTableKey3_3)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_KEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_KEYS_TempRow =
        SQLM_KEYS_RootRow:SQLC_KEYS_Right3;
    SQLM_KEYS_TempRow:SQLC_KEYS_Color3 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey3_4)
! Setup pointers and clear loop counter. !
    SQLM_KEYS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_KEYS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_KEYS_GrandFather=SQLX_GrandFather;
    SQLM_KEYS_Father=SQLX_Father;
    SQLM_KEYS_OperRow=SQLX_Current;
    SQLM_KEYS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_KEYS_OperRow = SQLM_KEYS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey3_4;
    FI;
LOOPtowComInsKeyTableKey3_4)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_KEYS_GrandGrandFather,
            SQLM_KEYS_GrandFather,
            SQLM_KEYS_Father,
            SQLM_KEYS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_KEYS_OperRow = SQLM_KEYS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey3_4;
! Test key to be inserted against 'root' node. !
    DO SQLS_KEYS_KeyTest4;
    IF SQLX_KeyTest = 1 THEN
! If key exist, abort. !
        IF SQLM_KEYS_OperRow = SQLM_KEYS_WorkRow GOTO ENDLOOPtowComInsKeyTableKey3_4;
        IF SQLM_KEYS_OperRow > SQLM_KEYS_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey3_4)
    SQLM_KEYS_GrandGrandFather = SQLM_KEYS_GrandFather;
    SQLM_KEYS_GrandFather = SQLM_KEYS_Father;
    SQLM_KEYS_Father = SQLM_KEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_KEYS_OperRow = SQLM_KEYS_OperRow:SQLC_KEYS_Left4;
    ELSE
        SQLM_KEYS_OperRow = SQLM_KEYS_OperRow:SQLC_KEYS_Right4;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_KEYS_TempRow = SQLM_KEYS_OperRow:SQLC_KEYS_Left4;
    IF SQLM_KEYS_TempRow:SQLC_KEYS_Color4 = 0 THEN
        SQLM_KEYS_TempRow = SQLM_KEYS_OperRow:SQLC_KEYS_Right4;
        IF SQLM_KEYS_TempRow:SQLC_KEYS_Color4 = 0 THEN
! Top of a 4-node. !
            IF SQLM_KEYS_OperRow = SQLM_KEYS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_KEYS_OperRow=SQLM_KEYS_WorkRow;
                SQLM_KEYS_OperRow:SQLC_KEYS_Color4 = 0;
                SQLM_KEYS_OperRow:SQLC_KEYS_Left4  =
                    SQLM_KEYS_NilRow;
                SQLM_KEYS_OperRow:SQLC_KEYS_Right4 =
                    SQLM_KEYS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_KEYS_WorkRow = SQLM_KEYS_Father;
                DO SQLS_KEYS_KeyTest4;
                IF SQLX_KeyTest = 1 THEN
                    IF SQLM_KEYS_OperRow > SQLM_KEYS_WorkRow THEN
                        SQLX_KeyTest = 2;
                    ELSE
                        SQLX_KeyTest = 0;
                    FI;
                FI;
DISABLE INTERRUPT;
                SQLM_KEYS_WorkRow = SQLM_KEYS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_KEYS_Father:SQLC_KEYS_Left4 =
                        SQLM_KEYS_OperRow;
                ELSE
                    SQLM_KEYS_Father:SQLC_KEYS_Right4 =
                        SQLM_KEYS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_OperRow:SQLC_KEYS_Left4;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color4 = 1;
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_OperRow:SQLC_KEYS_Right4;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color4 = 1;
                SQLM_KEYS_OperRow:SQLC_KEYS_Color4 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_KEYS_Father:SQLC_KEYS_Color4 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left4 =
                   SQLM_KEYS_Father
                THEN
                    IF SQLM_KEYS_Father:SQLC_KEYS_Right4 =
                       SQLM_KEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_KEYS_Father:SQLC_KEYS_Right4 =
                            SQLM_KEYS_OperRow:SQLC_KEYS_Left4;
                        SQLM_KEYS_OperRow:SQLC_KEYS_Left4 =
                            SQLM_KEYS_Father;
                        SQLM_KEYS_Father =
                            SQLM_KEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_KEYS_GrandFather:SQLC_KEYS_Left4 =
                        SQLM_KEYS_Father:SQLC_KEYS_Right4;
                    SQLM_KEYS_Father:SQLC_KEYS_Right4 =
                        SQLM_KEYS_GrandFather;
                ELSE
                    IF SQLM_KEYS_Father:SQLC_KEYS_Left4 =
                        SQLM_KEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_KEYS_Father:SQLC_KEYS_Left4 =
                            SQLM_KEYS_OperRow:SQLC_KEYS_Right4;
                        SQLM_KEYS_OperRow:SQLC_KEYS_Right4 =
                            SQLM_KEYS_Father;
                        SQLM_KEYS_Father =
                            SQLM_KEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_KEYS_GrandFather:SQLC_KEYS_Right4 =
                        SQLM_KEYS_Father:SQLC_KEYS_Left4;
                    SQLM_KEYS_Father:SQLC_KEYS_Left4 =
                        SQLM_KEYS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_Father:SQLC_KEYS_Left4;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color4 = 0;
                SQLM_KEYS_TempRow =
                    SQLM_KEYS_Father:SQLC_KEYS_Right4;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color4 = 0;
                SQLM_KEYS_Father:SQLC_KEYS_Color4 = 1;
! Relink nodes !
                IF SQLM_KEYS_GrandGrandFather:SQLC_KEYS_Right4 =
                    SQLM_KEYS_GrandFather
                THEN
                    SQLM_KEYS_GrandGrandFather:SQLC_KEYS_Right4 =
                        SQLM_KEYS_Father;
                ELSE
                    SQLM_KEYS_GrandGrandFather:SQLC_KEYS_Left4 =
                        SQLM_KEYS_Father;
                FI;
                SQLM_KEYS_GrandFather =
                    SQLM_KEYS_Father;
                SQLM_KEYS_OperRow =
                    SQLM_KEYS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey3_4;
! Aftermath !
ENDLOOPtowComInsKeyTableKey3_4)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_KEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_KEYS_TempRow =
        SQLM_KEYS_RootRow:SQLC_KEYS_Right4;
    SQLM_KEYS_TempRow:SQLC_KEYS_Color4 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 4 DO
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComInsKeyTableKey4_2;
    WHEN 3 DO GOTO towComInsKeyTableKey4_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey4_2)
! Setup pointers and clear loop counter. !
    SQLM_KEYFIELDS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_KEYFIELDS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_KEYFIELDS_GrandFather=SQLX_GrandFather;
    SQLM_KEYFIELDS_Father=SQLX_Father;
    SQLM_KEYFIELDS_OperRow=SQLX_Current;
    SQLM_KEYFIELDS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey4_2;
    FI;
LOOPtowComInsKeyTableKey4_2)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_KEYFIELDS_GrandGrandFather,
            SQLM_KEYFIELDS_GrandFather,
            SQLM_KEYFIELDS_Father,
            SQLM_KEYFIELDS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey4_2;
! Test key to be inserted against 'root' node. !
    DO SQLS_KEYFIELDS_KeyTest2;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey4_2;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey4_2)
    SQLM_KEYFIELDS_GrandGrandFather = SQLM_KEYFIELDS_GrandFather;
    SQLM_KEYFIELDS_GrandFather = SQLM_KEYFIELDS_Father;
    SQLM_KEYFIELDS_Father = SQLM_KEYFIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
    ELSE
        SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_KEYFIELDS_TempRow = SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
    IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2 = 0 THEN
        SQLM_KEYFIELDS_TempRow = SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
        IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2 = 0 THEN
! Top of a 4-node. !
            IF SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_KEYFIELDS_OperRow=SQLM_KEYFIELDS_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;

IF SQLM_KEYFIELDS_TempRow /= SQLM_KEYFIELDS_NilRow THEN
    SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Right2 =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
FI;
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2 = 0;
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2  =
                    SQLM_KEYFIELDS_NilRow;
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2 =
                    SQLM_KEYFIELDS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_KEYFIELDS_WorkRow = SQLM_KEYFIELDS_Father;
                DO SQLS_KEYFIELDS_KeyTest2;
DISABLE INTERRUPT;
                SQLM_KEYFIELDS_WorkRow = SQLM_KEYFIELDS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2 =
                        SQLM_KEYFIELDS_OperRow;
                ELSE
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2 =
                        SQLM_KEYFIELDS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_KEYFIELDS_TempRow =
                    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2 = 1;
                SQLM_KEYFIELDS_TempRow =
                    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2 = 1;
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color2 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left2 =
                   SQLM_KEYFIELDS_Father
                THEN
                    IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2 =
                       SQLM_KEYFIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2 =
                            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
                        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2 =
                            SQLM_KEYFIELDS_Father;
                        SQLM_KEYFIELDS_Father =
                            SQLM_KEYFIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left2 =
                        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2;
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2 =
                        SQLM_KEYFIELDS_GrandFather;
                ELSE
                    IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2 =
                        SQLM_KEYFIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2 =
                            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
                        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2 =
                            SQLM_KEYFIELDS_Father;
                        SQLM_KEYFIELDS_Father =
                            SQLM_KEYFIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Right2 =
                        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2;
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2 =
                        SQLM_KEYFIELDS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_KEYFIELDS_TempRow =
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2 = 0;
                SQLM_KEYFIELDS_TempRow =
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2 = 0;
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color2 = 1;
! Relink nodes !
                IF SQLM_KEYFIELDS_GrandGrandFather:SQLC_KEYFIELDS_Right2 =
                    SQLM_KEYFIELDS_GrandFather
                THEN
                    SQLM_KEYFIELDS_GrandGrandFather:SQLC_KEYFIELDS_Right2 =
                        SQLM_KEYFIELDS_Father;
                ELSE
                    SQLM_KEYFIELDS_GrandGrandFather:SQLC_KEYFIELDS_Left2 =
                        SQLM_KEYFIELDS_Father;
                FI;
                SQLM_KEYFIELDS_GrandFather =
                    SQLM_KEYFIELDS_Father;
                SQLM_KEYFIELDS_OperRow =
                    SQLM_KEYFIELDS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey4_2;
! Aftermath !
ENDLOOPtowComInsKeyTableKey4_2)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_KEYFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_KEYFIELDS_TempRow =
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right2;
    SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey4_3)
! Setup pointers and clear loop counter. !
    SQLM_KEYFIELDS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_KEYFIELDS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_KEYFIELDS_GrandFather=SQLX_GrandFather;
    SQLM_KEYFIELDS_Father=SQLX_Father;
    SQLM_KEYFIELDS_OperRow=SQLX_Current;
    SQLM_KEYFIELDS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey4_3;
    FI;
LOOPtowComInsKeyTableKey4_3)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_KEYFIELDS_GrandGrandFather,
            SQLM_KEYFIELDS_GrandFather,
            SQLM_KEYFIELDS_Father,
            SQLM_KEYFIELDS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey4_3;
! Test key to be inserted against 'root' node. !
    DO SQLS_KEYFIELDS_KeyTest3;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey4_3;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey4_3)
    SQLM_KEYFIELDS_GrandGrandFather = SQLM_KEYFIELDS_GrandFather;
    SQLM_KEYFIELDS_GrandFather = SQLM_KEYFIELDS_Father;
    SQLM_KEYFIELDS_Father = SQLM_KEYFIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3;
    ELSE
        SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_KEYFIELDS_TempRow = SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3;
    IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3 = 0 THEN
        SQLM_KEYFIELDS_TempRow = SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3;
        IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3 = 0 THEN
! Top of a 4-node. !
            IF SQLM_KEYFIELDS_OperRow = SQLM_KEYFIELDS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_KEYFIELDS_OperRow=SQLM_KEYFIELDS_WorkRow;
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3 = 0;
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3  =
                    SQLM_KEYFIELDS_NilRow;
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3 =
                    SQLM_KEYFIELDS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_KEYFIELDS_WorkRow = SQLM_KEYFIELDS_Father;
                DO SQLS_KEYFIELDS_KeyTest3;
DISABLE INTERRUPT;
                SQLM_KEYFIELDS_WorkRow = SQLM_KEYFIELDS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3 =
                        SQLM_KEYFIELDS_OperRow;
                ELSE
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3 =
                        SQLM_KEYFIELDS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_KEYFIELDS_TempRow =
                    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3 = 1;
                SQLM_KEYFIELDS_TempRow =
                    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3 = 1;
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color3 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left3 =
                   SQLM_KEYFIELDS_Father
                THEN
                    IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3 =
                       SQLM_KEYFIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3 =
                            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3;
                        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3 =
                            SQLM_KEYFIELDS_Father;
                        SQLM_KEYFIELDS_Father =
                            SQLM_KEYFIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left3 =
                        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3;
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3 =
                        SQLM_KEYFIELDS_GrandFather;
                ELSE
                    IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3 =
                        SQLM_KEYFIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3 =
                            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3;
                        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3 =
                            SQLM_KEYFIELDS_Father;
                        SQLM_KEYFIELDS_Father =
                            SQLM_KEYFIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Right3 =
                        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3;
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3 =
                        SQLM_KEYFIELDS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_KEYFIELDS_TempRow =
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3 = 0;
                SQLM_KEYFIELDS_TempRow =
                    SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3 = 0;
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color3 = 1;
! Relink nodes !
                IF SQLM_KEYFIELDS_GrandGrandFather:SQLC_KEYFIELDS_Right3 =
                    SQLM_KEYFIELDS_GrandFather
                THEN
                    SQLM_KEYFIELDS_GrandGrandFather:SQLC_KEYFIELDS_Right3 =
                        SQLM_KEYFIELDS_Father;
                ELSE
                    SQLM_KEYFIELDS_GrandGrandFather:SQLC_KEYFIELDS_Left3 =
                        SQLM_KEYFIELDS_Father;
                FI;
                SQLM_KEYFIELDS_GrandFather =
                    SQLM_KEYFIELDS_Father;
                SQLM_KEYFIELDS_OperRow =
                    SQLM_KEYFIELDS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey4_3;
! Aftermath !
ENDLOOPtowComInsKeyTableKey4_3)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_KEYFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_KEYFIELDS_TempRow =
        SQLM_KEYFIELDS_RootRow:SQLC_KEYFIELDS_Right3;
    SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 5 DO
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComInsKeyTableKey5_2;
    WHEN 3 DO GOTO towComInsKeyTableKey5_3;
    WHEN 4 DO GOTO towComInsKeyTableKey5_4;
    WHEN 5 DO GOTO towComInsKeyTableKey5_5;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey5_2)
! Setup pointers and clear loop counter. !
    SQLM_FOREIGNKEYS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_FOREIGNKEYS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_FOREIGNKEYS_GrandFather=SQLX_GrandFather;
    SQLM_FOREIGNKEYS_Father=SQLX_Father;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Current;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey5_2;
    FI;
LOOPtowComInsKeyTableKey5_2)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FOREIGNKEYS_GrandGrandFather,
            SQLM_FOREIGNKEYS_GrandFather,
            SQLM_FOREIGNKEYS_Father,
            SQLM_FOREIGNKEYS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey5_2;
! Test key to be inserted against 'root' node. !
    DO SQLS_FOREIGNKEYS_KeyTest2;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey5_2;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey5_2)
    SQLM_FOREIGNKEYS_GrandGrandFather = SQLM_FOREIGNKEYS_GrandFather;
    SQLM_FOREIGNKEYS_GrandFather = SQLM_FOREIGNKEYS_Father;
    SQLM_FOREIGNKEYS_Father = SQLM_FOREIGNKEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
    ELSE
        SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_FOREIGNKEYS_TempRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
    IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2 = 0 THEN
        SQLM_FOREIGNKEYS_TempRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
        IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2 = 0 THEN
! Top of a 4-node. !
            IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_FOREIGNKEYS_OperRow=SQLM_FOREIGNKEYS_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;

IF SQLM_FOREIGNKEYS_TempRow /= SQLM_FOREIGNKEYS_NilRow THEN
    SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Right2 =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
FI;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2 = 0;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2  =
                    SQLM_FOREIGNKEYS_NilRow;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2 =
                    SQLM_FOREIGNKEYS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_FOREIGNKEYS_WorkRow = SQLM_FOREIGNKEYS_Father;
                DO SQLS_FOREIGNKEYS_KeyTest2;
DISABLE INTERRUPT;
                SQLM_FOREIGNKEYS_WorkRow = SQLM_FOREIGNKEYS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2 =
                        SQLM_FOREIGNKEYS_OperRow;
                ELSE
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2 =
                        SQLM_FOREIGNKEYS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2 = 1;
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2 = 1;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color2 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left2 =
                   SQLM_FOREIGNKEYS_Father
                THEN
                    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2 =
                       SQLM_FOREIGNKEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2 =
                            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
                        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2 =
                            SQLM_FOREIGNKEYS_Father;
                        SQLM_FOREIGNKEYS_Father =
                            SQLM_FOREIGNKEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left2 =
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2;
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2 =
                        SQLM_FOREIGNKEYS_GrandFather;
                ELSE
                    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2 =
                        SQLM_FOREIGNKEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2 =
                            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
                        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2 =
                            SQLM_FOREIGNKEYS_Father;
                        SQLM_FOREIGNKEYS_Father =
                            SQLM_FOREIGNKEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right2 =
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2;
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2 =
                        SQLM_FOREIGNKEYS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2 = 0;
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2 = 0;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color2 = 1;
! Relink nodes !
                IF SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Right2 =
                    SQLM_FOREIGNKEYS_GrandFather
                THEN
                    SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Right2 =
                        SQLM_FOREIGNKEYS_Father;
                ELSE
                    SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Left2 =
                        SQLM_FOREIGNKEYS_Father;
                FI;
                SQLM_FOREIGNKEYS_GrandFather =
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_OperRow =
                    SQLM_FOREIGNKEYS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey5_2;
! Aftermath !
ENDLOOPtowComInsKeyTableKey5_2)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_TempRow =
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right2;
    SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey5_3)
! Setup pointers and clear loop counter. !
    SQLM_FOREIGNKEYS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_FOREIGNKEYS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_FOREIGNKEYS_GrandFather=SQLX_GrandFather;
    SQLM_FOREIGNKEYS_Father=SQLX_Father;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Current;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey5_3;
    FI;
LOOPtowComInsKeyTableKey5_3)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FOREIGNKEYS_GrandGrandFather,
            SQLM_FOREIGNKEYS_GrandFather,
            SQLM_FOREIGNKEYS_Father,
            SQLM_FOREIGNKEYS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey5_3;
! Test key to be inserted against 'root' node. !
    DO SQLS_FOREIGNKEYS_KeyTest3;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey5_3;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey5_3)
    SQLM_FOREIGNKEYS_GrandGrandFather = SQLM_FOREIGNKEYS_GrandFather;
    SQLM_FOREIGNKEYS_GrandFather = SQLM_FOREIGNKEYS_Father;
    SQLM_FOREIGNKEYS_Father = SQLM_FOREIGNKEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3;
    ELSE
        SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_FOREIGNKEYS_TempRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3;
    IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3 = 0 THEN
        SQLM_FOREIGNKEYS_TempRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3;
        IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3 = 0 THEN
! Top of a 4-node. !
            IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_FOREIGNKEYS_OperRow=SQLM_FOREIGNKEYS_WorkRow;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3 = 0;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3  =
                    SQLM_FOREIGNKEYS_NilRow;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3 =
                    SQLM_FOREIGNKEYS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_FOREIGNKEYS_WorkRow = SQLM_FOREIGNKEYS_Father;
                DO SQLS_FOREIGNKEYS_KeyTest3;
DISABLE INTERRUPT;
                SQLM_FOREIGNKEYS_WorkRow = SQLM_FOREIGNKEYS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3 =
                        SQLM_FOREIGNKEYS_OperRow;
                ELSE
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3 =
                        SQLM_FOREIGNKEYS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3 = 1;
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3 = 1;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color3 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left3 =
                   SQLM_FOREIGNKEYS_Father
                THEN
                    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3 =
                       SQLM_FOREIGNKEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3 =
                            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3;
                        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3 =
                            SQLM_FOREIGNKEYS_Father;
                        SQLM_FOREIGNKEYS_Father =
                            SQLM_FOREIGNKEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left3 =
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3;
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3 =
                        SQLM_FOREIGNKEYS_GrandFather;
                ELSE
                    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3 =
                        SQLM_FOREIGNKEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3 =
                            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3;
                        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3 =
                            SQLM_FOREIGNKEYS_Father;
                        SQLM_FOREIGNKEYS_Father =
                            SQLM_FOREIGNKEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right3 =
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3;
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3 =
                        SQLM_FOREIGNKEYS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3 = 0;
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3 = 0;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color3 = 1;
! Relink nodes !
                IF SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Right3 =
                    SQLM_FOREIGNKEYS_GrandFather
                THEN
                    SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Right3 =
                        SQLM_FOREIGNKEYS_Father;
                ELSE
                    SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Left3 =
                        SQLM_FOREIGNKEYS_Father;
                FI;
                SQLM_FOREIGNKEYS_GrandFather =
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_OperRow =
                    SQLM_FOREIGNKEYS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey5_3;
! Aftermath !
ENDLOOPtowComInsKeyTableKey5_3)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_TempRow =
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right3;
    SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey5_4)
! Setup pointers and clear loop counter. !
    SQLM_FOREIGNKEYS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_FOREIGNKEYS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_FOREIGNKEYS_GrandFather=SQLX_GrandFather;
    SQLM_FOREIGNKEYS_Father=SQLX_Father;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Current;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey5_4;
    FI;
LOOPtowComInsKeyTableKey5_4)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FOREIGNKEYS_GrandGrandFather,
            SQLM_FOREIGNKEYS_GrandFather,
            SQLM_FOREIGNKEYS_Father,
            SQLM_FOREIGNKEYS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey5_4;
! Test key to be inserted against 'root' node. !
    DO SQLS_FOREIGNKEYS_KeyTest4;
    IF SQLX_KeyTest = 1 THEN
! If key exist, abort. !
        IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_WorkRow GOTO ENDLOOPtowComInsKeyTableKey5_4;
        IF SQLM_FOREIGNKEYS_OperRow > SQLM_FOREIGNKEYS_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey5_4)
    SQLM_FOREIGNKEYS_GrandGrandFather = SQLM_FOREIGNKEYS_GrandFather;
    SQLM_FOREIGNKEYS_GrandFather = SQLM_FOREIGNKEYS_Father;
    SQLM_FOREIGNKEYS_Father = SQLM_FOREIGNKEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4;
    ELSE
        SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_FOREIGNKEYS_TempRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4;
    IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4 = 0 THEN
        SQLM_FOREIGNKEYS_TempRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4;
        IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4 = 0 THEN
! Top of a 4-node. !
            IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_FOREIGNKEYS_OperRow=SQLM_FOREIGNKEYS_WorkRow;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4 = 0;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4  =
                    SQLM_FOREIGNKEYS_NilRow;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4 =
                    SQLM_FOREIGNKEYS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_FOREIGNKEYS_WorkRow = SQLM_FOREIGNKEYS_Father;
                DO SQLS_FOREIGNKEYS_KeyTest4;
                IF SQLX_KeyTest = 1 THEN
                    IF SQLM_FOREIGNKEYS_OperRow > SQLM_FOREIGNKEYS_WorkRow THEN
                        SQLX_KeyTest = 2;
                    ELSE
                        SQLX_KeyTest = 0;
                    FI;
                FI;
DISABLE INTERRUPT;
                SQLM_FOREIGNKEYS_WorkRow = SQLM_FOREIGNKEYS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4 =
                        SQLM_FOREIGNKEYS_OperRow;
                ELSE
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4 =
                        SQLM_FOREIGNKEYS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4 = 1;
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4 = 1;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color4 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left4 =
                   SQLM_FOREIGNKEYS_Father
                THEN
                    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4 =
                       SQLM_FOREIGNKEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4 =
                            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4;
                        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4 =
                            SQLM_FOREIGNKEYS_Father;
                        SQLM_FOREIGNKEYS_Father =
                            SQLM_FOREIGNKEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left4 =
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4;
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4 =
                        SQLM_FOREIGNKEYS_GrandFather;
                ELSE
                    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4 =
                        SQLM_FOREIGNKEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4 =
                            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4;
                        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4 =
                            SQLM_FOREIGNKEYS_Father;
                        SQLM_FOREIGNKEYS_Father =
                            SQLM_FOREIGNKEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right4 =
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4;
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4 =
                        SQLM_FOREIGNKEYS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4 = 0;
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4 = 0;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color4 = 1;
! Relink nodes !
                IF SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Right4 =
                    SQLM_FOREIGNKEYS_GrandFather
                THEN
                    SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Right4 =
                        SQLM_FOREIGNKEYS_Father;
                ELSE
                    SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Left4 =
                        SQLM_FOREIGNKEYS_Father;
                FI;
                SQLM_FOREIGNKEYS_GrandFather =
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_OperRow =
                    SQLM_FOREIGNKEYS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey5_4;
! Aftermath !
ENDLOOPtowComInsKeyTableKey5_4)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_TempRow =
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right4;
    SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey5_5)
! Setup pointers and clear loop counter. !
    SQLM_FOREIGNKEYS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_FOREIGNKEYS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_FOREIGNKEYS_GrandFather=SQLX_GrandFather;
    SQLM_FOREIGNKEYS_Father=SQLX_Father;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Current;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey5_5;
    FI;
LOOPtowComInsKeyTableKey5_5)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FOREIGNKEYS_GrandGrandFather,
            SQLM_FOREIGNKEYS_GrandFather,
            SQLM_FOREIGNKEYS_Father,
            SQLM_FOREIGNKEYS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey5_5;
! Test key to be inserted against 'root' node. !
    DO SQLS_FOREIGNKEYS_KeyTest5;
    IF SQLX_KeyTest = 1 THEN
! If key exist, abort. !
        IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_WorkRow GOTO ENDLOOPtowComInsKeyTableKey5_5;
        IF SQLM_FOREIGNKEYS_OperRow > SQLM_FOREIGNKEYS_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey5_5)
    SQLM_FOREIGNKEYS_GrandGrandFather = SQLM_FOREIGNKEYS_GrandFather;
    SQLM_FOREIGNKEYS_GrandFather = SQLM_FOREIGNKEYS_Father;
    SQLM_FOREIGNKEYS_Father = SQLM_FOREIGNKEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5;
    ELSE
        SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_FOREIGNKEYS_TempRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5;
    IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5 = 0 THEN
        SQLM_FOREIGNKEYS_TempRow = SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5;
        IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5 = 0 THEN
! Top of a 4-node. !
            IF SQLM_FOREIGNKEYS_OperRow = SQLM_FOREIGNKEYS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_FOREIGNKEYS_OperRow=SQLM_FOREIGNKEYS_WorkRow;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5 = 0;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5  =
                    SQLM_FOREIGNKEYS_NilRow;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5 =
                    SQLM_FOREIGNKEYS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_FOREIGNKEYS_WorkRow = SQLM_FOREIGNKEYS_Father;
                DO SQLS_FOREIGNKEYS_KeyTest5;
                IF SQLX_KeyTest = 1 THEN
                    IF SQLM_FOREIGNKEYS_OperRow > SQLM_FOREIGNKEYS_WorkRow THEN
                        SQLX_KeyTest = 2;
                    ELSE
                        SQLX_KeyTest = 0;
                    FI;
                FI;
DISABLE INTERRUPT;
                SQLM_FOREIGNKEYS_WorkRow = SQLM_FOREIGNKEYS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5 =
                        SQLM_FOREIGNKEYS_OperRow;
                ELSE
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5 =
                        SQLM_FOREIGNKEYS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5 = 1;
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5 = 1;
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color5 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left5 =
                   SQLM_FOREIGNKEYS_Father
                THEN
                    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5 =
                       SQLM_FOREIGNKEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5 =
                            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5;
                        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5 =
                            SQLM_FOREIGNKEYS_Father;
                        SQLM_FOREIGNKEYS_Father =
                            SQLM_FOREIGNKEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left5 =
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5;
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5 =
                        SQLM_FOREIGNKEYS_GrandFather;
                ELSE
                    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5 =
                        SQLM_FOREIGNKEYS_OperRow
                    THEN
! Double rotation !
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5 =
                            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5;
                        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5 =
                            SQLM_FOREIGNKEYS_Father;
                        SQLM_FOREIGNKEYS_Father =
                            SQLM_FOREIGNKEYS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right5 =
                        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5;
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5 =
                        SQLM_FOREIGNKEYS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5 = 0;
                SQLM_FOREIGNKEYS_TempRow =
                    SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5 = 0;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color5 = 1;
! Relink nodes !
                IF SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Right5 =
                    SQLM_FOREIGNKEYS_GrandFather
                THEN
                    SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Right5 =
                        SQLM_FOREIGNKEYS_Father;
                ELSE
                    SQLM_FOREIGNKEYS_GrandGrandFather:SQLC_FOREIGNKEYS_Left5 =
                        SQLM_FOREIGNKEYS_Father;
                FI;
                SQLM_FOREIGNKEYS_GrandFather =
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_OperRow =
                    SQLM_FOREIGNKEYS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey5_5;
! Aftermath !
ENDLOOPtowComInsKeyTableKey5_5)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_FOREIGNKEYS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_FOREIGNKEYS_TempRow =
        SQLM_FOREIGNKEYS_RootRow:SQLC_FOREIGNKEYS_Right5;
    SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 6 DO
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComInsKeyTableKey6_2;
    WHEN 3 DO GOTO towComInsKeyTableKey6_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey6_2)
! Setup pointers and clear loop counter. !
    SQLM_SYMBOLS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_SYMBOLS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_SYMBOLS_GrandFather=SQLX_GrandFather;
    SQLM_SYMBOLS_Father=SQLX_Father;
    SQLM_SYMBOLS_OperRow=SQLX_Current;
    SQLM_SYMBOLS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey6_2;
    FI;
LOOPtowComInsKeyTableKey6_2)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_SYMBOLS_GrandGrandFather,
            SQLM_SYMBOLS_GrandFather,
            SQLM_SYMBOLS_Father,
            SQLM_SYMBOLS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey6_2;
! Test key to be inserted against 'root' node. !
    DO SQLS_SYMBOLS_KeyTest2;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey6_2;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey6_2)
    SQLM_SYMBOLS_GrandGrandFather = SQLM_SYMBOLS_GrandFather;
    SQLM_SYMBOLS_GrandFather = SQLM_SYMBOLS_Father;
    SQLM_SYMBOLS_Father = SQLM_SYMBOLS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
    ELSE
        SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_SYMBOLS_TempRow = SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
    IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2 = 0 THEN
        SQLM_SYMBOLS_TempRow = SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
        IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2 = 0 THEN
! Top of a 4-node. !
            IF SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_SYMBOLS_OperRow=SQLM_SYMBOLS_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;

IF SQLM_SYMBOLS_TempRow /= SQLM_SYMBOLS_NilRow THEN
    SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Right2 =
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
FI;
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2 = 0;
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2  =
                    SQLM_SYMBOLS_NilRow;
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2 =
                    SQLM_SYMBOLS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_SYMBOLS_WorkRow = SQLM_SYMBOLS_Father;
                DO SQLS_SYMBOLS_KeyTest2;
DISABLE INTERRUPT;
                SQLM_SYMBOLS_WorkRow = SQLM_SYMBOLS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2 =
                        SQLM_SYMBOLS_OperRow;
                ELSE
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2 =
                        SQLM_SYMBOLS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_SYMBOLS_TempRow =
                    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2 = 1;
                SQLM_SYMBOLS_TempRow =
                    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2 = 1;
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color2 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left2 =
                   SQLM_SYMBOLS_Father
                THEN
                    IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2 =
                       SQLM_SYMBOLS_OperRow
                    THEN
! Double rotation !
                        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2 =
                            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
                        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2 =
                            SQLM_SYMBOLS_Father;
                        SQLM_SYMBOLS_Father =
                            SQLM_SYMBOLS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left2 =
                        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2;
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2 =
                        SQLM_SYMBOLS_GrandFather;
                ELSE
                    IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2 =
                        SQLM_SYMBOLS_OperRow
                    THEN
! Double rotation !
                        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2 =
                            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
                        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2 =
                            SQLM_SYMBOLS_Father;
                        SQLM_SYMBOLS_Father =
                            SQLM_SYMBOLS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Right2 =
                        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2;
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2 =
                        SQLM_SYMBOLS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_SYMBOLS_TempRow =
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2 = 0;
                SQLM_SYMBOLS_TempRow =
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2 = 0;
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color2 = 1;
! Relink nodes !
                IF SQLM_SYMBOLS_GrandGrandFather:SQLC_SYMBOLS_Right2 =
                    SQLM_SYMBOLS_GrandFather
                THEN
                    SQLM_SYMBOLS_GrandGrandFather:SQLC_SYMBOLS_Right2 =
                        SQLM_SYMBOLS_Father;
                ELSE
                    SQLM_SYMBOLS_GrandGrandFather:SQLC_SYMBOLS_Left2 =
                        SQLM_SYMBOLS_Father;
                FI;
                SQLM_SYMBOLS_GrandFather =
                    SQLM_SYMBOLS_Father;
                SQLM_SYMBOLS_OperRow =
                    SQLM_SYMBOLS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey6_2;
! Aftermath !
ENDLOOPtowComInsKeyTableKey6_2)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_SYMBOLS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_SYMBOLS_TempRow =
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right2;
    SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey6_3)
! Setup pointers and clear loop counter. !
    SQLM_SYMBOLS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_SYMBOLS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_SYMBOLS_GrandFather=SQLX_GrandFather;
    SQLM_SYMBOLS_Father=SQLX_Father;
    SQLM_SYMBOLS_OperRow=SQLX_Current;
    SQLM_SYMBOLS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey6_3;
    FI;
LOOPtowComInsKeyTableKey6_3)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_SYMBOLS_GrandGrandFather,
            SQLM_SYMBOLS_GrandFather,
            SQLM_SYMBOLS_Father,
            SQLM_SYMBOLS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey6_3;
! Test key to be inserted against 'root' node. !
    DO SQLS_SYMBOLS_KeyTest3;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey6_3;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey6_3)
    SQLM_SYMBOLS_GrandGrandFather = SQLM_SYMBOLS_GrandFather;
    SQLM_SYMBOLS_GrandFather = SQLM_SYMBOLS_Father;
    SQLM_SYMBOLS_Father = SQLM_SYMBOLS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3;
    ELSE
        SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_SYMBOLS_TempRow = SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3;
    IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3 = 0 THEN
        SQLM_SYMBOLS_TempRow = SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3;
        IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3 = 0 THEN
! Top of a 4-node. !
            IF SQLM_SYMBOLS_OperRow = SQLM_SYMBOLS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_SYMBOLS_OperRow=SQLM_SYMBOLS_WorkRow;
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3 = 0;
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3  =
                    SQLM_SYMBOLS_NilRow;
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3 =
                    SQLM_SYMBOLS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_SYMBOLS_WorkRow = SQLM_SYMBOLS_Father;
                DO SQLS_SYMBOLS_KeyTest3;
DISABLE INTERRUPT;
                SQLM_SYMBOLS_WorkRow = SQLM_SYMBOLS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3 =
                        SQLM_SYMBOLS_OperRow;
                ELSE
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3 =
                        SQLM_SYMBOLS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_SYMBOLS_TempRow =
                    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3 = 1;
                SQLM_SYMBOLS_TempRow =
                    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3 = 1;
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color3 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left3 =
                   SQLM_SYMBOLS_Father
                THEN
                    IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3 =
                       SQLM_SYMBOLS_OperRow
                    THEN
! Double rotation !
                        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3 =
                            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3;
                        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3 =
                            SQLM_SYMBOLS_Father;
                        SQLM_SYMBOLS_Father =
                            SQLM_SYMBOLS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left3 =
                        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3;
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3 =
                        SQLM_SYMBOLS_GrandFather;
                ELSE
                    IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3 =
                        SQLM_SYMBOLS_OperRow
                    THEN
! Double rotation !
                        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3 =
                            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3;
                        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3 =
                            SQLM_SYMBOLS_Father;
                        SQLM_SYMBOLS_Father =
                            SQLM_SYMBOLS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Right3 =
                        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3;
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3 =
                        SQLM_SYMBOLS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_SYMBOLS_TempRow =
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3 = 0;
                SQLM_SYMBOLS_TempRow =
                    SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3 = 0;
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color3 = 1;
! Relink nodes !
                IF SQLM_SYMBOLS_GrandGrandFather:SQLC_SYMBOLS_Right3 =
                    SQLM_SYMBOLS_GrandFather
                THEN
                    SQLM_SYMBOLS_GrandGrandFather:SQLC_SYMBOLS_Right3 =
                        SQLM_SYMBOLS_Father;
                ELSE
                    SQLM_SYMBOLS_GrandGrandFather:SQLC_SYMBOLS_Left3 =
                        SQLM_SYMBOLS_Father;
                FI;
                SQLM_SYMBOLS_GrandFather =
                    SQLM_SYMBOLS_Father;
                SQLM_SYMBOLS_OperRow =
                    SQLM_SYMBOLS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey6_3;
! Aftermath !
ENDLOOPtowComInsKeyTableKey6_3)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_SYMBOLS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_SYMBOLS_TempRow =
        SQLM_SYMBOLS_RootRow:SQLC_SYMBOLS_Right3;
    SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 7 DO
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
! Setup pointers and clear loop counter. !
    SQLM_TOWFAULTCODES_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_TOWFAULTCODES_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_TOWFAULTCODES_GrandFather=SQLX_GrandFather;
    SQLM_TOWFAULTCODES_Father=SQLX_Father;
    SQLM_TOWFAULTCODES_OperRow=SQLX_Current;
    SQLM_TOWFAULTCODES_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_TOWFAULTCODES_OperRow = SQLM_TOWFAULTCODES_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey7_2;
    FI;
LOOPtowComInsKeyTableKey7_2)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TOWFAULTCODES_GrandGrandFather,
            SQLM_TOWFAULTCODES_GrandFather,
            SQLM_TOWFAULTCODES_Father,
            SQLM_TOWFAULTCODES_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_TOWFAULTCODES_OperRow = SQLM_TOWFAULTCODES_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey7_2;
! Test key to be inserted against 'root' node. !
    DO SQLS_TOWFAULTCODES_KeyTest2;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey7_2;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey7_2)
    SQLM_TOWFAULTCODES_GrandGrandFather = SQLM_TOWFAULTCODES_GrandFather;
    SQLM_TOWFAULTCODES_GrandFather = SQLM_TOWFAULTCODES_Father;
    SQLM_TOWFAULTCODES_Father = SQLM_TOWFAULTCODES_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TOWFAULTCODES_OperRow = SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
    ELSE
        SQLM_TOWFAULTCODES_OperRow = SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_TOWFAULTCODES_TempRow = SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
    IF SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2 = 0 THEN
        SQLM_TOWFAULTCODES_TempRow = SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
        IF SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2 = 0 THEN
! Top of a 4-node. !
            IF SQLM_TOWFAULTCODES_OperRow = SQLM_TOWFAULTCODES_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_TOWFAULTCODES_OperRow=SQLM_TOWFAULTCODES_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TOWFAULTCODES_TempRow =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Left2 =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
SQLM_TOWFAULTCODES_TempRow =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;

IF SQLM_TOWFAULTCODES_TempRow /= SQLM_TOWFAULTCODES_NilRow THEN
    SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Right2 =
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
FI;
                SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2 = 0;
                SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2  =
                    SQLM_TOWFAULTCODES_NilRow;
                SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2 =
                    SQLM_TOWFAULTCODES_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_TOWFAULTCODES_WorkRow = SQLM_TOWFAULTCODES_Father;
                DO SQLS_TOWFAULTCODES_KeyTest2;
DISABLE INTERRUPT;
                SQLM_TOWFAULTCODES_WorkRow = SQLM_TOWFAULTCODES_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2 =
                        SQLM_TOWFAULTCODES_OperRow;
                ELSE
                    SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2 =
                        SQLM_TOWFAULTCODES_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_TOWFAULTCODES_TempRow =
                    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
                SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2 = 1;
                SQLM_TOWFAULTCODES_TempRow =
                    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
                SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2 = 1;
                SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Color2 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Left2 =
                   SQLM_TOWFAULTCODES_Father
                THEN
                    IF SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2 =
                       SQLM_TOWFAULTCODES_OperRow
                    THEN
! Double rotation !
                        SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2 =
                            SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
                        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2 =
                            SQLM_TOWFAULTCODES_Father;
                        SQLM_TOWFAULTCODES_Father =
                            SQLM_TOWFAULTCODES_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Left2 =
                        SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2;
                    SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2 =
                        SQLM_TOWFAULTCODES_GrandFather;
                ELSE
                    IF SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2 =
                        SQLM_TOWFAULTCODES_OperRow
                    THEN
! Double rotation !
                        SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2 =
                            SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
                        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2 =
                            SQLM_TOWFAULTCODES_Father;
                        SQLM_TOWFAULTCODES_Father =
                            SQLM_TOWFAULTCODES_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Right2 =
                        SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2;
                    SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2 =
                        SQLM_TOWFAULTCODES_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_TOWFAULTCODES_TempRow =
                    SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2;
                SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2 = 0;
                SQLM_TOWFAULTCODES_TempRow =
                    SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2;
                SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2 = 0;
                SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Color2 = 1;
! Relink nodes !
                IF SQLM_TOWFAULTCODES_GrandGrandFather:SQLC_TOWFAULTCODES_Right2 =
                    SQLM_TOWFAULTCODES_GrandFather
                THEN
                    SQLM_TOWFAULTCODES_GrandGrandFather:SQLC_TOWFAULTCODES_Right2 =
                        SQLM_TOWFAULTCODES_Father;
                ELSE
                    SQLM_TOWFAULTCODES_GrandGrandFather:SQLC_TOWFAULTCODES_Left2 =
                        SQLM_TOWFAULTCODES_Father;
                FI;
                SQLM_TOWFAULTCODES_GrandFather =
                    SQLM_TOWFAULTCODES_Father;
                SQLM_TOWFAULTCODES_OperRow =
                    SQLM_TOWFAULTCODES_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey7_2;
! Aftermath !
ENDLOOPtowComInsKeyTableKey7_2)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_TOWFAULTCODES_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_TOWFAULTCODES_TempRow =
        SQLM_TOWFAULTCODES_RootRow:SQLC_TOWFAULTCODES_Right2;
    SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 8 DO
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
! Setup pointers and clear loop counter. !
    SQLM_SYSFAULTCODES_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_SYSFAULTCODES_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_SYSFAULTCODES_GrandFather=SQLX_GrandFather;
    SQLM_SYSFAULTCODES_Father=SQLX_Father;
    SQLM_SYSFAULTCODES_OperRow=SQLX_Current;
    SQLM_SYSFAULTCODES_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_SYSFAULTCODES_OperRow = SQLM_SYSFAULTCODES_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey8_2;
    FI;
LOOPtowComInsKeyTableKey8_2)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_SYSFAULTCODES_GrandGrandFather,
            SQLM_SYSFAULTCODES_GrandFather,
            SQLM_SYSFAULTCODES_Father,
            SQLM_SYSFAULTCODES_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_SYSFAULTCODES_OperRow = SQLM_SYSFAULTCODES_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey8_2;
! Test key to be inserted against 'root' node. !
    DO SQLS_SYSFAULTCODES_KeyTest2;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey8_2;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey8_2)
    SQLM_SYSFAULTCODES_GrandGrandFather = SQLM_SYSFAULTCODES_GrandFather;
    SQLM_SYSFAULTCODES_GrandFather = SQLM_SYSFAULTCODES_Father;
    SQLM_SYSFAULTCODES_Father = SQLM_SYSFAULTCODES_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_SYSFAULTCODES_OperRow = SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
    ELSE
        SQLM_SYSFAULTCODES_OperRow = SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_SYSFAULTCODES_TempRow = SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
    IF SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2 = 0 THEN
        SQLM_SYSFAULTCODES_TempRow = SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
        IF SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2 = 0 THEN
! Top of a 4-node. !
            IF SQLM_SYSFAULTCODES_OperRow = SQLM_SYSFAULTCODES_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_SYSFAULTCODES_OperRow=SQLM_SYSFAULTCODES_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYSFAULTCODES_TempRow =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Left2 =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
SQLM_SYSFAULTCODES_TempRow =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;

IF SQLM_SYSFAULTCODES_TempRow /= SQLM_SYSFAULTCODES_NilRow THEN
    SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Right2 =
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
FI;
                SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2 = 0;
                SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2  =
                    SQLM_SYSFAULTCODES_NilRow;
                SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2 =
                    SQLM_SYSFAULTCODES_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_SYSFAULTCODES_WorkRow = SQLM_SYSFAULTCODES_Father;
                DO SQLS_SYSFAULTCODES_KeyTest2;
DISABLE INTERRUPT;
                SQLM_SYSFAULTCODES_WorkRow = SQLM_SYSFAULTCODES_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2 =
                        SQLM_SYSFAULTCODES_OperRow;
                ELSE
                    SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2 =
                        SQLM_SYSFAULTCODES_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_SYSFAULTCODES_TempRow =
                    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
                SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2 = 1;
                SQLM_SYSFAULTCODES_TempRow =
                    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
                SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2 = 1;
                SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Color2 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Left2 =
                   SQLM_SYSFAULTCODES_Father
                THEN
                    IF SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2 =
                       SQLM_SYSFAULTCODES_OperRow
                    THEN
! Double rotation !
                        SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2 =
                            SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
                        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2 =
                            SQLM_SYSFAULTCODES_Father;
                        SQLM_SYSFAULTCODES_Father =
                            SQLM_SYSFAULTCODES_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Left2 =
                        SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2;
                    SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2 =
                        SQLM_SYSFAULTCODES_GrandFather;
                ELSE
                    IF SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2 =
                        SQLM_SYSFAULTCODES_OperRow
                    THEN
! Double rotation !
                        SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2 =
                            SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
                        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2 =
                            SQLM_SYSFAULTCODES_Father;
                        SQLM_SYSFAULTCODES_Father =
                            SQLM_SYSFAULTCODES_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Right2 =
                        SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2;
                    SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2 =
                        SQLM_SYSFAULTCODES_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_SYSFAULTCODES_TempRow =
                    SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2;
                SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2 = 0;
                SQLM_SYSFAULTCODES_TempRow =
                    SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2;
                SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2 = 0;
                SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Color2 = 1;
! Relink nodes !
                IF SQLM_SYSFAULTCODES_GrandGrandFather:SQLC_SYSFAULTCODES_Right2 =
                    SQLM_SYSFAULTCODES_GrandFather
                THEN
                    SQLM_SYSFAULTCODES_GrandGrandFather:SQLC_SYSFAULTCODES_Right2 =
                        SQLM_SYSFAULTCODES_Father;
                ELSE
                    SQLM_SYSFAULTCODES_GrandGrandFather:SQLC_SYSFAULTCODES_Left2 =
                        SQLM_SYSFAULTCODES_Father;
                FI;
                SQLM_SYSFAULTCODES_GrandFather =
                    SQLM_SYSFAULTCODES_Father;
                SQLM_SYSFAULTCODES_OperRow =
                    SQLM_SYSFAULTCODES_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey8_2;
! Aftermath !
ENDLOOPtowComInsKeyTableKey8_2)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_SYSFAULTCODES_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_SYSFAULTCODES_TempRow =
        SQLM_SYSFAULTCODES_RootRow:SQLC_SYSFAULTCODES_Right2;
    SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 9 DO
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComInsKeyTableKey9_2;
    WHEN 3 DO GOTO towComInsKeyTableKey9_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey9_2)
! Setup pointers and clear loop counter. !
    SQLM_SYSTEMFIELDS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_SYSTEMFIELDS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_SYSTEMFIELDS_GrandFather=SQLX_GrandFather;
    SQLM_SYSTEMFIELDS_Father=SQLX_Father;
    SQLM_SYSTEMFIELDS_OperRow=SQLX_Current;
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey9_2;
    FI;
LOOPtowComInsKeyTableKey9_2)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_SYSTEMFIELDS_GrandGrandFather,
            SQLM_SYSTEMFIELDS_GrandFather,
            SQLM_SYSTEMFIELDS_Father,
            SQLM_SYSTEMFIELDS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey9_2;
! Test key to be inserted against 'root' node. !
    DO SQLS_SYSTEMFIELDS_KeyTest2;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey9_2;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey9_2)
    SQLM_SYSTEMFIELDS_GrandGrandFather = SQLM_SYSTEMFIELDS_GrandFather;
    SQLM_SYSTEMFIELDS_GrandFather = SQLM_SYSTEMFIELDS_Father;
    SQLM_SYSTEMFIELDS_Father = SQLM_SYSTEMFIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
    ELSE
        SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_SYSTEMFIELDS_TempRow = SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
    IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2 = 0 THEN
        SQLM_SYSTEMFIELDS_TempRow = SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
        IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2 = 0 THEN
! Top of a 4-node. !
            IF SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_SYSTEMFIELDS_OperRow=SQLM_SYSTEMFIELDS_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYSTEMFIELDS_TempRow =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Left2 =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
SQLM_SYSTEMFIELDS_TempRow =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;

IF SQLM_SYSTEMFIELDS_TempRow /= SQLM_SYSTEMFIELDS_NilRow THEN
    SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Right2 =
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
FI;
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2 = 0;
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2  =
                    SQLM_SYSTEMFIELDS_NilRow;
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2 =
                    SQLM_SYSTEMFIELDS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_SYSTEMFIELDS_WorkRow = SQLM_SYSTEMFIELDS_Father;
                DO SQLS_SYSTEMFIELDS_KeyTest2;
DISABLE INTERRUPT;
                SQLM_SYSTEMFIELDS_WorkRow = SQLM_SYSTEMFIELDS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2 =
                        SQLM_SYSTEMFIELDS_OperRow;
                ELSE
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2 =
                        SQLM_SYSTEMFIELDS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_SYSTEMFIELDS_TempRow =
                    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2 = 1;
                SQLM_SYSTEMFIELDS_TempRow =
                    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2 = 1;
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color2 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left2 =
                   SQLM_SYSTEMFIELDS_Father
                THEN
                    IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2 =
                       SQLM_SYSTEMFIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2 =
                            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
                        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2 =
                            SQLM_SYSTEMFIELDS_Father;
                        SQLM_SYSTEMFIELDS_Father =
                            SQLM_SYSTEMFIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left2 =
                        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2;
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2 =
                        SQLM_SYSTEMFIELDS_GrandFather;
                ELSE
                    IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2 =
                        SQLM_SYSTEMFIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2 =
                            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
                        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2 =
                            SQLM_SYSTEMFIELDS_Father;
                        SQLM_SYSTEMFIELDS_Father =
                            SQLM_SYSTEMFIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Right2 =
                        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2;
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2 =
                        SQLM_SYSTEMFIELDS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_SYSTEMFIELDS_TempRow =
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2 = 0;
                SQLM_SYSTEMFIELDS_TempRow =
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2 = 0;
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color2 = 1;
! Relink nodes !
                IF SQLM_SYSTEMFIELDS_GrandGrandFather:SQLC_SYSTEMFIELDS_Right2 =
                    SQLM_SYSTEMFIELDS_GrandFather
                THEN
                    SQLM_SYSTEMFIELDS_GrandGrandFather:SQLC_SYSTEMFIELDS_Right2 =
                        SQLM_SYSTEMFIELDS_Father;
                ELSE
                    SQLM_SYSTEMFIELDS_GrandGrandFather:SQLC_SYSTEMFIELDS_Left2 =
                        SQLM_SYSTEMFIELDS_Father;
                FI;
                SQLM_SYSTEMFIELDS_GrandFather =
                    SQLM_SYSTEMFIELDS_Father;
                SQLM_SYSTEMFIELDS_OperRow =
                    SQLM_SYSTEMFIELDS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey9_2;
! Aftermath !
ENDLOOPtowComInsKeyTableKey9_2)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_SYSTEMFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_SYSTEMFIELDS_TempRow =
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right2;
    SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey9_3)
! Setup pointers and clear loop counter. !
    SQLM_SYSTEMFIELDS_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_SYSTEMFIELDS_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_SYSTEMFIELDS_GrandFather=SQLX_GrandFather;
    SQLM_SYSTEMFIELDS_Father=SQLX_Father;
    SQLM_SYSTEMFIELDS_OperRow=SQLX_Current;
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey9_3;
    FI;
LOOPtowComInsKeyTableKey9_3)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_SYSTEMFIELDS_GrandGrandFather,
            SQLM_SYSTEMFIELDS_GrandFather,
            SQLM_SYSTEMFIELDS_Father,
            SQLM_SYSTEMFIELDS_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey9_3;
! Test key to be inserted against 'root' node. !
    DO SQLS_SYSTEMFIELDS_KeyTest3;
    IF SQLX_KeyTest = 1 THEN
! If key exist, abort. !
        IF SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_WorkRow GOTO ENDLOOPtowComInsKeyTableKey9_3;
        IF SQLM_SYSTEMFIELDS_OperRow > SQLM_SYSTEMFIELDS_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey9_3)
    SQLM_SYSTEMFIELDS_GrandGrandFather = SQLM_SYSTEMFIELDS_GrandFather;
    SQLM_SYSTEMFIELDS_GrandFather = SQLM_SYSTEMFIELDS_Father;
    SQLM_SYSTEMFIELDS_Father = SQLM_SYSTEMFIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3;
    ELSE
        SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_SYSTEMFIELDS_TempRow = SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3;
    IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3 = 0 THEN
        SQLM_SYSTEMFIELDS_TempRow = SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3;
        IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3 = 0 THEN
! Top of a 4-node. !
            IF SQLM_SYSTEMFIELDS_OperRow = SQLM_SYSTEMFIELDS_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_SYSTEMFIELDS_OperRow=SQLM_SYSTEMFIELDS_WorkRow;
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3 = 0;
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3  =
                    SQLM_SYSTEMFIELDS_NilRow;
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3 =
                    SQLM_SYSTEMFIELDS_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_SYSTEMFIELDS_WorkRow = SQLM_SYSTEMFIELDS_Father;
                DO SQLS_SYSTEMFIELDS_KeyTest3;
                IF SQLX_KeyTest = 1 THEN
                    IF SQLM_SYSTEMFIELDS_OperRow > SQLM_SYSTEMFIELDS_WorkRow THEN
                        SQLX_KeyTest = 2;
                    ELSE
                        SQLX_KeyTest = 0;
                    FI;
                FI;
DISABLE INTERRUPT;
                SQLM_SYSTEMFIELDS_WorkRow = SQLM_SYSTEMFIELDS_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3 =
                        SQLM_SYSTEMFIELDS_OperRow;
                ELSE
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3 =
                        SQLM_SYSTEMFIELDS_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_SYSTEMFIELDS_TempRow =
                    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3 = 1;
                SQLM_SYSTEMFIELDS_TempRow =
                    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3 = 1;
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color3 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left3 =
                   SQLM_SYSTEMFIELDS_Father
                THEN
                    IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3 =
                       SQLM_SYSTEMFIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3 =
                            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3;
                        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3 =
                            SQLM_SYSTEMFIELDS_Father;
                        SQLM_SYSTEMFIELDS_Father =
                            SQLM_SYSTEMFIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left3 =
                        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3;
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3 =
                        SQLM_SYSTEMFIELDS_GrandFather;
                ELSE
                    IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3 =
                        SQLM_SYSTEMFIELDS_OperRow
                    THEN
! Double rotation !
                        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3 =
                            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3;
                        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3 =
                            SQLM_SYSTEMFIELDS_Father;
                        SQLM_SYSTEMFIELDS_Father =
                            SQLM_SYSTEMFIELDS_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Right3 =
                        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3;
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3 =
                        SQLM_SYSTEMFIELDS_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_SYSTEMFIELDS_TempRow =
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3 = 0;
                SQLM_SYSTEMFIELDS_TempRow =
                    SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3 = 0;
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color3 = 1;
! Relink nodes !
                IF SQLM_SYSTEMFIELDS_GrandGrandFather:SQLC_SYSTEMFIELDS_Right3 =
                    SQLM_SYSTEMFIELDS_GrandFather
                THEN
                    SQLM_SYSTEMFIELDS_GrandGrandFather:SQLC_SYSTEMFIELDS_Right3 =
                        SQLM_SYSTEMFIELDS_Father;
                ELSE
                    SQLM_SYSTEMFIELDS_GrandGrandFather:SQLC_SYSTEMFIELDS_Left3 =
                        SQLM_SYSTEMFIELDS_Father;
                FI;
                SQLM_SYSTEMFIELDS_GrandFather =
                    SQLM_SYSTEMFIELDS_Father;
                SQLM_SYSTEMFIELDS_OperRow =
                    SQLM_SYSTEMFIELDS_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey9_3;
! Aftermath !
ENDLOOPtowComInsKeyTableKey9_3)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_SYSTEMFIELDS_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_SYSTEMFIELDS_TempRow =
        SQLM_SYSTEMFIELDS_RootRow:SQLC_SYSTEMFIELDS_Right3;
    SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 10 DO
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComInsKeyTableKey10_2;
    WHEN 3 DO GOTO towComInsKeyTableKey10_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey10_2)
! Setup pointers and clear loop counter. !
    SQLM_TEST1_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_TEST1_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_TEST1_GrandFather=SQLX_GrandFather;
    SQLM_TEST1_Father=SQLX_Father;
    SQLM_TEST1_OperRow=SQLX_Current;
    SQLM_TEST1_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_TEST1_OperRow = SQLM_TEST1_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey10_2;
    FI;
LOOPtowComInsKeyTableKey10_2)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TEST1_GrandGrandFather,
            SQLM_TEST1_GrandFather,
            SQLM_TEST1_Father,
            SQLM_TEST1_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_TEST1_OperRow = SQLM_TEST1_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey10_2;
! Test key to be inserted against 'root' node. !
    DO SQLS_TEST1_KeyTest2;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey10_2;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey10_2)
    SQLM_TEST1_GrandGrandFather = SQLM_TEST1_GrandFather;
    SQLM_TEST1_GrandFather = SQLM_TEST1_Father;
    SQLM_TEST1_Father = SQLM_TEST1_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TEST1_OperRow = SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
    ELSE
        SQLM_TEST1_OperRow = SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_TEST1_TempRow = SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
    IF SQLM_TEST1_TempRow:SQLC_TEST1_Color2 = 0 THEN
        SQLM_TEST1_TempRow = SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
        IF SQLM_TEST1_TempRow:SQLC_TEST1_Color2 = 0 THEN
! Top of a 4-node. !
            IF SQLM_TEST1_OperRow = SQLM_TEST1_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_TEST1_OperRow=SQLM_TEST1_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TEST1_TempRow =
    SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
SQLM_TEST1_TempRow:SQLC_TEST1_Left2 =
    SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
SQLM_TEST1_TempRow =
    SQLM_TEST1_OperRow:SQLC_TEST1_Left2;

IF SQLM_TEST1_TempRow /= SQLM_TEST1_NilRow THEN
    SQLM_TEST1_TempRow:SQLC_TEST1_Right2 =
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
FI;
                SQLM_TEST1_OperRow:SQLC_TEST1_Color2 = 0;
                SQLM_TEST1_OperRow:SQLC_TEST1_Left2  =
                    SQLM_TEST1_NilRow;
                SQLM_TEST1_OperRow:SQLC_TEST1_Right2 =
                    SQLM_TEST1_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_TEST1_WorkRow = SQLM_TEST1_Father;
                DO SQLS_TEST1_KeyTest2;
DISABLE INTERRUPT;
                SQLM_TEST1_WorkRow = SQLM_TEST1_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_TEST1_Father:SQLC_TEST1_Left2 =
                        SQLM_TEST1_OperRow;
                ELSE
                    SQLM_TEST1_Father:SQLC_TEST1_Right2 =
                        SQLM_TEST1_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_TEST1_TempRow =
                    SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color2 = 1;
                SQLM_TEST1_TempRow =
                    SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color2 = 1;
                SQLM_TEST1_OperRow:SQLC_TEST1_Color2 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_TEST1_Father:SQLC_TEST1_Color2 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_TEST1_GrandFather:SQLC_TEST1_Left2 =
                   SQLM_TEST1_Father
                THEN
                    IF SQLM_TEST1_Father:SQLC_TEST1_Right2 =
                       SQLM_TEST1_OperRow
                    THEN
! Double rotation !
                        SQLM_TEST1_Father:SQLC_TEST1_Right2 =
                            SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
                        SQLM_TEST1_OperRow:SQLC_TEST1_Left2 =
                            SQLM_TEST1_Father;
                        SQLM_TEST1_Father =
                            SQLM_TEST1_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TEST1_GrandFather:SQLC_TEST1_Left2 =
                        SQLM_TEST1_Father:SQLC_TEST1_Right2;
                    SQLM_TEST1_Father:SQLC_TEST1_Right2 =
                        SQLM_TEST1_GrandFather;
                ELSE
                    IF SQLM_TEST1_Father:SQLC_TEST1_Left2 =
                        SQLM_TEST1_OperRow
                    THEN
! Double rotation !
                        SQLM_TEST1_Father:SQLC_TEST1_Left2 =
                            SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
                        SQLM_TEST1_OperRow:SQLC_TEST1_Right2 =
                            SQLM_TEST1_Father;
                        SQLM_TEST1_Father =
                            SQLM_TEST1_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TEST1_GrandFather:SQLC_TEST1_Right2 =
                        SQLM_TEST1_Father:SQLC_TEST1_Left2;
                    SQLM_TEST1_Father:SQLC_TEST1_Left2 =
                        SQLM_TEST1_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_TEST1_TempRow =
                    SQLM_TEST1_Father:SQLC_TEST1_Left2;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color2 = 0;
                SQLM_TEST1_TempRow =
                    SQLM_TEST1_Father:SQLC_TEST1_Right2;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color2 = 0;
                SQLM_TEST1_Father:SQLC_TEST1_Color2 = 1;
! Relink nodes !
                IF SQLM_TEST1_GrandGrandFather:SQLC_TEST1_Right2 =
                    SQLM_TEST1_GrandFather
                THEN
                    SQLM_TEST1_GrandGrandFather:SQLC_TEST1_Right2 =
                        SQLM_TEST1_Father;
                ELSE
                    SQLM_TEST1_GrandGrandFather:SQLC_TEST1_Left2 =
                        SQLM_TEST1_Father;
                FI;
                SQLM_TEST1_GrandFather =
                    SQLM_TEST1_Father;
                SQLM_TEST1_OperRow =
                    SQLM_TEST1_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey10_2;
! Aftermath !
ENDLOOPtowComInsKeyTableKey10_2)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_TEST1_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_TEST1_TempRow =
        SQLM_TEST1_RootRow:SQLC_TEST1_Right2;
    SQLM_TEST1_TempRow:SQLC_TEST1_Color2 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey10_3)
! Setup pointers and clear loop counter. !
    SQLM_TEST1_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_TEST1_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_TEST1_GrandFather=SQLX_GrandFather;
    SQLM_TEST1_Father=SQLX_Father;
    SQLM_TEST1_OperRow=SQLX_Current;
    SQLM_TEST1_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_TEST1_OperRow = SQLM_TEST1_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey10_3;
    FI;
LOOPtowComInsKeyTableKey10_3)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TEST1_GrandGrandFather,
            SQLM_TEST1_GrandFather,
            SQLM_TEST1_Father,
            SQLM_TEST1_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_TEST1_OperRow = SQLM_TEST1_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey10_3;
! Test key to be inserted against 'root' node. !
    DO SQLS_TEST1_KeyTest3;
    IF SQLX_KeyTest = 1 THEN
! If key exist, abort. !
        IF SQLM_TEST1_OperRow = SQLM_TEST1_WorkRow GOTO ENDLOOPtowComInsKeyTableKey10_3;
        IF SQLM_TEST1_OperRow > SQLM_TEST1_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey10_3)
    SQLM_TEST1_GrandGrandFather = SQLM_TEST1_GrandFather;
    SQLM_TEST1_GrandFather = SQLM_TEST1_Father;
    SQLM_TEST1_Father = SQLM_TEST1_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TEST1_OperRow = SQLM_TEST1_OperRow:SQLC_TEST1_Left3;
    ELSE
        SQLM_TEST1_OperRow = SQLM_TEST1_OperRow:SQLC_TEST1_Right3;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_TEST1_TempRow = SQLM_TEST1_OperRow:SQLC_TEST1_Left3;
    IF SQLM_TEST1_TempRow:SQLC_TEST1_Color3 = 0 THEN
        SQLM_TEST1_TempRow = SQLM_TEST1_OperRow:SQLC_TEST1_Right3;
        IF SQLM_TEST1_TempRow:SQLC_TEST1_Color3 = 0 THEN
! Top of a 4-node. !
            IF SQLM_TEST1_OperRow = SQLM_TEST1_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_TEST1_OperRow=SQLM_TEST1_WorkRow;
                SQLM_TEST1_OperRow:SQLC_TEST1_Color3 = 0;
                SQLM_TEST1_OperRow:SQLC_TEST1_Left3  =
                    SQLM_TEST1_NilRow;
                SQLM_TEST1_OperRow:SQLC_TEST1_Right3 =
                    SQLM_TEST1_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_TEST1_WorkRow = SQLM_TEST1_Father;
                DO SQLS_TEST1_KeyTest3;
                IF SQLX_KeyTest = 1 THEN
                    IF SQLM_TEST1_OperRow > SQLM_TEST1_WorkRow THEN
                        SQLX_KeyTest = 2;
                    ELSE
                        SQLX_KeyTest = 0;
                    FI;
                FI;
DISABLE INTERRUPT;
                SQLM_TEST1_WorkRow = SQLM_TEST1_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_TEST1_Father:SQLC_TEST1_Left3 =
                        SQLM_TEST1_OperRow;
                ELSE
                    SQLM_TEST1_Father:SQLC_TEST1_Right3 =
                        SQLM_TEST1_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_TEST1_TempRow =
                    SQLM_TEST1_OperRow:SQLC_TEST1_Left3;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color3 = 1;
                SQLM_TEST1_TempRow =
                    SQLM_TEST1_OperRow:SQLC_TEST1_Right3;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color3 = 1;
                SQLM_TEST1_OperRow:SQLC_TEST1_Color3 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_TEST1_Father:SQLC_TEST1_Color3 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_TEST1_GrandFather:SQLC_TEST1_Left3 =
                   SQLM_TEST1_Father
                THEN
                    IF SQLM_TEST1_Father:SQLC_TEST1_Right3 =
                       SQLM_TEST1_OperRow
                    THEN
! Double rotation !
                        SQLM_TEST1_Father:SQLC_TEST1_Right3 =
                            SQLM_TEST1_OperRow:SQLC_TEST1_Left3;
                        SQLM_TEST1_OperRow:SQLC_TEST1_Left3 =
                            SQLM_TEST1_Father;
                        SQLM_TEST1_Father =
                            SQLM_TEST1_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TEST1_GrandFather:SQLC_TEST1_Left3 =
                        SQLM_TEST1_Father:SQLC_TEST1_Right3;
                    SQLM_TEST1_Father:SQLC_TEST1_Right3 =
                        SQLM_TEST1_GrandFather;
                ELSE
                    IF SQLM_TEST1_Father:SQLC_TEST1_Left3 =
                        SQLM_TEST1_OperRow
                    THEN
! Double rotation !
                        SQLM_TEST1_Father:SQLC_TEST1_Left3 =
                            SQLM_TEST1_OperRow:SQLC_TEST1_Right3;
                        SQLM_TEST1_OperRow:SQLC_TEST1_Right3 =
                            SQLM_TEST1_Father;
                        SQLM_TEST1_Father =
                            SQLM_TEST1_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TEST1_GrandFather:SQLC_TEST1_Right3 =
                        SQLM_TEST1_Father:SQLC_TEST1_Left3;
                    SQLM_TEST1_Father:SQLC_TEST1_Left3 =
                        SQLM_TEST1_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_TEST1_TempRow =
                    SQLM_TEST1_Father:SQLC_TEST1_Left3;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color3 = 0;
                SQLM_TEST1_TempRow =
                    SQLM_TEST1_Father:SQLC_TEST1_Right3;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color3 = 0;
                SQLM_TEST1_Father:SQLC_TEST1_Color3 = 1;
! Relink nodes !
                IF SQLM_TEST1_GrandGrandFather:SQLC_TEST1_Right3 =
                    SQLM_TEST1_GrandFather
                THEN
                    SQLM_TEST1_GrandGrandFather:SQLC_TEST1_Right3 =
                        SQLM_TEST1_Father;
                ELSE
                    SQLM_TEST1_GrandGrandFather:SQLC_TEST1_Left3 =
                        SQLM_TEST1_Father;
                FI;
                SQLM_TEST1_GrandFather =
                    SQLM_TEST1_Father;
                SQLM_TEST1_OperRow =
                    SQLM_TEST1_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey10_3;
! Aftermath !
ENDLOOPtowComInsKeyTableKey10_3)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_TEST1_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_TEST1_TempRow =
        SQLM_TEST1_RootRow:SQLC_TEST1_Right3;
    SQLM_TEST1_TempRow:SQLC_TEST1_Color3 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    WHEN 4 DO GOTO towComInsKeyLab4;
    WHEN 5 DO GOTO towComInsKeyLab5;
    WHEN 6 DO GOTO towComInsKeyLab6;
    WHEN 7 DO GOTO towComInsKeyLab7;
    WHEN 8 DO GOTO towComInsKeyLab8;
    WHEN 9 DO GOTO towComInsKeyLab9;
    WHEN 10 DO GOTO towComInsKeyLab10;
    WHEN 11 DO GOTO towComInsKeyLab11;
    WHEN 12 DO GOTO towComInsKeyLab12;
    WHEN 13 DO GOTO towComInsKeyLab13;
    WHEN 14 DO GOTO towComInsKeyLab14;
    WHEN 15 DO GOTO towComInsKeyLab15;
    WHEN 16 DO GOTO towComInsKeyLab16;
    WHEN 17 DO GOTO towComInsKeyLab17;
    WHEN 18 DO GOTO towComInsKeyLab18;
    WHEN 19 DO GOTO towComInsKeyLab19;
    WHEN 20 DO GOTO towComInsKeyLab20;
    WHEN 21 DO GOTO towComInsKeyLab21;
    WHEN 22 DO GOTO towComInsKeyLab22;
    WHEN 23 DO GOTO towComInsKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKey !
!------------------------------------------------!
    ENTER towComDelKey WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        SQLX_KeyNumber,
        SQLX_ReturnLabel,
        SQLX_KeyPrefix,
        SQLX_GrandFather,
        SQLX_Father,
        SQLX_Current,
        SQLX_DeleteFather,
        SQLX_Delete;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
! Setup pointers !
    SQLM_PROGRAMS_GrandFather=SQLX_GrandFather;
    SQLM_PROGRAMS_Father=SQLX_Father;
    SQLM_PROGRAMS_OperRow=SQLX_Current;
    SQLM_PROGRAMS_WorkRow=SQLX_WorkRow;
    SQLM_PROGRAMS_DeleteFather=SQLX_DeleteFather;
    SQLM_PROGRAMS_Delete=SQLX_Delete;
    SQLM_PROGRAMS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey0_2)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_PROGRAMS_GrandFather,
            SQLM_PROGRAMS_Father,
            SQLM_PROGRAMS_OperRow,
            SQLM_PROGRAMS_DeleteFather,
            SQLM_PROGRAMS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_PROGRAMS_OperRow=SQLM_PROGRAMS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey0_2;
! Test key. !
    DO SQLS_PROGRAMS_KeyTest2;
! Move down to next node !
    SQLM_PROGRAMS_GrandFather=SQLM_PROGRAMS_Father;
    SQLM_PROGRAMS_Father=SQLM_PROGRAMS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_PROGRAMS_OperRow=
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2;
        SQLM_PROGRAMS_Brother=
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2;
    ELSE
        SQLM_PROGRAMS_OperRow=
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2;
        SQLM_PROGRAMS_Brother=
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2 (*)
        SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Color2 (*)
        (-) SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Color2 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Color2=0;
        SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Color2=1;
        IF SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2=
            SQLM_PROGRAMS_Brother
        THEN
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2=
                SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Left2;
            SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Left2=
                SQLM_PROGRAMS_Father;
        ELSE
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2=
                SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Right2;
            SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Right2=
                SQLM_PROGRAMS_Father;
        FI;
        IF SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Left2=
            SQLM_PROGRAMS_Father
        THEN
            SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Left2=
                SQLM_PROGRAMS_Brother;
        ELSE
            SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Right2=
                SQLM_PROGRAMS_Brother;
        FI;
        SQLM_PROGRAMS_GrandFather=SQLM_PROGRAMS_Brother;
        IF SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2=
            SQLM_PROGRAMS_OperRow
        THEN
            SQLM_PROGRAMS_Brother=
                SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2;
        ELSE
            SQLM_PROGRAMS_Brother=
                SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2=
        SQLM_PROGRAMS_OperRow
    THEN
        SQLM_PROGRAMS_Nephew=
            SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Left2;
    ELSE
        SQLM_PROGRAMS_Nephew=
            SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Right2;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2=1 THEN
     SQLM_PROGRAMS_TempRow=
         SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
     IF SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2=1 THEN
      SQLM_PROGRAMS_TempRow=
          SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
      IF SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Color2=1 THEN
         SQLM_PROGRAMS_TempRow=
             SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Right2;
         IF SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2=1 THEN
          SQLM_PROGRAMS_TempRow=
              SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Left2;
          IF SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2=1 THEN
            SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2=0;
            SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Color2=0;
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Color2=1;
            GOTO L2towComDelKeyTableKey0_2;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_PROGRAMS_Nephew:SQLC_PROGRAMS_Color2=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_PROGRAMS_Nephew:SQLC_PROGRAMS_Color2=
                SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Color2;
            IF SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2=
               SQLM_PROGRAMS_OperRow
            THEN
                SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_Nephew:SQLC_PROGRAMS_Left2;
                SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_Nephew:SQLC_PROGRAMS_Right2;
                SQLM_PROGRAMS_Nephew:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_Father;
                SQLM_PROGRAMS_Nephew:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_Brother;
            ELSE
                SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_Nephew:SQLC_PROGRAMS_Right2;
                SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_Nephew:SQLC_PROGRAMS_Left2;
                SQLM_PROGRAMS_Nephew:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_Father;
                SQLM_PROGRAMS_Nephew:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_Brother;
            FI;
            SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2=0;
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Color2=1;
            IF SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Left2=
               SQLM_PROGRAMS_Father
            THEN
                SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_Nephew;
            ELSE
                SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_Nephew;
            FI;
            SQLM_PROGRAMS_GrandFather=SQLM_PROGRAMS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_PROGRAMS_Nephew:SQLC_PROGRAMS_Color2=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Color2=
                SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Color2;
            IF SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2=
               SQLM_PROGRAMS_OperRow
            THEN
                SQLM_PROGRAMS_TempRow=
                    SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Right2;
                SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2=1;
                SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Left2;
                SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_Father;
            ELSE
                SQLM_PROGRAMS_TempRow=
                    SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Left2;
                SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Color2=1;
                SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Right2;
                SQLM_PROGRAMS_Brother:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_Father;
            FI;
            SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Color2=0;
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Color2=1;
            IF SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Left2=
                SQLM_PROGRAMS_Father
            THEN
                SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Left2=
                    SQLM_PROGRAMS_Brother;
            ELSE
                SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Right2=
                    SQLM_PROGRAMS_Brother;
            FI;
            SQLM_PROGRAMS_GrandFather=SQLM_PROGRAMS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey0_2)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_PROGRAMS_DeleteFather=SQLM_PROGRAMS_GrandFather;
        SQLM_PROGRAMS_Delete=SQLM_PROGRAMS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey0_2;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey0_2)
    IF SQLM_PROGRAMS_Delete /= SQLM_PROGRAMS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_PROGRAMS_DeleteFather:SQLC_PROGRAMS_Left2=
           SQLM_PROGRAMS_Delete
        THEN
            SQLM_PROGRAMS_DeleteFather:SQLC_PROGRAMS_Left2=
                SQLM_PROGRAMS_Father;
        ELSE
            SQLM_PROGRAMS_DeleteFather:SQLC_PROGRAMS_Right2=
                SQLM_PROGRAMS_Father;
        FI;
        IF SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Left2=
           SQLM_PROGRAMS_Father
        THEN
            SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Left2=
                SQLM_PROGRAMS_NilRow;
        ELSE
            SQLM_PROGRAMS_GrandFather:SQLC_PROGRAMS_Right2=
                SQLM_PROGRAMS_NilRow;
        FI;
        IF SQLM_PROGRAMS_Father /= SQLM_PROGRAMS_Delete THEN
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Color2=
                SQLM_PROGRAMS_Delete:SQLC_PROGRAMS_Color2;
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Right2=
                SQLM_PROGRAMS_Delete:SQLC_PROGRAMS_Right2;
            SQLM_PROGRAMS_Father:SQLC_PROGRAMS_Left2=
                SQLM_PROGRAMS_Delete:SQLC_PROGRAMS_Left2;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
        SQLM_PROGRAMS_OperRow=SQLM_PROGRAMS_Delete;
        SQLM_PROGRAMS_GuardRow= SQLM_TableReference:SQLM_System;
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2 =
    SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2;
SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2 =
    SQLM_PROGRAMS_OperRow;
        SQLM_PROGRAMS_Delete:SQLC_PROGRAMS_Allocated=0;
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 1 DO
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 3 DO GOTO towComDelKeyTableKey1_3;
    WHEN 4 DO GOTO towComDelKeyTableKey1_4;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey1_3)
! Setup pointers !
    SQLM_TABLES_GrandFather=SQLX_GrandFather;
    SQLM_TABLES_Father=SQLX_Father;
    SQLM_TABLES_OperRow=SQLX_Current;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_DeleteFather=SQLX_DeleteFather;
    SQLM_TABLES_Delete=SQLX_Delete;
    SQLM_TABLES_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey1_3)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TABLES_GrandFather,
            SQLM_TABLES_Father,
            SQLM_TABLES_OperRow,
            SQLM_TABLES_DeleteFather,
            SQLM_TABLES_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_TABLES_OperRow=SQLM_TABLES_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey1_3;
! Test key. !
    DO SQLS_TABLES_KeyTest3;
! Move down to next node !
    SQLM_TABLES_GrandFather=SQLM_TABLES_Father;
    SQLM_TABLES_Father=SQLM_TABLES_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TABLES_OperRow=
            SQLM_TABLES_Father:SQLC_TABLES_Left3;
        SQLM_TABLES_Brother=
            SQLM_TABLES_Father:SQLC_TABLES_Right3;
    ELSE
        SQLM_TABLES_OperRow=
            SQLM_TABLES_Father:SQLC_TABLES_Right3;
        SQLM_TABLES_Brother=
            SQLM_TABLES_Father:SQLC_TABLES_Left3;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Color3 (*)
        SQLM_TABLES_Father:SQLC_TABLES_Color3 (*)
        (-) SQLM_TABLES_Brother:SQLC_TABLES_Color3 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_TABLES_Father:SQLC_TABLES_Color3=0;
        SQLM_TABLES_Brother:SQLC_TABLES_Color3=1;
        IF SQLM_TABLES_Father:SQLC_TABLES_Right3=
            SQLM_TABLES_Brother
        THEN
            SQLM_TABLES_Father:SQLC_TABLES_Right3=
                SQLM_TABLES_Brother:SQLC_TABLES_Left3;
            SQLM_TABLES_Brother:SQLC_TABLES_Left3=
                SQLM_TABLES_Father;
        ELSE
            SQLM_TABLES_Father:SQLC_TABLES_Left3=
                SQLM_TABLES_Brother:SQLC_TABLES_Right3;
            SQLM_TABLES_Brother:SQLC_TABLES_Right3=
                SQLM_TABLES_Father;
        FI;
        IF SQLM_TABLES_GrandFather:SQLC_TABLES_Left3=
            SQLM_TABLES_Father
        THEN
            SQLM_TABLES_GrandFather:SQLC_TABLES_Left3=
                SQLM_TABLES_Brother;
        ELSE
            SQLM_TABLES_GrandFather:SQLC_TABLES_Right3=
                SQLM_TABLES_Brother;
        FI;
        SQLM_TABLES_GrandFather=SQLM_TABLES_Brother;
        IF SQLM_TABLES_Father:SQLC_TABLES_Left3=
            SQLM_TABLES_OperRow
        THEN
            SQLM_TABLES_Brother=
                SQLM_TABLES_Father:SQLC_TABLES_Right3;
        ELSE
            SQLM_TABLES_Brother=
                SQLM_TABLES_Father:SQLC_TABLES_Left3;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_TABLES_Father:SQLC_TABLES_Left3=
        SQLM_TABLES_OperRow
    THEN
        SQLM_TABLES_Nephew=
            SQLM_TABLES_Brother:SQLC_TABLES_Left3;
    ELSE
        SQLM_TABLES_Nephew=
            SQLM_TABLES_Brother:SQLC_TABLES_Right3;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Color3=1 THEN
     SQLM_TABLES_TempRow=
         SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
     IF SQLM_TABLES_TempRow:SQLC_TABLES_Color3=1 THEN
      SQLM_TABLES_TempRow=
          SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
      IF SQLM_TABLES_TempRow:SQLC_TABLES_Color3=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_TABLES_Brother:SQLC_TABLES_Color3=1 THEN
         SQLM_TABLES_TempRow=
             SQLM_TABLES_Brother:SQLC_TABLES_Right3;
         IF SQLM_TABLES_TempRow:SQLC_TABLES_Color3=1 THEN
          SQLM_TABLES_TempRow=
              SQLM_TABLES_Brother:SQLC_TABLES_Left3;
          IF SQLM_TABLES_TempRow:SQLC_TABLES_Color3=1 THEN
            SQLM_TABLES_OperRow:SQLC_TABLES_Color3=0;
            SQLM_TABLES_Brother:SQLC_TABLES_Color3=0;
            SQLM_TABLES_Father:SQLC_TABLES_Color3=1;
            GOTO L2towComDelKeyTableKey1_3;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_TABLES_Nephew:SQLC_TABLES_Color3=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_TABLES_Nephew:SQLC_TABLES_Color3=
                SQLM_TABLES_Father:SQLC_TABLES_Color3;
            IF SQLM_TABLES_Father:SQLC_TABLES_Left3=
               SQLM_TABLES_OperRow
            THEN
                SQLM_TABLES_Father:SQLC_TABLES_Right3=
                    SQLM_TABLES_Nephew:SQLC_TABLES_Left3;
                SQLM_TABLES_Brother:SQLC_TABLES_Left3=
                    SQLM_TABLES_Nephew:SQLC_TABLES_Right3;
                SQLM_TABLES_Nephew:SQLC_TABLES_Left3=
                    SQLM_TABLES_Father;
                SQLM_TABLES_Nephew:SQLC_TABLES_Right3=
                    SQLM_TABLES_Brother;
            ELSE
                SQLM_TABLES_Father:SQLC_TABLES_Left3=
                    SQLM_TABLES_Nephew:SQLC_TABLES_Right3;
                SQLM_TABLES_Brother:SQLC_TABLES_Right3=
                    SQLM_TABLES_Nephew:SQLC_TABLES_Left3;
                SQLM_TABLES_Nephew:SQLC_TABLES_Right3=
                    SQLM_TABLES_Father;
                SQLM_TABLES_Nephew:SQLC_TABLES_Left3=
                    SQLM_TABLES_Brother;
            FI;
            SQLM_TABLES_OperRow:SQLC_TABLES_Color3=0;
            SQLM_TABLES_Father:SQLC_TABLES_Color3=1;
            IF SQLM_TABLES_GrandFather:SQLC_TABLES_Left3=
               SQLM_TABLES_Father
            THEN
                SQLM_TABLES_GrandFather:SQLC_TABLES_Left3=
                    SQLM_TABLES_Nephew;
            ELSE
                SQLM_TABLES_GrandFather:SQLC_TABLES_Right3=
                    SQLM_TABLES_Nephew;
            FI;
            SQLM_TABLES_GrandFather=SQLM_TABLES_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_TABLES_Nephew:SQLC_TABLES_Color3=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_TABLES_Brother:SQLC_TABLES_Color3=
                SQLM_TABLES_Father:SQLC_TABLES_Color3;
            IF SQLM_TABLES_Father:SQLC_TABLES_Left3=
               SQLM_TABLES_OperRow
            THEN
                SQLM_TABLES_TempRow=
                    SQLM_TABLES_Brother:SQLC_TABLES_Right3;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color3=1;
                SQLM_TABLES_Father:SQLC_TABLES_Right3=
                    SQLM_TABLES_Brother:SQLC_TABLES_Left3;
                SQLM_TABLES_Brother:SQLC_TABLES_Left3=
                    SQLM_TABLES_Father;
            ELSE
                SQLM_TABLES_TempRow=
                    SQLM_TABLES_Brother:SQLC_TABLES_Left3;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color3=1;
                SQLM_TABLES_Father:SQLC_TABLES_Left3=
                    SQLM_TABLES_Brother:SQLC_TABLES_Right3;
                SQLM_TABLES_Brother:SQLC_TABLES_Right3=
                    SQLM_TABLES_Father;
            FI;
            SQLM_TABLES_OperRow:SQLC_TABLES_Color3=0;
            SQLM_TABLES_Father:SQLC_TABLES_Color3=1;
            IF SQLM_TABLES_GrandFather:SQLC_TABLES_Left3=
                SQLM_TABLES_Father
            THEN
                SQLM_TABLES_GrandFather:SQLC_TABLES_Left3=
                    SQLM_TABLES_Brother;
            ELSE
                SQLM_TABLES_GrandFather:SQLC_TABLES_Right3=
                    SQLM_TABLES_Brother;
            FI;
            SQLM_TABLES_GrandFather=SQLM_TABLES_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey1_3)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_TABLES_DeleteFather=SQLM_TABLES_GrandFather;
        SQLM_TABLES_Delete=SQLM_TABLES_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey1_3;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey1_3)
    IF SQLM_TABLES_Delete /= SQLM_TABLES_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_TABLES_DeleteFather:SQLC_TABLES_Left3=
           SQLM_TABLES_Delete
        THEN
            SQLM_TABLES_DeleteFather:SQLC_TABLES_Left3=
                SQLM_TABLES_Father;
        ELSE
            SQLM_TABLES_DeleteFather:SQLC_TABLES_Right3=
                SQLM_TABLES_Father;
        FI;
        IF SQLM_TABLES_GrandFather:SQLC_TABLES_Left3=
           SQLM_TABLES_Father
        THEN
            SQLM_TABLES_GrandFather:SQLC_TABLES_Left3=
                SQLM_TABLES_NilRow;
        ELSE
            SQLM_TABLES_GrandFather:SQLC_TABLES_Right3=
                SQLM_TABLES_NilRow;
        FI;
        IF SQLM_TABLES_Father /= SQLM_TABLES_Delete THEN
            SQLM_TABLES_Father:SQLC_TABLES_Color3=
                SQLM_TABLES_Delete:SQLC_TABLES_Color3;
            SQLM_TABLES_Father:SQLC_TABLES_Right3=
                SQLM_TABLES_Delete:SQLC_TABLES_Right3;
            SQLM_TABLES_Father:SQLC_TABLES_Left3=
                SQLM_TABLES_Delete:SQLC_TABLES_Left3;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey1_4)
! Setup pointers !
    SQLM_TABLES_GrandFather=SQLX_GrandFather;
    SQLM_TABLES_Father=SQLX_Father;
    SQLM_TABLES_OperRow=SQLX_Current;
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
    SQLM_TABLES_DeleteFather=SQLX_DeleteFather;
    SQLM_TABLES_Delete=SQLX_Delete;
    SQLM_TABLES_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey1_4)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TABLES_GrandFather,
            SQLM_TABLES_Father,
            SQLM_TABLES_OperRow,
            SQLM_TABLES_DeleteFather,
            SQLM_TABLES_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_TABLES_OperRow=SQLM_TABLES_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey1_4;
! Test key. !
    DO SQLS_TABLES_KeyTest4;
    IF SQLX_KeyTest = 1 THEN
        IF SQLM_TABLES_OperRow > SQLM_TABLES_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Move down to next node !
    SQLM_TABLES_GrandFather=SQLM_TABLES_Father;
    SQLM_TABLES_Father=SQLM_TABLES_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TABLES_OperRow=
            SQLM_TABLES_Father:SQLC_TABLES_Left4;
        SQLM_TABLES_Brother=
            SQLM_TABLES_Father:SQLC_TABLES_Right4;
    ELSE
        SQLM_TABLES_OperRow=
            SQLM_TABLES_Father:SQLC_TABLES_Right4;
        SQLM_TABLES_Brother=
            SQLM_TABLES_Father:SQLC_TABLES_Left4;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Color4 (*)
        SQLM_TABLES_Father:SQLC_TABLES_Color4 (*)
        (-) SQLM_TABLES_Brother:SQLC_TABLES_Color4 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_TABLES_Father:SQLC_TABLES_Color4=0;
        SQLM_TABLES_Brother:SQLC_TABLES_Color4=1;
        IF SQLM_TABLES_Father:SQLC_TABLES_Right4=
            SQLM_TABLES_Brother
        THEN
            SQLM_TABLES_Father:SQLC_TABLES_Right4=
                SQLM_TABLES_Brother:SQLC_TABLES_Left4;
            SQLM_TABLES_Brother:SQLC_TABLES_Left4=
                SQLM_TABLES_Father;
        ELSE
            SQLM_TABLES_Father:SQLC_TABLES_Left4=
                SQLM_TABLES_Brother:SQLC_TABLES_Right4;
            SQLM_TABLES_Brother:SQLC_TABLES_Right4=
                SQLM_TABLES_Father;
        FI;
        IF SQLM_TABLES_GrandFather:SQLC_TABLES_Left4=
            SQLM_TABLES_Father
        THEN
            SQLM_TABLES_GrandFather:SQLC_TABLES_Left4=
                SQLM_TABLES_Brother;
        ELSE
            SQLM_TABLES_GrandFather:SQLC_TABLES_Right4=
                SQLM_TABLES_Brother;
        FI;
        SQLM_TABLES_GrandFather=SQLM_TABLES_Brother;
        IF SQLM_TABLES_Father:SQLC_TABLES_Left4=
            SQLM_TABLES_OperRow
        THEN
            SQLM_TABLES_Brother=
                SQLM_TABLES_Father:SQLC_TABLES_Right4;
        ELSE
            SQLM_TABLES_Brother=
                SQLM_TABLES_Father:SQLC_TABLES_Left4;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_TABLES_Father:SQLC_TABLES_Left4=
        SQLM_TABLES_OperRow
    THEN
        SQLM_TABLES_Nephew=
            SQLM_TABLES_Brother:SQLC_TABLES_Left4;
    ELSE
        SQLM_TABLES_Nephew=
            SQLM_TABLES_Brother:SQLC_TABLES_Right4;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_TABLES_OperRow:SQLC_TABLES_Color4=1 THEN
     SQLM_TABLES_TempRow=
         SQLM_TABLES_OperRow:SQLC_TABLES_Right4;
     IF SQLM_TABLES_TempRow:SQLC_TABLES_Color4=1 THEN
      SQLM_TABLES_TempRow=
          SQLM_TABLES_OperRow:SQLC_TABLES_Left4;
      IF SQLM_TABLES_TempRow:SQLC_TABLES_Color4=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_TABLES_Brother:SQLC_TABLES_Color4=1 THEN
         SQLM_TABLES_TempRow=
             SQLM_TABLES_Brother:SQLC_TABLES_Right4;
         IF SQLM_TABLES_TempRow:SQLC_TABLES_Color4=1 THEN
          SQLM_TABLES_TempRow=
              SQLM_TABLES_Brother:SQLC_TABLES_Left4;
          IF SQLM_TABLES_TempRow:SQLC_TABLES_Color4=1 THEN
            SQLM_TABLES_OperRow:SQLC_TABLES_Color4=0;
            SQLM_TABLES_Brother:SQLC_TABLES_Color4=0;
            SQLM_TABLES_Father:SQLC_TABLES_Color4=1;
            GOTO L2towComDelKeyTableKey1_4;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_TABLES_Nephew:SQLC_TABLES_Color4=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_TABLES_Nephew:SQLC_TABLES_Color4=
                SQLM_TABLES_Father:SQLC_TABLES_Color4;
            IF SQLM_TABLES_Father:SQLC_TABLES_Left4=
               SQLM_TABLES_OperRow
            THEN
                SQLM_TABLES_Father:SQLC_TABLES_Right4=
                    SQLM_TABLES_Nephew:SQLC_TABLES_Left4;
                SQLM_TABLES_Brother:SQLC_TABLES_Left4=
                    SQLM_TABLES_Nephew:SQLC_TABLES_Right4;
                SQLM_TABLES_Nephew:SQLC_TABLES_Left4=
                    SQLM_TABLES_Father;
                SQLM_TABLES_Nephew:SQLC_TABLES_Right4=
                    SQLM_TABLES_Brother;
            ELSE
                SQLM_TABLES_Father:SQLC_TABLES_Left4=
                    SQLM_TABLES_Nephew:SQLC_TABLES_Right4;
                SQLM_TABLES_Brother:SQLC_TABLES_Right4=
                    SQLM_TABLES_Nephew:SQLC_TABLES_Left4;
                SQLM_TABLES_Nephew:SQLC_TABLES_Right4=
                    SQLM_TABLES_Father;
                SQLM_TABLES_Nephew:SQLC_TABLES_Left4=
                    SQLM_TABLES_Brother;
            FI;
            SQLM_TABLES_OperRow:SQLC_TABLES_Color4=0;
            SQLM_TABLES_Father:SQLC_TABLES_Color4=1;
            IF SQLM_TABLES_GrandFather:SQLC_TABLES_Left4=
               SQLM_TABLES_Father
            THEN
                SQLM_TABLES_GrandFather:SQLC_TABLES_Left4=
                    SQLM_TABLES_Nephew;
            ELSE
                SQLM_TABLES_GrandFather:SQLC_TABLES_Right4=
                    SQLM_TABLES_Nephew;
            FI;
            SQLM_TABLES_GrandFather=SQLM_TABLES_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_TABLES_Nephew:SQLC_TABLES_Color4=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_TABLES_Brother:SQLC_TABLES_Color4=
                SQLM_TABLES_Father:SQLC_TABLES_Color4;
            IF SQLM_TABLES_Father:SQLC_TABLES_Left4=
               SQLM_TABLES_OperRow
            THEN
                SQLM_TABLES_TempRow=
                    SQLM_TABLES_Brother:SQLC_TABLES_Right4;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color4=1;
                SQLM_TABLES_Father:SQLC_TABLES_Right4=
                    SQLM_TABLES_Brother:SQLC_TABLES_Left4;
                SQLM_TABLES_Brother:SQLC_TABLES_Left4=
                    SQLM_TABLES_Father;
            ELSE
                SQLM_TABLES_TempRow=
                    SQLM_TABLES_Brother:SQLC_TABLES_Left4;
                SQLM_TABLES_TempRow:SQLC_TABLES_Color4=1;
                SQLM_TABLES_Father:SQLC_TABLES_Left4=
                    SQLM_TABLES_Brother:SQLC_TABLES_Right4;
                SQLM_TABLES_Brother:SQLC_TABLES_Right4=
                    SQLM_TABLES_Father;
            FI;
            SQLM_TABLES_OperRow:SQLC_TABLES_Color4=0;
            SQLM_TABLES_Father:SQLC_TABLES_Color4=1;
            IF SQLM_TABLES_GrandFather:SQLC_TABLES_Left4=
                SQLM_TABLES_Father
            THEN
                SQLM_TABLES_GrandFather:SQLC_TABLES_Left4=
                    SQLM_TABLES_Brother;
            ELSE
                SQLM_TABLES_GrandFather:SQLC_TABLES_Right4=
                    SQLM_TABLES_Brother;
            FI;
            SQLM_TABLES_GrandFather=SQLM_TABLES_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey1_4)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_TABLES_DeleteFather=SQLM_TABLES_GrandFather;
        SQLM_TABLES_Delete=SQLM_TABLES_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey1_4;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey1_4)
    IF SQLM_TABLES_Delete /= SQLM_TABLES_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_TABLES_DeleteFather:SQLC_TABLES_Left4=
           SQLM_TABLES_Delete
        THEN
            SQLM_TABLES_DeleteFather:SQLC_TABLES_Left4=
                SQLM_TABLES_Father;
        ELSE
            SQLM_TABLES_DeleteFather:SQLC_TABLES_Right4=
                SQLM_TABLES_Father;
        FI;
        IF SQLM_TABLES_GrandFather:SQLC_TABLES_Left4=
           SQLM_TABLES_Father
        THEN
            SQLM_TABLES_GrandFather:SQLC_TABLES_Left4=
                SQLM_TABLES_NilRow;
        ELSE
            SQLM_TABLES_GrandFather:SQLC_TABLES_Right4=
                SQLM_TABLES_NilRow;
        FI;
        IF SQLM_TABLES_Father /= SQLM_TABLES_Delete THEN
            SQLM_TABLES_Father:SQLC_TABLES_Color4=
                SQLM_TABLES_Delete:SQLC_TABLES_Color4;
            SQLM_TABLES_Father:SQLC_TABLES_Right4=
                SQLM_TABLES_Delete:SQLC_TABLES_Right4;
            SQLM_TABLES_Father:SQLC_TABLES_Left4=
                SQLM_TABLES_Delete:SQLC_TABLES_Left4;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 2 DO
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 3 DO GOTO towComDelKeyTableKey2_3;
    WHEN 4 DO GOTO towComDelKeyTableKey2_4;
    WHEN 5 DO GOTO towComDelKeyTableKey2_5;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey2_3)
! Setup pointers !
    SQLM_FIELDS_GrandFather=SQLX_GrandFather;
    SQLM_FIELDS_Father=SQLX_Father;
    SQLM_FIELDS_OperRow=SQLX_Current;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    SQLM_FIELDS_DeleteFather=SQLX_DeleteFather;
    SQLM_FIELDS_Delete=SQLX_Delete;
    SQLM_FIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey2_3)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FIELDS_GrandFather,
            SQLM_FIELDS_Father,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_DeleteFather,
            SQLM_FIELDS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_FIELDS_OperRow=SQLM_FIELDS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey2_3;
! Test key. !
    DO SQLS_FIELDS_KeyTest3;
! Move down to next node !
    SQLM_FIELDS_GrandFather=SQLM_FIELDS_Father;
    SQLM_FIELDS_Father=SQLM_FIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FIELDS_OperRow=
            SQLM_FIELDS_Father:SQLC_FIELDS_Left3;
        SQLM_FIELDS_Brother=
            SQLM_FIELDS_Father:SQLC_FIELDS_Right3;
    ELSE
        SQLM_FIELDS_OperRow=
            SQLM_FIELDS_Father:SQLC_FIELDS_Right3;
        SQLM_FIELDS_Brother=
            SQLM_FIELDS_Father:SQLC_FIELDS_Left3;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3 (*)
        SQLM_FIELDS_Father:SQLC_FIELDS_Color3 (*)
        (-) SQLM_FIELDS_Brother:SQLC_FIELDS_Color3 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_FIELDS_Father:SQLC_FIELDS_Color3=0;
        SQLM_FIELDS_Brother:SQLC_FIELDS_Color3=1;
        IF SQLM_FIELDS_Father:SQLC_FIELDS_Right3=
            SQLM_FIELDS_Brother
        THEN
            SQLM_FIELDS_Father:SQLC_FIELDS_Right3=
                SQLM_FIELDS_Brother:SQLC_FIELDS_Left3;
            SQLM_FIELDS_Brother:SQLC_FIELDS_Left3=
                SQLM_FIELDS_Father;
        ELSE
            SQLM_FIELDS_Father:SQLC_FIELDS_Left3=
                SQLM_FIELDS_Brother:SQLC_FIELDS_Right3;
            SQLM_FIELDS_Brother:SQLC_FIELDS_Right3=
                SQLM_FIELDS_Father;
        FI;
        IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left3=
            SQLM_FIELDS_Father
        THEN
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left3=
                SQLM_FIELDS_Brother;
        ELSE
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right3=
                SQLM_FIELDS_Brother;
        FI;
        SQLM_FIELDS_GrandFather=SQLM_FIELDS_Brother;
        IF SQLM_FIELDS_Father:SQLC_FIELDS_Left3=
            SQLM_FIELDS_OperRow
        THEN
            SQLM_FIELDS_Brother=
                SQLM_FIELDS_Father:SQLC_FIELDS_Right3;
        ELSE
            SQLM_FIELDS_Brother=
                SQLM_FIELDS_Father:SQLC_FIELDS_Left3;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_FIELDS_Father:SQLC_FIELDS_Left3=
        SQLM_FIELDS_OperRow
    THEN
        SQLM_FIELDS_Nephew=
            SQLM_FIELDS_Brother:SQLC_FIELDS_Left3;
    ELSE
        SQLM_FIELDS_Nephew=
            SQLM_FIELDS_Brother:SQLC_FIELDS_Right3;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3=1 THEN
     SQLM_FIELDS_TempRow=
         SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
     IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3=1 THEN
      SQLM_FIELDS_TempRow=
          SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
      IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_FIELDS_Brother:SQLC_FIELDS_Color3=1 THEN
         SQLM_FIELDS_TempRow=
             SQLM_FIELDS_Brother:SQLC_FIELDS_Right3;
         IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3=1 THEN
          SQLM_FIELDS_TempRow=
              SQLM_FIELDS_Brother:SQLC_FIELDS_Left3;
          IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3=1 THEN
            SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3=0;
            SQLM_FIELDS_Brother:SQLC_FIELDS_Color3=0;
            SQLM_FIELDS_Father:SQLC_FIELDS_Color3=1;
            GOTO L2towComDelKeyTableKey2_3;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_FIELDS_Nephew:SQLC_FIELDS_Color3=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_FIELDS_Nephew:SQLC_FIELDS_Color3=
                SQLM_FIELDS_Father:SQLC_FIELDS_Color3;
            IF SQLM_FIELDS_Father:SQLC_FIELDS_Left3=
               SQLM_FIELDS_OperRow
            THEN
                SQLM_FIELDS_Father:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Left3;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Right3;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_Father;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_Brother;
            ELSE
                SQLM_FIELDS_Father:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Right3;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Left3;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_Father;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_Brother;
            FI;
            SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3=0;
            SQLM_FIELDS_Father:SQLC_FIELDS_Color3=1;
            IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left3=
               SQLM_FIELDS_Father
            THEN
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_Nephew;
            ELSE
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_Nephew;
            FI;
            SQLM_FIELDS_GrandFather=SQLM_FIELDS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_FIELDS_Nephew:SQLC_FIELDS_Color3=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_FIELDS_Brother:SQLC_FIELDS_Color3=
                SQLM_FIELDS_Father:SQLC_FIELDS_Color3;
            IF SQLM_FIELDS_Father:SQLC_FIELDS_Left3=
               SQLM_FIELDS_OperRow
            THEN
                SQLM_FIELDS_TempRow=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Right3;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3=1;
                SQLM_FIELDS_Father:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Left3;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_Father;
            ELSE
                SQLM_FIELDS_TempRow=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Left3;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color3=1;
                SQLM_FIELDS_Father:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Right3;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_Father;
            FI;
            SQLM_FIELDS_OperRow:SQLC_FIELDS_Color3=0;
            SQLM_FIELDS_Father:SQLC_FIELDS_Color3=1;
            IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left3=
                SQLM_FIELDS_Father
            THEN
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left3=
                    SQLM_FIELDS_Brother;
            ELSE
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right3=
                    SQLM_FIELDS_Brother;
            FI;
            SQLM_FIELDS_GrandFather=SQLM_FIELDS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey2_3)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_FIELDS_DeleteFather=SQLM_FIELDS_GrandFather;
        SQLM_FIELDS_Delete=SQLM_FIELDS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey2_3;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey2_3)
    IF SQLM_FIELDS_Delete /= SQLM_FIELDS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_FIELDS_DeleteFather:SQLC_FIELDS_Left3=
           SQLM_FIELDS_Delete
        THEN
            SQLM_FIELDS_DeleteFather:SQLC_FIELDS_Left3=
                SQLM_FIELDS_Father;
        ELSE
            SQLM_FIELDS_DeleteFather:SQLC_FIELDS_Right3=
                SQLM_FIELDS_Father;
        FI;
        IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left3=
           SQLM_FIELDS_Father
        THEN
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left3=
                SQLM_FIELDS_NilRow;
        ELSE
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right3=
                SQLM_FIELDS_NilRow;
        FI;
        IF SQLM_FIELDS_Father /= SQLM_FIELDS_Delete THEN
            SQLM_FIELDS_Father:SQLC_FIELDS_Color3=
                SQLM_FIELDS_Delete:SQLC_FIELDS_Color3;
            SQLM_FIELDS_Father:SQLC_FIELDS_Right3=
                SQLM_FIELDS_Delete:SQLC_FIELDS_Right3;
            SQLM_FIELDS_Father:SQLC_FIELDS_Left3=
                SQLM_FIELDS_Delete:SQLC_FIELDS_Left3;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey2_4)
! Setup pointers !
    SQLM_FIELDS_GrandFather=SQLX_GrandFather;
    SQLM_FIELDS_Father=SQLX_Father;
    SQLM_FIELDS_OperRow=SQLX_Current;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    SQLM_FIELDS_DeleteFather=SQLX_DeleteFather;
    SQLM_FIELDS_Delete=SQLX_Delete;
    SQLM_FIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey2_4)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FIELDS_GrandFather,
            SQLM_FIELDS_Father,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_DeleteFather,
            SQLM_FIELDS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_FIELDS_OperRow=SQLM_FIELDS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey2_4;
! Test key. !
    DO SQLS_FIELDS_KeyTest4;
! Move down to next node !
    SQLM_FIELDS_GrandFather=SQLM_FIELDS_Father;
    SQLM_FIELDS_Father=SQLM_FIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FIELDS_OperRow=
            SQLM_FIELDS_Father:SQLC_FIELDS_Left4;
        SQLM_FIELDS_Brother=
            SQLM_FIELDS_Father:SQLC_FIELDS_Right4;
    ELSE
        SQLM_FIELDS_OperRow=
            SQLM_FIELDS_Father:SQLC_FIELDS_Right4;
        SQLM_FIELDS_Brother=
            SQLM_FIELDS_Father:SQLC_FIELDS_Left4;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4 (*)
        SQLM_FIELDS_Father:SQLC_FIELDS_Color4 (*)
        (-) SQLM_FIELDS_Brother:SQLC_FIELDS_Color4 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_FIELDS_Father:SQLC_FIELDS_Color4=0;
        SQLM_FIELDS_Brother:SQLC_FIELDS_Color4=1;
        IF SQLM_FIELDS_Father:SQLC_FIELDS_Right4=
            SQLM_FIELDS_Brother
        THEN
            SQLM_FIELDS_Father:SQLC_FIELDS_Right4=
                SQLM_FIELDS_Brother:SQLC_FIELDS_Left4;
            SQLM_FIELDS_Brother:SQLC_FIELDS_Left4=
                SQLM_FIELDS_Father;
        ELSE
            SQLM_FIELDS_Father:SQLC_FIELDS_Left4=
                SQLM_FIELDS_Brother:SQLC_FIELDS_Right4;
            SQLM_FIELDS_Brother:SQLC_FIELDS_Right4=
                SQLM_FIELDS_Father;
        FI;
        IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left4=
            SQLM_FIELDS_Father
        THEN
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left4=
                SQLM_FIELDS_Brother;
        ELSE
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right4=
                SQLM_FIELDS_Brother;
        FI;
        SQLM_FIELDS_GrandFather=SQLM_FIELDS_Brother;
        IF SQLM_FIELDS_Father:SQLC_FIELDS_Left4=
            SQLM_FIELDS_OperRow
        THEN
            SQLM_FIELDS_Brother=
                SQLM_FIELDS_Father:SQLC_FIELDS_Right4;
        ELSE
            SQLM_FIELDS_Brother=
                SQLM_FIELDS_Father:SQLC_FIELDS_Left4;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_FIELDS_Father:SQLC_FIELDS_Left4=
        SQLM_FIELDS_OperRow
    THEN
        SQLM_FIELDS_Nephew=
            SQLM_FIELDS_Brother:SQLC_FIELDS_Left4;
    ELSE
        SQLM_FIELDS_Nephew=
            SQLM_FIELDS_Brother:SQLC_FIELDS_Right4;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4=1 THEN
     SQLM_FIELDS_TempRow=
         SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4;
     IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4=1 THEN
      SQLM_FIELDS_TempRow=
          SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4;
      IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_FIELDS_Brother:SQLC_FIELDS_Color4=1 THEN
         SQLM_FIELDS_TempRow=
             SQLM_FIELDS_Brother:SQLC_FIELDS_Right4;
         IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4=1 THEN
          SQLM_FIELDS_TempRow=
              SQLM_FIELDS_Brother:SQLC_FIELDS_Left4;
          IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4=1 THEN
            SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4=0;
            SQLM_FIELDS_Brother:SQLC_FIELDS_Color4=0;
            SQLM_FIELDS_Father:SQLC_FIELDS_Color4=1;
            GOTO L2towComDelKeyTableKey2_4;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_FIELDS_Nephew:SQLC_FIELDS_Color4=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_FIELDS_Nephew:SQLC_FIELDS_Color4=
                SQLM_FIELDS_Father:SQLC_FIELDS_Color4;
            IF SQLM_FIELDS_Father:SQLC_FIELDS_Left4=
               SQLM_FIELDS_OperRow
            THEN
                SQLM_FIELDS_Father:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Left4;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Right4;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_Father;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_Brother;
            ELSE
                SQLM_FIELDS_Father:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Right4;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Left4;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_Father;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_Brother;
            FI;
            SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4=0;
            SQLM_FIELDS_Father:SQLC_FIELDS_Color4=1;
            IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left4=
               SQLM_FIELDS_Father
            THEN
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_Nephew;
            ELSE
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_Nephew;
            FI;
            SQLM_FIELDS_GrandFather=SQLM_FIELDS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_FIELDS_Nephew:SQLC_FIELDS_Color4=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_FIELDS_Brother:SQLC_FIELDS_Color4=
                SQLM_FIELDS_Father:SQLC_FIELDS_Color4;
            IF SQLM_FIELDS_Father:SQLC_FIELDS_Left4=
               SQLM_FIELDS_OperRow
            THEN
                SQLM_FIELDS_TempRow=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Right4;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4=1;
                SQLM_FIELDS_Father:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Left4;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_Father;
            ELSE
                SQLM_FIELDS_TempRow=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Left4;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color4=1;
                SQLM_FIELDS_Father:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Right4;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_Father;
            FI;
            SQLM_FIELDS_OperRow:SQLC_FIELDS_Color4=0;
            SQLM_FIELDS_Father:SQLC_FIELDS_Color4=1;
            IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left4=
                SQLM_FIELDS_Father
            THEN
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left4=
                    SQLM_FIELDS_Brother;
            ELSE
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right4=
                    SQLM_FIELDS_Brother;
            FI;
            SQLM_FIELDS_GrandFather=SQLM_FIELDS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey2_4)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_FIELDS_DeleteFather=SQLM_FIELDS_GrandFather;
        SQLM_FIELDS_Delete=SQLM_FIELDS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey2_4;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey2_4)
    IF SQLM_FIELDS_Delete /= SQLM_FIELDS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_FIELDS_DeleteFather:SQLC_FIELDS_Left4=
           SQLM_FIELDS_Delete
        THEN
            SQLM_FIELDS_DeleteFather:SQLC_FIELDS_Left4=
                SQLM_FIELDS_Father;
        ELSE
            SQLM_FIELDS_DeleteFather:SQLC_FIELDS_Right4=
                SQLM_FIELDS_Father;
        FI;
        IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left4=
           SQLM_FIELDS_Father
        THEN
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left4=
                SQLM_FIELDS_NilRow;
        ELSE
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right4=
                SQLM_FIELDS_NilRow;
        FI;
        IF SQLM_FIELDS_Father /= SQLM_FIELDS_Delete THEN
            SQLM_FIELDS_Father:SQLC_FIELDS_Color4=
                SQLM_FIELDS_Delete:SQLC_FIELDS_Color4;
            SQLM_FIELDS_Father:SQLC_FIELDS_Right4=
                SQLM_FIELDS_Delete:SQLC_FIELDS_Right4;
            SQLM_FIELDS_Father:SQLC_FIELDS_Left4=
                SQLM_FIELDS_Delete:SQLC_FIELDS_Left4;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey2_5)
! Setup pointers !
    SQLM_FIELDS_GrandFather=SQLX_GrandFather;
    SQLM_FIELDS_Father=SQLX_Father;
    SQLM_FIELDS_OperRow=SQLX_Current;
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
    SQLM_FIELDS_DeleteFather=SQLX_DeleteFather;
    SQLM_FIELDS_Delete=SQLX_Delete;
    SQLM_FIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey2_5)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FIELDS_GrandFather,
            SQLM_FIELDS_Father,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_DeleteFather,
            SQLM_FIELDS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_FIELDS_OperRow=SQLM_FIELDS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey2_5;
! Test key. !
    DO SQLS_FIELDS_KeyTest5;
    IF SQLX_KeyTest = 1 THEN
        IF SQLM_FIELDS_OperRow > SQLM_FIELDS_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Move down to next node !
    SQLM_FIELDS_GrandFather=SQLM_FIELDS_Father;
    SQLM_FIELDS_Father=SQLM_FIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FIELDS_OperRow=
            SQLM_FIELDS_Father:SQLC_FIELDS_Left5;
        SQLM_FIELDS_Brother=
            SQLM_FIELDS_Father:SQLC_FIELDS_Right5;
    ELSE
        SQLM_FIELDS_OperRow=
            SQLM_FIELDS_Father:SQLC_FIELDS_Right5;
        SQLM_FIELDS_Brother=
            SQLM_FIELDS_Father:SQLC_FIELDS_Left5;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5 (*)
        SQLM_FIELDS_Father:SQLC_FIELDS_Color5 (*)
        (-) SQLM_FIELDS_Brother:SQLC_FIELDS_Color5 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_FIELDS_Father:SQLC_FIELDS_Color5=0;
        SQLM_FIELDS_Brother:SQLC_FIELDS_Color5=1;
        IF SQLM_FIELDS_Father:SQLC_FIELDS_Right5=
            SQLM_FIELDS_Brother
        THEN
            SQLM_FIELDS_Father:SQLC_FIELDS_Right5=
                SQLM_FIELDS_Brother:SQLC_FIELDS_Left5;
            SQLM_FIELDS_Brother:SQLC_FIELDS_Left5=
                SQLM_FIELDS_Father;
        ELSE
            SQLM_FIELDS_Father:SQLC_FIELDS_Left5=
                SQLM_FIELDS_Brother:SQLC_FIELDS_Right5;
            SQLM_FIELDS_Brother:SQLC_FIELDS_Right5=
                SQLM_FIELDS_Father;
        FI;
        IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left5=
            SQLM_FIELDS_Father
        THEN
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left5=
                SQLM_FIELDS_Brother;
        ELSE
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right5=
                SQLM_FIELDS_Brother;
        FI;
        SQLM_FIELDS_GrandFather=SQLM_FIELDS_Brother;
        IF SQLM_FIELDS_Father:SQLC_FIELDS_Left5=
            SQLM_FIELDS_OperRow
        THEN
            SQLM_FIELDS_Brother=
                SQLM_FIELDS_Father:SQLC_FIELDS_Right5;
        ELSE
            SQLM_FIELDS_Brother=
                SQLM_FIELDS_Father:SQLC_FIELDS_Left5;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_FIELDS_Father:SQLC_FIELDS_Left5=
        SQLM_FIELDS_OperRow
    THEN
        SQLM_FIELDS_Nephew=
            SQLM_FIELDS_Brother:SQLC_FIELDS_Left5;
    ELSE
        SQLM_FIELDS_Nephew=
            SQLM_FIELDS_Brother:SQLC_FIELDS_Right5;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5=1 THEN
     SQLM_FIELDS_TempRow=
         SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5;
     IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5=1 THEN
      SQLM_FIELDS_TempRow=
          SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5;
      IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_FIELDS_Brother:SQLC_FIELDS_Color5=1 THEN
         SQLM_FIELDS_TempRow=
             SQLM_FIELDS_Brother:SQLC_FIELDS_Right5;
         IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5=1 THEN
          SQLM_FIELDS_TempRow=
              SQLM_FIELDS_Brother:SQLC_FIELDS_Left5;
          IF SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5=1 THEN
            SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5=0;
            SQLM_FIELDS_Brother:SQLC_FIELDS_Color5=0;
            SQLM_FIELDS_Father:SQLC_FIELDS_Color5=1;
            GOTO L2towComDelKeyTableKey2_5;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_FIELDS_Nephew:SQLC_FIELDS_Color5=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_FIELDS_Nephew:SQLC_FIELDS_Color5=
                SQLM_FIELDS_Father:SQLC_FIELDS_Color5;
            IF SQLM_FIELDS_Father:SQLC_FIELDS_Left5=
               SQLM_FIELDS_OperRow
            THEN
                SQLM_FIELDS_Father:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Left5;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Right5;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_Father;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_Brother;
            ELSE
                SQLM_FIELDS_Father:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Right5;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_Nephew:SQLC_FIELDS_Left5;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_Father;
                SQLM_FIELDS_Nephew:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_Brother;
            FI;
            SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5=0;
            SQLM_FIELDS_Father:SQLC_FIELDS_Color5=1;
            IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left5=
               SQLM_FIELDS_Father
            THEN
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_Nephew;
            ELSE
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_Nephew;
            FI;
            SQLM_FIELDS_GrandFather=SQLM_FIELDS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_FIELDS_Nephew:SQLC_FIELDS_Color5=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_FIELDS_Brother:SQLC_FIELDS_Color5=
                SQLM_FIELDS_Father:SQLC_FIELDS_Color5;
            IF SQLM_FIELDS_Father:SQLC_FIELDS_Left5=
               SQLM_FIELDS_OperRow
            THEN
                SQLM_FIELDS_TempRow=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Right5;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5=1;
                SQLM_FIELDS_Father:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Left5;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_Father;
            ELSE
                SQLM_FIELDS_TempRow=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Left5;
                SQLM_FIELDS_TempRow:SQLC_FIELDS_Color5=1;
                SQLM_FIELDS_Father:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_Brother:SQLC_FIELDS_Right5;
                SQLM_FIELDS_Brother:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_Father;
            FI;
            SQLM_FIELDS_OperRow:SQLC_FIELDS_Color5=0;
            SQLM_FIELDS_Father:SQLC_FIELDS_Color5=1;
            IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left5=
                SQLM_FIELDS_Father
            THEN
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left5=
                    SQLM_FIELDS_Brother;
            ELSE
                SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right5=
                    SQLM_FIELDS_Brother;
            FI;
            SQLM_FIELDS_GrandFather=SQLM_FIELDS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey2_5)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_FIELDS_DeleteFather=SQLM_FIELDS_GrandFather;
        SQLM_FIELDS_Delete=SQLM_FIELDS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey2_5;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey2_5)
    IF SQLM_FIELDS_Delete /= SQLM_FIELDS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_FIELDS_DeleteFather:SQLC_FIELDS_Left5=
           SQLM_FIELDS_Delete
        THEN
            SQLM_FIELDS_DeleteFather:SQLC_FIELDS_Left5=
                SQLM_FIELDS_Father;
        ELSE
            SQLM_FIELDS_DeleteFather:SQLC_FIELDS_Right5=
                SQLM_FIELDS_Father;
        FI;
        IF SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left5=
           SQLM_FIELDS_Father
        THEN
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Left5=
                SQLM_FIELDS_NilRow;
        ELSE
            SQLM_FIELDS_GrandFather:SQLC_FIELDS_Right5=
                SQLM_FIELDS_NilRow;
        FI;
        IF SQLM_FIELDS_Father /= SQLM_FIELDS_Delete THEN
            SQLM_FIELDS_Father:SQLC_FIELDS_Color5=
                SQLM_FIELDS_Delete:SQLC_FIELDS_Color5;
            SQLM_FIELDS_Father:SQLC_FIELDS_Right5=
                SQLM_FIELDS_Delete:SQLC_FIELDS_Right5;
            SQLM_FIELDS_Father:SQLC_FIELDS_Left5=
                SQLM_FIELDS_Delete:SQLC_FIELDS_Left5;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 3 DO
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComDelKeyTableKey3_2;
    WHEN 3 DO GOTO towComDelKeyTableKey3_3;
    WHEN 4 DO GOTO towComDelKeyTableKey3_4;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey3_2)
! Setup pointers !
    SQLM_KEYS_GrandFather=SQLX_GrandFather;
    SQLM_KEYS_Father=SQLX_Father;
    SQLM_KEYS_OperRow=SQLX_Current;
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_DeleteFather=SQLX_DeleteFather;
    SQLM_KEYS_Delete=SQLX_Delete;
    SQLM_KEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey3_2)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_KEYS_GrandFather,
            SQLM_KEYS_Father,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_DeleteFather,
            SQLM_KEYS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_KEYS_OperRow=SQLM_KEYS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey3_2;
! Test key. !
    DO SQLS_KEYS_KeyTest2;
! Move down to next node !
    SQLM_KEYS_GrandFather=SQLM_KEYS_Father;
    SQLM_KEYS_Father=SQLM_KEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_KEYS_OperRow=
            SQLM_KEYS_Father:SQLC_KEYS_Left2;
        SQLM_KEYS_Brother=
            SQLM_KEYS_Father:SQLC_KEYS_Right2;
    ELSE
        SQLM_KEYS_OperRow=
            SQLM_KEYS_Father:SQLC_KEYS_Right2;
        SQLM_KEYS_Brother=
            SQLM_KEYS_Father:SQLC_KEYS_Left2;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Color2 (*)
        SQLM_KEYS_Father:SQLC_KEYS_Color2 (*)
        (-) SQLM_KEYS_Brother:SQLC_KEYS_Color2 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_KEYS_Father:SQLC_KEYS_Color2=0;
        SQLM_KEYS_Brother:SQLC_KEYS_Color2=1;
        IF SQLM_KEYS_Father:SQLC_KEYS_Right2=
            SQLM_KEYS_Brother
        THEN
            SQLM_KEYS_Father:SQLC_KEYS_Right2=
                SQLM_KEYS_Brother:SQLC_KEYS_Left2;
            SQLM_KEYS_Brother:SQLC_KEYS_Left2=
                SQLM_KEYS_Father;
        ELSE
            SQLM_KEYS_Father:SQLC_KEYS_Left2=
                SQLM_KEYS_Brother:SQLC_KEYS_Right2;
            SQLM_KEYS_Brother:SQLC_KEYS_Right2=
                SQLM_KEYS_Father;
        FI;
        IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left2=
            SQLM_KEYS_Father
        THEN
            SQLM_KEYS_GrandFather:SQLC_KEYS_Left2=
                SQLM_KEYS_Brother;
        ELSE
            SQLM_KEYS_GrandFather:SQLC_KEYS_Right2=
                SQLM_KEYS_Brother;
        FI;
        SQLM_KEYS_GrandFather=SQLM_KEYS_Brother;
        IF SQLM_KEYS_Father:SQLC_KEYS_Left2=
            SQLM_KEYS_OperRow
        THEN
            SQLM_KEYS_Brother=
                SQLM_KEYS_Father:SQLC_KEYS_Right2;
        ELSE
            SQLM_KEYS_Brother=
                SQLM_KEYS_Father:SQLC_KEYS_Left2;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_KEYS_Father:SQLC_KEYS_Left2=
        SQLM_KEYS_OperRow
    THEN
        SQLM_KEYS_Nephew=
            SQLM_KEYS_Brother:SQLC_KEYS_Left2;
    ELSE
        SQLM_KEYS_Nephew=
            SQLM_KEYS_Brother:SQLC_KEYS_Right2;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Color2=1 THEN
     SQLM_KEYS_TempRow=
         SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
     IF SQLM_KEYS_TempRow:SQLC_KEYS_Color2=1 THEN
      SQLM_KEYS_TempRow=
          SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
      IF SQLM_KEYS_TempRow:SQLC_KEYS_Color2=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_KEYS_Brother:SQLC_KEYS_Color2=1 THEN
         SQLM_KEYS_TempRow=
             SQLM_KEYS_Brother:SQLC_KEYS_Right2;
         IF SQLM_KEYS_TempRow:SQLC_KEYS_Color2=1 THEN
          SQLM_KEYS_TempRow=
              SQLM_KEYS_Brother:SQLC_KEYS_Left2;
          IF SQLM_KEYS_TempRow:SQLC_KEYS_Color2=1 THEN
            SQLM_KEYS_OperRow:SQLC_KEYS_Color2=0;
            SQLM_KEYS_Brother:SQLC_KEYS_Color2=0;
            SQLM_KEYS_Father:SQLC_KEYS_Color2=1;
            GOTO L2towComDelKeyTableKey3_2;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_KEYS_Nephew:SQLC_KEYS_Color2=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_KEYS_Nephew:SQLC_KEYS_Color2=
                SQLM_KEYS_Father:SQLC_KEYS_Color2;
            IF SQLM_KEYS_Father:SQLC_KEYS_Left2=
               SQLM_KEYS_OperRow
            THEN
                SQLM_KEYS_Father:SQLC_KEYS_Right2=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Left2;
                SQLM_KEYS_Brother:SQLC_KEYS_Left2=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Right2;
                SQLM_KEYS_Nephew:SQLC_KEYS_Left2=
                    SQLM_KEYS_Father;
                SQLM_KEYS_Nephew:SQLC_KEYS_Right2=
                    SQLM_KEYS_Brother;
            ELSE
                SQLM_KEYS_Father:SQLC_KEYS_Left2=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Right2;
                SQLM_KEYS_Brother:SQLC_KEYS_Right2=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Left2;
                SQLM_KEYS_Nephew:SQLC_KEYS_Right2=
                    SQLM_KEYS_Father;
                SQLM_KEYS_Nephew:SQLC_KEYS_Left2=
                    SQLM_KEYS_Brother;
            FI;
            SQLM_KEYS_OperRow:SQLC_KEYS_Color2=0;
            SQLM_KEYS_Father:SQLC_KEYS_Color2=1;
            IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left2=
               SQLM_KEYS_Father
            THEN
                SQLM_KEYS_GrandFather:SQLC_KEYS_Left2=
                    SQLM_KEYS_Nephew;
            ELSE
                SQLM_KEYS_GrandFather:SQLC_KEYS_Right2=
                    SQLM_KEYS_Nephew;
            FI;
            SQLM_KEYS_GrandFather=SQLM_KEYS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_KEYS_Nephew:SQLC_KEYS_Color2=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_KEYS_Brother:SQLC_KEYS_Color2=
                SQLM_KEYS_Father:SQLC_KEYS_Color2;
            IF SQLM_KEYS_Father:SQLC_KEYS_Left2=
               SQLM_KEYS_OperRow
            THEN
                SQLM_KEYS_TempRow=
                    SQLM_KEYS_Brother:SQLC_KEYS_Right2;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color2=1;
                SQLM_KEYS_Father:SQLC_KEYS_Right2=
                    SQLM_KEYS_Brother:SQLC_KEYS_Left2;
                SQLM_KEYS_Brother:SQLC_KEYS_Left2=
                    SQLM_KEYS_Father;
            ELSE
                SQLM_KEYS_TempRow=
                    SQLM_KEYS_Brother:SQLC_KEYS_Left2;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color2=1;
                SQLM_KEYS_Father:SQLC_KEYS_Left2=
                    SQLM_KEYS_Brother:SQLC_KEYS_Right2;
                SQLM_KEYS_Brother:SQLC_KEYS_Right2=
                    SQLM_KEYS_Father;
            FI;
            SQLM_KEYS_OperRow:SQLC_KEYS_Color2=0;
            SQLM_KEYS_Father:SQLC_KEYS_Color2=1;
            IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left2=
                SQLM_KEYS_Father
            THEN
                SQLM_KEYS_GrandFather:SQLC_KEYS_Left2=
                    SQLM_KEYS_Brother;
            ELSE
                SQLM_KEYS_GrandFather:SQLC_KEYS_Right2=
                    SQLM_KEYS_Brother;
            FI;
            SQLM_KEYS_GrandFather=SQLM_KEYS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey3_2)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_KEYS_DeleteFather=SQLM_KEYS_GrandFather;
        SQLM_KEYS_Delete=SQLM_KEYS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey3_2;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey3_2)
    IF SQLM_KEYS_Delete /= SQLM_KEYS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_KEYS_DeleteFather:SQLC_KEYS_Left2=
           SQLM_KEYS_Delete
        THEN
            SQLM_KEYS_DeleteFather:SQLC_KEYS_Left2=
                SQLM_KEYS_Father;
        ELSE
            SQLM_KEYS_DeleteFather:SQLC_KEYS_Right2=
                SQLM_KEYS_Father;
        FI;
        IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left2=
           SQLM_KEYS_Father
        THEN
            SQLM_KEYS_GrandFather:SQLC_KEYS_Left2=
                SQLM_KEYS_NilRow;
        ELSE
            SQLM_KEYS_GrandFather:SQLC_KEYS_Right2=
                SQLM_KEYS_NilRow;
        FI;
        IF SQLM_KEYS_Father /= SQLM_KEYS_Delete THEN
            SQLM_KEYS_Father:SQLC_KEYS_Color2=
                SQLM_KEYS_Delete:SQLC_KEYS_Color2;
            SQLM_KEYS_Father:SQLC_KEYS_Right2=
                SQLM_KEYS_Delete:SQLC_KEYS_Right2;
            SQLM_KEYS_Father:SQLC_KEYS_Left2=
                SQLM_KEYS_Delete:SQLC_KEYS_Left2;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
        SQLM_KEYS_OperRow=SQLM_KEYS_Delete;
        SQLM_KEYS_GuardRow= SQLM_TableReference:SQLM_System;
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_KEYS_OperRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_GuardRow:SQLC_KEYS_Right2;
SQLM_KEYS_GuardRow:SQLC_KEYS_Right2 =
    SQLM_KEYS_OperRow;
        SQLM_KEYS_Delete:SQLC_KEYS_Allocated=0;
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey3_3)
! Setup pointers !
    SQLM_KEYS_GrandFather=SQLX_GrandFather;
    SQLM_KEYS_Father=SQLX_Father;
    SQLM_KEYS_OperRow=SQLX_Current;
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_DeleteFather=SQLX_DeleteFather;
    SQLM_KEYS_Delete=SQLX_Delete;
    SQLM_KEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey3_3)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_KEYS_GrandFather,
            SQLM_KEYS_Father,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_DeleteFather,
            SQLM_KEYS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_KEYS_OperRow=SQLM_KEYS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey3_3;
! Test key. !
    DO SQLS_KEYS_KeyTest3;
! Move down to next node !
    SQLM_KEYS_GrandFather=SQLM_KEYS_Father;
    SQLM_KEYS_Father=SQLM_KEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_KEYS_OperRow=
            SQLM_KEYS_Father:SQLC_KEYS_Left3;
        SQLM_KEYS_Brother=
            SQLM_KEYS_Father:SQLC_KEYS_Right3;
    ELSE
        SQLM_KEYS_OperRow=
            SQLM_KEYS_Father:SQLC_KEYS_Right3;
        SQLM_KEYS_Brother=
            SQLM_KEYS_Father:SQLC_KEYS_Left3;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Color3 (*)
        SQLM_KEYS_Father:SQLC_KEYS_Color3 (*)
        (-) SQLM_KEYS_Brother:SQLC_KEYS_Color3 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_KEYS_Father:SQLC_KEYS_Color3=0;
        SQLM_KEYS_Brother:SQLC_KEYS_Color3=1;
        IF SQLM_KEYS_Father:SQLC_KEYS_Right3=
            SQLM_KEYS_Brother
        THEN
            SQLM_KEYS_Father:SQLC_KEYS_Right3=
                SQLM_KEYS_Brother:SQLC_KEYS_Left3;
            SQLM_KEYS_Brother:SQLC_KEYS_Left3=
                SQLM_KEYS_Father;
        ELSE
            SQLM_KEYS_Father:SQLC_KEYS_Left3=
                SQLM_KEYS_Brother:SQLC_KEYS_Right3;
            SQLM_KEYS_Brother:SQLC_KEYS_Right3=
                SQLM_KEYS_Father;
        FI;
        IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left3=
            SQLM_KEYS_Father
        THEN
            SQLM_KEYS_GrandFather:SQLC_KEYS_Left3=
                SQLM_KEYS_Brother;
        ELSE
            SQLM_KEYS_GrandFather:SQLC_KEYS_Right3=
                SQLM_KEYS_Brother;
        FI;
        SQLM_KEYS_GrandFather=SQLM_KEYS_Brother;
        IF SQLM_KEYS_Father:SQLC_KEYS_Left3=
            SQLM_KEYS_OperRow
        THEN
            SQLM_KEYS_Brother=
                SQLM_KEYS_Father:SQLC_KEYS_Right3;
        ELSE
            SQLM_KEYS_Brother=
                SQLM_KEYS_Father:SQLC_KEYS_Left3;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_KEYS_Father:SQLC_KEYS_Left3=
        SQLM_KEYS_OperRow
    THEN
        SQLM_KEYS_Nephew=
            SQLM_KEYS_Brother:SQLC_KEYS_Left3;
    ELSE
        SQLM_KEYS_Nephew=
            SQLM_KEYS_Brother:SQLC_KEYS_Right3;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Color3=1 THEN
     SQLM_KEYS_TempRow=
         SQLM_KEYS_OperRow:SQLC_KEYS_Right3;
     IF SQLM_KEYS_TempRow:SQLC_KEYS_Color3=1 THEN
      SQLM_KEYS_TempRow=
          SQLM_KEYS_OperRow:SQLC_KEYS_Left3;
      IF SQLM_KEYS_TempRow:SQLC_KEYS_Color3=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_KEYS_Brother:SQLC_KEYS_Color3=1 THEN
         SQLM_KEYS_TempRow=
             SQLM_KEYS_Brother:SQLC_KEYS_Right3;
         IF SQLM_KEYS_TempRow:SQLC_KEYS_Color3=1 THEN
          SQLM_KEYS_TempRow=
              SQLM_KEYS_Brother:SQLC_KEYS_Left3;
          IF SQLM_KEYS_TempRow:SQLC_KEYS_Color3=1 THEN
            SQLM_KEYS_OperRow:SQLC_KEYS_Color3=0;
            SQLM_KEYS_Brother:SQLC_KEYS_Color3=0;
            SQLM_KEYS_Father:SQLC_KEYS_Color3=1;
            GOTO L2towComDelKeyTableKey3_3;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_KEYS_Nephew:SQLC_KEYS_Color3=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_KEYS_Nephew:SQLC_KEYS_Color3=
                SQLM_KEYS_Father:SQLC_KEYS_Color3;
            IF SQLM_KEYS_Father:SQLC_KEYS_Left3=
               SQLM_KEYS_OperRow
            THEN
                SQLM_KEYS_Father:SQLC_KEYS_Right3=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Left3;
                SQLM_KEYS_Brother:SQLC_KEYS_Left3=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Right3;
                SQLM_KEYS_Nephew:SQLC_KEYS_Left3=
                    SQLM_KEYS_Father;
                SQLM_KEYS_Nephew:SQLC_KEYS_Right3=
                    SQLM_KEYS_Brother;
            ELSE
                SQLM_KEYS_Father:SQLC_KEYS_Left3=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Right3;
                SQLM_KEYS_Brother:SQLC_KEYS_Right3=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Left3;
                SQLM_KEYS_Nephew:SQLC_KEYS_Right3=
                    SQLM_KEYS_Father;
                SQLM_KEYS_Nephew:SQLC_KEYS_Left3=
                    SQLM_KEYS_Brother;
            FI;
            SQLM_KEYS_OperRow:SQLC_KEYS_Color3=0;
            SQLM_KEYS_Father:SQLC_KEYS_Color3=1;
            IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left3=
               SQLM_KEYS_Father
            THEN
                SQLM_KEYS_GrandFather:SQLC_KEYS_Left3=
                    SQLM_KEYS_Nephew;
            ELSE
                SQLM_KEYS_GrandFather:SQLC_KEYS_Right3=
                    SQLM_KEYS_Nephew;
            FI;
            SQLM_KEYS_GrandFather=SQLM_KEYS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_KEYS_Nephew:SQLC_KEYS_Color3=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_KEYS_Brother:SQLC_KEYS_Color3=
                SQLM_KEYS_Father:SQLC_KEYS_Color3;
            IF SQLM_KEYS_Father:SQLC_KEYS_Left3=
               SQLM_KEYS_OperRow
            THEN
                SQLM_KEYS_TempRow=
                    SQLM_KEYS_Brother:SQLC_KEYS_Right3;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color3=1;
                SQLM_KEYS_Father:SQLC_KEYS_Right3=
                    SQLM_KEYS_Brother:SQLC_KEYS_Left3;
                SQLM_KEYS_Brother:SQLC_KEYS_Left3=
                    SQLM_KEYS_Father;
            ELSE
                SQLM_KEYS_TempRow=
                    SQLM_KEYS_Brother:SQLC_KEYS_Left3;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color3=1;
                SQLM_KEYS_Father:SQLC_KEYS_Left3=
                    SQLM_KEYS_Brother:SQLC_KEYS_Right3;
                SQLM_KEYS_Brother:SQLC_KEYS_Right3=
                    SQLM_KEYS_Father;
            FI;
            SQLM_KEYS_OperRow:SQLC_KEYS_Color3=0;
            SQLM_KEYS_Father:SQLC_KEYS_Color3=1;
            IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left3=
                SQLM_KEYS_Father
            THEN
                SQLM_KEYS_GrandFather:SQLC_KEYS_Left3=
                    SQLM_KEYS_Brother;
            ELSE
                SQLM_KEYS_GrandFather:SQLC_KEYS_Right3=
                    SQLM_KEYS_Brother;
            FI;
            SQLM_KEYS_GrandFather=SQLM_KEYS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey3_3)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_KEYS_DeleteFather=SQLM_KEYS_GrandFather;
        SQLM_KEYS_Delete=SQLM_KEYS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey3_3;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey3_3)
    IF SQLM_KEYS_Delete /= SQLM_KEYS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_KEYS_DeleteFather:SQLC_KEYS_Left3=
           SQLM_KEYS_Delete
        THEN
            SQLM_KEYS_DeleteFather:SQLC_KEYS_Left3=
                SQLM_KEYS_Father;
        ELSE
            SQLM_KEYS_DeleteFather:SQLC_KEYS_Right3=
                SQLM_KEYS_Father;
        FI;
        IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left3=
           SQLM_KEYS_Father
        THEN
            SQLM_KEYS_GrandFather:SQLC_KEYS_Left3=
                SQLM_KEYS_NilRow;
        ELSE
            SQLM_KEYS_GrandFather:SQLC_KEYS_Right3=
                SQLM_KEYS_NilRow;
        FI;
        IF SQLM_KEYS_Father /= SQLM_KEYS_Delete THEN
            SQLM_KEYS_Father:SQLC_KEYS_Color3=
                SQLM_KEYS_Delete:SQLC_KEYS_Color3;
            SQLM_KEYS_Father:SQLC_KEYS_Right3=
                SQLM_KEYS_Delete:SQLC_KEYS_Right3;
            SQLM_KEYS_Father:SQLC_KEYS_Left3=
                SQLM_KEYS_Delete:SQLC_KEYS_Left3;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey3_4)
! Setup pointers !
    SQLM_KEYS_GrandFather=SQLX_GrandFather;
    SQLM_KEYS_Father=SQLX_Father;
    SQLM_KEYS_OperRow=SQLX_Current;
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
    SQLM_KEYS_DeleteFather=SQLX_DeleteFather;
    SQLM_KEYS_Delete=SQLX_Delete;
    SQLM_KEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey3_4)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_KEYS_GrandFather,
            SQLM_KEYS_Father,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_DeleteFather,
            SQLM_KEYS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_KEYS_OperRow=SQLM_KEYS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey3_4;
! Test key. !
    DO SQLS_KEYS_KeyTest4;
    IF SQLX_KeyTest = 1 THEN
        IF SQLM_KEYS_OperRow > SQLM_KEYS_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Move down to next node !
    SQLM_KEYS_GrandFather=SQLM_KEYS_Father;
    SQLM_KEYS_Father=SQLM_KEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_KEYS_OperRow=
            SQLM_KEYS_Father:SQLC_KEYS_Left4;
        SQLM_KEYS_Brother=
            SQLM_KEYS_Father:SQLC_KEYS_Right4;
    ELSE
        SQLM_KEYS_OperRow=
            SQLM_KEYS_Father:SQLC_KEYS_Right4;
        SQLM_KEYS_Brother=
            SQLM_KEYS_Father:SQLC_KEYS_Left4;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Color4 (*)
        SQLM_KEYS_Father:SQLC_KEYS_Color4 (*)
        (-) SQLM_KEYS_Brother:SQLC_KEYS_Color4 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_KEYS_Father:SQLC_KEYS_Color4=0;
        SQLM_KEYS_Brother:SQLC_KEYS_Color4=1;
        IF SQLM_KEYS_Father:SQLC_KEYS_Right4=
            SQLM_KEYS_Brother
        THEN
            SQLM_KEYS_Father:SQLC_KEYS_Right4=
                SQLM_KEYS_Brother:SQLC_KEYS_Left4;
            SQLM_KEYS_Brother:SQLC_KEYS_Left4=
                SQLM_KEYS_Father;
        ELSE
            SQLM_KEYS_Father:SQLC_KEYS_Left4=
                SQLM_KEYS_Brother:SQLC_KEYS_Right4;
            SQLM_KEYS_Brother:SQLC_KEYS_Right4=
                SQLM_KEYS_Father;
        FI;
        IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left4=
            SQLM_KEYS_Father
        THEN
            SQLM_KEYS_GrandFather:SQLC_KEYS_Left4=
                SQLM_KEYS_Brother;
        ELSE
            SQLM_KEYS_GrandFather:SQLC_KEYS_Right4=
                SQLM_KEYS_Brother;
        FI;
        SQLM_KEYS_GrandFather=SQLM_KEYS_Brother;
        IF SQLM_KEYS_Father:SQLC_KEYS_Left4=
            SQLM_KEYS_OperRow
        THEN
            SQLM_KEYS_Brother=
                SQLM_KEYS_Father:SQLC_KEYS_Right4;
        ELSE
            SQLM_KEYS_Brother=
                SQLM_KEYS_Father:SQLC_KEYS_Left4;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_KEYS_Father:SQLC_KEYS_Left4=
        SQLM_KEYS_OperRow
    THEN
        SQLM_KEYS_Nephew=
            SQLM_KEYS_Brother:SQLC_KEYS_Left4;
    ELSE
        SQLM_KEYS_Nephew=
            SQLM_KEYS_Brother:SQLC_KEYS_Right4;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_KEYS_OperRow:SQLC_KEYS_Color4=1 THEN
     SQLM_KEYS_TempRow=
         SQLM_KEYS_OperRow:SQLC_KEYS_Right4;
     IF SQLM_KEYS_TempRow:SQLC_KEYS_Color4=1 THEN
      SQLM_KEYS_TempRow=
          SQLM_KEYS_OperRow:SQLC_KEYS_Left4;
      IF SQLM_KEYS_TempRow:SQLC_KEYS_Color4=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_KEYS_Brother:SQLC_KEYS_Color4=1 THEN
         SQLM_KEYS_TempRow=
             SQLM_KEYS_Brother:SQLC_KEYS_Right4;
         IF SQLM_KEYS_TempRow:SQLC_KEYS_Color4=1 THEN
          SQLM_KEYS_TempRow=
              SQLM_KEYS_Brother:SQLC_KEYS_Left4;
          IF SQLM_KEYS_TempRow:SQLC_KEYS_Color4=1 THEN
            SQLM_KEYS_OperRow:SQLC_KEYS_Color4=0;
            SQLM_KEYS_Brother:SQLC_KEYS_Color4=0;
            SQLM_KEYS_Father:SQLC_KEYS_Color4=1;
            GOTO L2towComDelKeyTableKey3_4;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_KEYS_Nephew:SQLC_KEYS_Color4=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_KEYS_Nephew:SQLC_KEYS_Color4=
                SQLM_KEYS_Father:SQLC_KEYS_Color4;
            IF SQLM_KEYS_Father:SQLC_KEYS_Left4=
               SQLM_KEYS_OperRow
            THEN
                SQLM_KEYS_Father:SQLC_KEYS_Right4=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Left4;
                SQLM_KEYS_Brother:SQLC_KEYS_Left4=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Right4;
                SQLM_KEYS_Nephew:SQLC_KEYS_Left4=
                    SQLM_KEYS_Father;
                SQLM_KEYS_Nephew:SQLC_KEYS_Right4=
                    SQLM_KEYS_Brother;
            ELSE
                SQLM_KEYS_Father:SQLC_KEYS_Left4=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Right4;
                SQLM_KEYS_Brother:SQLC_KEYS_Right4=
                    SQLM_KEYS_Nephew:SQLC_KEYS_Left4;
                SQLM_KEYS_Nephew:SQLC_KEYS_Right4=
                    SQLM_KEYS_Father;
                SQLM_KEYS_Nephew:SQLC_KEYS_Left4=
                    SQLM_KEYS_Brother;
            FI;
            SQLM_KEYS_OperRow:SQLC_KEYS_Color4=0;
            SQLM_KEYS_Father:SQLC_KEYS_Color4=1;
            IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left4=
               SQLM_KEYS_Father
            THEN
                SQLM_KEYS_GrandFather:SQLC_KEYS_Left4=
                    SQLM_KEYS_Nephew;
            ELSE
                SQLM_KEYS_GrandFather:SQLC_KEYS_Right4=
                    SQLM_KEYS_Nephew;
            FI;
            SQLM_KEYS_GrandFather=SQLM_KEYS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_KEYS_Nephew:SQLC_KEYS_Color4=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_KEYS_Brother:SQLC_KEYS_Color4=
                SQLM_KEYS_Father:SQLC_KEYS_Color4;
            IF SQLM_KEYS_Father:SQLC_KEYS_Left4=
               SQLM_KEYS_OperRow
            THEN
                SQLM_KEYS_TempRow=
                    SQLM_KEYS_Brother:SQLC_KEYS_Right4;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color4=1;
                SQLM_KEYS_Father:SQLC_KEYS_Right4=
                    SQLM_KEYS_Brother:SQLC_KEYS_Left4;
                SQLM_KEYS_Brother:SQLC_KEYS_Left4=
                    SQLM_KEYS_Father;
            ELSE
                SQLM_KEYS_TempRow=
                    SQLM_KEYS_Brother:SQLC_KEYS_Left4;
                SQLM_KEYS_TempRow:SQLC_KEYS_Color4=1;
                SQLM_KEYS_Father:SQLC_KEYS_Left4=
                    SQLM_KEYS_Brother:SQLC_KEYS_Right4;
                SQLM_KEYS_Brother:SQLC_KEYS_Right4=
                    SQLM_KEYS_Father;
            FI;
            SQLM_KEYS_OperRow:SQLC_KEYS_Color4=0;
            SQLM_KEYS_Father:SQLC_KEYS_Color4=1;
            IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left4=
                SQLM_KEYS_Father
            THEN
                SQLM_KEYS_GrandFather:SQLC_KEYS_Left4=
                    SQLM_KEYS_Brother;
            ELSE
                SQLM_KEYS_GrandFather:SQLC_KEYS_Right4=
                    SQLM_KEYS_Brother;
            FI;
            SQLM_KEYS_GrandFather=SQLM_KEYS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey3_4)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_KEYS_DeleteFather=SQLM_KEYS_GrandFather;
        SQLM_KEYS_Delete=SQLM_KEYS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey3_4;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey3_4)
    IF SQLM_KEYS_Delete /= SQLM_KEYS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_KEYS_DeleteFather:SQLC_KEYS_Left4=
           SQLM_KEYS_Delete
        THEN
            SQLM_KEYS_DeleteFather:SQLC_KEYS_Left4=
                SQLM_KEYS_Father;
        ELSE
            SQLM_KEYS_DeleteFather:SQLC_KEYS_Right4=
                SQLM_KEYS_Father;
        FI;
        IF SQLM_KEYS_GrandFather:SQLC_KEYS_Left4=
           SQLM_KEYS_Father
        THEN
            SQLM_KEYS_GrandFather:SQLC_KEYS_Left4=
                SQLM_KEYS_NilRow;
        ELSE
            SQLM_KEYS_GrandFather:SQLC_KEYS_Right4=
                SQLM_KEYS_NilRow;
        FI;
        IF SQLM_KEYS_Father /= SQLM_KEYS_Delete THEN
            SQLM_KEYS_Father:SQLC_KEYS_Color4=
                SQLM_KEYS_Delete:SQLC_KEYS_Color4;
            SQLM_KEYS_Father:SQLC_KEYS_Right4=
                SQLM_KEYS_Delete:SQLC_KEYS_Right4;
            SQLM_KEYS_Father:SQLC_KEYS_Left4=
                SQLM_KEYS_Delete:SQLC_KEYS_Left4;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 4 DO
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComDelKeyTableKey4_2;
    WHEN 3 DO GOTO towComDelKeyTableKey4_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey4_2)
! Setup pointers !
    SQLM_KEYFIELDS_GrandFather=SQLX_GrandFather;
    SQLM_KEYFIELDS_Father=SQLX_Father;
    SQLM_KEYFIELDS_OperRow=SQLX_Current;
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_KEYFIELDS_DeleteFather=SQLX_DeleteFather;
    SQLM_KEYFIELDS_Delete=SQLX_Delete;
    SQLM_KEYFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey4_2)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_KEYFIELDS_GrandFather,
            SQLM_KEYFIELDS_Father,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_DeleteFather,
            SQLM_KEYFIELDS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_KEYFIELDS_OperRow=SQLM_KEYFIELDS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey4_2;
! Test key. !
    DO SQLS_KEYFIELDS_KeyTest2;
! Move down to next node !
    SQLM_KEYFIELDS_GrandFather=SQLM_KEYFIELDS_Father;
    SQLM_KEYFIELDS_Father=SQLM_KEYFIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_KEYFIELDS_OperRow=
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2;
        SQLM_KEYFIELDS_Brother=
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2;
    ELSE
        SQLM_KEYFIELDS_OperRow=
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2;
        SQLM_KEYFIELDS_Brother=
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2 (*)
        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color2 (*)
        (-) SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Color2 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color2=0;
        SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Color2=1;
        IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2=
            SQLM_KEYFIELDS_Brother
        THEN
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2=
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left2;
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left2=
                SQLM_KEYFIELDS_Father;
        ELSE
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2=
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right2;
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right2=
                SQLM_KEYFIELDS_Father;
        FI;
        IF SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left2=
            SQLM_KEYFIELDS_Father
        THEN
            SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left2=
                SQLM_KEYFIELDS_Brother;
        ELSE
            SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Right2=
                SQLM_KEYFIELDS_Brother;
        FI;
        SQLM_KEYFIELDS_GrandFather=SQLM_KEYFIELDS_Brother;
        IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2=
            SQLM_KEYFIELDS_OperRow
        THEN
            SQLM_KEYFIELDS_Brother=
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2;
        ELSE
            SQLM_KEYFIELDS_Brother=
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2=
        SQLM_KEYFIELDS_OperRow
    THEN
        SQLM_KEYFIELDS_Nephew=
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left2;
    ELSE
        SQLM_KEYFIELDS_Nephew=
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right2;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2=1 THEN
     SQLM_KEYFIELDS_TempRow=
         SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
     IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2=1 THEN
      SQLM_KEYFIELDS_TempRow=
          SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
      IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Color2=1 THEN
         SQLM_KEYFIELDS_TempRow=
             SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right2;
         IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2=1 THEN
          SQLM_KEYFIELDS_TempRow=
              SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left2;
          IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2=1 THEN
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2=0;
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Color2=0;
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color2=1;
            GOTO L2towComDelKeyTableKey4_2;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Color2=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Color2=
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color2;
            IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2=
               SQLM_KEYFIELDS_OperRow
            THEN
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Left2;
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Right2;
                SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_Father;
                SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_Brother;
            ELSE
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Right2;
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Left2;
                SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_Father;
                SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_Brother;
            FI;
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2=0;
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color2=1;
            IF SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left2=
               SQLM_KEYFIELDS_Father
            THEN
                SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_Nephew;
            ELSE
                SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_Nephew;
            FI;
            SQLM_KEYFIELDS_GrandFather=SQLM_KEYFIELDS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Color2=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Color2=
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color2;
            IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2=
               SQLM_KEYFIELDS_OperRow
            THEN
                SQLM_KEYFIELDS_TempRow=
                    SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right2;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2=1;
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left2;
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_Father;
            ELSE
                SQLM_KEYFIELDS_TempRow=
                    SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left2;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color2=1;
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right2;
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_Father;
            FI;
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color2=0;
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color2=1;
            IF SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left2=
                SQLM_KEYFIELDS_Father
            THEN
                SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left2=
                    SQLM_KEYFIELDS_Brother;
            ELSE
                SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Right2=
                    SQLM_KEYFIELDS_Brother;
            FI;
            SQLM_KEYFIELDS_GrandFather=SQLM_KEYFIELDS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey4_2)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_KEYFIELDS_DeleteFather=SQLM_KEYFIELDS_GrandFather;
        SQLM_KEYFIELDS_Delete=SQLM_KEYFIELDS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey4_2;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey4_2)
    IF SQLM_KEYFIELDS_Delete /= SQLM_KEYFIELDS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_KEYFIELDS_DeleteFather:SQLC_KEYFIELDS_Left2=
           SQLM_KEYFIELDS_Delete
        THEN
            SQLM_KEYFIELDS_DeleteFather:SQLC_KEYFIELDS_Left2=
                SQLM_KEYFIELDS_Father;
        ELSE
            SQLM_KEYFIELDS_DeleteFather:SQLC_KEYFIELDS_Right2=
                SQLM_KEYFIELDS_Father;
        FI;
        IF SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left2=
           SQLM_KEYFIELDS_Father
        THEN
            SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left2=
                SQLM_KEYFIELDS_NilRow;
        ELSE
            SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Right2=
                SQLM_KEYFIELDS_NilRow;
        FI;
        IF SQLM_KEYFIELDS_Father /= SQLM_KEYFIELDS_Delete THEN
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color2=
                SQLM_KEYFIELDS_Delete:SQLC_KEYFIELDS_Color2;
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right2=
                SQLM_KEYFIELDS_Delete:SQLC_KEYFIELDS_Right2;
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left2=
                SQLM_KEYFIELDS_Delete:SQLC_KEYFIELDS_Left2;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
        SQLM_KEYFIELDS_OperRow=SQLM_KEYFIELDS_Delete;
        SQLM_KEYFIELDS_GuardRow= SQLM_TableReference:SQLM_System;
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2;
SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2 =
    SQLM_KEYFIELDS_OperRow;
        SQLM_KEYFIELDS_Delete:SQLC_KEYFIELDS_Allocated=0;
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey4_3)
! Setup pointers !
    SQLM_KEYFIELDS_GrandFather=SQLX_GrandFather;
    SQLM_KEYFIELDS_Father=SQLX_Father;
    SQLM_KEYFIELDS_OperRow=SQLX_Current;
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_KEYFIELDS_DeleteFather=SQLX_DeleteFather;
    SQLM_KEYFIELDS_Delete=SQLX_Delete;
    SQLM_KEYFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey4_3)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_KEYFIELDS_GrandFather,
            SQLM_KEYFIELDS_Father,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_DeleteFather,
            SQLM_KEYFIELDS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_KEYFIELDS_OperRow=SQLM_KEYFIELDS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey4_3;
! Test key. !
    DO SQLS_KEYFIELDS_KeyTest3;
! Move down to next node !
    SQLM_KEYFIELDS_GrandFather=SQLM_KEYFIELDS_Father;
    SQLM_KEYFIELDS_Father=SQLM_KEYFIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_KEYFIELDS_OperRow=
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3;
        SQLM_KEYFIELDS_Brother=
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3;
    ELSE
        SQLM_KEYFIELDS_OperRow=
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3;
        SQLM_KEYFIELDS_Brother=
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3 (*)
        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color3 (*)
        (-) SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Color3 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color3=0;
        SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Color3=1;
        IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3=
            SQLM_KEYFIELDS_Brother
        THEN
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3=
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left3;
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left3=
                SQLM_KEYFIELDS_Father;
        ELSE
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3=
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right3;
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right3=
                SQLM_KEYFIELDS_Father;
        FI;
        IF SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left3=
            SQLM_KEYFIELDS_Father
        THEN
            SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left3=
                SQLM_KEYFIELDS_Brother;
        ELSE
            SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Right3=
                SQLM_KEYFIELDS_Brother;
        FI;
        SQLM_KEYFIELDS_GrandFather=SQLM_KEYFIELDS_Brother;
        IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3=
            SQLM_KEYFIELDS_OperRow
        THEN
            SQLM_KEYFIELDS_Brother=
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3;
        ELSE
            SQLM_KEYFIELDS_Brother=
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3=
        SQLM_KEYFIELDS_OperRow
    THEN
        SQLM_KEYFIELDS_Nephew=
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left3;
    ELSE
        SQLM_KEYFIELDS_Nephew=
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right3;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3=1 THEN
     SQLM_KEYFIELDS_TempRow=
         SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3;
     IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3=1 THEN
      SQLM_KEYFIELDS_TempRow=
          SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3;
      IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Color3=1 THEN
         SQLM_KEYFIELDS_TempRow=
             SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right3;
         IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3=1 THEN
          SQLM_KEYFIELDS_TempRow=
              SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left3;
          IF SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3=1 THEN
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3=0;
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Color3=0;
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color3=1;
            GOTO L2towComDelKeyTableKey4_3;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Color3=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Color3=
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color3;
            IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3=
               SQLM_KEYFIELDS_OperRow
            THEN
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Left3;
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Right3;
                SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_Father;
                SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_Brother;
            ELSE
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Right3;
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Left3;
                SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_Father;
                SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_Brother;
            FI;
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3=0;
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color3=1;
            IF SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left3=
               SQLM_KEYFIELDS_Father
            THEN
                SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_Nephew;
            ELSE
                SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_Nephew;
            FI;
            SQLM_KEYFIELDS_GrandFather=SQLM_KEYFIELDS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_KEYFIELDS_Nephew:SQLC_KEYFIELDS_Color3=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Color3=
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color3;
            IF SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3=
               SQLM_KEYFIELDS_OperRow
            THEN
                SQLM_KEYFIELDS_TempRow=
                    SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right3;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3=1;
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left3;
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_Father;
            ELSE
                SQLM_KEYFIELDS_TempRow=
                    SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Left3;
                SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Color3=1;
                SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right3;
                SQLM_KEYFIELDS_Brother:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_Father;
            FI;
            SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Color3=0;
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color3=1;
            IF SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left3=
                SQLM_KEYFIELDS_Father
            THEN
                SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left3=
                    SQLM_KEYFIELDS_Brother;
            ELSE
                SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Right3=
                    SQLM_KEYFIELDS_Brother;
            FI;
            SQLM_KEYFIELDS_GrandFather=SQLM_KEYFIELDS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey4_3)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_KEYFIELDS_DeleteFather=SQLM_KEYFIELDS_GrandFather;
        SQLM_KEYFIELDS_Delete=SQLM_KEYFIELDS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey4_3;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey4_3)
    IF SQLM_KEYFIELDS_Delete /= SQLM_KEYFIELDS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_KEYFIELDS_DeleteFather:SQLC_KEYFIELDS_Left3=
           SQLM_KEYFIELDS_Delete
        THEN
            SQLM_KEYFIELDS_DeleteFather:SQLC_KEYFIELDS_Left3=
                SQLM_KEYFIELDS_Father;
        ELSE
            SQLM_KEYFIELDS_DeleteFather:SQLC_KEYFIELDS_Right3=
                SQLM_KEYFIELDS_Father;
        FI;
        IF SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left3=
           SQLM_KEYFIELDS_Father
        THEN
            SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Left3=
                SQLM_KEYFIELDS_NilRow;
        ELSE
            SQLM_KEYFIELDS_GrandFather:SQLC_KEYFIELDS_Right3=
                SQLM_KEYFIELDS_NilRow;
        FI;
        IF SQLM_KEYFIELDS_Father /= SQLM_KEYFIELDS_Delete THEN
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Color3=
                SQLM_KEYFIELDS_Delete:SQLC_KEYFIELDS_Color3;
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Right3=
                SQLM_KEYFIELDS_Delete:SQLC_KEYFIELDS_Right3;
            SQLM_KEYFIELDS_Father:SQLC_KEYFIELDS_Left3=
                SQLM_KEYFIELDS_Delete:SQLC_KEYFIELDS_Left3;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 5 DO
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComDelKeyTableKey5_2;
    WHEN 3 DO GOTO towComDelKeyTableKey5_3;
    WHEN 4 DO GOTO towComDelKeyTableKey5_4;
    WHEN 5 DO GOTO towComDelKeyTableKey5_5;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey5_2)
! Setup pointers !
    SQLM_FOREIGNKEYS_GrandFather=SQLX_GrandFather;
    SQLM_FOREIGNKEYS_Father=SQLX_Father;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Current;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_DeleteFather=SQLX_DeleteFather;
    SQLM_FOREIGNKEYS_Delete=SQLX_Delete;
    SQLM_FOREIGNKEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey5_2)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FOREIGNKEYS_GrandFather,
            SQLM_FOREIGNKEYS_Father,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_DeleteFather,
            SQLM_FOREIGNKEYS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_FOREIGNKEYS_OperRow=SQLM_FOREIGNKEYS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey5_2;
! Test key. !
    DO SQLS_FOREIGNKEYS_KeyTest2;
! Move down to next node !
    SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Father;
    SQLM_FOREIGNKEYS_Father=SQLM_FOREIGNKEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FOREIGNKEYS_OperRow=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2;
        SQLM_FOREIGNKEYS_Brother=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2;
    ELSE
        SQLM_FOREIGNKEYS_OperRow=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2;
        SQLM_FOREIGNKEYS_Brother=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2 (*)
        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color2 (*)
        (-) SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color2 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color2=0;
        SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color2=1;
        IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2=
            SQLM_FOREIGNKEYS_Brother
        THEN
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2=
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left2;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left2=
                SQLM_FOREIGNKEYS_Father;
        ELSE
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2=
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right2;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right2=
                SQLM_FOREIGNKEYS_Father;
        FI;
        IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left2=
            SQLM_FOREIGNKEYS_Father
        THEN
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left2=
                SQLM_FOREIGNKEYS_Brother;
        ELSE
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right2=
                SQLM_FOREIGNKEYS_Brother;
        FI;
        SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Brother;
        IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2=
            SQLM_FOREIGNKEYS_OperRow
        THEN
            SQLM_FOREIGNKEYS_Brother=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2;
        ELSE
            SQLM_FOREIGNKEYS_Brother=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2=
        SQLM_FOREIGNKEYS_OperRow
    THEN
        SQLM_FOREIGNKEYS_Nephew=
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left2;
    ELSE
        SQLM_FOREIGNKEYS_Nephew=
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right2;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2=1 THEN
     SQLM_FOREIGNKEYS_TempRow=
         SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
     IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2=1 THEN
      SQLM_FOREIGNKEYS_TempRow=
          SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
      IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color2=1 THEN
         SQLM_FOREIGNKEYS_TempRow=
             SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right2;
         IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2=1 THEN
          SQLM_FOREIGNKEYS_TempRow=
              SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left2;
          IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2=1 THEN
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2=0;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color2=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color2=1;
            GOTO L2towComDelKeyTableKey5_2;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color2=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color2=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color2;
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2=
               SQLM_FOREIGNKEYS_OperRow
            THEN
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left2;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right2;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_Brother;
            ELSE
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right2;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left2;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_Brother;
            FI;
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color2=1;
            IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left2=
               SQLM_FOREIGNKEYS_Father
            THEN
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_Nephew;
            ELSE
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_Nephew;
            FI;
            SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color2=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color2=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color2;
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2=
               SQLM_FOREIGNKEYS_OperRow
            THEN
                SQLM_FOREIGNKEYS_TempRow=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right2;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2=1;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left2;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_Father;
            ELSE
                SQLM_FOREIGNKEYS_TempRow=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left2;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color2=1;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right2;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_Father;
            FI;
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color2=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color2=1;
            IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left2=
                SQLM_FOREIGNKEYS_Father
            THEN
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left2=
                    SQLM_FOREIGNKEYS_Brother;
            ELSE
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right2=
                    SQLM_FOREIGNKEYS_Brother;
            FI;
            SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey5_2)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_FOREIGNKEYS_DeleteFather=SQLM_FOREIGNKEYS_GrandFather;
        SQLM_FOREIGNKEYS_Delete=SQLM_FOREIGNKEYS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey5_2;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey5_2)
    IF SQLM_FOREIGNKEYS_Delete /= SQLM_FOREIGNKEYS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Left2=
           SQLM_FOREIGNKEYS_Delete
        THEN
            SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Left2=
                SQLM_FOREIGNKEYS_Father;
        ELSE
            SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Right2=
                SQLM_FOREIGNKEYS_Father;
        FI;
        IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left2=
           SQLM_FOREIGNKEYS_Father
        THEN
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left2=
                SQLM_FOREIGNKEYS_NilRow;
        ELSE
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right2=
                SQLM_FOREIGNKEYS_NilRow;
        FI;
        IF SQLM_FOREIGNKEYS_Father /= SQLM_FOREIGNKEYS_Delete THEN
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color2=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Color2;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right2=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Right2;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left2=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Left2;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
        SQLM_FOREIGNKEYS_OperRow=SQLM_FOREIGNKEYS_Delete;
        SQLM_FOREIGNKEYS_GuardRow= SQLM_TableReference:SQLM_System;
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2;
SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2 =
    SQLM_FOREIGNKEYS_OperRow;
        SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Allocated=0;
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey5_3)
! Setup pointers !
    SQLM_FOREIGNKEYS_GrandFather=SQLX_GrandFather;
    SQLM_FOREIGNKEYS_Father=SQLX_Father;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Current;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_DeleteFather=SQLX_DeleteFather;
    SQLM_FOREIGNKEYS_Delete=SQLX_Delete;
    SQLM_FOREIGNKEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey5_3)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FOREIGNKEYS_GrandFather,
            SQLM_FOREIGNKEYS_Father,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_DeleteFather,
            SQLM_FOREIGNKEYS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_FOREIGNKEYS_OperRow=SQLM_FOREIGNKEYS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey5_3;
! Test key. !
    DO SQLS_FOREIGNKEYS_KeyTest3;
! Move down to next node !
    SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Father;
    SQLM_FOREIGNKEYS_Father=SQLM_FOREIGNKEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FOREIGNKEYS_OperRow=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3;
        SQLM_FOREIGNKEYS_Brother=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3;
    ELSE
        SQLM_FOREIGNKEYS_OperRow=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3;
        SQLM_FOREIGNKEYS_Brother=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3 (*)
        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color3 (*)
        (-) SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color3 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color3=0;
        SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color3=1;
        IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3=
            SQLM_FOREIGNKEYS_Brother
        THEN
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3=
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left3;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left3=
                SQLM_FOREIGNKEYS_Father;
        ELSE
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3=
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right3;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right3=
                SQLM_FOREIGNKEYS_Father;
        FI;
        IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left3=
            SQLM_FOREIGNKEYS_Father
        THEN
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left3=
                SQLM_FOREIGNKEYS_Brother;
        ELSE
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right3=
                SQLM_FOREIGNKEYS_Brother;
        FI;
        SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Brother;
        IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3=
            SQLM_FOREIGNKEYS_OperRow
        THEN
            SQLM_FOREIGNKEYS_Brother=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3;
        ELSE
            SQLM_FOREIGNKEYS_Brother=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3=
        SQLM_FOREIGNKEYS_OperRow
    THEN
        SQLM_FOREIGNKEYS_Nephew=
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left3;
    ELSE
        SQLM_FOREIGNKEYS_Nephew=
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right3;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3=1 THEN
     SQLM_FOREIGNKEYS_TempRow=
         SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3;
     IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3=1 THEN
      SQLM_FOREIGNKEYS_TempRow=
          SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3;
      IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color3=1 THEN
         SQLM_FOREIGNKEYS_TempRow=
             SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right3;
         IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3=1 THEN
          SQLM_FOREIGNKEYS_TempRow=
              SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left3;
          IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3=1 THEN
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3=0;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color3=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color3=1;
            GOTO L2towComDelKeyTableKey5_3;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color3=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color3=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color3;
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3=
               SQLM_FOREIGNKEYS_OperRow
            THEN
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left3;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right3;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_Brother;
            ELSE
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right3;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left3;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_Brother;
            FI;
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color3=1;
            IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left3=
               SQLM_FOREIGNKEYS_Father
            THEN
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_Nephew;
            ELSE
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_Nephew;
            FI;
            SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color3=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color3=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color3;
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3=
               SQLM_FOREIGNKEYS_OperRow
            THEN
                SQLM_FOREIGNKEYS_TempRow=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right3;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3=1;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left3;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_Father;
            ELSE
                SQLM_FOREIGNKEYS_TempRow=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left3;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color3=1;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right3;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_Father;
            FI;
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color3=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color3=1;
            IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left3=
                SQLM_FOREIGNKEYS_Father
            THEN
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left3=
                    SQLM_FOREIGNKEYS_Brother;
            ELSE
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right3=
                    SQLM_FOREIGNKEYS_Brother;
            FI;
            SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey5_3)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_FOREIGNKEYS_DeleteFather=SQLM_FOREIGNKEYS_GrandFather;
        SQLM_FOREIGNKEYS_Delete=SQLM_FOREIGNKEYS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey5_3;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey5_3)
    IF SQLM_FOREIGNKEYS_Delete /= SQLM_FOREIGNKEYS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Left3=
           SQLM_FOREIGNKEYS_Delete
        THEN
            SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Left3=
                SQLM_FOREIGNKEYS_Father;
        ELSE
            SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Right3=
                SQLM_FOREIGNKEYS_Father;
        FI;
        IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left3=
           SQLM_FOREIGNKEYS_Father
        THEN
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left3=
                SQLM_FOREIGNKEYS_NilRow;
        ELSE
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right3=
                SQLM_FOREIGNKEYS_NilRow;
        FI;
        IF SQLM_FOREIGNKEYS_Father /= SQLM_FOREIGNKEYS_Delete THEN
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color3=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Color3;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right3=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Right3;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left3=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Left3;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey5_4)
! Setup pointers !
    SQLM_FOREIGNKEYS_GrandFather=SQLX_GrandFather;
    SQLM_FOREIGNKEYS_Father=SQLX_Father;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Current;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_DeleteFather=SQLX_DeleteFather;
    SQLM_FOREIGNKEYS_Delete=SQLX_Delete;
    SQLM_FOREIGNKEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey5_4)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FOREIGNKEYS_GrandFather,
            SQLM_FOREIGNKEYS_Father,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_DeleteFather,
            SQLM_FOREIGNKEYS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_FOREIGNKEYS_OperRow=SQLM_FOREIGNKEYS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey5_4;
! Test key. !
    DO SQLS_FOREIGNKEYS_KeyTest4;
    IF SQLX_KeyTest = 1 THEN
        IF SQLM_FOREIGNKEYS_OperRow > SQLM_FOREIGNKEYS_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Move down to next node !
    SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Father;
    SQLM_FOREIGNKEYS_Father=SQLM_FOREIGNKEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FOREIGNKEYS_OperRow=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4;
        SQLM_FOREIGNKEYS_Brother=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4;
    ELSE
        SQLM_FOREIGNKEYS_OperRow=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4;
        SQLM_FOREIGNKEYS_Brother=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4 (*)
        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color4 (*)
        (-) SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color4 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color4=0;
        SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color4=1;
        IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4=
            SQLM_FOREIGNKEYS_Brother
        THEN
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4=
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left4;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left4=
                SQLM_FOREIGNKEYS_Father;
        ELSE
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4=
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right4;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right4=
                SQLM_FOREIGNKEYS_Father;
        FI;
        IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left4=
            SQLM_FOREIGNKEYS_Father
        THEN
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left4=
                SQLM_FOREIGNKEYS_Brother;
        ELSE
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right4=
                SQLM_FOREIGNKEYS_Brother;
        FI;
        SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Brother;
        IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4=
            SQLM_FOREIGNKEYS_OperRow
        THEN
            SQLM_FOREIGNKEYS_Brother=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4;
        ELSE
            SQLM_FOREIGNKEYS_Brother=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4=
        SQLM_FOREIGNKEYS_OperRow
    THEN
        SQLM_FOREIGNKEYS_Nephew=
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left4;
    ELSE
        SQLM_FOREIGNKEYS_Nephew=
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right4;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4=1 THEN
     SQLM_FOREIGNKEYS_TempRow=
         SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4;
     IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4=1 THEN
      SQLM_FOREIGNKEYS_TempRow=
          SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4;
      IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color4=1 THEN
         SQLM_FOREIGNKEYS_TempRow=
             SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right4;
         IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4=1 THEN
          SQLM_FOREIGNKEYS_TempRow=
              SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left4;
          IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4=1 THEN
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4=0;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color4=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color4=1;
            GOTO L2towComDelKeyTableKey5_4;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color4=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color4=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color4;
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4=
               SQLM_FOREIGNKEYS_OperRow
            THEN
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left4;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right4;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_Brother;
            ELSE
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right4;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left4;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_Brother;
            FI;
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color4=1;
            IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left4=
               SQLM_FOREIGNKEYS_Father
            THEN
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_Nephew;
            ELSE
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_Nephew;
            FI;
            SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color4=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color4=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color4;
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4=
               SQLM_FOREIGNKEYS_OperRow
            THEN
                SQLM_FOREIGNKEYS_TempRow=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right4;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4=1;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left4;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_Father;
            ELSE
                SQLM_FOREIGNKEYS_TempRow=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left4;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color4=1;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right4;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_Father;
            FI;
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color4=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color4=1;
            IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left4=
                SQLM_FOREIGNKEYS_Father
            THEN
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left4=
                    SQLM_FOREIGNKEYS_Brother;
            ELSE
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right4=
                    SQLM_FOREIGNKEYS_Brother;
            FI;
            SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey5_4)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_FOREIGNKEYS_DeleteFather=SQLM_FOREIGNKEYS_GrandFather;
        SQLM_FOREIGNKEYS_Delete=SQLM_FOREIGNKEYS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey5_4;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey5_4)
    IF SQLM_FOREIGNKEYS_Delete /= SQLM_FOREIGNKEYS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Left4=
           SQLM_FOREIGNKEYS_Delete
        THEN
            SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Left4=
                SQLM_FOREIGNKEYS_Father;
        ELSE
            SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Right4=
                SQLM_FOREIGNKEYS_Father;
        FI;
        IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left4=
           SQLM_FOREIGNKEYS_Father
        THEN
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left4=
                SQLM_FOREIGNKEYS_NilRow;
        ELSE
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right4=
                SQLM_FOREIGNKEYS_NilRow;
        FI;
        IF SQLM_FOREIGNKEYS_Father /= SQLM_FOREIGNKEYS_Delete THEN
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color4=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Color4;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right4=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Right4;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left4=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Left4;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey5_5)
! Setup pointers !
    SQLM_FOREIGNKEYS_GrandFather=SQLX_GrandFather;
    SQLM_FOREIGNKEYS_Father=SQLX_Father;
    SQLM_FOREIGNKEYS_OperRow=SQLX_Current;
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
    SQLM_FOREIGNKEYS_DeleteFather=SQLX_DeleteFather;
    SQLM_FOREIGNKEYS_Delete=SQLX_Delete;
    SQLM_FOREIGNKEYS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey5_5)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_FOREIGNKEYS_GrandFather,
            SQLM_FOREIGNKEYS_Father,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_DeleteFather,
            SQLM_FOREIGNKEYS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_FOREIGNKEYS_OperRow=SQLM_FOREIGNKEYS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey5_5;
! Test key. !
    DO SQLS_FOREIGNKEYS_KeyTest5;
    IF SQLX_KeyTest = 1 THEN
        IF SQLM_FOREIGNKEYS_OperRow > SQLM_FOREIGNKEYS_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Move down to next node !
    SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Father;
    SQLM_FOREIGNKEYS_Father=SQLM_FOREIGNKEYS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_FOREIGNKEYS_OperRow=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5;
        SQLM_FOREIGNKEYS_Brother=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5;
    ELSE
        SQLM_FOREIGNKEYS_OperRow=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5;
        SQLM_FOREIGNKEYS_Brother=
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5 (*)
        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color5 (*)
        (-) SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color5 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color5=0;
        SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color5=1;
        IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5=
            SQLM_FOREIGNKEYS_Brother
        THEN
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5=
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left5;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left5=
                SQLM_FOREIGNKEYS_Father;
        ELSE
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5=
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right5;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right5=
                SQLM_FOREIGNKEYS_Father;
        FI;
        IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left5=
            SQLM_FOREIGNKEYS_Father
        THEN
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left5=
                SQLM_FOREIGNKEYS_Brother;
        ELSE
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right5=
                SQLM_FOREIGNKEYS_Brother;
        FI;
        SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Brother;
        IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5=
            SQLM_FOREIGNKEYS_OperRow
        THEN
            SQLM_FOREIGNKEYS_Brother=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5;
        ELSE
            SQLM_FOREIGNKEYS_Brother=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5=
        SQLM_FOREIGNKEYS_OperRow
    THEN
        SQLM_FOREIGNKEYS_Nephew=
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left5;
    ELSE
        SQLM_FOREIGNKEYS_Nephew=
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right5;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5=1 THEN
     SQLM_FOREIGNKEYS_TempRow=
         SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5;
     IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5=1 THEN
      SQLM_FOREIGNKEYS_TempRow=
          SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5;
      IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color5=1 THEN
         SQLM_FOREIGNKEYS_TempRow=
             SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right5;
         IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5=1 THEN
          SQLM_FOREIGNKEYS_TempRow=
              SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left5;
          IF SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5=1 THEN
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5=0;
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color5=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color5=1;
            GOTO L2towComDelKeyTableKey5_5;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color5=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color5=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color5;
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5=
               SQLM_FOREIGNKEYS_OperRow
            THEN
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left5;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right5;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_Brother;
            ELSE
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right5;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left5;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_Father;
                SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_Brother;
            FI;
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color5=1;
            IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left5=
               SQLM_FOREIGNKEYS_Father
            THEN
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_Nephew;
            ELSE
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_Nephew;
            FI;
            SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_FOREIGNKEYS_Nephew:SQLC_FOREIGNKEYS_Color5=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Color5=
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color5;
            IF SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5=
               SQLM_FOREIGNKEYS_OperRow
            THEN
                SQLM_FOREIGNKEYS_TempRow=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right5;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5=1;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left5;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_Father;
            ELSE
                SQLM_FOREIGNKEYS_TempRow=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Left5;
                SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Color5=1;
                SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right5;
                SQLM_FOREIGNKEYS_Brother:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_Father;
            FI;
            SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Color5=0;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color5=1;
            IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left5=
                SQLM_FOREIGNKEYS_Father
            THEN
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left5=
                    SQLM_FOREIGNKEYS_Brother;
            ELSE
                SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right5=
                    SQLM_FOREIGNKEYS_Brother;
            FI;
            SQLM_FOREIGNKEYS_GrandFather=SQLM_FOREIGNKEYS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey5_5)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_FOREIGNKEYS_DeleteFather=SQLM_FOREIGNKEYS_GrandFather;
        SQLM_FOREIGNKEYS_Delete=SQLM_FOREIGNKEYS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey5_5;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey5_5)
    IF SQLM_FOREIGNKEYS_Delete /= SQLM_FOREIGNKEYS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Left5=
           SQLM_FOREIGNKEYS_Delete
        THEN
            SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Left5=
                SQLM_FOREIGNKEYS_Father;
        ELSE
            SQLM_FOREIGNKEYS_DeleteFather:SQLC_FOREIGNKEYS_Right5=
                SQLM_FOREIGNKEYS_Father;
        FI;
        IF SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left5=
           SQLM_FOREIGNKEYS_Father
        THEN
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Left5=
                SQLM_FOREIGNKEYS_NilRow;
        ELSE
            SQLM_FOREIGNKEYS_GrandFather:SQLC_FOREIGNKEYS_Right5=
                SQLM_FOREIGNKEYS_NilRow;
        FI;
        IF SQLM_FOREIGNKEYS_Father /= SQLM_FOREIGNKEYS_Delete THEN
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Color5=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Color5;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Right5=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Right5;
            SQLM_FOREIGNKEYS_Father:SQLC_FOREIGNKEYS_Left5=
                SQLM_FOREIGNKEYS_Delete:SQLC_FOREIGNKEYS_Left5;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 6 DO
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComDelKeyTableKey6_2;
    WHEN 3 DO GOTO towComDelKeyTableKey6_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey6_2)
! Setup pointers !
    SQLM_SYMBOLS_GrandFather=SQLX_GrandFather;
    SQLM_SYMBOLS_Father=SQLX_Father;
    SQLM_SYMBOLS_OperRow=SQLX_Current;
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    SQLM_SYMBOLS_DeleteFather=SQLX_DeleteFather;
    SQLM_SYMBOLS_Delete=SQLX_Delete;
    SQLM_SYMBOLS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey6_2)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_SYMBOLS_GrandFather,
            SQLM_SYMBOLS_Father,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_DeleteFather,
            SQLM_SYMBOLS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_SYMBOLS_OperRow=SQLM_SYMBOLS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey6_2;
! Test key. !
    DO SQLS_SYMBOLS_KeyTest2;
! Move down to next node !
    SQLM_SYMBOLS_GrandFather=SQLM_SYMBOLS_Father;
    SQLM_SYMBOLS_Father=SQLM_SYMBOLS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_SYMBOLS_OperRow=
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2;
        SQLM_SYMBOLS_Brother=
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2;
    ELSE
        SQLM_SYMBOLS_OperRow=
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2;
        SQLM_SYMBOLS_Brother=
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2 (*)
        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color2 (*)
        (-) SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Color2 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color2=0;
        SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Color2=1;
        IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2=
            SQLM_SYMBOLS_Brother
        THEN
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2=
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left2;
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left2=
                SQLM_SYMBOLS_Father;
        ELSE
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2=
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right2;
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right2=
                SQLM_SYMBOLS_Father;
        FI;
        IF SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left2=
            SQLM_SYMBOLS_Father
        THEN
            SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left2=
                SQLM_SYMBOLS_Brother;
        ELSE
            SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Right2=
                SQLM_SYMBOLS_Brother;
        FI;
        SQLM_SYMBOLS_GrandFather=SQLM_SYMBOLS_Brother;
        IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2=
            SQLM_SYMBOLS_OperRow
        THEN
            SQLM_SYMBOLS_Brother=
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2;
        ELSE
            SQLM_SYMBOLS_Brother=
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2=
        SQLM_SYMBOLS_OperRow
    THEN
        SQLM_SYMBOLS_Nephew=
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left2;
    ELSE
        SQLM_SYMBOLS_Nephew=
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right2;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2=1 THEN
     SQLM_SYMBOLS_TempRow=
         SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
     IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2=1 THEN
      SQLM_SYMBOLS_TempRow=
          SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
      IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Color2=1 THEN
         SQLM_SYMBOLS_TempRow=
             SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right2;
         IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2=1 THEN
          SQLM_SYMBOLS_TempRow=
              SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left2;
          IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2=1 THEN
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2=0;
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Color2=0;
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color2=1;
            GOTO L2towComDelKeyTableKey6_2;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Color2=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Color2=
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color2;
            IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2=
               SQLM_SYMBOLS_OperRow
            THEN
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Left2;
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Right2;
                SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_Father;
                SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_Brother;
            ELSE
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Right2;
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Left2;
                SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_Father;
                SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_Brother;
            FI;
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2=0;
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color2=1;
            IF SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left2=
               SQLM_SYMBOLS_Father
            THEN
                SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_Nephew;
            ELSE
                SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_Nephew;
            FI;
            SQLM_SYMBOLS_GrandFather=SQLM_SYMBOLS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Color2=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Color2=
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color2;
            IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2=
               SQLM_SYMBOLS_OperRow
            THEN
                SQLM_SYMBOLS_TempRow=
                    SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right2;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2=1;
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left2;
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_Father;
            ELSE
                SQLM_SYMBOLS_TempRow=
                    SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left2;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color2=1;
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right2;
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_Father;
            FI;
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color2=0;
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color2=1;
            IF SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left2=
                SQLM_SYMBOLS_Father
            THEN
                SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left2=
                    SQLM_SYMBOLS_Brother;
            ELSE
                SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Right2=
                    SQLM_SYMBOLS_Brother;
            FI;
            SQLM_SYMBOLS_GrandFather=SQLM_SYMBOLS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey6_2)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_SYMBOLS_DeleteFather=SQLM_SYMBOLS_GrandFather;
        SQLM_SYMBOLS_Delete=SQLM_SYMBOLS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey6_2;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey6_2)
    IF SQLM_SYMBOLS_Delete /= SQLM_SYMBOLS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_SYMBOLS_DeleteFather:SQLC_SYMBOLS_Left2=
           SQLM_SYMBOLS_Delete
        THEN
            SQLM_SYMBOLS_DeleteFather:SQLC_SYMBOLS_Left2=
                SQLM_SYMBOLS_Father;
        ELSE
            SQLM_SYMBOLS_DeleteFather:SQLC_SYMBOLS_Right2=
                SQLM_SYMBOLS_Father;
        FI;
        IF SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left2=
           SQLM_SYMBOLS_Father
        THEN
            SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left2=
                SQLM_SYMBOLS_NilRow;
        ELSE
            SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Right2=
                SQLM_SYMBOLS_NilRow;
        FI;
        IF SQLM_SYMBOLS_Father /= SQLM_SYMBOLS_Delete THEN
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color2=
                SQLM_SYMBOLS_Delete:SQLC_SYMBOLS_Color2;
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right2=
                SQLM_SYMBOLS_Delete:SQLC_SYMBOLS_Right2;
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left2=
                SQLM_SYMBOLS_Delete:SQLC_SYMBOLS_Left2;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
        SQLM_SYMBOLS_OperRow=SQLM_SYMBOLS_Delete;
        SQLM_SYMBOLS_GuardRow= SQLM_TableReference:SQLM_System;
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2;
SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2 =
    SQLM_SYMBOLS_OperRow;
        SQLM_SYMBOLS_Delete:SQLC_SYMBOLS_Allocated=0;
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey6_3)
! Setup pointers !
    SQLM_SYMBOLS_GrandFather=SQLX_GrandFather;
    SQLM_SYMBOLS_Father=SQLX_Father;
    SQLM_SYMBOLS_OperRow=SQLX_Current;
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
    SQLM_SYMBOLS_DeleteFather=SQLX_DeleteFather;
    SQLM_SYMBOLS_Delete=SQLX_Delete;
    SQLM_SYMBOLS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey6_3)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_SYMBOLS_GrandFather,
            SQLM_SYMBOLS_Father,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_DeleteFather,
            SQLM_SYMBOLS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_SYMBOLS_OperRow=SQLM_SYMBOLS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey6_3;
! Test key. !
    DO SQLS_SYMBOLS_KeyTest3;
! Move down to next node !
    SQLM_SYMBOLS_GrandFather=SQLM_SYMBOLS_Father;
    SQLM_SYMBOLS_Father=SQLM_SYMBOLS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_SYMBOLS_OperRow=
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3;
        SQLM_SYMBOLS_Brother=
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3;
    ELSE
        SQLM_SYMBOLS_OperRow=
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3;
        SQLM_SYMBOLS_Brother=
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3 (*)
        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color3 (*)
        (-) SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Color3 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color3=0;
        SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Color3=1;
        IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3=
            SQLM_SYMBOLS_Brother
        THEN
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3=
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left3;
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left3=
                SQLM_SYMBOLS_Father;
        ELSE
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3=
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right3;
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right3=
                SQLM_SYMBOLS_Father;
        FI;
        IF SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left3=
            SQLM_SYMBOLS_Father
        THEN
            SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left3=
                SQLM_SYMBOLS_Brother;
        ELSE
            SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Right3=
                SQLM_SYMBOLS_Brother;
        FI;
        SQLM_SYMBOLS_GrandFather=SQLM_SYMBOLS_Brother;
        IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3=
            SQLM_SYMBOLS_OperRow
        THEN
            SQLM_SYMBOLS_Brother=
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3;
        ELSE
            SQLM_SYMBOLS_Brother=
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3=
        SQLM_SYMBOLS_OperRow
    THEN
        SQLM_SYMBOLS_Nephew=
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left3;
    ELSE
        SQLM_SYMBOLS_Nephew=
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right3;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3=1 THEN
     SQLM_SYMBOLS_TempRow=
         SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3;
     IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3=1 THEN
      SQLM_SYMBOLS_TempRow=
          SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3;
      IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Color3=1 THEN
         SQLM_SYMBOLS_TempRow=
             SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right3;
         IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3=1 THEN
          SQLM_SYMBOLS_TempRow=
              SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left3;
          IF SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3=1 THEN
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3=0;
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Color3=0;
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color3=1;
            GOTO L2towComDelKeyTableKey6_3;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Color3=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Color3=
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color3;
            IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3=
               SQLM_SYMBOLS_OperRow
            THEN
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Left3;
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Right3;
                SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_Father;
                SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_Brother;
            ELSE
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Right3;
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Left3;
                SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_Father;
                SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_Brother;
            FI;
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3=0;
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color3=1;
            IF SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left3=
               SQLM_SYMBOLS_Father
            THEN
                SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_Nephew;
            ELSE
                SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_Nephew;
            FI;
            SQLM_SYMBOLS_GrandFather=SQLM_SYMBOLS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_SYMBOLS_Nephew:SQLC_SYMBOLS_Color3=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Color3=
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color3;
            IF SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3=
               SQLM_SYMBOLS_OperRow
            THEN
                SQLM_SYMBOLS_TempRow=
                    SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right3;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3=1;
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left3;
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_Father;
            ELSE
                SQLM_SYMBOLS_TempRow=
                    SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Left3;
                SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Color3=1;
                SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right3;
                SQLM_SYMBOLS_Brother:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_Father;
            FI;
            SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Color3=0;
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color3=1;
            IF SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left3=
                SQLM_SYMBOLS_Father
            THEN
                SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left3=
                    SQLM_SYMBOLS_Brother;
            ELSE
                SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Right3=
                    SQLM_SYMBOLS_Brother;
            FI;
            SQLM_SYMBOLS_GrandFather=SQLM_SYMBOLS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey6_3)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_SYMBOLS_DeleteFather=SQLM_SYMBOLS_GrandFather;
        SQLM_SYMBOLS_Delete=SQLM_SYMBOLS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey6_3;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey6_3)
    IF SQLM_SYMBOLS_Delete /= SQLM_SYMBOLS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_SYMBOLS_DeleteFather:SQLC_SYMBOLS_Left3=
           SQLM_SYMBOLS_Delete
        THEN
            SQLM_SYMBOLS_DeleteFather:SQLC_SYMBOLS_Left3=
                SQLM_SYMBOLS_Father;
        ELSE
            SQLM_SYMBOLS_DeleteFather:SQLC_SYMBOLS_Right3=
                SQLM_SYMBOLS_Father;
        FI;
        IF SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left3=
           SQLM_SYMBOLS_Father
        THEN
            SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Left3=
                SQLM_SYMBOLS_NilRow;
        ELSE
            SQLM_SYMBOLS_GrandFather:SQLC_SYMBOLS_Right3=
                SQLM_SYMBOLS_NilRow;
        FI;
        IF SQLM_SYMBOLS_Father /= SQLM_SYMBOLS_Delete THEN
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Color3=
                SQLM_SYMBOLS_Delete:SQLC_SYMBOLS_Color3;
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Right3=
                SQLM_SYMBOLS_Delete:SQLC_SYMBOLS_Right3;
            SQLM_SYMBOLS_Father:SQLC_SYMBOLS_Left3=
                SQLM_SYMBOLS_Delete:SQLC_SYMBOLS_Left3;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 7 DO
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
! Setup pointers !
    SQLM_TOWFAULTCODES_GrandFather=SQLX_GrandFather;
    SQLM_TOWFAULTCODES_Father=SQLX_Father;
    SQLM_TOWFAULTCODES_OperRow=SQLX_Current;
    SQLM_TOWFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_TOWFAULTCODES_DeleteFather=SQLX_DeleteFather;
    SQLM_TOWFAULTCODES_Delete=SQLX_Delete;
    SQLM_TOWFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey7_2)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TOWFAULTCODES_GrandFather,
            SQLM_TOWFAULTCODES_Father,
            SQLM_TOWFAULTCODES_OperRow,
            SQLM_TOWFAULTCODES_DeleteFather,
            SQLM_TOWFAULTCODES_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_TOWFAULTCODES_OperRow=SQLM_TOWFAULTCODES_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey7_2;
! Test key. !
    DO SQLS_TOWFAULTCODES_KeyTest2;
! Move down to next node !
    SQLM_TOWFAULTCODES_GrandFather=SQLM_TOWFAULTCODES_Father;
    SQLM_TOWFAULTCODES_Father=SQLM_TOWFAULTCODES_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TOWFAULTCODES_OperRow=
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2;
        SQLM_TOWFAULTCODES_Brother=
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2;
    ELSE
        SQLM_TOWFAULTCODES_OperRow=
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2;
        SQLM_TOWFAULTCODES_Brother=
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2 (*)
        SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Color2 (*)
        (-) SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Color2 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Color2=0;
        SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Color2=1;
        IF SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2=
            SQLM_TOWFAULTCODES_Brother
        THEN
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2=
                SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Left2;
            SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Left2=
                SQLM_TOWFAULTCODES_Father;
        ELSE
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2=
                SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Right2;
            SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Right2=
                SQLM_TOWFAULTCODES_Father;
        FI;
        IF SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Left2=
            SQLM_TOWFAULTCODES_Father
        THEN
            SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Left2=
                SQLM_TOWFAULTCODES_Brother;
        ELSE
            SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Right2=
                SQLM_TOWFAULTCODES_Brother;
        FI;
        SQLM_TOWFAULTCODES_GrandFather=SQLM_TOWFAULTCODES_Brother;
        IF SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2=
            SQLM_TOWFAULTCODES_OperRow
        THEN
            SQLM_TOWFAULTCODES_Brother=
                SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2;
        ELSE
            SQLM_TOWFAULTCODES_Brother=
                SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2=
        SQLM_TOWFAULTCODES_OperRow
    THEN
        SQLM_TOWFAULTCODES_Nephew=
            SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Left2;
    ELSE
        SQLM_TOWFAULTCODES_Nephew=
            SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Right2;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2=1 THEN
     SQLM_TOWFAULTCODES_TempRow=
         SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
     IF SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2=1 THEN
      SQLM_TOWFAULTCODES_TempRow=
          SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
      IF SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Color2=1 THEN
         SQLM_TOWFAULTCODES_TempRow=
             SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Right2;
         IF SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2=1 THEN
          SQLM_TOWFAULTCODES_TempRow=
              SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Left2;
          IF SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2=1 THEN
            SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2=0;
            SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Color2=0;
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Color2=1;
            GOTO L2towComDelKeyTableKey7_2;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_TOWFAULTCODES_Nephew:SQLC_TOWFAULTCODES_Color2=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_TOWFAULTCODES_Nephew:SQLC_TOWFAULTCODES_Color2=
                SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Color2;
            IF SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2=
               SQLM_TOWFAULTCODES_OperRow
            THEN
                SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_Nephew:SQLC_TOWFAULTCODES_Left2;
                SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_Nephew:SQLC_TOWFAULTCODES_Right2;
                SQLM_TOWFAULTCODES_Nephew:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_Father;
                SQLM_TOWFAULTCODES_Nephew:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_Brother;
            ELSE
                SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_Nephew:SQLC_TOWFAULTCODES_Right2;
                SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_Nephew:SQLC_TOWFAULTCODES_Left2;
                SQLM_TOWFAULTCODES_Nephew:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_Father;
                SQLM_TOWFAULTCODES_Nephew:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_Brother;
            FI;
            SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2=0;
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Color2=1;
            IF SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Left2=
               SQLM_TOWFAULTCODES_Father
            THEN
                SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_Nephew;
            ELSE
                SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_Nephew;
            FI;
            SQLM_TOWFAULTCODES_GrandFather=SQLM_TOWFAULTCODES_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_TOWFAULTCODES_Nephew:SQLC_TOWFAULTCODES_Color2=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Color2=
                SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Color2;
            IF SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2=
               SQLM_TOWFAULTCODES_OperRow
            THEN
                SQLM_TOWFAULTCODES_TempRow=
                    SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Right2;
                SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2=1;
                SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Left2;
                SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_Father;
            ELSE
                SQLM_TOWFAULTCODES_TempRow=
                    SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Left2;
                SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Color2=1;
                SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Right2;
                SQLM_TOWFAULTCODES_Brother:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_Father;
            FI;
            SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Color2=0;
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Color2=1;
            IF SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Left2=
                SQLM_TOWFAULTCODES_Father
            THEN
                SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Left2=
                    SQLM_TOWFAULTCODES_Brother;
            ELSE
                SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Right2=
                    SQLM_TOWFAULTCODES_Brother;
            FI;
            SQLM_TOWFAULTCODES_GrandFather=SQLM_TOWFAULTCODES_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey7_2)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_TOWFAULTCODES_DeleteFather=SQLM_TOWFAULTCODES_GrandFather;
        SQLM_TOWFAULTCODES_Delete=SQLM_TOWFAULTCODES_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey7_2;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey7_2)
    IF SQLM_TOWFAULTCODES_Delete /= SQLM_TOWFAULTCODES_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_TOWFAULTCODES_DeleteFather:SQLC_TOWFAULTCODES_Left2=
           SQLM_TOWFAULTCODES_Delete
        THEN
            SQLM_TOWFAULTCODES_DeleteFather:SQLC_TOWFAULTCODES_Left2=
                SQLM_TOWFAULTCODES_Father;
        ELSE
            SQLM_TOWFAULTCODES_DeleteFather:SQLC_TOWFAULTCODES_Right2=
                SQLM_TOWFAULTCODES_Father;
        FI;
        IF SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Left2=
           SQLM_TOWFAULTCODES_Father
        THEN
            SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Left2=
                SQLM_TOWFAULTCODES_NilRow;
        ELSE
            SQLM_TOWFAULTCODES_GrandFather:SQLC_TOWFAULTCODES_Right2=
                SQLM_TOWFAULTCODES_NilRow;
        FI;
        IF SQLM_TOWFAULTCODES_Father /= SQLM_TOWFAULTCODES_Delete THEN
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Color2=
                SQLM_TOWFAULTCODES_Delete:SQLC_TOWFAULTCODES_Color2;
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Right2=
                SQLM_TOWFAULTCODES_Delete:SQLC_TOWFAULTCODES_Right2;
            SQLM_TOWFAULTCODES_Father:SQLC_TOWFAULTCODES_Left2=
                SQLM_TOWFAULTCODES_Delete:SQLC_TOWFAULTCODES_Left2;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
        SQLM_TOWFAULTCODES_OperRow=SQLM_TOWFAULTCODES_Delete;
        SQLM_TOWFAULTCODES_GuardRow= SQLM_TableReference:SQLM_System;
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2 =
    SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2;
SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2 =
    SQLM_TOWFAULTCODES_OperRow;
        SQLM_TOWFAULTCODES_Delete:SQLC_TOWFAULTCODES_Allocated=0;
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 8 DO
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
! Setup pointers !
    SQLM_SYSFAULTCODES_GrandFather=SQLX_GrandFather;
    SQLM_SYSFAULTCODES_Father=SQLX_Father;
    SQLM_SYSFAULTCODES_OperRow=SQLX_Current;
    SQLM_SYSFAULTCODES_WorkRow=SQLX_WorkRow;
    SQLM_SYSFAULTCODES_DeleteFather=SQLX_DeleteFather;
    SQLM_SYSFAULTCODES_Delete=SQLX_Delete;
    SQLM_SYSFAULTCODES_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey8_2)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_SYSFAULTCODES_GrandFather,
            SQLM_SYSFAULTCODES_Father,
            SQLM_SYSFAULTCODES_OperRow,
            SQLM_SYSFAULTCODES_DeleteFather,
            SQLM_SYSFAULTCODES_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_SYSFAULTCODES_OperRow=SQLM_SYSFAULTCODES_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey8_2;
! Test key. !
    DO SQLS_SYSFAULTCODES_KeyTest2;
! Move down to next node !
    SQLM_SYSFAULTCODES_GrandFather=SQLM_SYSFAULTCODES_Father;
    SQLM_SYSFAULTCODES_Father=SQLM_SYSFAULTCODES_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_SYSFAULTCODES_OperRow=
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2;
        SQLM_SYSFAULTCODES_Brother=
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2;
    ELSE
        SQLM_SYSFAULTCODES_OperRow=
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2;
        SQLM_SYSFAULTCODES_Brother=
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2 (*)
        SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Color2 (*)
        (-) SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Color2 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Color2=0;
        SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Color2=1;
        IF SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2=
            SQLM_SYSFAULTCODES_Brother
        THEN
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2=
                SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Left2;
            SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Left2=
                SQLM_SYSFAULTCODES_Father;
        ELSE
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2=
                SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Right2;
            SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Right2=
                SQLM_SYSFAULTCODES_Father;
        FI;
        IF SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Left2=
            SQLM_SYSFAULTCODES_Father
        THEN
            SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Left2=
                SQLM_SYSFAULTCODES_Brother;
        ELSE
            SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Right2=
                SQLM_SYSFAULTCODES_Brother;
        FI;
        SQLM_SYSFAULTCODES_GrandFather=SQLM_SYSFAULTCODES_Brother;
        IF SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2=
            SQLM_SYSFAULTCODES_OperRow
        THEN
            SQLM_SYSFAULTCODES_Brother=
                SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2;
        ELSE
            SQLM_SYSFAULTCODES_Brother=
                SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2=
        SQLM_SYSFAULTCODES_OperRow
    THEN
        SQLM_SYSFAULTCODES_Nephew=
            SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Left2;
    ELSE
        SQLM_SYSFAULTCODES_Nephew=
            SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Right2;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2=1 THEN
     SQLM_SYSFAULTCODES_TempRow=
         SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
     IF SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2=1 THEN
      SQLM_SYSFAULTCODES_TempRow=
          SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
      IF SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Color2=1 THEN
         SQLM_SYSFAULTCODES_TempRow=
             SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Right2;
         IF SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2=1 THEN
          SQLM_SYSFAULTCODES_TempRow=
              SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Left2;
          IF SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2=1 THEN
            SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2=0;
            SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Color2=0;
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Color2=1;
            GOTO L2towComDelKeyTableKey8_2;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_SYSFAULTCODES_Nephew:SQLC_SYSFAULTCODES_Color2=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_SYSFAULTCODES_Nephew:SQLC_SYSFAULTCODES_Color2=
                SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Color2;
            IF SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2=
               SQLM_SYSFAULTCODES_OperRow
            THEN
                SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_Nephew:SQLC_SYSFAULTCODES_Left2;
                SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_Nephew:SQLC_SYSFAULTCODES_Right2;
                SQLM_SYSFAULTCODES_Nephew:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_Father;
                SQLM_SYSFAULTCODES_Nephew:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_Brother;
            ELSE
                SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_Nephew:SQLC_SYSFAULTCODES_Right2;
                SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_Nephew:SQLC_SYSFAULTCODES_Left2;
                SQLM_SYSFAULTCODES_Nephew:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_Father;
                SQLM_SYSFAULTCODES_Nephew:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_Brother;
            FI;
            SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2=0;
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Color2=1;
            IF SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Left2=
               SQLM_SYSFAULTCODES_Father
            THEN
                SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_Nephew;
            ELSE
                SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_Nephew;
            FI;
            SQLM_SYSFAULTCODES_GrandFather=SQLM_SYSFAULTCODES_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_SYSFAULTCODES_Nephew:SQLC_SYSFAULTCODES_Color2=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Color2=
                SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Color2;
            IF SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2=
               SQLM_SYSFAULTCODES_OperRow
            THEN
                SQLM_SYSFAULTCODES_TempRow=
                    SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Right2;
                SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2=1;
                SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Left2;
                SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_Father;
            ELSE
                SQLM_SYSFAULTCODES_TempRow=
                    SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Left2;
                SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Color2=1;
                SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Right2;
                SQLM_SYSFAULTCODES_Brother:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_Father;
            FI;
            SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Color2=0;
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Color2=1;
            IF SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Left2=
                SQLM_SYSFAULTCODES_Father
            THEN
                SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Left2=
                    SQLM_SYSFAULTCODES_Brother;
            ELSE
                SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Right2=
                    SQLM_SYSFAULTCODES_Brother;
            FI;
            SQLM_SYSFAULTCODES_GrandFather=SQLM_SYSFAULTCODES_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey8_2)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_SYSFAULTCODES_DeleteFather=SQLM_SYSFAULTCODES_GrandFather;
        SQLM_SYSFAULTCODES_Delete=SQLM_SYSFAULTCODES_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey8_2;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey8_2)
    IF SQLM_SYSFAULTCODES_Delete /= SQLM_SYSFAULTCODES_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_SYSFAULTCODES_DeleteFather:SQLC_SYSFAULTCODES_Left2=
           SQLM_SYSFAULTCODES_Delete
        THEN
            SQLM_SYSFAULTCODES_DeleteFather:SQLC_SYSFAULTCODES_Left2=
                SQLM_SYSFAULTCODES_Father;
        ELSE
            SQLM_SYSFAULTCODES_DeleteFather:SQLC_SYSFAULTCODES_Right2=
                SQLM_SYSFAULTCODES_Father;
        FI;
        IF SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Left2=
           SQLM_SYSFAULTCODES_Father
        THEN
            SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Left2=
                SQLM_SYSFAULTCODES_NilRow;
        ELSE
            SQLM_SYSFAULTCODES_GrandFather:SQLC_SYSFAULTCODES_Right2=
                SQLM_SYSFAULTCODES_NilRow;
        FI;
        IF SQLM_SYSFAULTCODES_Father /= SQLM_SYSFAULTCODES_Delete THEN
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Color2=
                SQLM_SYSFAULTCODES_Delete:SQLC_SYSFAULTCODES_Color2;
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Right2=
                SQLM_SYSFAULTCODES_Delete:SQLC_SYSFAULTCODES_Right2;
            SQLM_SYSFAULTCODES_Father:SQLC_SYSFAULTCODES_Left2=
                SQLM_SYSFAULTCODES_Delete:SQLC_SYSFAULTCODES_Left2;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
        SQLM_SYSFAULTCODES_OperRow=SQLM_SYSFAULTCODES_Delete;
        SQLM_SYSFAULTCODES_GuardRow= SQLM_TableReference:SQLM_System;
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2 =
    SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2;
SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2 =
    SQLM_SYSFAULTCODES_OperRow;
        SQLM_SYSFAULTCODES_Delete:SQLC_SYSFAULTCODES_Allocated=0;
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 9 DO
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComDelKeyTableKey9_2;
    WHEN 3 DO GOTO towComDelKeyTableKey9_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey9_2)
! Setup pointers !
    SQLM_SYSTEMFIELDS_GrandFather=SQLX_GrandFather;
    SQLM_SYSTEMFIELDS_Father=SQLX_Father;
    SQLM_SYSTEMFIELDS_OperRow=SQLX_Current;
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_DeleteFather=SQLX_DeleteFather;
    SQLM_SYSTEMFIELDS_Delete=SQLX_Delete;
    SQLM_SYSTEMFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey9_2)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_SYSTEMFIELDS_GrandFather,
            SQLM_SYSTEMFIELDS_Father,
            SQLM_SYSTEMFIELDS_OperRow,
            SQLM_SYSTEMFIELDS_DeleteFather,
            SQLM_SYSTEMFIELDS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_SYSTEMFIELDS_OperRow=SQLM_SYSTEMFIELDS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey9_2;
! Test key. !
    DO SQLS_SYSTEMFIELDS_KeyTest2;
! Move down to next node !
    SQLM_SYSTEMFIELDS_GrandFather=SQLM_SYSTEMFIELDS_Father;
    SQLM_SYSTEMFIELDS_Father=SQLM_SYSTEMFIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_SYSTEMFIELDS_OperRow=
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2;
        SQLM_SYSTEMFIELDS_Brother=
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2;
    ELSE
        SQLM_SYSTEMFIELDS_OperRow=
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2;
        SQLM_SYSTEMFIELDS_Brother=
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2 (*)
        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color2 (*)
        (-) SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Color2 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color2=0;
        SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Color2=1;
        IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2=
            SQLM_SYSTEMFIELDS_Brother
        THEN
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2=
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left2;
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left2=
                SQLM_SYSTEMFIELDS_Father;
        ELSE
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2=
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right2;
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right2=
                SQLM_SYSTEMFIELDS_Father;
        FI;
        IF SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left2=
            SQLM_SYSTEMFIELDS_Father
        THEN
            SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left2=
                SQLM_SYSTEMFIELDS_Brother;
        ELSE
            SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Right2=
                SQLM_SYSTEMFIELDS_Brother;
        FI;
        SQLM_SYSTEMFIELDS_GrandFather=SQLM_SYSTEMFIELDS_Brother;
        IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2=
            SQLM_SYSTEMFIELDS_OperRow
        THEN
            SQLM_SYSTEMFIELDS_Brother=
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2;
        ELSE
            SQLM_SYSTEMFIELDS_Brother=
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2=
        SQLM_SYSTEMFIELDS_OperRow
    THEN
        SQLM_SYSTEMFIELDS_Nephew=
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left2;
    ELSE
        SQLM_SYSTEMFIELDS_Nephew=
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right2;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2=1 THEN
     SQLM_SYSTEMFIELDS_TempRow=
         SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
     IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2=1 THEN
      SQLM_SYSTEMFIELDS_TempRow=
          SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
      IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Color2=1 THEN
         SQLM_SYSTEMFIELDS_TempRow=
             SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right2;
         IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2=1 THEN
          SQLM_SYSTEMFIELDS_TempRow=
              SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left2;
          IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2=1 THEN
            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2=0;
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Color2=0;
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color2=1;
            GOTO L2towComDelKeyTableKey9_2;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Color2=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Color2=
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color2;
            IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2=
               SQLM_SYSTEMFIELDS_OperRow
            THEN
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Left2;
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Right2;
                SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_Father;
                SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_Brother;
            ELSE
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Right2;
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Left2;
                SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_Father;
                SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_Brother;
            FI;
            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2=0;
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color2=1;
            IF SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left2=
               SQLM_SYSTEMFIELDS_Father
            THEN
                SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_Nephew;
            ELSE
                SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_Nephew;
            FI;
            SQLM_SYSTEMFIELDS_GrandFather=SQLM_SYSTEMFIELDS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Color2=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Color2=
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color2;
            IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2=
               SQLM_SYSTEMFIELDS_OperRow
            THEN
                SQLM_SYSTEMFIELDS_TempRow=
                    SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right2;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2=1;
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left2;
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_Father;
            ELSE
                SQLM_SYSTEMFIELDS_TempRow=
                    SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left2;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color2=1;
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right2;
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_Father;
            FI;
            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color2=0;
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color2=1;
            IF SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left2=
                SQLM_SYSTEMFIELDS_Father
            THEN
                SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left2=
                    SQLM_SYSTEMFIELDS_Brother;
            ELSE
                SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Right2=
                    SQLM_SYSTEMFIELDS_Brother;
            FI;
            SQLM_SYSTEMFIELDS_GrandFather=SQLM_SYSTEMFIELDS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey9_2)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_SYSTEMFIELDS_DeleteFather=SQLM_SYSTEMFIELDS_GrandFather;
        SQLM_SYSTEMFIELDS_Delete=SQLM_SYSTEMFIELDS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey9_2;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey9_2)
    IF SQLM_SYSTEMFIELDS_Delete /= SQLM_SYSTEMFIELDS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_SYSTEMFIELDS_DeleteFather:SQLC_SYSTEMFIELDS_Left2=
           SQLM_SYSTEMFIELDS_Delete
        THEN
            SQLM_SYSTEMFIELDS_DeleteFather:SQLC_SYSTEMFIELDS_Left2=
                SQLM_SYSTEMFIELDS_Father;
        ELSE
            SQLM_SYSTEMFIELDS_DeleteFather:SQLC_SYSTEMFIELDS_Right2=
                SQLM_SYSTEMFIELDS_Father;
        FI;
        IF SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left2=
           SQLM_SYSTEMFIELDS_Father
        THEN
            SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left2=
                SQLM_SYSTEMFIELDS_NilRow;
        ELSE
            SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Right2=
                SQLM_SYSTEMFIELDS_NilRow;
        FI;
        IF SQLM_SYSTEMFIELDS_Father /= SQLM_SYSTEMFIELDS_Delete THEN
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color2=
                SQLM_SYSTEMFIELDS_Delete:SQLC_SYSTEMFIELDS_Color2;
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right2=
                SQLM_SYSTEMFIELDS_Delete:SQLC_SYSTEMFIELDS_Right2;
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left2=
                SQLM_SYSTEMFIELDS_Delete:SQLC_SYSTEMFIELDS_Left2;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
        SQLM_SYSTEMFIELDS_OperRow=SQLM_SYSTEMFIELDS_Delete;
        SQLM_SYSTEMFIELDS_GuardRow= SQLM_TableReference:SQLM_System;
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2 =
    SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2;
SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2 =
    SQLM_SYSTEMFIELDS_OperRow;
        SQLM_SYSTEMFIELDS_Delete:SQLC_SYSTEMFIELDS_Allocated=0;
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey9_3)
! Setup pointers !
    SQLM_SYSTEMFIELDS_GrandFather=SQLX_GrandFather;
    SQLM_SYSTEMFIELDS_Father=SQLX_Father;
    SQLM_SYSTEMFIELDS_OperRow=SQLX_Current;
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_DeleteFather=SQLX_DeleteFather;
    SQLM_SYSTEMFIELDS_Delete=SQLX_Delete;
    SQLM_SYSTEMFIELDS_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey9_3)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_SYSTEMFIELDS_GrandFather,
            SQLM_SYSTEMFIELDS_Father,
            SQLM_SYSTEMFIELDS_OperRow,
            SQLM_SYSTEMFIELDS_DeleteFather,
            SQLM_SYSTEMFIELDS_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_SYSTEMFIELDS_OperRow=SQLM_SYSTEMFIELDS_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey9_3;
! Test key. !
    DO SQLS_SYSTEMFIELDS_KeyTest3;
    IF SQLX_KeyTest = 1 THEN
        IF SQLM_SYSTEMFIELDS_OperRow > SQLM_SYSTEMFIELDS_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Move down to next node !
    SQLM_SYSTEMFIELDS_GrandFather=SQLM_SYSTEMFIELDS_Father;
    SQLM_SYSTEMFIELDS_Father=SQLM_SYSTEMFIELDS_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_SYSTEMFIELDS_OperRow=
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3;
        SQLM_SYSTEMFIELDS_Brother=
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3;
    ELSE
        SQLM_SYSTEMFIELDS_OperRow=
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3;
        SQLM_SYSTEMFIELDS_Brother=
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3 (*)
        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color3 (*)
        (-) SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Color3 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color3=0;
        SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Color3=1;
        IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3=
            SQLM_SYSTEMFIELDS_Brother
        THEN
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3=
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left3;
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left3=
                SQLM_SYSTEMFIELDS_Father;
        ELSE
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3=
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right3;
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right3=
                SQLM_SYSTEMFIELDS_Father;
        FI;
        IF SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left3=
            SQLM_SYSTEMFIELDS_Father
        THEN
            SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left3=
                SQLM_SYSTEMFIELDS_Brother;
        ELSE
            SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Right3=
                SQLM_SYSTEMFIELDS_Brother;
        FI;
        SQLM_SYSTEMFIELDS_GrandFather=SQLM_SYSTEMFIELDS_Brother;
        IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3=
            SQLM_SYSTEMFIELDS_OperRow
        THEN
            SQLM_SYSTEMFIELDS_Brother=
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3;
        ELSE
            SQLM_SYSTEMFIELDS_Brother=
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3=
        SQLM_SYSTEMFIELDS_OperRow
    THEN
        SQLM_SYSTEMFIELDS_Nephew=
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left3;
    ELSE
        SQLM_SYSTEMFIELDS_Nephew=
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right3;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3=1 THEN
     SQLM_SYSTEMFIELDS_TempRow=
         SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3;
     IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3=1 THEN
      SQLM_SYSTEMFIELDS_TempRow=
          SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3;
      IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Color3=1 THEN
         SQLM_SYSTEMFIELDS_TempRow=
             SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right3;
         IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3=1 THEN
          SQLM_SYSTEMFIELDS_TempRow=
              SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left3;
          IF SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3=1 THEN
            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3=0;
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Color3=0;
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color3=1;
            GOTO L2towComDelKeyTableKey9_3;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Color3=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Color3=
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color3;
            IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3=
               SQLM_SYSTEMFIELDS_OperRow
            THEN
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Left3;
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Right3;
                SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_Father;
                SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_Brother;
            ELSE
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Right3;
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Left3;
                SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_Father;
                SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_Brother;
            FI;
            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3=0;
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color3=1;
            IF SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left3=
               SQLM_SYSTEMFIELDS_Father
            THEN
                SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_Nephew;
            ELSE
                SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_Nephew;
            FI;
            SQLM_SYSTEMFIELDS_GrandFather=SQLM_SYSTEMFIELDS_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_SYSTEMFIELDS_Nephew:SQLC_SYSTEMFIELDS_Color3=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Color3=
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color3;
            IF SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3=
               SQLM_SYSTEMFIELDS_OperRow
            THEN
                SQLM_SYSTEMFIELDS_TempRow=
                    SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right3;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3=1;
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left3;
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_Father;
            ELSE
                SQLM_SYSTEMFIELDS_TempRow=
                    SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Left3;
                SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Color3=1;
                SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right3;
                SQLM_SYSTEMFIELDS_Brother:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_Father;
            FI;
            SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Color3=0;
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color3=1;
            IF SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left3=
                SQLM_SYSTEMFIELDS_Father
            THEN
                SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left3=
                    SQLM_SYSTEMFIELDS_Brother;
            ELSE
                SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Right3=
                    SQLM_SYSTEMFIELDS_Brother;
            FI;
            SQLM_SYSTEMFIELDS_GrandFather=SQLM_SYSTEMFIELDS_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey9_3)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_SYSTEMFIELDS_DeleteFather=SQLM_SYSTEMFIELDS_GrandFather;
        SQLM_SYSTEMFIELDS_Delete=SQLM_SYSTEMFIELDS_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey9_3;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey9_3)
    IF SQLM_SYSTEMFIELDS_Delete /= SQLM_SYSTEMFIELDS_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_SYSTEMFIELDS_DeleteFather:SQLC_SYSTEMFIELDS_Left3=
           SQLM_SYSTEMFIELDS_Delete
        THEN
            SQLM_SYSTEMFIELDS_DeleteFather:SQLC_SYSTEMFIELDS_Left3=
                SQLM_SYSTEMFIELDS_Father;
        ELSE
            SQLM_SYSTEMFIELDS_DeleteFather:SQLC_SYSTEMFIELDS_Right3=
                SQLM_SYSTEMFIELDS_Father;
        FI;
        IF SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left3=
           SQLM_SYSTEMFIELDS_Father
        THEN
            SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Left3=
                SQLM_SYSTEMFIELDS_NilRow;
        ELSE
            SQLM_SYSTEMFIELDS_GrandFather:SQLC_SYSTEMFIELDS_Right3=
                SQLM_SYSTEMFIELDS_NilRow;
        FI;
        IF SQLM_SYSTEMFIELDS_Father /= SQLM_SYSTEMFIELDS_Delete THEN
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Color3=
                SQLM_SYSTEMFIELDS_Delete:SQLC_SYSTEMFIELDS_Color3;
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Right3=
                SQLM_SYSTEMFIELDS_Delete:SQLC_SYSTEMFIELDS_Right3;
            SQLM_SYSTEMFIELDS_Father:SQLC_SYSTEMFIELDS_Left3=
                SQLM_SYSTEMFIELDS_Delete:SQLC_SYSTEMFIELDS_Left3;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    WHEN 10 DO
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComDelKeyTableKey10_2;
    WHEN 3 DO GOTO towComDelKeyTableKey10_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey10_2)
! Setup pointers !
    SQLM_TEST1_GrandFather=SQLX_GrandFather;
    SQLM_TEST1_Father=SQLX_Father;
    SQLM_TEST1_OperRow=SQLX_Current;
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
    SQLM_TEST1_DeleteFather=SQLX_DeleteFather;
    SQLM_TEST1_Delete=SQLX_Delete;
    SQLM_TEST1_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey10_2)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TEST1_GrandFather,
            SQLM_TEST1_Father,
            SQLM_TEST1_OperRow,
            SQLM_TEST1_DeleteFather,
            SQLM_TEST1_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_TEST1_OperRow=SQLM_TEST1_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey10_2;
! Test key. !
    DO SQLS_TEST1_KeyTest2;
! Move down to next node !
    SQLM_TEST1_GrandFather=SQLM_TEST1_Father;
    SQLM_TEST1_Father=SQLM_TEST1_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TEST1_OperRow=
            SQLM_TEST1_Father:SQLC_TEST1_Left2;
        SQLM_TEST1_Brother=
            SQLM_TEST1_Father:SQLC_TEST1_Right2;
    ELSE
        SQLM_TEST1_OperRow=
            SQLM_TEST1_Father:SQLC_TEST1_Right2;
        SQLM_TEST1_Brother=
            SQLM_TEST1_Father:SQLC_TEST1_Left2;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Color2 (*)
        SQLM_TEST1_Father:SQLC_TEST1_Color2 (*)
        (-) SQLM_TEST1_Brother:SQLC_TEST1_Color2 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_TEST1_Father:SQLC_TEST1_Color2=0;
        SQLM_TEST1_Brother:SQLC_TEST1_Color2=1;
        IF SQLM_TEST1_Father:SQLC_TEST1_Right2=
            SQLM_TEST1_Brother
        THEN
            SQLM_TEST1_Father:SQLC_TEST1_Right2=
                SQLM_TEST1_Brother:SQLC_TEST1_Left2;
            SQLM_TEST1_Brother:SQLC_TEST1_Left2=
                SQLM_TEST1_Father;
        ELSE
            SQLM_TEST1_Father:SQLC_TEST1_Left2=
                SQLM_TEST1_Brother:SQLC_TEST1_Right2;
            SQLM_TEST1_Brother:SQLC_TEST1_Right2=
                SQLM_TEST1_Father;
        FI;
        IF SQLM_TEST1_GrandFather:SQLC_TEST1_Left2=
            SQLM_TEST1_Father
        THEN
            SQLM_TEST1_GrandFather:SQLC_TEST1_Left2=
                SQLM_TEST1_Brother;
        ELSE
            SQLM_TEST1_GrandFather:SQLC_TEST1_Right2=
                SQLM_TEST1_Brother;
        FI;
        SQLM_TEST1_GrandFather=SQLM_TEST1_Brother;
        IF SQLM_TEST1_Father:SQLC_TEST1_Left2=
            SQLM_TEST1_OperRow
        THEN
            SQLM_TEST1_Brother=
                SQLM_TEST1_Father:SQLC_TEST1_Right2;
        ELSE
            SQLM_TEST1_Brother=
                SQLM_TEST1_Father:SQLC_TEST1_Left2;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_TEST1_Father:SQLC_TEST1_Left2=
        SQLM_TEST1_OperRow
    THEN
        SQLM_TEST1_Nephew=
            SQLM_TEST1_Brother:SQLC_TEST1_Left2;
    ELSE
        SQLM_TEST1_Nephew=
            SQLM_TEST1_Brother:SQLC_TEST1_Right2;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Color2=1 THEN
     SQLM_TEST1_TempRow=
         SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
     IF SQLM_TEST1_TempRow:SQLC_TEST1_Color2=1 THEN
      SQLM_TEST1_TempRow=
          SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
      IF SQLM_TEST1_TempRow:SQLC_TEST1_Color2=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_TEST1_Brother:SQLC_TEST1_Color2=1 THEN
         SQLM_TEST1_TempRow=
             SQLM_TEST1_Brother:SQLC_TEST1_Right2;
         IF SQLM_TEST1_TempRow:SQLC_TEST1_Color2=1 THEN
          SQLM_TEST1_TempRow=
              SQLM_TEST1_Brother:SQLC_TEST1_Left2;
          IF SQLM_TEST1_TempRow:SQLC_TEST1_Color2=1 THEN
            SQLM_TEST1_OperRow:SQLC_TEST1_Color2=0;
            SQLM_TEST1_Brother:SQLC_TEST1_Color2=0;
            SQLM_TEST1_Father:SQLC_TEST1_Color2=1;
            GOTO L2towComDelKeyTableKey10_2;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_TEST1_Nephew:SQLC_TEST1_Color2=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_TEST1_Nephew:SQLC_TEST1_Color2=
                SQLM_TEST1_Father:SQLC_TEST1_Color2;
            IF SQLM_TEST1_Father:SQLC_TEST1_Left2=
               SQLM_TEST1_OperRow
            THEN
                SQLM_TEST1_Father:SQLC_TEST1_Right2=
                    SQLM_TEST1_Nephew:SQLC_TEST1_Left2;
                SQLM_TEST1_Brother:SQLC_TEST1_Left2=
                    SQLM_TEST1_Nephew:SQLC_TEST1_Right2;
                SQLM_TEST1_Nephew:SQLC_TEST1_Left2=
                    SQLM_TEST1_Father;
                SQLM_TEST1_Nephew:SQLC_TEST1_Right2=
                    SQLM_TEST1_Brother;
            ELSE
                SQLM_TEST1_Father:SQLC_TEST1_Left2=
                    SQLM_TEST1_Nephew:SQLC_TEST1_Right2;
                SQLM_TEST1_Brother:SQLC_TEST1_Right2=
                    SQLM_TEST1_Nephew:SQLC_TEST1_Left2;
                SQLM_TEST1_Nephew:SQLC_TEST1_Right2=
                    SQLM_TEST1_Father;
                SQLM_TEST1_Nephew:SQLC_TEST1_Left2=
                    SQLM_TEST1_Brother;
            FI;
            SQLM_TEST1_OperRow:SQLC_TEST1_Color2=0;
            SQLM_TEST1_Father:SQLC_TEST1_Color2=1;
            IF SQLM_TEST1_GrandFather:SQLC_TEST1_Left2=
               SQLM_TEST1_Father
            THEN
                SQLM_TEST1_GrandFather:SQLC_TEST1_Left2=
                    SQLM_TEST1_Nephew;
            ELSE
                SQLM_TEST1_GrandFather:SQLC_TEST1_Right2=
                    SQLM_TEST1_Nephew;
            FI;
            SQLM_TEST1_GrandFather=SQLM_TEST1_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_TEST1_Nephew:SQLC_TEST1_Color2=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_TEST1_Brother:SQLC_TEST1_Color2=
                SQLM_TEST1_Father:SQLC_TEST1_Color2;
            IF SQLM_TEST1_Father:SQLC_TEST1_Left2=
               SQLM_TEST1_OperRow
            THEN
                SQLM_TEST1_TempRow=
                    SQLM_TEST1_Brother:SQLC_TEST1_Right2;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color2=1;
                SQLM_TEST1_Father:SQLC_TEST1_Right2=
                    SQLM_TEST1_Brother:SQLC_TEST1_Left2;
                SQLM_TEST1_Brother:SQLC_TEST1_Left2=
                    SQLM_TEST1_Father;
            ELSE
                SQLM_TEST1_TempRow=
                    SQLM_TEST1_Brother:SQLC_TEST1_Left2;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color2=1;
                SQLM_TEST1_Father:SQLC_TEST1_Left2=
                    SQLM_TEST1_Brother:SQLC_TEST1_Right2;
                SQLM_TEST1_Brother:SQLC_TEST1_Right2=
                    SQLM_TEST1_Father;
            FI;
            SQLM_TEST1_OperRow:SQLC_TEST1_Color2=0;
            SQLM_TEST1_Father:SQLC_TEST1_Color2=1;
            IF SQLM_TEST1_GrandFather:SQLC_TEST1_Left2=
                SQLM_TEST1_Father
            THEN
                SQLM_TEST1_GrandFather:SQLC_TEST1_Left2=
                    SQLM_TEST1_Brother;
            ELSE
                SQLM_TEST1_GrandFather:SQLC_TEST1_Right2=
                    SQLM_TEST1_Brother;
            FI;
            SQLM_TEST1_GrandFather=SQLM_TEST1_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey10_2)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_TEST1_DeleteFather=SQLM_TEST1_GrandFather;
        SQLM_TEST1_Delete=SQLM_TEST1_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey10_2;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey10_2)
    IF SQLM_TEST1_Delete /= SQLM_TEST1_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_TEST1_DeleteFather:SQLC_TEST1_Left2=
           SQLM_TEST1_Delete
        THEN
            SQLM_TEST1_DeleteFather:SQLC_TEST1_Left2=
                SQLM_TEST1_Father;
        ELSE
            SQLM_TEST1_DeleteFather:SQLC_TEST1_Right2=
                SQLM_TEST1_Father;
        FI;
        IF SQLM_TEST1_GrandFather:SQLC_TEST1_Left2=
           SQLM_TEST1_Father
        THEN
            SQLM_TEST1_GrandFather:SQLC_TEST1_Left2=
                SQLM_TEST1_NilRow;
        ELSE
            SQLM_TEST1_GrandFather:SQLC_TEST1_Right2=
                SQLM_TEST1_NilRow;
        FI;
        IF SQLM_TEST1_Father /= SQLM_TEST1_Delete THEN
            SQLM_TEST1_Father:SQLC_TEST1_Color2=
                SQLM_TEST1_Delete:SQLC_TEST1_Color2;
            SQLM_TEST1_Father:SQLC_TEST1_Right2=
                SQLM_TEST1_Delete:SQLC_TEST1_Right2;
            SQLM_TEST1_Father:SQLC_TEST1_Left2=
                SQLM_TEST1_Delete:SQLC_TEST1_Left2;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
        SQLM_TEST1_OperRow=SQLM_TEST1_Delete;
        SQLM_TEST1_GuardRow= SQLM_TableReference:SQLM_System;
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_TEST1_OperRow:SQLC_TEST1_Left2 =
    SQLM_TEST1_GuardRow:SQLC_TEST1_Right2;
SQLM_TEST1_GuardRow:SQLC_TEST1_Right2 =
    SQLM_TEST1_OperRow;
        SQLM_TEST1_Delete:SQLC_TEST1_Allocated=0;
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey10_3)
! Setup pointers !
    SQLM_TEST1_GrandFather=SQLX_GrandFather;
    SQLM_TEST1_Father=SQLX_Father;
    SQLM_TEST1_OperRow=SQLX_Current;
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
    SQLM_TEST1_DeleteFather=SQLX_DeleteFather;
    SQLM_TEST1_Delete=SQLX_Delete;
    SQLM_TEST1_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey10_3)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TEST1_GrandFather,
            SQLM_TEST1_Father,
            SQLM_TEST1_OperRow,
            SQLM_TEST1_DeleteFather,
            SQLM_TEST1_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_TEST1_OperRow=SQLM_TEST1_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey10_3;
! Test key. !
    DO SQLS_TEST1_KeyTest3;
    IF SQLX_KeyTest = 1 THEN
        IF SQLM_TEST1_OperRow > SQLM_TEST1_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Move down to next node !
    SQLM_TEST1_GrandFather=SQLM_TEST1_Father;
    SQLM_TEST1_Father=SQLM_TEST1_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TEST1_OperRow=
            SQLM_TEST1_Father:SQLC_TEST1_Left3;
        SQLM_TEST1_Brother=
            SQLM_TEST1_Father:SQLC_TEST1_Right3;
    ELSE
        SQLM_TEST1_OperRow=
            SQLM_TEST1_Father:SQLC_TEST1_Right3;
        SQLM_TEST1_Brother=
            SQLM_TEST1_Father:SQLC_TEST1_Left3;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Color3 (*)
        SQLM_TEST1_Father:SQLC_TEST1_Color3 (*)
        (-) SQLM_TEST1_Brother:SQLC_TEST1_Color3 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_TEST1_Father:SQLC_TEST1_Color3=0;
        SQLM_TEST1_Brother:SQLC_TEST1_Color3=1;
        IF SQLM_TEST1_Father:SQLC_TEST1_Right3=
            SQLM_TEST1_Brother
        THEN
            SQLM_TEST1_Father:SQLC_TEST1_Right3=
                SQLM_TEST1_Brother:SQLC_TEST1_Left3;
            SQLM_TEST1_Brother:SQLC_TEST1_Left3=
                SQLM_TEST1_Father;
        ELSE
            SQLM_TEST1_Father:SQLC_TEST1_Left3=
                SQLM_TEST1_Brother:SQLC_TEST1_Right3;
            SQLM_TEST1_Brother:SQLC_TEST1_Right3=
                SQLM_TEST1_Father;
        FI;
        IF SQLM_TEST1_GrandFather:SQLC_TEST1_Left3=
            SQLM_TEST1_Father
        THEN
            SQLM_TEST1_GrandFather:SQLC_TEST1_Left3=
                SQLM_TEST1_Brother;
        ELSE
            SQLM_TEST1_GrandFather:SQLC_TEST1_Right3=
                SQLM_TEST1_Brother;
        FI;
        SQLM_TEST1_GrandFather=SQLM_TEST1_Brother;
        IF SQLM_TEST1_Father:SQLC_TEST1_Left3=
            SQLM_TEST1_OperRow
        THEN
            SQLM_TEST1_Brother=
                SQLM_TEST1_Father:SQLC_TEST1_Right3;
        ELSE
            SQLM_TEST1_Brother=
                SQLM_TEST1_Father:SQLC_TEST1_Left3;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_TEST1_Father:SQLC_TEST1_Left3=
        SQLM_TEST1_OperRow
    THEN
        SQLM_TEST1_Nephew=
            SQLM_TEST1_Brother:SQLC_TEST1_Left3;
    ELSE
        SQLM_TEST1_Nephew=
            SQLM_TEST1_Brother:SQLC_TEST1_Right3;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_TEST1_OperRow:SQLC_TEST1_Color3=1 THEN
     SQLM_TEST1_TempRow=
         SQLM_TEST1_OperRow:SQLC_TEST1_Right3;
     IF SQLM_TEST1_TempRow:SQLC_TEST1_Color3=1 THEN
      SQLM_TEST1_TempRow=
          SQLM_TEST1_OperRow:SQLC_TEST1_Left3;
      IF SQLM_TEST1_TempRow:SQLC_TEST1_Color3=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_TEST1_Brother:SQLC_TEST1_Color3=1 THEN
         SQLM_TEST1_TempRow=
             SQLM_TEST1_Brother:SQLC_TEST1_Right3;
         IF SQLM_TEST1_TempRow:SQLC_TEST1_Color3=1 THEN
          SQLM_TEST1_TempRow=
              SQLM_TEST1_Brother:SQLC_TEST1_Left3;
          IF SQLM_TEST1_TempRow:SQLC_TEST1_Color3=1 THEN
            SQLM_TEST1_OperRow:SQLC_TEST1_Color3=0;
            SQLM_TEST1_Brother:SQLC_TEST1_Color3=0;
            SQLM_TEST1_Father:SQLC_TEST1_Color3=1;
            GOTO L2towComDelKeyTableKey10_3;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_TEST1_Nephew:SQLC_TEST1_Color3=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_TEST1_Nephew:SQLC_TEST1_Color3=
                SQLM_TEST1_Father:SQLC_TEST1_Color3;
            IF SQLM_TEST1_Father:SQLC_TEST1_Left3=
               SQLM_TEST1_OperRow
            THEN
                SQLM_TEST1_Father:SQLC_TEST1_Right3=
                    SQLM_TEST1_Nephew:SQLC_TEST1_Left3;
                SQLM_TEST1_Brother:SQLC_TEST1_Left3=
                    SQLM_TEST1_Nephew:SQLC_TEST1_Right3;
                SQLM_TEST1_Nephew:SQLC_TEST1_Left3=
                    SQLM_TEST1_Father;
                SQLM_TEST1_Nephew:SQLC_TEST1_Right3=
                    SQLM_TEST1_Brother;
            ELSE
                SQLM_TEST1_Father:SQLC_TEST1_Left3=
                    SQLM_TEST1_Nephew:SQLC_TEST1_Right3;
                SQLM_TEST1_Brother:SQLC_TEST1_Right3=
                    SQLM_TEST1_Nephew:SQLC_TEST1_Left3;
                SQLM_TEST1_Nephew:SQLC_TEST1_Right3=
                    SQLM_TEST1_Father;
                SQLM_TEST1_Nephew:SQLC_TEST1_Left3=
                    SQLM_TEST1_Brother;
            FI;
            SQLM_TEST1_OperRow:SQLC_TEST1_Color3=0;
            SQLM_TEST1_Father:SQLC_TEST1_Color3=1;
            IF SQLM_TEST1_GrandFather:SQLC_TEST1_Left3=
               SQLM_TEST1_Father
            THEN
                SQLM_TEST1_GrandFather:SQLC_TEST1_Left3=
                    SQLM_TEST1_Nephew;
            ELSE
                SQLM_TEST1_GrandFather:SQLC_TEST1_Right3=
                    SQLM_TEST1_Nephew;
            FI;
            SQLM_TEST1_GrandFather=SQLM_TEST1_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_TEST1_Nephew:SQLC_TEST1_Color3=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_TEST1_Brother:SQLC_TEST1_Color3=
                SQLM_TEST1_Father:SQLC_TEST1_Color3;
            IF SQLM_TEST1_Father:SQLC_TEST1_Left3=
               SQLM_TEST1_OperRow
            THEN
                SQLM_TEST1_TempRow=
                    SQLM_TEST1_Brother:SQLC_TEST1_Right3;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color3=1;
                SQLM_TEST1_Father:SQLC_TEST1_Right3=
                    SQLM_TEST1_Brother:SQLC_TEST1_Left3;
                SQLM_TEST1_Brother:SQLC_TEST1_Left3=
                    SQLM_TEST1_Father;
            ELSE
                SQLM_TEST1_TempRow=
                    SQLM_TEST1_Brother:SQLC_TEST1_Left3;
                SQLM_TEST1_TempRow:SQLC_TEST1_Color3=1;
                SQLM_TEST1_Father:SQLC_TEST1_Left3=
                    SQLM_TEST1_Brother:SQLC_TEST1_Right3;
                SQLM_TEST1_Brother:SQLC_TEST1_Right3=
                    SQLM_TEST1_Father;
            FI;
            SQLM_TEST1_OperRow:SQLC_TEST1_Color3=0;
            SQLM_TEST1_Father:SQLC_TEST1_Color3=1;
            IF SQLM_TEST1_GrandFather:SQLC_TEST1_Left3=
                SQLM_TEST1_Father
            THEN
                SQLM_TEST1_GrandFather:SQLC_TEST1_Left3=
                    SQLM_TEST1_Brother;
            ELSE
                SQLM_TEST1_GrandFather:SQLC_TEST1_Right3=
                    SQLM_TEST1_Brother;
            FI;
            SQLM_TEST1_GrandFather=SQLM_TEST1_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey10_3)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_TEST1_DeleteFather=SQLM_TEST1_GrandFather;
        SQLM_TEST1_Delete=SQLM_TEST1_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey10_3;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey10_3)
    IF SQLM_TEST1_Delete /= SQLM_TEST1_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_TEST1_DeleteFather:SQLC_TEST1_Left3=
           SQLM_TEST1_Delete
        THEN
            SQLM_TEST1_DeleteFather:SQLC_TEST1_Left3=
                SQLM_TEST1_Father;
        ELSE
            SQLM_TEST1_DeleteFather:SQLC_TEST1_Right3=
                SQLM_TEST1_Father;
        FI;
        IF SQLM_TEST1_GrandFather:SQLC_TEST1_Left3=
           SQLM_TEST1_Father
        THEN
            SQLM_TEST1_GrandFather:SQLC_TEST1_Left3=
                SQLM_TEST1_NilRow;
        ELSE
            SQLM_TEST1_GrandFather:SQLC_TEST1_Right3=
                SQLM_TEST1_NilRow;
        FI;
        IF SQLM_TEST1_Father /= SQLM_TEST1_Delete THEN
            SQLM_TEST1_Father:SQLC_TEST1_Color3=
                SQLM_TEST1_Delete:SQLC_TEST1_Color3;
            SQLM_TEST1_Father:SQLC_TEST1_Right3=
                SQLM_TEST1_Delete:SQLC_TEST1_Right3;
            SQLM_TEST1_Father:SQLC_TEST1_Left3=
                SQLM_TEST1_Delete:SQLC_TEST1_Left3;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    WHEN 4 DO GOTO towComDelKeyLab4;
    WHEN 5 DO GOTO towComDelKeyLab5;
    WHEN 6 DO GOTO towComDelKeyLab6;
    WHEN 7 DO GOTO towComDelKeyLab7;
    WHEN 8 DO GOTO towComDelKeyLab8;
    WHEN 9 DO GOTO towComDelKeyLab9;
    WHEN 10 DO GOTO towComDelKeyLab10;
    WHEN 11 DO GOTO towComDelKeyLab11;
    WHEN 12 DO GOTO towComDelKeyLab12;
    WHEN 13 DO GOTO towComDelKeyLab13;
    WHEN 14 DO GOTO towComDelKeyLab14;
    WHEN 15 DO GOTO towComDelKeyLab15;
    WHEN 16 DO GOTO towComDelKeyLab16;
    WHEN 17 DO GOTO towComDelKeyLab17;
    WHEN 18 DO GOTO towComDelKeyLab18;
    WHEN 19 DO GOTO towComDelKeyLab19;
    WHEN 20 DO GOTO towComDelKeyLab20;
    WHEN 21 DO GOTO towComDelKeyLab21;
    WHEN 22 DO GOTO towComDelKeyLab22;
    WHEN 23 DO GOTO towComDelKeyLab23;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towPostComRow !
!------------------------------------------------!
    ENTER towPostComRow WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow;
    CASE SQLM_TableReference IS
    WHEN 10 DO GOTO towPostComRowTable10;
    OTHERWISE DO
        SEND towPostComRowR WITH
            SQLX_OtherProtected,
            0;
        EXIT;
    ESAC;
!------------------------------------------------!
!       towPostComRowTable !
!------------------------------------------------!
towPostComRowTable10)
! execute user code !
!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat75;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat75;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat75;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat75;
PROTECTEDALLOCATEDbeginStat75)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat75)
ENABLE INTERRUPT;
    IF SQLCODE = 3 + 17 <= 8 THEN
! Error: Protected region congestion, too many simultaneous users !
        SEND towPostComRowR WITH
            SQLX_OtherProtected,
            SQLCODE;
        EXIT;
    FI;
    PROTECTEDP:SQLBLOCK=SQLX_OtherBlock;
    PROTECTEDP:SQLOPERATION=SQLX_KeyOperation;
    PROTECTEDP:SQLX_SQLPROTECTED=SQLX_OtherProtected;
    PROTECTEDP:SQLX_SQLWORKROW=0;
    PROTECTEDP:SQLX_SQLOPERROW=SQLX_OperRow;
    DO YY;
    SQLX_OtherProtected=PROTECTEDP:SQLX_SQLPROTECTED;
!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_EXTENSIVETABS_Cursor=0;
    IF PROTECTEDP:SQLM_FINDFK_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDFK_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEWTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDORDNO_Cursor=0;
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDTROWNO_Cursor=0;
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor=0;
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETTROWNO_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=10;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab10)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;
! send back success !
    SEND towPostComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBck !
!------------------------------------------------!
    ENTER towRollBck WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow;
    CASE SQLM_TableReference IS
    WHEN 0 DO GOTO towRollBckTable0;
    WHEN 1 DO GOTO towRollBckTable1;
    WHEN 2 DO GOTO towRollBckTable2;
    WHEN 3 DO GOTO towRollBckTable3;
    WHEN 4 DO GOTO towRollBckTable4;
    WHEN 5 DO GOTO towRollBckTable5;
    WHEN 6 DO GOTO towRollBckTable6;
    WHEN 7 DO GOTO towRollBckTable7;
    WHEN 8 DO GOTO towRollBckTable8;
    WHEN 9 DO GOTO towRollBckTable9;
    WHEN 10 DO GOTO towRollBckTable10;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
towRollBckTable0)
! remove work rows and release locks !
    SQLM_PROGRAMS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_PROGRAMS_NilRow=SQLM_PROGRAMS_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_PROGRAMS_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_PROGRAMS_TempRow =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Left2 =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
SQLM_PROGRAMS_TempRow =
    SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;

IF SQLM_PROGRAMS_TempRow /= SQLM_PROGRAMS_NilRow THEN
    SQLM_PROGRAMS_TempRow:SQLC_PROGRAMS_Right2 =
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
FI;
! insert row in free list !
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2 =
    SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2;
SQLM_PROGRAMS_GuardRow:SQLC_PROGRAMS_Right2 =
    SQLM_PROGRAMS_OperRow;
! deallocate work row !
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated=0;
    WHEN 1 DO
        SQLM_PROGRAMS_WorkRow=SQLX_WorkRow;
        SQLM_PROGRAMS_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock=0;
    WHEN 2 DO
        SQLM_PROGRAMS_OperRow=SQLX_OperRow;
        SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
towRollBckTable1)
! remove work rows and release locks !
    SQLM_TABLES_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TABLES_NilRow=SQLM_TABLES_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_TABLES_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TABLES_TempRow =
    SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
SQLM_TABLES_TempRow:SQLC_TABLES_Left3 =
    SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
SQLM_TABLES_TempRow =
    SQLM_TABLES_OperRow:SQLC_TABLES_Left3;

IF SQLM_TABLES_TempRow /= SQLM_TABLES_NilRow THEN
    SQLM_TABLES_TempRow:SQLC_TABLES_Right3 =
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
FI;
! deallocate work row !
        SQLM_TABLES_OperRow:SQLC_TABLES_Allocated=0;
    WHEN 1 DO
        SQLM_TABLES_OperRow=SQLX_WorkRow;
! remove row from insert list. !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TABLES_TempRow =
    SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
SQLM_TABLES_TempRow:SQLC_TABLES_Left3 =
    SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
SQLM_TABLES_TempRow =
    SQLM_TABLES_OperRow:SQLC_TABLES_Left3;

IF SQLM_TABLES_TempRow /= SQLM_TABLES_NilRow THEN
    SQLM_TABLES_TempRow:SQLC_TABLES_Right3 =
        SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
FI;
        SQLM_TABLES_WorkRow=SQLX_WorkRow;
        SQLM_TABLES_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_TABLES_OperRow:SQLC_TABLES_Lock=0;
    WHEN 2 DO
        SQLM_TABLES_OperRow=SQLX_OperRow;
        SQLM_TABLES_OperRow:SQLC_TABLES_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
towRollBckTable2)
! remove work rows and release locks !
    SQLM_FIELDS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_FIELDS_NilRow=SQLM_FIELDS_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_FIELDS_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_FIELDS_TempRow =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
SQLM_FIELDS_TempRow:SQLC_FIELDS_Left3 =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
SQLM_FIELDS_TempRow =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;

IF SQLM_FIELDS_TempRow /= SQLM_FIELDS_NilRow THEN
    SQLM_FIELDS_TempRow:SQLC_FIELDS_Right3 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
FI;
! deallocate work row !
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated=0;
    WHEN 1 DO
        SQLM_FIELDS_OperRow=SQLX_WorkRow;
! remove row from insert list. !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_FIELDS_TempRow =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
SQLM_FIELDS_TempRow:SQLC_FIELDS_Left3 =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
SQLM_FIELDS_TempRow =
    SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;

IF SQLM_FIELDS_TempRow /= SQLM_FIELDS_NilRow THEN
    SQLM_FIELDS_TempRow:SQLC_FIELDS_Right3 =
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
FI;
        SQLM_FIELDS_WorkRow=SQLX_WorkRow;
        SQLM_FIELDS_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock=0;
    WHEN 2 DO
        SQLM_FIELDS_OperRow=SQLX_OperRow;
        SQLM_FIELDS_OperRow:SQLC_FIELDS_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
towRollBckTable3)
! remove work rows and release locks !
    SQLM_KEYS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_KEYS_NilRow=SQLM_KEYS_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_KEYS_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_KEYS_TempRow =
    SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
SQLM_KEYS_TempRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
SQLM_KEYS_TempRow =
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;

IF SQLM_KEYS_TempRow /= SQLM_KEYS_NilRow THEN
    SQLM_KEYS_TempRow:SQLC_KEYS_Right2 =
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
FI;
! insert row in free list !
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_KEYS_OperRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_GuardRow:SQLC_KEYS_Right2;
SQLM_KEYS_GuardRow:SQLC_KEYS_Right2 =
    SQLM_KEYS_OperRow;
! deallocate work row !
        SQLM_KEYS_OperRow:SQLC_KEYS_Allocated=0;
    WHEN 1 DO
        SQLM_KEYS_OperRow=SQLX_WorkRow;
! remove row from insert list. !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_KEYS_TempRow =
    SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
SQLM_KEYS_TempRow:SQLC_KEYS_Left2 =
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
SQLM_KEYS_TempRow =
    SQLM_KEYS_OperRow:SQLC_KEYS_Left2;

IF SQLM_KEYS_TempRow /= SQLM_KEYS_NilRow THEN
    SQLM_KEYS_TempRow:SQLC_KEYS_Right2 =
        SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
FI;
        SQLM_KEYS_WorkRow=SQLX_WorkRow;
        SQLM_KEYS_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_KEYS_OperRow:SQLC_KEYS_Lock=0;
    WHEN 2 DO
        SQLM_KEYS_OperRow=SQLX_OperRow;
        SQLM_KEYS_OperRow:SQLC_KEYS_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
towRollBckTable4)
! remove work rows and release locks !
    SQLM_KEYFIELDS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_KEYFIELDS_NilRow=SQLM_KEYFIELDS_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_KEYFIELDS_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;

IF SQLM_KEYFIELDS_TempRow /= SQLM_KEYFIELDS_NilRow THEN
    SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Right2 =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
FI;
! insert row in free list !
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2;
SQLM_KEYFIELDS_GuardRow:SQLC_KEYFIELDS_Right2 =
    SQLM_KEYFIELDS_OperRow;
! deallocate work row !
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated=0;
    WHEN 1 DO
        SQLM_KEYFIELDS_OperRow=SQLX_WorkRow;
! remove row from insert list. !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Left2 =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
SQLM_KEYFIELDS_TempRow =
    SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;

IF SQLM_KEYFIELDS_TempRow /= SQLM_KEYFIELDS_NilRow THEN
    SQLM_KEYFIELDS_TempRow:SQLC_KEYFIELDS_Right2 =
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
FI;
        SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
        SQLM_KEYFIELDS_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock=0;
    WHEN 2 DO
        SQLM_KEYFIELDS_OperRow=SQLX_OperRow;
        SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
towRollBckTable5)
! remove work rows and release locks !
    SQLM_FOREIGNKEYS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_FOREIGNKEYS_NilRow=SQLM_FOREIGNKEYS_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_FOREIGNKEYS_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;

IF SQLM_FOREIGNKEYS_TempRow /= SQLM_FOREIGNKEYS_NilRow THEN
    SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Right2 =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
FI;
! insert row in free list !
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2;
SQLM_FOREIGNKEYS_GuardRow:SQLC_FOREIGNKEYS_Right2 =
    SQLM_FOREIGNKEYS_OperRow;
! deallocate work row !
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated=0;
    WHEN 1 DO
        SQLM_FOREIGNKEYS_OperRow=SQLX_WorkRow;
! remove row from insert list. !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Left2 =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
SQLM_FOREIGNKEYS_TempRow =
    SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;

IF SQLM_FOREIGNKEYS_TempRow /= SQLM_FOREIGNKEYS_NilRow THEN
    SQLM_FOREIGNKEYS_TempRow:SQLC_FOREIGNKEYS_Right2 =
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
FI;
        SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
        SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock=0;
    WHEN 2 DO
        SQLM_FOREIGNKEYS_OperRow=SQLX_OperRow;
        SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
towRollBckTable6)
! remove work rows and release locks !
    SQLM_SYMBOLS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_SYMBOLS_NilRow=SQLM_SYMBOLS_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_SYMBOLS_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;

IF SQLM_SYMBOLS_TempRow /= SQLM_SYMBOLS_NilRow THEN
    SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Right2 =
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
FI;
! insert row in free list !
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2;
SQLM_SYMBOLS_GuardRow:SQLC_SYMBOLS_Right2 =
    SQLM_SYMBOLS_OperRow;
! deallocate work row !
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated=0;
    WHEN 1 DO
        SQLM_SYMBOLS_OperRow=SQLX_WorkRow;
! remove row from insert list. !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Left2 =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
SQLM_SYMBOLS_TempRow =
    SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;

IF SQLM_SYMBOLS_TempRow /= SQLM_SYMBOLS_NilRow THEN
    SQLM_SYMBOLS_TempRow:SQLC_SYMBOLS_Right2 =
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
FI;
        SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
        SQLM_SYMBOLS_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock=0;
    WHEN 2 DO
        SQLM_SYMBOLS_OperRow=SQLX_OperRow;
        SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
towRollBckTable7)
! remove work rows and release locks !
    SQLM_TOWFAULTCODES_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TOWFAULTCODES_NilRow=SQLM_TOWFAULTCODES_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_TOWFAULTCODES_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TOWFAULTCODES_TempRow =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Left2 =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
SQLM_TOWFAULTCODES_TempRow =
    SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;

IF SQLM_TOWFAULTCODES_TempRow /= SQLM_TOWFAULTCODES_NilRow THEN
    SQLM_TOWFAULTCODES_TempRow:SQLC_TOWFAULTCODES_Right2 =
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
FI;
! insert row in free list !
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2 =
    SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2;
SQLM_TOWFAULTCODES_GuardRow:SQLC_TOWFAULTCODES_Right2 =
    SQLM_TOWFAULTCODES_OperRow;
! deallocate work row !
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated=0;
    WHEN 1 DO
        SQLM_TOWFAULTCODES_WorkRow=SQLX_WorkRow;
        SQLM_TOWFAULTCODES_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock=0;
    WHEN 2 DO
        SQLM_TOWFAULTCODES_OperRow=SQLX_OperRow;
        SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
towRollBckTable8)
! remove work rows and release locks !
    SQLM_SYSFAULTCODES_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_SYSFAULTCODES_NilRow=SQLM_SYSFAULTCODES_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_SYSFAULTCODES_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYSFAULTCODES_TempRow =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Left2 =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
SQLM_SYSFAULTCODES_TempRow =
    SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;

IF SQLM_SYSFAULTCODES_TempRow /= SQLM_SYSFAULTCODES_NilRow THEN
    SQLM_SYSFAULTCODES_TempRow:SQLC_SYSFAULTCODES_Right2 =
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
FI;
! insert row in free list !
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2 =
    SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2;
SQLM_SYSFAULTCODES_GuardRow:SQLC_SYSFAULTCODES_Right2 =
    SQLM_SYSFAULTCODES_OperRow;
! deallocate work row !
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated=0;
    WHEN 1 DO
        SQLM_SYSFAULTCODES_WorkRow=SQLX_WorkRow;
        SQLM_SYSFAULTCODES_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock=0;
    WHEN 2 DO
        SQLM_SYSFAULTCODES_OperRow=SQLX_OperRow;
        SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
towRollBckTable9)
! remove work rows and release locks !
    SQLM_SYSTEMFIELDS_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_SYSTEMFIELDS_NilRow=SQLM_SYSTEMFIELDS_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_SYSTEMFIELDS_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_SYSTEMFIELDS_TempRow =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Left2 =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
SQLM_SYSTEMFIELDS_TempRow =
    SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;

IF SQLM_SYSTEMFIELDS_TempRow /= SQLM_SYSTEMFIELDS_NilRow THEN
    SQLM_SYSTEMFIELDS_TempRow:SQLC_SYSTEMFIELDS_Right2 =
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
FI;
! insert row in free list !
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2 =
    SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2;
SQLM_SYSTEMFIELDS_GuardRow:SQLC_SYSTEMFIELDS_Right2 =
    SQLM_SYSTEMFIELDS_OperRow;
! deallocate work row !
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated=0;
    WHEN 1 DO
        SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
        SQLM_SYSTEMFIELDS_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock=0;
    WHEN 2 DO
        SQLM_SYSTEMFIELDS_OperRow=SQLX_OperRow;
        SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
towRollBckTable10)
!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat77;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat77;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat77;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat77;
PROTECTEDALLOCATEDbeginStat77)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat77)
ENABLE INTERRUPT;
    IF SQLCODE = 3 + 17 <= 8 THEN
! Error: Protected region congestion, too many simultaneous users !
        SEND towRollBckR WITH
            SQLX_OtherProtected,
            SQLCODE;
        EXIT;
    FI;
    PROTECTEDP:SQLBLOCK=SQLX_OtherBlock;
    PROTECTEDP:SQLOPERATION=SQLX_KeyOperation;
    PROTECTEDP:SQLX_SQLPROTECTED=SQLX_OtherProtected;
    PROTECTEDP:SQLX_SQLTABLEREFERENCE=SQLM_TableReference;
    PROTECTEDP:SQLX_SQLOPERROW=SQLX_OperRow;
    PROTECTEDP:SQLX_SQLWORKROW=SQLX_WorkRow;
! execute user specified code !
    DO ZZ;
    SQLX_OtherBlock=PROTECTEDP:SQLBLOCK;
    SQLX_KeyOperation=PROTECTEDP:SQLOPERATION;
    SQLX_OtherProtected=PROTECTEDP:SQLX_SQLPROTECTED;
    SQLM_TableReference=PROTECTEDP:SQLX_SQLTABLEREFERENCE;
    SQLX_OperRow=PROTECTEDP:SQLX_SQLOPERROW;
    SQLX_WorkRow=PROTECTEDP:SQLX_SQLWORKROW;
!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_EXTENSIVETABS_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_EXTENSIVETABS_Cursor=0;
    IF PROTECTEDP:SQLM_FINDFK_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDFK_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEWTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEWTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor=0;
    IF PROTECTEDP:SQLM_FINDORDNO_Cursor /= 0 THEN
        SQLM_FOREIGNKEYS_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDORDNO_Cursor=0;
    IF PROTECTEDP:SQLM_FINDTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_FINDTROWNO_Cursor=0;
    IF PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETBLOCKANDTABREF_Cursor=0;
    IF PROTECTEDP:SQLM_GETTROWNO_Cursor /= 0 THEN
        SQLM_TABLES_WorkRow=PROTECTEDP:SQLM_FINDNEXTTABLE_Cursor;
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
    FI;
    PROTECTEDP:SQLM_GETTROWNO_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=11;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab11)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;
! remove work rows and release locks !
    SQLM_TEST1_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TEST1_NilRow=SQLM_TEST1_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_TEST1_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TEST1_TempRow =
    SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
SQLM_TEST1_TempRow:SQLC_TEST1_Left2 =
    SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
SQLM_TEST1_TempRow =
    SQLM_TEST1_OperRow:SQLC_TEST1_Left2;

IF SQLM_TEST1_TempRow /= SQLM_TEST1_NilRow THEN
    SQLM_TEST1_TempRow:SQLC_TEST1_Right2 =
        SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
FI;
! insert row in free list !
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_TEST1_OperRow:SQLC_TEST1_Left2 =
    SQLM_TEST1_GuardRow:SQLC_TEST1_Right2;
SQLM_TEST1_GuardRow:SQLC_TEST1_Right2 =
    SQLM_TEST1_OperRow;
! deallocate work row !
        SQLM_TEST1_OperRow:SQLC_TEST1_Allocated=0;
    WHEN 1 DO
        SQLM_TEST1_WorkRow=SQLX_WorkRow;
        SQLM_TEST1_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_TEST1_OperRow:SQLC_TEST1_Lock=0;
    WHEN 2 DO
        SQLM_TEST1_OperRow=SQLX_OperRow;
        SQLM_TEST1_OperRow:SQLC_TEST1_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towChaLock !
!------------------------------------------------!
    RECEIVE towChaLock WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow,
        SQLX_OldLock,
        SQLX_Lock,
        SQLX_DBnumber2;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_PROGRAMS_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock = 0 THEN
        IF SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
    WHEN 1 DO
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_TABLES_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_TABLES_WorkRow:SQLC_TABLES_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_TABLES_WorkRow:SQLC_TABLES_Lock = 0 THEN
        IF SQLM_TABLES_WorkRow:SQLC_TABLES_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_TABLES_WorkRow:SQLC_TABLES_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
    WHEN 2 DO
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_FIELDS_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock = 0 THEN
        IF SQLM_FIELDS_WorkRow:SQLC_FIELDS_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_FIELDS_WorkRow:SQLC_FIELDS_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
    WHEN 3 DO
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_KEYS_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_KEYS_WorkRow:SQLC_KEYS_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_KEYS_WorkRow:SQLC_KEYS_Lock = 0 THEN
        IF SQLM_KEYS_WorkRow:SQLC_KEYS_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_KEYS_WorkRow:SQLC_KEYS_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
    WHEN 4 DO
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_KEYFIELDS_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock = 0 THEN
        IF SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
    WHEN 5 DO
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_FOREIGNKEYS_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock = 0 THEN
        IF SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
    WHEN 6 DO
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_SYMBOLS_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock = 0 THEN
        IF SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
    WHEN 7 DO
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_TOWFAULTCODES_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock = 0 THEN
        IF SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
    WHEN 8 DO
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_SYSFAULTCODES_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock = 0 THEN
        IF SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
    WHEN 9 DO
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_SYSTEMFIELDS_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock = 0 THEN
        IF SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
    WHEN 10 DO
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_TEST1_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_TEST1_WorkRow:SQLC_TEST1_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_TEST1_WorkRow:SQLC_TEST1_Lock = 0 THEN
        IF SQLM_TEST1_WorkRow:SQLC_TEST1_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_TEST1_WorkRow:SQLC_TEST1_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------!
!       towGetTabNam!
!--------------------------------!
    RECEIVE towGetTabNam WITH
        SQLX_OtherProtected,
        SQLM_TableReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "PROGRAM REFERENCES";
    WHEN 1 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "TABLE DEFINITIONS";
    WHEN 2 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "FIELD DEFINITIONS";
    WHEN 3 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "KEY DEFINITIONS";
    WHEN 4 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "KEYFIELD DEFINITIONS";
    WHEN 5 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "FOREIGN KEY DEFINITIONS";
    WHEN 6 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "SYMBOL VALUES";
    WHEN 7 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "TABLE OWNER FAULT CODES";
    WHEN 8 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 9 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 10 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "test table no 1";
    OTHERWISE DO
        RETURN towGetTabNamAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetTabDat!
!--------------------------------!
    RECEIVE towGetTabDat WITH
        SQLX_OtherProtected,
        SQLM_TableReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_PROGRAMS_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_PROGRAMS_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        11,
        11,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        11,
        0,
        11,
        11,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        11,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        2;
    WHEN 1 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TABLES_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TABLES_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        21,
        65000,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        1,
        0,
        22,
        500,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        4;
    WHEN 2 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FIELDS_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FIELDS_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        21,
        65000,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        1,
        0,
        22,
        500,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        5;
    WHEN 3 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_KEYS_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_KEYS_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        1,
        65000,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        1,
        0,
        2,
        500,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        4;
    WHEN 4 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_KEYFIELDS_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_KEYFIELDS_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        3,
        30,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        1,
        0,
        4,
        500,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        3;
    WHEN 5 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FOREIGNKEYS_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FOREIGNKEYS_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        5,
        30,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        1,
        0,
        6,
        500,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        5;
    WHEN 6 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_SYMBOLS_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_SYMBOLS_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        7,
        65000,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        1,
        0,
        8,
        500,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        3;
    WHEN 7 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TOWFAULTCODES_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TOWFAULTCODES_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        9,
        30,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        1,
        0,
        10,
        500,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        2;
    WHEN 8 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_SYSFAULTCODES_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_SYSFAULTCODES_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        13,
        30,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        1,
        0,
        14,
        500,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        2;
    WHEN 9 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_SYSTEMFIELDS_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_SYSTEMFIELDS_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        15,
        65000,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        1,
        0,
        16,
        500,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        3;
    WHEN 10 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TEST1_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TEST1_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        19,
        65000,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        1,
        0,
        20,
        500,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        3;
    OTHERWISE DO
        RETURN towGetTabDatAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetFldNam!
!--------------------------------!
    RECEIVE towGetFldNam WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "BLOCK NAME";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "TABLE NAME";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 4 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 5 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "TABLE DESCRIPTION";
    WHEN 6 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 7 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 8 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 9 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 10 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 11 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 12 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 13 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 14 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 15 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 16 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 17 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "READ AUTHORITY CATEGORY";
    WHEN 18 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "WRITE AUTHORITY CATEGORY";
    WHEN 19 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "TABLE LOCATION";
    WHEN 20 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "NUMBER OF FAULT CODES";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "FIELD NAME";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 4 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 5 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 6 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "FIELD DESCRIPTION";
    WHEN 7 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 8 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 9 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "NULL PERMITTED";
    WHEN 10 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 11 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "BASE ADDRESS";
    WHEN 12 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 13 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 14 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 15 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 16 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 17 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 18 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 19 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 20 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 21 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 22 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 23 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 24 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 25 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 26 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 27 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 4 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 5 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 6 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 4 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 5 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 6 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 7 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 5 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 4 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 5 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 6 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 7 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 8 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 9 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 10 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 6 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "SYMBOL NAME";
    WHEN 4 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "SYMBOL VALUE";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 7 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 4 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 8 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 9 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 4 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 10 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "column 1";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "column 2";
    WHEN 4 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "column 3";
    WHEN 5 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "column 4";
    WHEN 6 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 7 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 8 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 9 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetStrFld!
!--------------------------------!
    RECEIVE towGetStrFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_PROGRAMS_NAME_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    OTHERWISE DO
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 1 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_NAME_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    WHEN 5 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_DESCR_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        3,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "  ",
        1;
    OTHERWISE DO
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_NAME_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    WHEN 6 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_DESCR_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        3,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "  ",
        1;
    WHEN 23 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FIELDS_DEFSTR_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FIELDS_DEFSTR_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        4,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    WHEN 24 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FIELDS_DEFNSTR_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FIELDS_DEFNSTR_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        4,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    OTHERWISE DO
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    WHEN 4 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    WHEN 5 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    WHEN 6 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 3 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_SYMBOLS_SYMBOL_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    OTHERWISE DO
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 7 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 4 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TOWFAULTCODES_FLTTEXT_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    OTHERWISE DO
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 8 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 3 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_SYSFAULTCODES_FLTTEXT_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    OTHERWISE DO
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 9 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    WHEN 10 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TEST1_COL1_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    WHEN 5 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TEST1_COL4_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        3,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "xxx",
        1;
    WHEN 7 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TEST1_COL6_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TEST1_COL6_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        4,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    WHEN 6 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TEST1_COL5_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TEST1_COL5_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        4,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    OTHERWISE DO
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetNumFld!
!--------------------------------!
    RECEIVE towGetNumFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 3 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_PROGRAMS_BLKREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        65535,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 1 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 3 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_BLKREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        65535,
        1;
    WHEN 4 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_TABREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        4095,
        1;
    WHEN 6 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TABLES_SAEIDT_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TABLES_SAEIDT_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        999,
        1;
    WHEN 7 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_ESTEPT_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, 1,
        1,
        65531,
        1;
    WHEN 8 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_MAXST_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, 65531,
        0,
        65531,
        1;
    WHEN 9 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_ALLOCST_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65531,
        1;
    WHEN 10 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_USEDST_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65531,
        1;
    WHEN 11 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TABLES_SAEIDW_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TABLES_SAEIDW_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        999,
        1;
    WHEN 12 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_ESTEPW_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, 1,
        1,
        65531,
        1;
    WHEN 13 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_MAXSW_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, 65531,
        0,
        65531,
        1;
    WHEN 14 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_ALLOCSW_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65531,
        1;
    WHEN 15 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_USEDSW_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65531,
        1;
    WHEN 17 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_RAUCAT_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        63,
        1;
    WHEN 18 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_WAUCAT_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        63,
        1;
    WHEN 20 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_NOFLTCO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        64,
        1;
    WHEN 16 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_STATE_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, TABLESSTATEWORKING,
        0,
        1,
        1;
    WHEN 19 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLES_LOCATE_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, TABLESLOCATESINGLE,
        0,
        1,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 3 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_TABREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        4095,
        1;
    WHEN 4 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_BLKREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        65535,
        1;
    WHEN 5 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_FIELDNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        4096,
        1;
    WHEN 8 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_PRWIDTH_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        63,
        1;
    WHEN 11 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_BADDRES_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        4095,
        1;
    WHEN 12 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FIELDS_MIN_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FIELDS_MIN_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        65535,
        1;
    WHEN 13 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FIELDS_MAX_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FIELDS_MAX_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        65535,
        1;
    WHEN 14 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_SIZE_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65535,
        1;
    WHEN 15 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FIELDS_DIDNR_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FIELDS_DIDNR_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        65535,
        1;
    WHEN 16 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FIELDS_DIDPOS_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FIELDS_DIDPOS_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        65535,
        1;
    WHEN 22 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FIELDS_DEFBITS_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FIELDS_DEFBITS_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        65535,
        1;
    WHEN 27 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FIELDS_TROWNO_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FIELDS_TROWNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        65531,
        1;
    WHEN 7 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_VISIBIL_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, FIELDSVISIBILREADWR,
        0,
        2,
        1;
    WHEN 9 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_NULLPER_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        1,
        1;
    WHEN 10 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_DATATYP_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        6,
        1;
    WHEN 17 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_PCLEAR_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, FIELDSPCLEARNO,
        0,
        1,
        1;
    WHEN 18 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_PRELOAD_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, FIELDSPRELOADYES,
        0,
        1,
        1;
    WHEN 19 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_PDUMP_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, FIELDSPDUMPNO,
        0,
        1,
        1;
    WHEN 20 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_PSTATIC_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, FIELDSPSTATICNO,
        0,
        1,
        1;
    WHEN 21 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FIELDS_VOLATIL_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, FIELDSVOLATILNO,
        0,
        1,
        1;
    WHEN 26 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FIELDS_DEFSYMB_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FIELDS_DEFSYMB_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        2,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_KEYS_TROWNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        1, 1,
        0,
        65531,
        1;
    WHEN 3 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_KEYS_KEYNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        255,
        1;
    WHEN 4 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_KEYS_TABREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        4095,
        1;
    WHEN 5 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_KEYS_BLKREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        65535,
        1;
    WHEN 6 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_KEYS_KEYTYPE_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        2,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_KEYFIELDS_TROWNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65531,
        1;
    WHEN 3 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_KEYFIELDS_KEYNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        255,
        1;
    WHEN 4 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_KEYFIELDS_TABREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        4095,
        1;
    WHEN 5 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_KEYFIELDS_BLKREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        65535,
        1;
    WHEN 6 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_KEYFIELDS_COMPNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        16,
        1;
    WHEN 7 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_KEYFIELDS_FROWNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65531,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 5 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FOREIGNKEYS_TROWNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65531,
        1;
    WHEN 3 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FOREIGNKEYS_ORDNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        255,
        1;
    WHEN 4 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FOREIGNKEYS_BLKREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        65535,
        1;
    WHEN 5 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FOREIGNKEYS_TABREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        4095,
        1;
    WHEN 6 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FOREIGNKEYS_KEYNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        255,
        1;
    WHEN 7 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FOREIGNKEYS_FTROWNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65531,
        1;
    WHEN 8 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FOREIGNKEYS_FTABREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        4095,
        1;
    WHEN 9 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FOREIGNKEYS_FBLKREF_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        65535,
        1;
    WHEN 10 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_FOREIGNKEYS_COND_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        3,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 6 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_SYMBOLS_FROWNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65531,
        1;
    WHEN 4 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_SYMBOLS_SYMVAL_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65535,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 7 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TOWFAULTCODES_TROWNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65531,
        1;
    WHEN 3 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TOWFAULTCODES_FAULTNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        255,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 8 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_SYSFAULTCODES_FAULTNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        256,
        511,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 9 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_SYSTEMFIELDS_TROWNO_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65531,
        1;
    WHEN 3 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_SYSTEMFIELDS_ROWGEN_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        4095,
        1;
    WHEN 4 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_SYSTEMFIELDS_LOCK_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        1,
        4095,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 10 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 3 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TEST1_COL2_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65535,
        1;
    WHEN 4 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TEST1_COL3_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TEST1_COL3_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        65535,
        1;
    WHEN 8 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TEST1_COL7_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TEST1_COL7_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        1,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetPckFld!
!--------------------------------!
    RECEIVE towGetPckFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    WHEN 1 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    WHEN 2 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 25 DO
!--------------------------------!
!       towGetPckFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_FIELDS_DEFPNS_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_FIELDS_DEFPNS_Data TO
        SQLX_BaseAddress2;
    RETURN towGetPckFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0, 0, 0, 0, 0, 0, 0, 0,
        1;
    OTHERWISE DO
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    WHEN 4 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    WHEN 5 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    WHEN 6 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    WHEN 7 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    WHEN 8 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    WHEN 9 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    WHEN 10 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 9 DO
!--------------------------------!
!       towGetPckFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TEST1_COL8_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TEST1_COL8_Data TO
        SQLX_BaseAddress2;
    RETURN towGetPckFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0, 0, 0, 0, 0, 0, 0, 0,
        1;
    OTHERWISE DO
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetKeyFld!
!--------------------------------!
    RECEIVE towGetKeyFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLX_ComponentReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 1 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0, 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0, 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    WHEN 2 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        4;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        4;
    WHEN 2 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        5;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 5 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        27;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        5;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        4;
    WHEN 2 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    WHEN 2 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        6;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        5;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        4;
    WHEN 2 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    WHEN 3 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        6;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 5 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        4;
    WHEN 2 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        5;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 5 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        7;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 6 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        4;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 7 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 8 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 9 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 10 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    WHEN 1 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        3;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        6;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetKeyDat!
!--------------------------------!
    RECEIVE towGetKeyDat WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        1;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 1 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 0, 0, 1;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        1,
        2;
    EXIT;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        3,
        1;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 0, 0, 1;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        1,
        3;
    EXIT;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        1,
        3;
    EXIT;
    WHEN 5 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        3,
        1;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        2;
    EXIT;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        1,
        3;
    EXIT;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        3,
        1;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        3;
    EXIT;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        1,
        4;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 5 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        2;
    EXIT;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        1,
        3;
    EXIT;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        3,
        1;
    EXIT;
    WHEN 5 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        3,
        1;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 6 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        2;
    EXIT;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        1,
        2;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 7 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        2;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 8 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        1;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 9 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        1;
    EXIT;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        3,
        1;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 10 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        2;
    EXIT;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        2,
        1;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetFks!
!--------------------------------!
    RECEIVE towGetFks WITH
        SQLX_OtherProtected,
        SQLM_TableReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        0,
        0;
    WHEN 1 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        1,
        4;
    WHEN 2 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        1,
        5;
    WHEN 3 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        1,
        4;
    WHEN 4 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        0,
        0;
    WHEN 5 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        2,
        4;
    WHEN 6 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        0,
        0;
    WHEN 7 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        0,
        0;
    WHEN 8 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        0,
        0;
    WHEN 9 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        1,
        3;
    WHEN 10 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        0,
        0;
    OTHERWISE DO
        RETURN towGetFksAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetFkInf!
!--------------------------------!
    RECEIVE towGetFkInf WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    WHEN 1 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 4 DO
        RETURN towGetFkInfAck WITH
            SQLX_OtherProtected,
            0,
            "PROGRAMS";
    OTHERWISE DO;
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 5 DO
        RETURN towGetFkInfAck WITH
            SQLX_OtherProtected,
            0,
            "TABLES";
    OTHERWISE DO;
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 4 DO
        RETURN towGetFkInfAck WITH
            SQLX_OtherProtected,
            0,
            "TABLES";
    OTHERWISE DO;
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    WHEN 5 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 4 DO
        RETURN towGetFkInfAck WITH
            SQLX_OtherProtected,
            0,
            "TABLES";
    WHEN 5 DO
        RETURN towGetFkInfAck WITH
            SQLX_OtherProtected,
            0,
            "TABLES";
    OTHERWISE DO;
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 6 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    WHEN 7 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    WHEN 8 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    WHEN 9 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 3 DO
        RETURN towGetFkInfAck WITH
            SQLX_OtherProtected,
            0,
            "TABLES";
    OTHERWISE DO;
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    ESAC;
    WHEN 10 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    OTHERWISE DO
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetFlt!
!--------------------------------!
    RECEIVE towGetFlt WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_FaultCode;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    WHEN 1 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    WHEN 2 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    WHEN 3 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    WHEN 4 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    WHEN 5 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    WHEN 6 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    WHEN 7 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    WHEN 8 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    WHEN 9 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    WHEN 10 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    OTHERWISE DO
        RETURN towGetFltAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetPreFlt!
!--------------------------------!
    RECEIVE towGetPreFlt WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_FaultCode;
        SQLX_ReturnCode=1;
    RETURN towGetPreFltAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_FaultCode;
!--------------------------------!
!       towGetSymbol!
!--------------------------------!
    RECEIVE towGetSymbol WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference,
        SQLX_SymbolValue;
    SQLX_ReturnCode=0;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 1 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
   CASE SQLX_ColumnReference IS
    WHEN 16 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="BLOCKED";
    WHEN 1 DO
        SQLX_Symbol="WORKING";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 19 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="SINGLE";
    WHEN 1 DO
        SQLX_Symbol="MULTI";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
   CASE SQLX_ColumnReference IS
    WHEN 7 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="INVIS";
    WHEN 1 DO
        SQLX_Symbol="READO";
    WHEN 2 DO
        SQLX_Symbol="READWR";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 9 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="TRUE";
    WHEN 1 DO
        SQLX_Symbol="FALSE";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 10 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="BITS";
    WHEN 1 DO
        SQLX_Symbol="STRING";
    WHEN 2 DO
        SQLX_Symbol="NUMSTR";
    WHEN 3 DO
        SQLX_Symbol="PNUMSTR";
    WHEN 4 DO
        SQLX_Symbol="SYMBOL";
    WHEN 5 DO
        SQLX_Symbol="ROWNUM";
    WHEN 6 DO
        SQLX_Symbol="DBNUM";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 17 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="YES";
    WHEN 1 DO
        SQLX_Symbol="NO";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 18 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="YES";
    WHEN 1 DO
        SQLX_Symbol="NO";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 19 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="YES";
    WHEN 1 DO
        SQLX_Symbol="NO";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 20 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="YES";
    WHEN 1 DO
        SQLX_Symbol="NO";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 21 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="YES";
    WHEN 1 DO
        SQLX_Symbol="NO";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 26 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="SYMBOL1";
    WHEN 1 DO
        SQLX_Symbol="SYMBOL2";
    WHEN 2 DO
        SQLX_Symbol="SYMBOL3";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
   CASE SQLX_ColumnReference IS
    WHEN 6 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="PRIMKEY";
    WHEN 1 DO
        SQLX_Symbol="ALTERN";
    WHEN 2 DO
        SQLX_Symbol="INDKEY";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 5 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
   CASE SQLX_ColumnReference IS
    WHEN 10 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="RESTR";
    WHEN 1 DO
        SQLX_Symbol="CASCAD";
    WHEN 2 DO
        SQLX_Symbol="SETNULL";
    WHEN 3 DO
        SQLX_Symbol="SETDEF";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    WHEN 6 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 7 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 8 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 9 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 10 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
   CASE SQLX_ColumnReference IS
    WHEN 8 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="FALSE";
    WHEN 1 DO
        SQLX_Symbol="TRUE";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    OTHERWISE DO SQLX_ReturnCode=1;
    ESAC;
    RETURN towGetSymbolAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_Symbol;
!--------------------------------!
!       towGetSymVal!
!--------------------------------!
    RECEIVE towGetSymVal WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference,
        SQLX_Symbol;
    SQLX_ReturnCode=0;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 1 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 16 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "BLOCKED" DO
        SQLX_SymbolValue=0;
    WHEN "WORKING" DO
        SQLX_SymbolValue=1;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 19 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "SINGLE" DO
        SQLX_SymbolValue=0;
    WHEN "MULTI" DO
        SQLX_SymbolValue=1;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 7 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "INVIS" DO
        SQLX_SymbolValue=0;
    WHEN "READO" DO
        SQLX_SymbolValue=1;
    WHEN "READWR" DO
        SQLX_SymbolValue=2;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 9 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "TRUE" DO
        SQLX_SymbolValue=0;
    WHEN "FALSE" DO
        SQLX_SymbolValue=1;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 10 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "BITS" DO
        SQLX_SymbolValue=0;
    WHEN "STRING" DO
        SQLX_SymbolValue=1;
    WHEN "NUMSTR" DO
        SQLX_SymbolValue=2;
    WHEN "PNUMSTR" DO
        SQLX_SymbolValue=3;
    WHEN "SYMBOL" DO
        SQLX_SymbolValue=4;
    WHEN "ROWNUM" DO
        SQLX_SymbolValue=5;
    WHEN "DBNUM" DO
        SQLX_SymbolValue=6;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 17 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "YES" DO
        SQLX_SymbolValue=0;
    WHEN "NO" DO
        SQLX_SymbolValue=1;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 18 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "YES" DO
        SQLX_SymbolValue=0;
    WHEN "NO" DO
        SQLX_SymbolValue=1;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 19 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "YES" DO
        SQLX_SymbolValue=0;
    WHEN "NO" DO
        SQLX_SymbolValue=1;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 20 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "YES" DO
        SQLX_SymbolValue=0;
    WHEN "NO" DO
        SQLX_SymbolValue=1;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 21 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "YES" DO
        SQLX_SymbolValue=0;
    WHEN "NO" DO
        SQLX_SymbolValue=1;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    WHEN 26 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "SYMBOL1" DO
        SQLX_SymbolValue=0;
    WHEN "SYMBOL2" DO
        SQLX_SymbolValue=1;
    WHEN "SYMBOL3" DO
        SQLX_SymbolValue=2;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 6 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "PRIMKEY" DO
        SQLX_SymbolValue=0;
    WHEN "ALTERN" DO
        SQLX_SymbolValue=1;
    WHEN "INDKEY" DO
        SQLX_SymbolValue=2;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 5 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 10 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "RESTR" DO
        SQLX_SymbolValue=0;
    WHEN "CASCAD" DO
        SQLX_SymbolValue=1;
    WHEN "SETNULL" DO
        SQLX_SymbolValue=2;
    WHEN "SETDEF" DO
        SQLX_SymbolValue=3;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    WHEN 6 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 7 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 8 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 9 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
        SQLX_ReturnCode=2;
    WHEN 10 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 8 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "FALSE" DO
        SQLX_SymbolValue=0;
    WHEN "TRUE" DO
        SQLX_SymbolValue=1;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    OTHERWISE DO SQLX_ReturnCode=1;
    ESAC;
    RETURN towGetSymValAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_SymbolValue;
!--------------------------------!
!       towGetPreSym!
!--------------------------------!
    RECEIVE towGetPreSym WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference,
        SQLX_SymbolValue;
    SQLX_ReturnCode=0;
    CASE SQLM_TableReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetPreSymTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 16 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="WORKING";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="BLOCKED";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    WHEN 19 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="MULTI";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="SINGLE";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    OTHERWISE DO SQLX_ReturnCode=2;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetPreSymTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 7 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 2 THEN
        SQLX_SymbolValue=2;
        SQLX_Symbol="READWR";
    ELSIF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="READO";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="INVIS";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    WHEN 9 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="FALSE";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="TRUE";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    WHEN 10 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 6 THEN
        SQLX_SymbolValue=6;
        SQLX_Symbol="DBNUM";
    ELSIF SQLX_SymbolValue > 5 THEN
        SQLX_SymbolValue=5;
        SQLX_Symbol="ROWNUM";
    ELSIF SQLX_SymbolValue > 4 THEN
        SQLX_SymbolValue=4;
        SQLX_Symbol="SYMBOL";
    ELSIF SQLX_SymbolValue > 3 THEN
        SQLX_SymbolValue=3;
        SQLX_Symbol="PNUMSTR";
    ELSIF SQLX_SymbolValue > 2 THEN
        SQLX_SymbolValue=2;
        SQLX_Symbol="NUMSTR";
    ELSIF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="STRING";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="BITS";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    WHEN 17 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="NO";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="YES";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    WHEN 18 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="NO";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="YES";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    WHEN 19 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="NO";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="YES";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    WHEN 20 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="NO";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="YES";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    WHEN 21 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="NO";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="YES";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    WHEN 26 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 2 THEN
        SQLX_SymbolValue=2;
        SQLX_Symbol="SYMBOL3";
    ELSIF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="SYMBOL2";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="SYMBOL1";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    OTHERWISE DO SQLX_ReturnCode=2;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetPreSymTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 6 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 2 THEN
        SQLX_SymbolValue=2;
        SQLX_Symbol="INDKEY";
    ELSIF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="ALTERN";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="PRIMKEY";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    OTHERWISE DO SQLX_ReturnCode=2;
    ESAC;
    WHEN 5 DO
!--------------------------------!
!       towGetPreSymTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 10 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 3 THEN
        SQLX_SymbolValue=3;
        SQLX_Symbol="SETDEF";
    ELSIF SQLX_SymbolValue > 2 THEN
        SQLX_SymbolValue=2;
        SQLX_Symbol="SETNULL";
    ELSIF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="CASCAD";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="RESTR";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    OTHERWISE DO SQLX_ReturnCode=2;
    ESAC;
    WHEN 10 DO
!--------------------------------!
!       towGetPreSymTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 8 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="TRUE";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="FALSE";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    OTHERWISE DO SQLX_ReturnCode=2;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=1;
    ESAC;
    RETURN towGetPreSymAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_SymbolValue,
        SQLX_Symbol;
!------------------------------------------------!
!       RESTARTPHASE1 !
!------------------------------------------------!
RESTARTPHASE1)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        1,
        cOwnRef,
        0,
        "PROGRAMS",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab1)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        1,
        cOwnRef,
        0,
        "DBNUM",
        1,
        2,
        6,
        32,
        1;
    EXIT;
ddhInitFieldLab1)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        2,
        cOwnRef,
        0,
        "NAME",
        2,
        1,
        1,
        7,
        1;
    EXIT;
ddhInitFieldLab2)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        3,
        cOwnRef,
        0,
        "BLKREF",
        3,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab3)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        2,
        cOwnRef,
        1,
        "TABLES",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab2)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        4,
        cOwnRef,
        1,
        "DBNUM",
        1,
        2,
        6,
        32,
        1;
    EXIT;
ddhInitFieldLab4)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        5,
        cOwnRef,
        1,
        "NAME",
        2,
        1,
        1,
        15,
        1;
    EXIT;
ddhInitFieldLab5)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        6,
        cOwnRef,
        1,
        "BLKREF",
        3,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab6)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        7,
        cOwnRef,
        1,
        "TABREF",
        4,
        0,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab7)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        8,
        cOwnRef,
        1,
        "DESCR",
        5,
        1,
        1,
        31,
        1;
    EXIT;
ddhInitFieldLab8)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        9,
        cOwnRef,
        1,
        "SAEIDT",
        6,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab9)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        10,
        cOwnRef,
        1,
        "ESTEPT",
        7,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab10)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        11,
        cOwnRef,
        1,
        "MAXST",
        8,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab11)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        12,
        cOwnRef,
        1,
        "ALLOCST",
        9,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab12)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        13,
        cOwnRef,
        1,
        "USEDST",
        10,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab13)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        14,
        cOwnRef,
        1,
        "SAEIDW",
        11,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab14)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        15,
        cOwnRef,
        1,
        "ESTEPW",
        12,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab15)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        16,
        cOwnRef,
        1,
        "MAXSW",
        13,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab16)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        17,
        cOwnRef,
        1,
        "ALLOCSW",
        14,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab17)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        18,
        cOwnRef,
        1,
        "USEDSW",
        15,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab18)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        19,
        cOwnRef,
        1,
        "STATE",
        16,
        1,
        4,
        1,
        1;
    EXIT;
ddhInitFieldLab19)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        20,
        cOwnRef,
        1,
        "RAUCAT",
        17,
        2,
        0,
        8,
        1;
    EXIT;
ddhInitFieldLab20)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        21,
        cOwnRef,
        1,
        "WAUCAT",
        18,
        2,
        0,
        8,
        1;
    EXIT;
ddhInitFieldLab21)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        22,
        cOwnRef,
        1,
        "LOCATE",
        19,
        1,
        4,
        1,
        1;
    EXIT;
ddhInitFieldLab22)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        23,
        cOwnRef,
        1,
        "NOFLTCO",
        20,
        1,
        0,
        8,
        1;
    EXIT;
ddhInitFieldLab23)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        3,
        cOwnRef,
        2,
        "FIELDS",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab3)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        24,
        cOwnRef,
        2,
        "DBNUM",
        1,
        2,
        6,
        32,
        1;
    EXIT;
ddhInitFieldLab24)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        25,
        cOwnRef,
        2,
        "NAME",
        2,
        1,
        1,
        7,
        1;
    EXIT;
ddhInitFieldLab25)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        26,
        cOwnRef,
        2,
        "TABREF",
        3,
        0,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab26)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        27,
        cOwnRef,
        2,
        "BLKREF",
        4,
        0,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab27)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        28,
        cOwnRef,
        2,
        "FIELDNO",
        5,
        0,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab28)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        29,
        cOwnRef,
        2,
        "DESCR",
        6,
        1,
        1,
        31,
        1;
    EXIT;
ddhInitFieldLab29)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        30,
        cOwnRef,
        2,
        "VISIBIL",
        7,
        1,
        4,
        2,
        1;
    EXIT;
ddhInitFieldLab30)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        31,
        cOwnRef,
        2,
        "PRWIDTH",
        8,
        1,
        0,
        8,
        1;
    EXIT;
ddhInitFieldLab31)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        32,
        cOwnRef,
        2,
        "NULLPER",
        9,
        1,
        4,
        1,
        1;
    EXIT;
ddhInitFieldLab32)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        33,
        cOwnRef,
        2,
        "DATATYP",
        10,
        1,
        4,
        4,
        1;
    EXIT;
ddhInitFieldLab33)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        34,
        cOwnRef,
        2,
        "BADDRES",
        11,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab34)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        35,
        cOwnRef,
        2,
        "MIN",
        12,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab35)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        36,
        cOwnRef,
        2,
        "MAX",
        13,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab36)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        37,
        cOwnRef,
        2,
        "SIZE",
        14,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab37)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        38,
        cOwnRef,
        2,
        "DIDNR",
        15,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab38)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        39,
        cOwnRef,
        2,
        "DIDPOS",
        16,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab39)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        40,
        cOwnRef,
        2,
        "PCLEAR",
        17,
        1,
        4,
        1,
        1;
    EXIT;
ddhInitFieldLab40)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        41,
        cOwnRef,
        2,
        "PRELOAD",
        18,
        1,
        4,
        1,
        1;
    EXIT;
ddhInitFieldLab41)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        42,
        cOwnRef,
        2,
        "PDUMP",
        19,
        1,
        4,
        1,
        1;
    EXIT;
ddhInitFieldLab42)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        43,
        cOwnRef,
        2,
        "PSTATIC",
        20,
        1,
        4,
        1,
        1;
    EXIT;
ddhInitFieldLab43)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        44,
        cOwnRef,
        2,
        "VOLATIL",
        21,
        1,
        4,
        1,
        1;
    EXIT;
ddhInitFieldLab44)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        45,
        cOwnRef,
        2,
        "DEFBITS",
        22,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab45)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        46,
        cOwnRef,
        2,
        "DEFSTR",
        23,
        1,
        1,
        31,
        1;
    EXIT;
ddhInitFieldLab46)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        47,
        cOwnRef,
        2,
        "DEFNSTR",
        24,
        1,
        2,
        31,
        1;
    EXIT;
ddhInitFieldLab47)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        48,
        cOwnRef,
        2,
        "DEFPNS",
        25,
        1,
        3,
        28,
        1;
    EXIT;
ddhInitFieldLab48)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        49,
        cOwnRef,
        2,
        "DEFSYMB",
        26,
        1,
        4,
        2,
        1;
    EXIT;
ddhInitFieldLab49)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        50,
        cOwnRef,
        2,
        "TROWNO",
        27,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab50)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        4,
        cOwnRef,
        3,
        "KEYS",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab4)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        51,
        cOwnRef,
        3,
        "DBNUM",
        1,
        2,
        6,
        32,
        1;
    EXIT;
ddhInitFieldLab51)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        52,
        cOwnRef,
        3,
        "TROWNO",
        2,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab52)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        53,
        cOwnRef,
        3,
        "KEYNO",
        3,
        1,
        0,
        8,
        1;
    EXIT;
ddhInitFieldLab53)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        54,
        cOwnRef,
        3,
        "TABREF",
        4,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab54)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        55,
        cOwnRef,
        3,
        "BLKREF",
        5,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab55)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        56,
        cOwnRef,
        3,
        "KEYTYPE",
        6,
        1,
        4,
        2,
        1;
    EXIT;
ddhInitFieldLab56)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        5,
        cOwnRef,
        4,
        "KEYFIELDS",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab5)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        57,
        cOwnRef,
        4,
        "DBNUM",
        1,
        2,
        6,
        32,
        1;
    EXIT;
ddhInitFieldLab57)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        58,
        cOwnRef,
        4,
        "TROWNO",
        2,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab58)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        59,
        cOwnRef,
        4,
        "KEYNO",
        3,
        1,
        0,
        8,
        1;
    EXIT;
ddhInitFieldLab59)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        60,
        cOwnRef,
        4,
        "TABREF",
        4,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab60)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        61,
        cOwnRef,
        4,
        "BLKREF",
        5,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab61)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        62,
        cOwnRef,
        4,
        "COMPNO",
        6,
        1,
        0,
        8,
        1;
    EXIT;
ddhInitFieldLab62)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        63,
        cOwnRef,
        4,
        "FROWNO",
        7,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab63)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        6,
        cOwnRef,
        5,
        "FOREIGNKEYS",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab6)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        64,
        cOwnRef,
        5,
        "DBNUM",
        1,
        2,
        6,
        32,
        1;
    EXIT;
ddhInitFieldLab64)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        65,
        cOwnRef,
        5,
        "TROWNO",
        2,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab65)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        66,
        cOwnRef,
        5,
        "ORDNO",
        3,
        1,
        0,
        8,
        1;
    EXIT;
ddhInitFieldLab66)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        67,
        cOwnRef,
        5,
        "BLKREF",
        4,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab67)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        68,
        cOwnRef,
        5,
        "TABREF",
        5,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab68)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        69,
        cOwnRef,
        5,
        "KEYNO",
        6,
        1,
        0,
        8,
        1;
    EXIT;
ddhInitFieldLab69)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        70,
        cOwnRef,
        5,
        "FTROWNO",
        7,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab70)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        71,
        cOwnRef,
        5,
        "FTABREF",
        8,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab71)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        72,
        cOwnRef,
        5,
        "FBLKREF",
        9,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab72)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        73,
        cOwnRef,
        5,
        "COND",
        10,
        1,
        4,
        4,
        1;
    EXIT;
ddhInitFieldLab73)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        7,
        cOwnRef,
        6,
        "SYMBOLS",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab7)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        74,
        cOwnRef,
        6,
        "DBNUM",
        1,
        2,
        6,
        32,
        1;
    EXIT;
ddhInitFieldLab74)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        75,
        cOwnRef,
        6,
        "FROWNO",
        2,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab75)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        76,
        cOwnRef,
        6,
        "SYMBOL",
        3,
        1,
        1,
        7,
        1;
    EXIT;
ddhInitFieldLab76)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        77,
        cOwnRef,
        6,
        "SYMVAL",
        4,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab77)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        8,
        cOwnRef,
        7,
        "TOWFAULTCODES",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab8)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        78,
        cOwnRef,
        7,
        "DBNUM",
        1,
        2,
        6,
        32,
        1;
    EXIT;
ddhInitFieldLab78)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        79,
        cOwnRef,
        7,
        "TROWNO",
        2,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab79)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        80,
        cOwnRef,
        7,
        "FAULTNO",
        3,
        1,
        0,
        8,
        1;
    EXIT;
ddhInitFieldLab80)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        81,
        cOwnRef,
        7,
        "FLTTEXT",
        4,
        1,
        1,
        31,
        1;
    EXIT;
ddhInitFieldLab81)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        9,
        cOwnRef,
        8,
        "SYSFAULTCODES",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab9)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        82,
        cOwnRef,
        8,
        "DBNUM",
        1,
        2,
        6,
        32,
        1;
    EXIT;
ddhInitFieldLab82)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        83,
        cOwnRef,
        8,
        "FAULTNO",
        2,
        2,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab83)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        84,
        cOwnRef,
        8,
        "FLTTEXT",
        3,
        2,
        1,
        15,
        1;
    EXIT;
ddhInitFieldLab84)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        10,
        cOwnRef,
        9,
        "SYSTEMFIELDS",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab10)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        85,
        cOwnRef,
        9,
        "DBNUM",
        1,
        2,
        6,
        32,
        1;
    EXIT;
ddhInitFieldLab85)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        86,
        cOwnRef,
        9,
        "TROWNO",
        2,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab86)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        87,
        cOwnRef,
        9,
        "ROWGEN",
        3,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab87)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        88,
        cOwnRef,
        9,
        "LOCK",
        4,
        1,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab88)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        11,
        cOwnRef,
        10,
        "TEST1",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab11)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        89,
        cOwnRef,
        10,
        "COL10",
        1,
        2,
        6,
        0,
        1;
    EXIT;
ddhInitFieldLab89)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        90,
        cOwnRef,
        10,
        "COL1",
        2,
        2,
        1,
        15,
        1;
    EXIT;
ddhInitFieldLab90)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        91,
        cOwnRef,
        10,
        "COL2",
        3,
        2,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab91)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        92,
        cOwnRef,
        10,
        "COL3",
        4,
        2,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab92)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        93,
        cOwnRef,
        10,
        "COL4",
        5,
        2,
        1,
        15,
        0;
    EXIT;
ddhInitFieldLab93)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        94,
        cOwnRef,
        10,
        "COL5",
        6,
        2,
        2,
        7,
        1;
    EXIT;
ddhInitFieldLab94)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        95,
        cOwnRef,
        10,
        "COL6",
        7,
        2,
        1,
        31,
        1;
    EXIT;
ddhInitFieldLab95)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        96,
        cOwnRef,
        10,
        "COL7",
        8,
        2,
        4,
        1,
        1;
    EXIT;
ddhInitFieldLab96)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        97,
        cOwnRef,
        10,
        "COL8",
        9,
        2,
        3,
        28,
        1;
    EXIT;
ddhInitFieldLab97)
    GOTO RESTARTEND;
!------------------------------------------------!
!       RESTARTPHASE2 !
!------------------------------------------------!
RESTARTPHASE2)
! Send FK data to Data Dictionary !
    SEND ddhInitFk WITH
        1,
        cOwnRef,
        1,
        4,
        "PROGRAMS",
        0;
    EXIT;
ddhInitFkLab1)
! Send FK data to Data Dictionary !
    SEND ddhInitFk WITH
        2,
        cOwnRef,
        2,
        5,
        "TABLES",
        2;
    EXIT;
ddhInitFkLab2)
! Send FK data to Data Dictionary !
    SEND ddhInitFk WITH
        3,
        cOwnRef,
        3,
        4,
        "TABLES",
        3;
    EXIT;
ddhInitFkLab3)
! Send FK data to Data Dictionary !
    SEND ddhInitFk WITH
        4,
        cOwnRef,
        5,
        4,
        "TABLES",
        1;
    EXIT;
ddhInitFkLab4)
! Send FK data to Data Dictionary !
    SEND ddhInitFk WITH
        5,
        cOwnRef,
        5,
        5,
        "TABLES",
        1;
    EXIT;
ddhInitFkLab5)
! Send FK data to Data Dictionary !
    SEND ddhInitFk WITH
        6,
        cOwnRef,
        9,
        3,
        "TABLES",
        0;
    EXIT;
ddhInitFkLab6)
    GOTO RESTARTEND;
!------------------------------------------------!
!       RESTARTPHASE4 !
!------------------------------------------------!
RESTARTPHASE4)
! Clear work area. !
    SQLM_TableReference=0;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_PROGRAMS_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Allocated=0;
    FI;
! Clear work area. !
    SQLM_TableReference=1;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_TABLES_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_TABLES_WorkRow:SQLC_TABLES_Allocated=0;
    FI;
! Clear work area. !
    SQLM_TableReference=2;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_FIELDS_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_FIELDS_WorkRow:SQLC_FIELDS_Allocated=0;
    FI;
! Clear work area. !
    SQLM_TableReference=3;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_KEYS_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_KEYS_WorkRow:SQLC_KEYS_Allocated=0;
    FI;
! Clear work area. !
    SQLM_TableReference=4;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_KEYFIELDS_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Allocated=0;
    FI;
! Clear work area. !
    SQLM_TableReference=5;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_FOREIGNKEYS_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Allocated=0;
    FI;
! Clear work area. !
    SQLM_TableReference=6;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_SYMBOLS_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Allocated=0;
    FI;
! Clear work area. !
    SQLM_TableReference=7;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_TOWFAULTCODES_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Allocated=0;
    FI;
! Clear work area. !
    SQLM_TableReference=8;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_SYSFAULTCODES_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Allocated=0;
    FI;
! Clear work area. !
    SQLM_TableReference=9;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_SYSTEMFIELDS_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Allocated=0;
    FI;
! Clear work area. !
    SQLM_TableReference=10;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_TEST1_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_TEST1_WorkRow:SQLC_TEST1_Allocated=0;
    FI;
    GOTO RESTARTEND;
!------------------------------------------------!
!       RESTARTPHASE5 !
!------------------------------------------------!
!------------------------------------------------!
!       towDdhInitTableR !
!------------------------------------------------!
    ENTER ddhInitTableR WITH SQLX_ReturnLabel;
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO ddhInitTableLab1;
    WHEN 2 DO GOTO ddhInitTableLab2;
    WHEN 3 DO GOTO ddhInitTableLab3;
    WHEN 4 DO GOTO ddhInitTableLab4;
    WHEN 5 DO GOTO ddhInitTableLab5;
    WHEN 6 DO GOTO ddhInitTableLab6;
    WHEN 7 DO GOTO ddhInitTableLab7;
    WHEN 8 DO GOTO ddhInitTableLab8;
    WHEN 9 DO GOTO ddhInitTableLab9;
    WHEN 10 DO GOTO ddhInitTableLab10;
    WHEN 11 DO GOTO ddhInitTableLab11;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towDdhInitFieldR !
!------------------------------------------------!
    ENTER ddhInitFIeldR WITH SQLX_ReturnLabel;
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO ddhInitFieldLab1;
    WHEN 2 DO GOTO ddhInitFieldLab2;
    WHEN 3 DO GOTO ddhInitFieldLab3;
    WHEN 4 DO GOTO ddhInitFieldLab4;
    WHEN 5 DO GOTO ddhInitFieldLab5;
    WHEN 6 DO GOTO ddhInitFieldLab6;
    WHEN 7 DO GOTO ddhInitFieldLab7;
    WHEN 8 DO GOTO ddhInitFieldLab8;
    WHEN 9 DO GOTO ddhInitFieldLab9;
    WHEN 10 DO GOTO ddhInitFieldLab10;
    WHEN 11 DO GOTO ddhInitFieldLab11;
    WHEN 12 DO GOTO ddhInitFieldLab12;
    WHEN 13 DO GOTO ddhInitFieldLab13;
    WHEN 14 DO GOTO ddhInitFieldLab14;
    WHEN 15 DO GOTO ddhInitFieldLab15;
    WHEN 16 DO GOTO ddhInitFieldLab16;
    WHEN 17 DO GOTO ddhInitFieldLab17;
    WHEN 18 DO GOTO ddhInitFieldLab18;
    WHEN 19 DO GOTO ddhInitFieldLab19;
    WHEN 20 DO GOTO ddhInitFieldLab20;
    WHEN 21 DO GOTO ddhInitFieldLab21;
    WHEN 22 DO GOTO ddhInitFieldLab22;
    WHEN 23 DO GOTO ddhInitFieldLab23;
    WHEN 24 DO GOTO ddhInitFieldLab24;
    WHEN 25 DO GOTO ddhInitFieldLab25;
    WHEN 26 DO GOTO ddhInitFieldLab26;
    WHEN 27 DO GOTO ddhInitFieldLab27;
    WHEN 28 DO GOTO ddhInitFieldLab28;
    WHEN 29 DO GOTO ddhInitFieldLab29;
    WHEN 30 DO GOTO ddhInitFieldLab30;
    WHEN 31 DO GOTO ddhInitFieldLab31;
    WHEN 32 DO GOTO ddhInitFieldLab32;
    WHEN 33 DO GOTO ddhInitFieldLab33;
    WHEN 34 DO GOTO ddhInitFieldLab34;
    WHEN 35 DO GOTO ddhInitFieldLab35;
    WHEN 36 DO GOTO ddhInitFieldLab36;
    WHEN 37 DO GOTO ddhInitFieldLab37;
    WHEN 38 DO GOTO ddhInitFieldLab38;
    WHEN 39 DO GOTO ddhInitFieldLab39;
    WHEN 40 DO GOTO ddhInitFieldLab40;
    WHEN 41 DO GOTO ddhInitFieldLab41;
    WHEN 42 DO GOTO ddhInitFieldLab42;
    WHEN 43 DO GOTO ddhInitFieldLab43;
    WHEN 44 DO GOTO ddhInitFieldLab44;
    WHEN 45 DO GOTO ddhInitFieldLab45;
    WHEN 46 DO GOTO ddhInitFieldLab46;
    WHEN 47 DO GOTO ddhInitFieldLab47;
    WHEN 48 DO GOTO ddhInitFieldLab48;
    WHEN 49 DO GOTO ddhInitFieldLab49;
    WHEN 50 DO GOTO ddhInitFieldLab50;
    WHEN 51 DO GOTO ddhInitFieldLab51;
    WHEN 52 DO GOTO ddhInitFieldLab52;
    WHEN 53 DO GOTO ddhInitFieldLab53;
    WHEN 54 DO GOTO ddhInitFieldLab54;
    WHEN 55 DO GOTO ddhInitFieldLab55;
    WHEN 56 DO GOTO ddhInitFieldLab56;
    WHEN 57 DO GOTO ddhInitFieldLab57;
    WHEN 58 DO GOTO ddhInitFieldLab58;
    WHEN 59 DO GOTO ddhInitFieldLab59;
    WHEN 60 DO GOTO ddhInitFieldLab60;
    WHEN 61 DO GOTO ddhInitFieldLab61;
    WHEN 62 DO GOTO ddhInitFieldLab62;
    WHEN 63 DO GOTO ddhInitFieldLab63;
    WHEN 64 DO GOTO ddhInitFieldLab64;
    WHEN 65 DO GOTO ddhInitFieldLab65;
    WHEN 66 DO GOTO ddhInitFieldLab66;
    WHEN 67 DO GOTO ddhInitFieldLab67;
    WHEN 68 DO GOTO ddhInitFieldLab68;
    WHEN 69 DO GOTO ddhInitFieldLab69;
    WHEN 70 DO GOTO ddhInitFieldLab70;
    WHEN 71 DO GOTO ddhInitFieldLab71;
    WHEN 72 DO GOTO ddhInitFieldLab72;
    WHEN 73 DO GOTO ddhInitFieldLab73;
    WHEN 74 DO GOTO ddhInitFieldLab74;
    WHEN 75 DO GOTO ddhInitFieldLab75;
    WHEN 76 DO GOTO ddhInitFieldLab76;
    WHEN 77 DO GOTO ddhInitFieldLab77;
    WHEN 78 DO GOTO ddhInitFieldLab78;
    WHEN 79 DO GOTO ddhInitFieldLab79;
    WHEN 80 DO GOTO ddhInitFieldLab80;
    WHEN 81 DO GOTO ddhInitFieldLab81;
    WHEN 82 DO GOTO ddhInitFieldLab82;
    WHEN 83 DO GOTO ddhInitFieldLab83;
    WHEN 84 DO GOTO ddhInitFieldLab84;
    WHEN 85 DO GOTO ddhInitFieldLab85;
    WHEN 86 DO GOTO ddhInitFieldLab86;
    WHEN 87 DO GOTO ddhInitFieldLab87;
    WHEN 88 DO GOTO ddhInitFieldLab88;
    WHEN 89 DO GOTO ddhInitFieldLab89;
    WHEN 90 DO GOTO ddhInitFieldLab90;
    WHEN 91 DO GOTO ddhInitFieldLab91;
    WHEN 92 DO GOTO ddhInitFieldLab92;
    WHEN 93 DO GOTO ddhInitFieldLab93;
    WHEN 94 DO GOTO ddhInitFieldLab94;
    WHEN 95 DO GOTO ddhInitFieldLab95;
    WHEN 96 DO GOTO ddhInitFieldLab96;
    WHEN 97 DO GOTO ddhInitFieldLab97;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towDdhInitFkR !
!------------------------------------------------!
    ENTER ddhInitFkR WITH SQLX_ReturnLabel;
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO ddhInitFkLab1;
    WHEN 2 DO GOTO ddhInitFkLab2;
    WHEN 3 DO GOTO ddhInitFkLab3;
    WHEN 4 DO GOTO ddhInitFkLab4;
    WHEN 5 DO GOTO ddhInitFkLab5;
    WHEN 6 DO GOTO ddhInitFkLab6;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towGetSch !
!------------------------------------------------!
    ENTER towGetSch WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLX_OperRow,
        SQLX_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLX_ReturnLabel;
    CASE SQLM_TableReference IS

    WHEN 0 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_PROGRAMS_OperRow = SQLX_OperRow;
    SQLM_PROGRAMS_WorkRow = SQLX_WorkRow;
    SQLM_PROGRAMS_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree0_2)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_PROGRAMS_OperRow,
            SQLM_PROGRAMS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_PROGRAMS_OperRow /= SQLM_PROGRAMS_NilRow THEN
        DO SQLS_PROGRAMS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            SQLM_PROGRAMS_OperRow =
                SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
            GOTO LOOPtowGetSchTableKeyBTree0_2;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_PROGRAMS_OperRow =
                SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
            GOTO LOOPtowGetSchTableKeyBTree0_2;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_PROGRAMS_OperRow,
        SQLM_PROGRAMS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_PROGRAMS_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_PROGRAMS_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_PROGRAMS_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow0;
! find first allocated row, then schedule if necessary !
    IF SQLM_PROGRAMS_OperRow < 24000 THEN
        FOR FIRST SQLM_PROGRAMS_OperRow
            FROM SQLM_PROGRAMS_OperRow-1
            WHERE SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow0;
        GOTO FAILEDtowGetSchTableCursorRow0;
    ELSE
        FOR FIRST SQLM_PROGRAMS_OperRow
            FROM SQLM_PROGRAMS_OperRow-1
            UNTIL SQLM_PROGRAMS_OperRow-24000
            WHERE SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow0;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_PROGRAMS_OperRow,
            SQLM_PROGRAMS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow0)
    SQLM_PROGRAMS_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow0)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_PROGRAMS_OperRow,
        SQLM_PROGRAMS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree0_2)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_PROGRAMS_OperRow,
            SQLM_PROGRAMS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_PROGRAMS_OperRow /= SQLM_PROGRAMS_NilRow THEN
        DO SQLS_PROGRAMS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_PROGRAMS_OperRow;
                FI;
            FI;
            SQLM_PROGRAMS_OperRow =
                SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_PROGRAMS_OperRow <
                SQLM_PROGRAMS_WorkRow:SQLC_PROGRAMS_Left2
            THEN
                SQLX_RightTurn = SQLM_PROGRAMS_OperRow;
                SQLM_PROGRAMS_OperRow =
                  SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Right2;
            ELSE
                SQLM_PROGRAMS_OperRow =
                  SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
            FI;
        ELSE
            SQLM_PROGRAMS_OperRow =
              SQLM_PROGRAMS_OperRow:SQLC_PROGRAMS_Left2;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree0_2;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_PROGRAMS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 1 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_TABLES_OperRow = SQLX_OperRow;
    SQLM_TABLES_WorkRow = SQLX_WorkRow;
    SQLM_TABLES_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree1_3)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TABLES_OperRow,
            SQLM_TABLES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_TABLES_OperRow /= SQLM_TABLES_NilRow THEN
        DO SQLS_TABLES_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            SQLM_TABLES_OperRow =
                SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
            GOTO LOOPtowGetSchTableKeyBTree1_3;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_TABLES_OperRow =
                SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
            GOTO LOOPtowGetSchTableKeyBTree1_3;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_TABLES_OperRow,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_TABLES_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_TABLES_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow1;
! find first allocated row, then schedule if necessary !
    IF SQLM_TABLES_OperRow < 24000 THEN
        FOR FIRST SQLM_TABLES_OperRow
            FROM SQLM_TABLES_OperRow-1
            WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow1;
        GOTO FAILEDtowGetSchTableCursorRow1;
    ELSE
        FOR FIRST SQLM_TABLES_OperRow
            FROM SQLM_TABLES_OperRow-1
            UNTIL SQLM_TABLES_OperRow-24000
            WHERE SQLM_TABLES_OperRow:SQLC_TABLES_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow1;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TABLES_OperRow,
            SQLM_TABLES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow1)
    SQLM_TABLES_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow1)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_TABLES_OperRow,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree1_3)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TABLES_OperRow,
            SQLM_TABLES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_TABLES_OperRow /= SQLM_TABLES_NilRow THEN
        DO SQLS_TABLES_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_TABLES_OperRow;
                FI;
            FI;
            SQLM_TABLES_OperRow =
                SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_TABLES_OperRow <
                SQLM_TABLES_WorkRow:SQLC_TABLES_Left3
            THEN
                SQLX_RightTurn = SQLM_TABLES_OperRow;
                SQLM_TABLES_OperRow =
                  SQLM_TABLES_OperRow:SQLC_TABLES_Right3;
            ELSE
                SQLM_TABLES_OperRow =
                  SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
            FI;
        ELSE
            SQLM_TABLES_OperRow =
              SQLM_TABLES_OperRow:SQLC_TABLES_Left3;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree1_3;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 4 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree1_4)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TABLES_OperRow,
            SQLM_TABLES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_TABLES_OperRow /= SQLM_TABLES_NilRow THEN
        DO SQLS_TABLES_KeyTest4;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_TABLES_OperRow;
                FI;
            FI;
            SQLM_TABLES_OperRow =
                SQLM_TABLES_OperRow:SQLC_TABLES_Right4;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_TABLES_OperRow <
                SQLM_TABLES_WorkRow:SQLC_TABLES_Left3
            THEN
                SQLX_RightTurn = SQLM_TABLES_OperRow;
                SQLM_TABLES_OperRow =
                  SQLM_TABLES_OperRow:SQLC_TABLES_Right4;
            ELSE
                SQLM_TABLES_OperRow =
                  SQLM_TABLES_OperRow:SQLC_TABLES_Left4;
            FI;
        ELSE
            SQLM_TABLES_OperRow =
              SQLM_TABLES_OperRow:SQLC_TABLES_Left4;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree1_4;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_TABLES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 2 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_FIELDS_OperRow = SQLX_OperRow;
    SQLM_FIELDS_WorkRow = SQLX_WorkRow;
    SQLM_FIELDS_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree2_3)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_FIELDS_OperRow /= SQLM_FIELDS_NilRow THEN
        DO SQLS_FIELDS_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            SQLM_FIELDS_OperRow =
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
            GOTO LOOPtowGetSchTableKeyBTree2_3;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_FIELDS_OperRow =
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
            GOTO LOOPtowGetSchTableKeyBTree2_3;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_FIELDS_OperRow,
        SQLM_FIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 4 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree2_4)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_FIELDS_OperRow /= SQLM_FIELDS_NilRow THEN
        DO SQLS_FIELDS_KeyTest4;
        IF SQLX_KeyTest < 1 THEN
            SQLM_FIELDS_OperRow =
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4;
            GOTO LOOPtowGetSchTableKeyBTree2_4;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_FIELDS_OperRow =
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4;
            GOTO LOOPtowGetSchTableKeyBTree2_4;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_FIELDS_OperRow,
        SQLM_FIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_FIELDS_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_FIELDS_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_FIELDS_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow2;
! find first allocated row, then schedule if necessary !
    IF SQLM_FIELDS_OperRow < 24000 THEN
        FOR FIRST SQLM_FIELDS_OperRow
            FROM SQLM_FIELDS_OperRow-1
            WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow2;
        GOTO FAILEDtowGetSchTableCursorRow2;
    ELSE
        FOR FIRST SQLM_FIELDS_OperRow
            FROM SQLM_FIELDS_OperRow-1
            UNTIL SQLM_FIELDS_OperRow-24000
            WHERE SQLM_FIELDS_OperRow:SQLC_FIELDS_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow2;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow2)
    SQLM_FIELDS_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow2)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_FIELDS_OperRow,
        SQLM_FIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree2_3)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_FIELDS_OperRow /= SQLM_FIELDS_NilRow THEN
        DO SQLS_FIELDS_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_FIELDS_OperRow;
                FI;
            FI;
            SQLM_FIELDS_OperRow =
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_FIELDS_OperRow <
                SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3
            THEN
                SQLX_RightTurn = SQLM_FIELDS_OperRow;
                SQLM_FIELDS_OperRow =
                  SQLM_FIELDS_OperRow:SQLC_FIELDS_Right3;
            ELSE
                SQLM_FIELDS_OperRow =
                  SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
            FI;
        ELSE
            SQLM_FIELDS_OperRow =
              SQLM_FIELDS_OperRow:SQLC_FIELDS_Left3;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree2_3;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_FIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 4 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree2_4)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_FIELDS_OperRow /= SQLM_FIELDS_NilRow THEN
        DO SQLS_FIELDS_KeyTest4;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_FIELDS_OperRow;
                FI;
            FI;
            SQLM_FIELDS_OperRow =
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_FIELDS_OperRow <
                SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3
            THEN
                SQLX_RightTurn = SQLM_FIELDS_OperRow;
                SQLM_FIELDS_OperRow =
                  SQLM_FIELDS_OperRow:SQLC_FIELDS_Right4;
            ELSE
                SQLM_FIELDS_OperRow =
                  SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4;
            FI;
        ELSE
            SQLM_FIELDS_OperRow =
              SQLM_FIELDS_OperRow:SQLC_FIELDS_Left4;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree2_4;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_FIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 5 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree2_5)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FIELDS_OperRow,
            SQLM_FIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_FIELDS_OperRow /= SQLM_FIELDS_NilRow THEN
        DO SQLS_FIELDS_KeyTest5;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_FIELDS_OperRow;
                FI;
            FI;
            SQLM_FIELDS_OperRow =
                SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_FIELDS_OperRow <
                SQLM_FIELDS_WorkRow:SQLC_FIELDS_Left3
            THEN
                SQLX_RightTurn = SQLM_FIELDS_OperRow;
                SQLM_FIELDS_OperRow =
                  SQLM_FIELDS_OperRow:SQLC_FIELDS_Right5;
            ELSE
                SQLM_FIELDS_OperRow =
                  SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5;
            FI;
        ELSE
            SQLM_FIELDS_OperRow =
              SQLM_FIELDS_OperRow:SQLC_FIELDS_Left5;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree2_5;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_FIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 3 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_KEYS_OperRow = SQLX_OperRow;
    SQLM_KEYS_WorkRow = SQLX_WorkRow;
    SQLM_KEYS_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree3_2)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_KEYS_OperRow /= SQLM_KEYS_NilRow THEN
        DO SQLS_KEYS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            SQLM_KEYS_OperRow =
                SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
            GOTO LOOPtowGetSchTableKeyBTree3_2;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_KEYS_OperRow =
                SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
            GOTO LOOPtowGetSchTableKeyBTree3_2;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_KEYS_OperRow,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree3_3)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_KEYS_OperRow /= SQLM_KEYS_NilRow THEN
        DO SQLS_KEYS_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            SQLM_KEYS_OperRow =
                SQLM_KEYS_OperRow:SQLC_KEYS_Right3;
            GOTO LOOPtowGetSchTableKeyBTree3_3;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_KEYS_OperRow =
                SQLM_KEYS_OperRow:SQLC_KEYS_Left3;
            GOTO LOOPtowGetSchTableKeyBTree3_3;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_KEYS_OperRow,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_KEYS_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_KEYS_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_KEYS_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow3;
! find first allocated row, then schedule if necessary !
    IF SQLM_KEYS_OperRow < 24000 THEN
        FOR FIRST SQLM_KEYS_OperRow
            FROM SQLM_KEYS_OperRow-1
            WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow3;
        GOTO FAILEDtowGetSchTableCursorRow3;
    ELSE
        FOR FIRST SQLM_KEYS_OperRow
            FROM SQLM_KEYS_OperRow-1
            UNTIL SQLM_KEYS_OperRow-24000
            WHERE SQLM_KEYS_OperRow:SQLC_KEYS_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow3;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow3)
    SQLM_KEYS_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow3)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_KEYS_OperRow,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree3_2)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_KEYS_OperRow /= SQLM_KEYS_NilRow THEN
        DO SQLS_KEYS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_KEYS_OperRow;
                FI;
            FI;
            SQLM_KEYS_OperRow =
                SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_KEYS_OperRow <
                SQLM_KEYS_WorkRow:SQLC_KEYS_Left2
            THEN
                SQLX_RightTurn = SQLM_KEYS_OperRow;
                SQLM_KEYS_OperRow =
                  SQLM_KEYS_OperRow:SQLC_KEYS_Right2;
            ELSE
                SQLM_KEYS_OperRow =
                  SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
            FI;
        ELSE
            SQLM_KEYS_OperRow =
              SQLM_KEYS_OperRow:SQLC_KEYS_Left2;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree3_2;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree3_3)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_KEYS_OperRow /= SQLM_KEYS_NilRow THEN
        DO SQLS_KEYS_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_KEYS_OperRow;
                FI;
            FI;
            SQLM_KEYS_OperRow =
                SQLM_KEYS_OperRow:SQLC_KEYS_Right3;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_KEYS_OperRow <
                SQLM_KEYS_WorkRow:SQLC_KEYS_Left2
            THEN
                SQLX_RightTurn = SQLM_KEYS_OperRow;
                SQLM_KEYS_OperRow =
                  SQLM_KEYS_OperRow:SQLC_KEYS_Right3;
            ELSE
                SQLM_KEYS_OperRow =
                  SQLM_KEYS_OperRow:SQLC_KEYS_Left3;
            FI;
        ELSE
            SQLM_KEYS_OperRow =
              SQLM_KEYS_OperRow:SQLC_KEYS_Left3;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree3_3;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 4 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree3_4)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_KEYS_OperRow,
            SQLM_KEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_KEYS_OperRow /= SQLM_KEYS_NilRow THEN
        DO SQLS_KEYS_KeyTest4;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_KEYS_OperRow;
                FI;
            FI;
            SQLM_KEYS_OperRow =
                SQLM_KEYS_OperRow:SQLC_KEYS_Right4;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_KEYS_OperRow <
                SQLM_KEYS_WorkRow:SQLC_KEYS_Left2
            THEN
                SQLX_RightTurn = SQLM_KEYS_OperRow;
                SQLM_KEYS_OperRow =
                  SQLM_KEYS_OperRow:SQLC_KEYS_Right4;
            ELSE
                SQLM_KEYS_OperRow =
                  SQLM_KEYS_OperRow:SQLC_KEYS_Left4;
            FI;
        ELSE
            SQLM_KEYS_OperRow =
              SQLM_KEYS_OperRow:SQLC_KEYS_Left4;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree3_4;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_KEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 4 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_KEYFIELDS_OperRow = SQLX_OperRow;
    SQLM_KEYFIELDS_WorkRow = SQLX_WorkRow;
    SQLM_KEYFIELDS_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree4_2)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_KEYFIELDS_OperRow /= SQLM_KEYFIELDS_NilRow THEN
        DO SQLS_KEYFIELDS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            SQLM_KEYFIELDS_OperRow =
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
            GOTO LOOPtowGetSchTableKeyBTree4_2;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_KEYFIELDS_OperRow =
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
            GOTO LOOPtowGetSchTableKeyBTree4_2;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_KEYFIELDS_OperRow,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree4_3)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_KEYFIELDS_OperRow /= SQLM_KEYFIELDS_NilRow THEN
        DO SQLS_KEYFIELDS_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            SQLM_KEYFIELDS_OperRow =
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3;
            GOTO LOOPtowGetSchTableKeyBTree4_3;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_KEYFIELDS_OperRow =
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3;
            GOTO LOOPtowGetSchTableKeyBTree4_3;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_KEYFIELDS_OperRow,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_KEYFIELDS_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_KEYFIELDS_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_KEYFIELDS_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow4;
! find first allocated row, then schedule if necessary !
    IF SQLM_KEYFIELDS_OperRow < 24000 THEN
        FOR FIRST SQLM_KEYFIELDS_OperRow
            FROM SQLM_KEYFIELDS_OperRow-1
            WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow4;
        GOTO FAILEDtowGetSchTableCursorRow4;
    ELSE
        FOR FIRST SQLM_KEYFIELDS_OperRow
            FROM SQLM_KEYFIELDS_OperRow-1
            UNTIL SQLM_KEYFIELDS_OperRow-24000
            WHERE SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow4;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow4)
    SQLM_KEYFIELDS_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow4)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_KEYFIELDS_OperRow,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree4_2)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_KEYFIELDS_OperRow /= SQLM_KEYFIELDS_NilRow THEN
        DO SQLS_KEYFIELDS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_KEYFIELDS_OperRow;
                FI;
            FI;
            SQLM_KEYFIELDS_OperRow =
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_KEYFIELDS_OperRow <
                SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2
            THEN
                SQLX_RightTurn = SQLM_KEYFIELDS_OperRow;
                SQLM_KEYFIELDS_OperRow =
                  SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right2;
            ELSE
                SQLM_KEYFIELDS_OperRow =
                  SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
            FI;
        ELSE
            SQLM_KEYFIELDS_OperRow =
              SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left2;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree4_2;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree4_3)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_KEYFIELDS_OperRow,
            SQLM_KEYFIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_KEYFIELDS_OperRow /= SQLM_KEYFIELDS_NilRow THEN
        DO SQLS_KEYFIELDS_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_KEYFIELDS_OperRow;
                FI;
            FI;
            SQLM_KEYFIELDS_OperRow =
                SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_KEYFIELDS_OperRow <
                SQLM_KEYFIELDS_WorkRow:SQLC_KEYFIELDS_Left2
            THEN
                SQLX_RightTurn = SQLM_KEYFIELDS_OperRow;
                SQLM_KEYFIELDS_OperRow =
                  SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Right3;
            ELSE
                SQLM_KEYFIELDS_OperRow =
                  SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3;
            FI;
        ELSE
            SQLM_KEYFIELDS_OperRow =
              SQLM_KEYFIELDS_OperRow:SQLC_KEYFIELDS_Left3;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree4_3;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_KEYFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 5 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_FOREIGNKEYS_OperRow = SQLX_OperRow;
    SQLM_FOREIGNKEYS_WorkRow = SQLX_WorkRow;
    SQLM_FOREIGNKEYS_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree5_2)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_FOREIGNKEYS_OperRow /= SQLM_FOREIGNKEYS_NilRow THEN
        DO SQLS_FOREIGNKEYS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            SQLM_FOREIGNKEYS_OperRow =
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
            GOTO LOOPtowGetSchTableKeyBTree5_2;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_FOREIGNKEYS_OperRow =
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
            GOTO LOOPtowGetSchTableKeyBTree5_2;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree5_3)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_FOREIGNKEYS_OperRow /= SQLM_FOREIGNKEYS_NilRow THEN
        DO SQLS_FOREIGNKEYS_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            SQLM_FOREIGNKEYS_OperRow =
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3;
            GOTO LOOPtowGetSchTableKeyBTree5_3;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_FOREIGNKEYS_OperRow =
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3;
            GOTO LOOPtowGetSchTableKeyBTree5_3;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_FOREIGNKEYS_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_FOREIGNKEYS_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow5;
! find first allocated row, then schedule if necessary !
    IF SQLM_FOREIGNKEYS_OperRow < 24000 THEN
        FOR FIRST SQLM_FOREIGNKEYS_OperRow
            FROM SQLM_FOREIGNKEYS_OperRow-1
            WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow5;
        GOTO FAILEDtowGetSchTableCursorRow5;
    ELSE
        FOR FIRST SQLM_FOREIGNKEYS_OperRow
            FROM SQLM_FOREIGNKEYS_OperRow-1
            UNTIL SQLM_FOREIGNKEYS_OperRow-24000
            WHERE SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow5;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow5)
    SQLM_FOREIGNKEYS_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow5)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_FOREIGNKEYS_OperRow,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree5_2)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_FOREIGNKEYS_OperRow /= SQLM_FOREIGNKEYS_NilRow THEN
        DO SQLS_FOREIGNKEYS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_FOREIGNKEYS_OperRow;
                FI;
            FI;
            SQLM_FOREIGNKEYS_OperRow =
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_FOREIGNKEYS_OperRow <
                SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2
            THEN
                SQLX_RightTurn = SQLM_FOREIGNKEYS_OperRow;
                SQLM_FOREIGNKEYS_OperRow =
                  SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right2;
            ELSE
                SQLM_FOREIGNKEYS_OperRow =
                  SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
            FI;
        ELSE
            SQLM_FOREIGNKEYS_OperRow =
              SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left2;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree5_2;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree5_3)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_FOREIGNKEYS_OperRow /= SQLM_FOREIGNKEYS_NilRow THEN
        DO SQLS_FOREIGNKEYS_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_FOREIGNKEYS_OperRow;
                FI;
            FI;
            SQLM_FOREIGNKEYS_OperRow =
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_FOREIGNKEYS_OperRow <
                SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2
            THEN
                SQLX_RightTurn = SQLM_FOREIGNKEYS_OperRow;
                SQLM_FOREIGNKEYS_OperRow =
                  SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right3;
            ELSE
                SQLM_FOREIGNKEYS_OperRow =
                  SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3;
            FI;
        ELSE
            SQLM_FOREIGNKEYS_OperRow =
              SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left3;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree5_3;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 4 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree5_4)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_FOREIGNKEYS_OperRow /= SQLM_FOREIGNKEYS_NilRow THEN
        DO SQLS_FOREIGNKEYS_KeyTest4;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_FOREIGNKEYS_OperRow;
                FI;
            FI;
            SQLM_FOREIGNKEYS_OperRow =
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_FOREIGNKEYS_OperRow <
                SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2
            THEN
                SQLX_RightTurn = SQLM_FOREIGNKEYS_OperRow;
                SQLM_FOREIGNKEYS_OperRow =
                  SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right4;
            ELSE
                SQLM_FOREIGNKEYS_OperRow =
                  SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4;
            FI;
        ELSE
            SQLM_FOREIGNKEYS_OperRow =
              SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left4;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree5_4;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 5 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree5_5)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_FOREIGNKEYS_OperRow,
            SQLM_FOREIGNKEYS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_FOREIGNKEYS_OperRow /= SQLM_FOREIGNKEYS_NilRow THEN
        DO SQLS_FOREIGNKEYS_KeyTest5;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_FOREIGNKEYS_OperRow;
                FI;
            FI;
            SQLM_FOREIGNKEYS_OperRow =
                SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_FOREIGNKEYS_OperRow <
                SQLM_FOREIGNKEYS_WorkRow:SQLC_FOREIGNKEYS_Left2
            THEN
                SQLX_RightTurn = SQLM_FOREIGNKEYS_OperRow;
                SQLM_FOREIGNKEYS_OperRow =
                  SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Right5;
            ELSE
                SQLM_FOREIGNKEYS_OperRow =
                  SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5;
            FI;
        ELSE
            SQLM_FOREIGNKEYS_OperRow =
              SQLM_FOREIGNKEYS_OperRow:SQLC_FOREIGNKEYS_Left5;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree5_5;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_FOREIGNKEYS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 6 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_SYMBOLS_OperRow = SQLX_OperRow;
    SQLM_SYMBOLS_WorkRow = SQLX_WorkRow;
    SQLM_SYMBOLS_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree6_2)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_SYMBOLS_OperRow /= SQLM_SYMBOLS_NilRow THEN
        DO SQLS_SYMBOLS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            SQLM_SYMBOLS_OperRow =
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
            GOTO LOOPtowGetSchTableKeyBTree6_2;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_SYMBOLS_OperRow =
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
            GOTO LOOPtowGetSchTableKeyBTree6_2;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_SYMBOLS_OperRow,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree6_3)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_SYMBOLS_OperRow /= SQLM_SYMBOLS_NilRow THEN
        DO SQLS_SYMBOLS_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            SQLM_SYMBOLS_OperRow =
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3;
            GOTO LOOPtowGetSchTableKeyBTree6_3;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_SYMBOLS_OperRow =
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3;
            GOTO LOOPtowGetSchTableKeyBTree6_3;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_SYMBOLS_OperRow,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_SYMBOLS_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_SYMBOLS_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_SYMBOLS_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow6;
! find first allocated row, then schedule if necessary !
    IF SQLM_SYMBOLS_OperRow < 24000 THEN
        FOR FIRST SQLM_SYMBOLS_OperRow
            FROM SQLM_SYMBOLS_OperRow-1
            WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow6;
        GOTO FAILEDtowGetSchTableCursorRow6;
    ELSE
        FOR FIRST SQLM_SYMBOLS_OperRow
            FROM SQLM_SYMBOLS_OperRow-1
            UNTIL SQLM_SYMBOLS_OperRow-24000
            WHERE SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow6;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow6)
    SQLM_SYMBOLS_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow6)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_SYMBOLS_OperRow,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree6_2)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_SYMBOLS_OperRow /= SQLM_SYMBOLS_NilRow THEN
        DO SQLS_SYMBOLS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_SYMBOLS_OperRow;
                FI;
            FI;
            SQLM_SYMBOLS_OperRow =
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_SYMBOLS_OperRow <
                SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2
            THEN
                SQLX_RightTurn = SQLM_SYMBOLS_OperRow;
                SQLM_SYMBOLS_OperRow =
                  SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right2;
            ELSE
                SQLM_SYMBOLS_OperRow =
                  SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
            FI;
        ELSE
            SQLM_SYMBOLS_OperRow =
              SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left2;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree6_2;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree6_3)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYMBOLS_OperRow,
            SQLM_SYMBOLS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_SYMBOLS_OperRow /= SQLM_SYMBOLS_NilRow THEN
        DO SQLS_SYMBOLS_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_SYMBOLS_OperRow;
                FI;
            FI;
            SQLM_SYMBOLS_OperRow =
                SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_SYMBOLS_OperRow <
                SQLM_SYMBOLS_WorkRow:SQLC_SYMBOLS_Left2
            THEN
                SQLX_RightTurn = SQLM_SYMBOLS_OperRow;
                SQLM_SYMBOLS_OperRow =
                  SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Right3;
            ELSE
                SQLM_SYMBOLS_OperRow =
                  SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3;
            FI;
        ELSE
            SQLM_SYMBOLS_OperRow =
              SQLM_SYMBOLS_OperRow:SQLC_SYMBOLS_Left3;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree6_3;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_SYMBOLS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 7 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_TOWFAULTCODES_OperRow = SQLX_OperRow;
    SQLM_TOWFAULTCODES_WorkRow = SQLX_WorkRow;
    SQLM_TOWFAULTCODES_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree7_2)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TOWFAULTCODES_OperRow,
            SQLM_TOWFAULTCODES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_TOWFAULTCODES_OperRow /= SQLM_TOWFAULTCODES_NilRow THEN
        DO SQLS_TOWFAULTCODES_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            SQLM_TOWFAULTCODES_OperRow =
                SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
            GOTO LOOPtowGetSchTableKeyBTree7_2;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_TOWFAULTCODES_OperRow =
                SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
            GOTO LOOPtowGetSchTableKeyBTree7_2;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_TOWFAULTCODES_OperRow,
        SQLM_TOWFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_TOWFAULTCODES_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_TOWFAULTCODES_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_TOWFAULTCODES_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow7;
! find first allocated row, then schedule if necessary !
    IF SQLM_TOWFAULTCODES_OperRow < 24000 THEN
        FOR FIRST SQLM_TOWFAULTCODES_OperRow
            FROM SQLM_TOWFAULTCODES_OperRow-1
            WHERE SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow7;
        GOTO FAILEDtowGetSchTableCursorRow7;
    ELSE
        FOR FIRST SQLM_TOWFAULTCODES_OperRow
            FROM SQLM_TOWFAULTCODES_OperRow-1
            UNTIL SQLM_TOWFAULTCODES_OperRow-24000
            WHERE SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow7;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TOWFAULTCODES_OperRow,
            SQLM_TOWFAULTCODES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow7)
    SQLM_TOWFAULTCODES_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow7)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_TOWFAULTCODES_OperRow,
        SQLM_TOWFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree7_2)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TOWFAULTCODES_OperRow,
            SQLM_TOWFAULTCODES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_TOWFAULTCODES_OperRow /= SQLM_TOWFAULTCODES_NilRow THEN
        DO SQLS_TOWFAULTCODES_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_TOWFAULTCODES_OperRow;
                FI;
            FI;
            SQLM_TOWFAULTCODES_OperRow =
                SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_TOWFAULTCODES_OperRow <
                SQLM_TOWFAULTCODES_WorkRow:SQLC_TOWFAULTCODES_Left2
            THEN
                SQLX_RightTurn = SQLM_TOWFAULTCODES_OperRow;
                SQLM_TOWFAULTCODES_OperRow =
                  SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Right2;
            ELSE
                SQLM_TOWFAULTCODES_OperRow =
                  SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
            FI;
        ELSE
            SQLM_TOWFAULTCODES_OperRow =
              SQLM_TOWFAULTCODES_OperRow:SQLC_TOWFAULTCODES_Left2;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree7_2;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_TOWFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 8 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_SYSFAULTCODES_OperRow = SQLX_OperRow;
    SQLM_SYSFAULTCODES_WorkRow = SQLX_WorkRow;
    SQLM_SYSFAULTCODES_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree8_2)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYSFAULTCODES_OperRow,
            SQLM_SYSFAULTCODES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_SYSFAULTCODES_OperRow /= SQLM_SYSFAULTCODES_NilRow THEN
        DO SQLS_SYSFAULTCODES_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            SQLM_SYSFAULTCODES_OperRow =
                SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
            GOTO LOOPtowGetSchTableKeyBTree8_2;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_SYSFAULTCODES_OperRow =
                SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
            GOTO LOOPtowGetSchTableKeyBTree8_2;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_SYSFAULTCODES_OperRow,
        SQLM_SYSFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_SYSFAULTCODES_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_SYSFAULTCODES_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_SYSFAULTCODES_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow8;
! find first allocated row, then schedule if necessary !
    IF SQLM_SYSFAULTCODES_OperRow < 24000 THEN
        FOR FIRST SQLM_SYSFAULTCODES_OperRow
            FROM SQLM_SYSFAULTCODES_OperRow-1
            WHERE SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow8;
        GOTO FAILEDtowGetSchTableCursorRow8;
    ELSE
        FOR FIRST SQLM_SYSFAULTCODES_OperRow
            FROM SQLM_SYSFAULTCODES_OperRow-1
            UNTIL SQLM_SYSFAULTCODES_OperRow-24000
            WHERE SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow8;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYSFAULTCODES_OperRow,
            SQLM_SYSFAULTCODES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow8)
    SQLM_SYSFAULTCODES_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow8)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_SYSFAULTCODES_OperRow,
        SQLM_SYSFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree8_2)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYSFAULTCODES_OperRow,
            SQLM_SYSFAULTCODES_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_SYSFAULTCODES_OperRow /= SQLM_SYSFAULTCODES_NilRow THEN
        DO SQLS_SYSFAULTCODES_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_SYSFAULTCODES_OperRow;
                FI;
            FI;
            SQLM_SYSFAULTCODES_OperRow =
                SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_SYSFAULTCODES_OperRow <
                SQLM_SYSFAULTCODES_WorkRow:SQLC_SYSFAULTCODES_Left2
            THEN
                SQLX_RightTurn = SQLM_SYSFAULTCODES_OperRow;
                SQLM_SYSFAULTCODES_OperRow =
                  SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Right2;
            ELSE
                SQLM_SYSFAULTCODES_OperRow =
                  SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
            FI;
        ELSE
            SQLM_SYSFAULTCODES_OperRow =
              SQLM_SYSFAULTCODES_OperRow:SQLC_SYSFAULTCODES_Left2;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree8_2;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_SYSFAULTCODES_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 9 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_SYSTEMFIELDS_OperRow = SQLX_OperRow;
    SQLM_SYSTEMFIELDS_WorkRow = SQLX_WorkRow;
    SQLM_SYSTEMFIELDS_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree9_2)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYSTEMFIELDS_OperRow,
            SQLM_SYSTEMFIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_SYSTEMFIELDS_OperRow /= SQLM_SYSTEMFIELDS_NilRow THEN
        DO SQLS_SYSTEMFIELDS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            SQLM_SYSTEMFIELDS_OperRow =
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
            GOTO LOOPtowGetSchTableKeyBTree9_2;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_SYSTEMFIELDS_OperRow =
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
            GOTO LOOPtowGetSchTableKeyBTree9_2;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_SYSTEMFIELDS_OperRow,
        SQLM_SYSTEMFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_SYSTEMFIELDS_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_SYSTEMFIELDS_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_SYSTEMFIELDS_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow9;
! find first allocated row, then schedule if necessary !
    IF SQLM_SYSTEMFIELDS_OperRow < 24000 THEN
        FOR FIRST SQLM_SYSTEMFIELDS_OperRow
            FROM SQLM_SYSTEMFIELDS_OperRow-1
            WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow9;
        GOTO FAILEDtowGetSchTableCursorRow9;
    ELSE
        FOR FIRST SQLM_SYSTEMFIELDS_OperRow
            FROM SQLM_SYSTEMFIELDS_OperRow-1
            UNTIL SQLM_SYSTEMFIELDS_OperRow-24000
            WHERE SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow9;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYSTEMFIELDS_OperRow,
            SQLM_SYSTEMFIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow9)
    SQLM_SYSTEMFIELDS_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow9)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_SYSTEMFIELDS_OperRow,
        SQLM_SYSTEMFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree9_2)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYSTEMFIELDS_OperRow,
            SQLM_SYSTEMFIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_SYSTEMFIELDS_OperRow /= SQLM_SYSTEMFIELDS_NilRow THEN
        DO SQLS_SYSTEMFIELDS_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_SYSTEMFIELDS_OperRow;
                FI;
            FI;
            SQLM_SYSTEMFIELDS_OperRow =
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_SYSTEMFIELDS_OperRow <
                SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2
            THEN
                SQLX_RightTurn = SQLM_SYSTEMFIELDS_OperRow;
                SQLM_SYSTEMFIELDS_OperRow =
                  SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right2;
            ELSE
                SQLM_SYSTEMFIELDS_OperRow =
                  SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
            FI;
        ELSE
            SQLM_SYSTEMFIELDS_OperRow =
              SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left2;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree9_2;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_SYSTEMFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree9_3)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 18 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_SYSTEMFIELDS_OperRow,
            SQLM_SYSTEMFIELDS_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_SYSTEMFIELDS_OperRow /= SQLM_SYSTEMFIELDS_NilRow THEN
        DO SQLS_SYSTEMFIELDS_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_SYSTEMFIELDS_OperRow;
                FI;
            FI;
            SQLM_SYSTEMFIELDS_OperRow =
                SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_SYSTEMFIELDS_OperRow <
                SQLM_SYSTEMFIELDS_WorkRow:SQLC_SYSTEMFIELDS_Left2
            THEN
                SQLX_RightTurn = SQLM_SYSTEMFIELDS_OperRow;
                SQLM_SYSTEMFIELDS_OperRow =
                  SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Right3;
            ELSE
                SQLM_SYSTEMFIELDS_OperRow =
                  SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3;
            FI;
        ELSE
            SQLM_SYSTEMFIELDS_OperRow =
              SQLM_SYSTEMFIELDS_OperRow:SQLC_SYSTEMFIELDS_Left3;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree9_3;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_SYSTEMFIELDS_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 10 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_TEST1_OperRow = SQLX_OperRow;
    SQLM_TEST1_WorkRow = SQLX_WorkRow;
    SQLM_TEST1_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree10_2)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TEST1_OperRow,
            SQLM_TEST1_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_TEST1_OperRow /= SQLM_TEST1_NilRow THEN
        DO SQLS_TEST1_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            SQLM_TEST1_OperRow =
                SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
            GOTO LOOPtowGetSchTableKeyBTree10_2;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_TEST1_OperRow =
                SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
            GOTO LOOPtowGetSchTableKeyBTree10_2;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_TEST1_OperRow,
        SQLM_TEST1_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_TEST1_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_TEST1_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_TEST1_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow10;
! find first allocated row, then schedule if necessary !
    IF SQLM_TEST1_OperRow < 24000 THEN
        FOR FIRST SQLM_TEST1_OperRow
            FROM SQLM_TEST1_OperRow-1
            WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow10;
        GOTO FAILEDtowGetSchTableCursorRow10;
    ELSE
        FOR FIRST SQLM_TEST1_OperRow
            FROM SQLM_TEST1_OperRow-1
            UNTIL SQLM_TEST1_OperRow-24000
            WHERE SQLM_TEST1_OperRow:SQLC_TEST1_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow10;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TEST1_OperRow,
            SQLM_TEST1_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow10)
    SQLM_TEST1_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow10)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_TEST1_OperRow,
        SQLM_TEST1_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree10_2)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TEST1_OperRow,
            SQLM_TEST1_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_TEST1_OperRow /= SQLM_TEST1_NilRow THEN
        DO SQLS_TEST1_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_TEST1_OperRow;
                FI;
            FI;
            SQLM_TEST1_OperRow =
                SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_TEST1_OperRow <
                SQLM_TEST1_WorkRow:SQLC_TEST1_Left2
            THEN
                SQLX_RightTurn = SQLM_TEST1_OperRow;
                SQLM_TEST1_OperRow =
                  SQLM_TEST1_OperRow:SQLC_TEST1_Right2;
            ELSE
                SQLM_TEST1_OperRow =
                  SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
            FI;
        ELSE
            SQLM_TEST1_OperRow =
              SQLM_TEST1_OperRow:SQLC_TEST1_Left2;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree10_2;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_TEST1_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree10_3)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TEST1_OperRow,
            SQLM_TEST1_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_TEST1_OperRow /= SQLM_TEST1_NilRow THEN
        DO SQLS_TEST1_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_TEST1_OperRow;
                FI;
            FI;
            SQLM_TEST1_OperRow =
                SQLM_TEST1_OperRow:SQLC_TEST1_Right3;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_TEST1_OperRow <
                SQLM_TEST1_WorkRow:SQLC_TEST1_Left2
            THEN
                SQLX_RightTurn = SQLM_TEST1_OperRow;
                SQLM_TEST1_OperRow =
                  SQLM_TEST1_OperRow:SQLC_TEST1_Right3;
            ELSE
                SQLM_TEST1_OperRow =
                  SQLM_TEST1_OperRow:SQLC_TEST1_Left3;
            FI;
        ELSE
            SQLM_TEST1_OperRow =
              SQLM_TEST1_OperRow:SQLC_TEST1_Left3;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree10_3;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_TEST1_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 11 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab11;

    WHEN 12 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab12;

    WHEN 13 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab13;

    WHEN 14 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab14;

    WHEN 15 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab15;

    WHEN 16 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab16;

    WHEN 17 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab17;

    WHEN 18 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab18;

    WHEN 19 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab19;

    WHEN 20 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab20;

    WHEN 21 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab21;

    WHEN 22 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab22;

    WHEN 23 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab23;

    WHEN 24 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab24;

    WHEN 25 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab25;

    WHEN 26 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab26;

    WHEN 27 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab27;

    WHEN 28 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab28;

    WHEN 29 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab29;

    WHEN 30 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab30;

    WHEN 31 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab31;

    WHEN 32 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab32;

    WHEN 33 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab33;

    WHEN 34 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab34;

    WHEN 35 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab35;

    WHEN 36 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab36;

    WHEN 37 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab37;

    WHEN 38 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab38;

    WHEN 39 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab39;

    WHEN 40 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab40;

    WHEN 41 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab41;

    WHEN 42 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab42;

    WHEN 43 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab43;

    WHEN 44 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab44;

    WHEN 45 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab45;

    WHEN 46 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab46;

    WHEN 47 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab47;

    WHEN 48 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab48;

    WHEN 49 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab49;

    WHEN 50 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab50;

    WHEN 51 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab51;

    WHEN 52 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab52;

    WHEN 53 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab53;

    WHEN 54 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab54;

    WHEN 55 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab55;

    WHEN 56 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab56;

    WHEN 57 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab57;

    WHEN 58 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab58;

    WHEN 59 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab59;

    WHEN 60 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab60;

    WHEN 61 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab61;

    WHEN 62 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab62;

    WHEN 63 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab63;

    WHEN 64 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab64;

    WHEN 65 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab65;

    WHEN 66 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab66;

    WHEN 67 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab67;

    WHEN 68 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab68;

    WHEN 69 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab69;

    WHEN 70 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab70;

    WHEN 71 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab71;

    WHEN 72 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab72;

    WHEN 73 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab73;

    WHEN 74 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab74;

    WHEN 75 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab75;

    WHEN 76 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab76;

    WHEN 77 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab77;

    WHEN 78 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab78;

    WHEN 79 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab79;

    WHEN 80 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab80;

    WHEN 81 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab81;

    WHEN 82 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab82;

    WHEN 83 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab83;

    WHEN 84 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab84;

    WHEN 85 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab85;

    WHEN 86 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab86;

    WHEN 87 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab87;

    WHEN 88 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab88;

    WHEN 89 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab89;

    WHEN 90 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab90;

    WHEN 91 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab91;

    WHEN 92 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab92;

    WHEN 93 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab93;

    WHEN 94 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab94;

    WHEN 95 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab95;

    WHEN 96 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab96;

    WHEN 97 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab97;

    WHEN 98 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab98;

    WHEN 99 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab99;

    WHEN 100 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab100;

    WHEN 101 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab101;

    WHEN 102 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab102;

    WHEN 103 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab103;

    WHEN 104 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab104;

    WHEN 105 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab105;

    WHEN 106 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab106;

    WHEN 107 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab107;

    WHEN 108 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab108;

    WHEN 109 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab109;
    OTHERWISE DO;
    ESAC;
    EXIT;

!------------------------------------------------!
!       tuPlexCode !
!------------------------------------------------!
!------------------------------------------------!
!       comPlexCode !
!------------------------------------------------!
!------------------------------------------------!
!       RESTARTPHASE3 !
!------------------------------------------------!
RESTARTPHASE3)
! Ask for block and table reference for remote table !
    SEND ddhTabRef WITH
        1,
        cOwnRef,
        "TEST2";
    EXIT;
ddhTabRefLab1)
    SQLM_Remote(0).block=SQLX_OtherBlock;
    SQLM_Remote(0).table=SQLX_TableReference;
    GOTO RESTARTEND;
!------------------------------------------------!
!       tuDdhTabRefR !
!------------------------------------------------!
    ENTER ddhTabRefR WITH
        SQLX_ReturnLabel,
        SQLX_ReturnCode,
        SQLX_OtherBlock,
        SQLX_TableReference;
    GOTO ddhTabRefLab1;
!--------------------------------------!
!        recTusReAllProt !
!--------------------------------------!
    RECEIVE TusReAllProt WITH
        PROTECTEDP,
        SQLX_OtherProtected;
    PROTECTEDP:SQLM_Allocated = 1;
    RETURN TusReAllProtAck WITH
        SQLX_OtherProtected;
!--------------------------------------!
!       recTowGetR      !
!--------------------------------------!
!--------------------------------------!
!       recTowChaVolRowR        !
!--------------------------------------!
    ENTER towChaVolRowR WITH
        PROTECTEDP,
        SQLCODE;
    GOTO towChaVolRowLab1;
    EXIT;
!--------------------------------------!
!       recTrhInsRowR   !
!--------------------------------------!
    ENTER trhInsRowR WITH
        PROTECTEDP,
        SQLCODE;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO trhInsRowLab1;
    WHEN 2 DO GOTO trhInsRowLab2;
    WHEN 3 DO GOTO trhInsRowLab3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recTrhLetFldR    !
!--------------------------------------!
    ENTER TrhLetFldR WITH
        PROTECTEDP,
        SQLCODE;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO trhLetFldLab1;
    WHEN 2 DO GOTO trhLetFldLab2;
    WHEN 3 DO GOTO trhLetFldLab3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recTrhChaRowR   !
!--------------------------------------!
    ENTER trhChaRowR WITH
        PROTECTEDP,
        SQLCODE;
    GOTO trhChaRowLab1;
    EXIT;
!--------------------------------------!
!       recTrhDelRowR   !
!--------------------------------------!
    ENTER trhDelRowR WITH
        PROTECTEDP,
        SQLCODE;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO trhDelRowLab1;
    WHEN 2 DO GOTO trhDelRowLab2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recTowOpenR     !
!--------------------------------------!
!--------------------------------------!
!       recTrhStaTransR !
!--------------------------------------!
    ENTER trhStaTransR WITH
        PROTECTEDP,
        SQLCODE,
        PROTECTEDP:SQLTRANSID;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO trhStaTransLab1;
    WHEN 2 DO GOTO trhStaTransLab2;
    WHEN 3 DO GOTO trhStaTransLab3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recTrhVerTransR !
!--------------------------------------!
    ENTER trhVerTransR WITH
        PROTECTEDP,
        SQLCODE,
        PROTECTEDP:SQLBLOCK,
        PROTECTEDP:SQLTABLE;
    GOTO trhVerTransLab1;
    EXIT;
!--------------------------------------!
!       recTrhComTransR !
!--------------------------------------!
    ENTER trhComTransR WITH
        PROTECTEDP,
        SQLCODE,
        PROTECTEDP:SQLBLOCK,
        PROTECTEDP:SQLTABLE;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO trhComTransLab1;
    WHEN 2 DO GOTO trhComTransLab2;
    WHEN 3 DO GOTO trhComTransLab3;
    WHEN 4 DO GOTO trhComTransLab4;
    WHEN 5 DO GOTO trhComTransLab5;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recTrhRollBckR  !
!--------------------------------------!
    ENTER trhRollBckR WITH
        PROTECTEDP,
        SQLCODE;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO trhRollBckLab1;
    WHEN 2 DO GOTO trhRollBckLab2;
    WHEN 3 DO GOTO trhRollBckLab3;
    WHEN 4 DO GOTO trhRollBckLab4;
    WHEN 5 DO GOTO trhRollBckLab5;
    WHEN 6 DO GOTO trhRollBckLab6;
    WHEN 7 DO GOTO trhRollBckLab7;
    WHEN 8 DO GOTO trhRollBckLab8;
    WHEN 9 DO GOTO trhRollBckLab9;
    WHEN 10 DO GOTO trhRollBckLab10;
    WHEN 11 DO GOTO trhRollBckLab11;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recContinueB !
!--------------------------------------!
    ENTER CONTINUEB WITH
        PROTECTEDP,
        SQLX_ReturnLabel;
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO continueBLab1;
    WHEN 2 DO GOTO continueBLab2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recContinueC !
!--------------------------------------!
!END SQL!
END PROGRAM;
!BEGIN SQL COMMON 0!
!------------------------------------------------!
!       towAsaCode !
!------------------------------------------------!
!------------------------------------------------!
!       comAsaCode !
!------------------------------------------------!
!------------------------------------------------!
!       sPack !
!------------------------------------------------!

PROGRAM SQLS_PROGRAMS_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_PROGRAMS_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_1)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_1;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,3
        ADDR    EXIT_1!
LHC CR/W0-3; JGT WR1,EXIT_1;
LHC CR/W0-0; JER WR1,L0_1;!        ADDR    L0_1!
LHC CR/W0-1; JER WR1,L1_1;!        ADDR    L1_1!
LHC CR/W0-2; JER WR1,L2_1;!        ADDR    L2_1!
LHC CR/W0-3; JER WR1,L3_1;!        ADDR    L3_1!

L0_1)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_1;

L1_1)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_PROGRAMS_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_1;

L2_1)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_PROGRAMS_NAME_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-4;
        JLN     LOOP_1;

L3_1)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_PROGRAMS_BLKREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_1;
EXIT_1)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_TABLES_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_TABLES_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_2)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_2;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,20
        ADDR    EXIT_2!
LHC CR/W0-20; JGT WR1,EXIT_2;
LHC CR/W0-0; JER WR1,L0_2;!        ADDR    L0_2!
LHC CR/W0-1; JER WR1,L1_2;!        ADDR    L1_2!
LHC CR/W0-2; JER WR1,L2_2;!        ADDR    L2_2!
LHC CR/W0-3; JER WR1,L3_2;!        ADDR    L3_2!
LHC CR/W0-4; JER WR1,L4_2;!        ADDR    L4_2!
LHC CR/W0-5; JER WR1,L5_2;!        ADDR    L5_2!
LHC CR/W0-6; JER WR1,L6_2;!        ADDR    L6_2!
LHC CR/W0-7; JER WR1,L7_2;!        ADDR    L7_2!
LHC CR/W0-8; JER WR1,L8_2;!        ADDR    L8_2!
LHC CR/W0-9; JER WR1,L9_2;!        ADDR    L9_2!
LHC CR/W0-10; JER WR1,L10_2;!        ADDR    L10_2!
LHC CR/W0-11; JER WR1,L11_2;!        ADDR    L11_2!
LHC CR/W0-12; JER WR1,L12_2;!        ADDR    L12_2!
LHC CR/W0-13; JER WR1,L13_2;!        ADDR    L13_2!
LHC CR/W0-14; JER WR1,L14_2;!        ADDR    L14_2!
LHC CR/W0-15; JER WR1,L15_2;!        ADDR    L15_2!
LHC CR/W0-16; JER WR1,L16_2;!        ADDR    L16_2!
LHC CR/W0-17; JER WR1,L17_2;!        ADDR    L17_2!
LHC CR/W0-18; JER WR1,L18_2;!        ADDR    L18_2!
LHC CR/W0-19; JER WR1,L19_2;!        ADDR    L19_2!
LHC CR/W0-20; JER WR1,L20_2;!        ADDR    L20_2!

L0_2)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_2;

L1_2)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_TABLES_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_2;

L2_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_NAME_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-8;
        JLN     LOOP_2;

L3_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_BLKREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L4_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_TABREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L5_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_DESCR_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    AWCD    SQLX_DR3-16;
        JLN     LOOP_2;

L6_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_SAEIDT_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_TABLES_SAEIDT_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L7_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_ESTEPT_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L8_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_MAXST_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L9_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_ALLOCST_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L10_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_USEDST_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L11_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_SAEIDW_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_TABLES_SAEIDW_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L12_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_ESTEPW_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L13_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_MAXSW_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L14_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_ALLOCSW_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L15_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_USEDSW_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L16_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_STATE_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L17_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_RAUCAT_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L18_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_WAUCAT_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L19_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_LOCATE_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;

L20_2)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLES_NOFLTCO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_2;
EXIT_2)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_FIELDS_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_FIELDS_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_3)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_3;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,27
        ADDR    EXIT_3!
LHC CR/W0-27; JGT WR1,EXIT_3;
LHC CR/W0-0; JER WR1,L0_3;!        ADDR    L0_3!
LHC CR/W0-1; JER WR1,L1_3;!        ADDR    L1_3!
LHC CR/W0-2; JER WR1,L2_3;!        ADDR    L2_3!
LHC CR/W0-3; JER WR1,L3_3;!        ADDR    L3_3!
LHC CR/W0-4; JER WR1,L4_3;!        ADDR    L4_3!
LHC CR/W0-5; JER WR1,L5_3;!        ADDR    L5_3!
LHC CR/W0-6; JER WR1,L6_3;!        ADDR    L6_3!
LHC CR/W0-7; JER WR1,L7_3;!        ADDR    L7_3!
LHC CR/W0-8; JER WR1,L8_3;!        ADDR    L8_3!
LHC CR/W0-9; JER WR1,L9_3;!        ADDR    L9_3!
LHC CR/W0-10; JER WR1,L10_3;!        ADDR    L10_3!
LHC CR/W0-11; JER WR1,L11_3;!        ADDR    L11_3!
LHC CR/W0-12; JER WR1,L12_3;!        ADDR    L12_3!
LHC CR/W0-13; JER WR1,L13_3;!        ADDR    L13_3!
LHC CR/W0-14; JER WR1,L14_3;!        ADDR    L14_3!
LHC CR/W0-15; JER WR1,L15_3;!        ADDR    L15_3!
LHC CR/W0-16; JER WR1,L16_3;!        ADDR    L16_3!
LHC CR/W0-17; JER WR1,L17_3;!        ADDR    L17_3!
LHC CR/W0-18; JER WR1,L18_3;!        ADDR    L18_3!
LHC CR/W0-19; JER WR1,L19_3;!        ADDR    L19_3!
LHC CR/W0-20; JER WR1,L20_3;!        ADDR    L20_3!
LHC CR/W0-21; JER WR1,L21_3;!        ADDR    L21_3!
LHC CR/W0-22; JER WR1,L22_3;!        ADDR    L22_3!
LHC CR/W0-23; JER WR1,L23_3;!        ADDR    L23_3!
LHC CR/W0-24; JER WR1,L24_3;!        ADDR    L24_3!
LHC CR/W0-25; JER WR1,L25_3;!        ADDR    L25_3!
LHC CR/W0-26; JER WR1,L26_3;!        ADDR    L26_3!
LHC CR/W0-27; JER WR1,L27_3;!        ADDR    L27_3!

L0_3)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_3;

L1_3)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_FIELDS_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_3;

L2_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_NAME_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-4;
        JLN     LOOP_3;

L3_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_TABREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L4_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_BLKREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L5_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_FIELDNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L6_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_DESCR_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    AWCD    SQLX_DR3-16;
        JLN     LOOP_3;

L7_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_VISIBIL_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L8_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_PRWIDTH_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L9_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_NULLPER_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L10_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_DATATYP_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L11_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_BADDRES_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L12_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_MIN_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_FIELDS_MIN_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L13_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_MAX_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_FIELDS_MAX_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L14_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_SIZE_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L15_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_DIDNR_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_FIELDS_DIDNR_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L16_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_DIDPOS_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_FIELDS_DIDPOS_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L17_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_PCLEAR_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L18_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_PRELOAD_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L19_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_PDUMP_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L20_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_PSTATIC_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L21_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_VOLATIL_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L22_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_DEFBITS_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_FIELDS_DEFBITS_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L23_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_DEFSTR_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_FIELDS_DEFSTR_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    AWCD    SQLX_DR3-16;
        JLN     LOOP_3;

L24_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_DEFNSTR_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_FIELDS_DEFNSTR_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    AWCD    SQLX_DR3-16;
        JLN     LOOP_3;

L25_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_DEFPNS_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLX_TempData;
    RSS     WR2-SQLC_FIELDS_DEFPNS_Data/W0;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_FIELDS_DEFPNS_Data/W1;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_FIELDS_DEFPNS_Data/W2;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_FIELDS_DEFPNS_Data/W3;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_FIELDS_DEFPNS_Data/W4;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_FIELDS_DEFPNS_Data/W5;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_FIELDS_DEFPNS_Data/W6;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_FIELDS_DEFPNS_Data/W7;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L26_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_DEFSYMB_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_FIELDS_DEFSYMB_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;

L27_3)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FIELDS_TROWNO_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_FIELDS_TROWNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_3;
EXIT_3)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_KEYS_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_KEYS_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_4)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_4;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,6
        ADDR    EXIT_4!
LHC CR/W0-6; JGT WR1,EXIT_4;
LHC CR/W0-0; JER WR1,L0_4;!        ADDR    L0_4!
LHC CR/W0-1; JER WR1,L1_4;!        ADDR    L1_4!
LHC CR/W0-2; JER WR1,L2_4;!        ADDR    L2_4!
LHC CR/W0-3; JER WR1,L3_4;!        ADDR    L3_4!
LHC CR/W0-4; JER WR1,L4_4;!        ADDR    L4_4!
LHC CR/W0-5; JER WR1,L5_4;!        ADDR    L5_4!
LHC CR/W0-6; JER WR1,L6_4;!        ADDR    L6_4!

L0_4)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_4;

L1_4)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_KEYS_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_4;

L2_4)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_KEYS_TROWNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_4;

L3_4)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_KEYS_KEYNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_4;

L4_4)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_KEYS_TABREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_4;

L5_4)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_KEYS_BLKREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_4;

L6_4)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_KEYS_KEYTYPE_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_4;
EXIT_4)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_KEYFIELDS_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_KEYFIELDS_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_5)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_5;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,7
        ADDR    EXIT_5!
LHC CR/W0-7; JGT WR1,EXIT_5;
LHC CR/W0-0; JER WR1,L0_5;!        ADDR    L0_5!
LHC CR/W0-1; JER WR1,L1_5;!        ADDR    L1_5!
LHC CR/W0-2; JER WR1,L2_5;!        ADDR    L2_5!
LHC CR/W0-3; JER WR1,L3_5;!        ADDR    L3_5!
LHC CR/W0-4; JER WR1,L4_5;!        ADDR    L4_5!
LHC CR/W0-5; JER WR1,L5_5;!        ADDR    L5_5!
LHC CR/W0-6; JER WR1,L6_5;!        ADDR    L6_5!
LHC CR/W0-7; JER WR1,L7_5;!        ADDR    L7_5!

L0_5)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_5;

L1_5)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_KEYFIELDS_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_5;

L2_5)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_KEYFIELDS_TROWNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_5;

L3_5)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_KEYFIELDS_KEYNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_5;

L4_5)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_KEYFIELDS_TABREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_5;

L5_5)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_KEYFIELDS_BLKREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_5;

L6_5)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_KEYFIELDS_COMPNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_5;

L7_5)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_KEYFIELDS_FROWNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_5;
EXIT_5)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_FOREIGNKEYS_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_FOREIGNKEYS_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_6)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_6;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,10
        ADDR    EXIT_6!
LHC CR/W0-10; JGT WR1,EXIT_6;
LHC CR/W0-0; JER WR1,L0_6;!        ADDR    L0_6!
LHC CR/W0-1; JER WR1,L1_6;!        ADDR    L1_6!
LHC CR/W0-2; JER WR1,L2_6;!        ADDR    L2_6!
LHC CR/W0-3; JER WR1,L3_6;!        ADDR    L3_6!
LHC CR/W0-4; JER WR1,L4_6;!        ADDR    L4_6!
LHC CR/W0-5; JER WR1,L5_6;!        ADDR    L5_6!
LHC CR/W0-6; JER WR1,L6_6;!        ADDR    L6_6!
LHC CR/W0-7; JER WR1,L7_6;!        ADDR    L7_6!
LHC CR/W0-8; JER WR1,L8_6;!        ADDR    L8_6!
LHC CR/W0-9; JER WR1,L9_6;!        ADDR    L9_6!
LHC CR/W0-10; JER WR1,L10_6;!        ADDR    L10_6!

L0_6)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_6;

L1_6)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_FOREIGNKEYS_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_6;

L2_6)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FOREIGNKEYS_TROWNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_6;

L3_6)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FOREIGNKEYS_ORDNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_6;

L4_6)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FOREIGNKEYS_BLKREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_6;

L5_6)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FOREIGNKEYS_TABREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_6;

L6_6)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FOREIGNKEYS_KEYNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_6;

L7_6)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FOREIGNKEYS_FTROWNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_6;

L8_6)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FOREIGNKEYS_FTABREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_6;

L9_6)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FOREIGNKEYS_FBLKREF_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_6;

L10_6)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_FOREIGNKEYS_COND_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_6;
EXIT_6)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_SYMBOLS_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_SYMBOLS_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_7)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_7;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,4
        ADDR    EXIT_7!
LHC CR/W0-4; JGT WR1,EXIT_7;
LHC CR/W0-0; JER WR1,L0_7;!        ADDR    L0_7!
LHC CR/W0-1; JER WR1,L1_7;!        ADDR    L1_7!
LHC CR/W0-2; JER WR1,L2_7;!        ADDR    L2_7!
LHC CR/W0-3; JER WR1,L3_7;!        ADDR    L3_7!
LHC CR/W0-4; JER WR1,L4_7;!        ADDR    L4_7!

L0_7)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_7;

L1_7)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_SYMBOLS_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_7;

L2_7)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_SYMBOLS_FROWNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_7;

L3_7)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_SYMBOLS_SYMBOL_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-4;
        JLN     LOOP_7;

L4_7)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_SYMBOLS_SYMVAL_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_7;
EXIT_7)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_TOWFAULTCODES_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_TOWFAULTCODES_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_8)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_8;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,4
        ADDR    EXIT_8!
LHC CR/W0-4; JGT WR1,EXIT_8;
LHC CR/W0-0; JER WR1,L0_8;!        ADDR    L0_8!
LHC CR/W0-1; JER WR1,L1_8;!        ADDR    L1_8!
LHC CR/W0-2; JER WR1,L2_8;!        ADDR    L2_8!
LHC CR/W0-3; JER WR1,L3_8;!        ADDR    L3_8!
LHC CR/W0-4; JER WR1,L4_8;!        ADDR    L4_8!

L0_8)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_8;

L1_8)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_TOWFAULTCODES_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_8;

L2_8)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TOWFAULTCODES_TROWNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_8;

L3_8)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TOWFAULTCODES_FAULTNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_8;

L4_8)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TOWFAULTCODES_FLTTEXT_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    AWCD    SQLX_DR3-16;
        JLN     LOOP_8;
EXIT_8)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_SYSFAULTCODES_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_SYSFAULTCODES_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_9)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_9;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,3
        ADDR    EXIT_9!
LHC CR/W0-3; JGT WR1,EXIT_9;
LHC CR/W0-0; JER WR1,L0_9;!        ADDR    L0_9!
LHC CR/W0-1; JER WR1,L1_9;!        ADDR    L1_9!
LHC CR/W0-2; JER WR1,L2_9;!        ADDR    L2_9!
LHC CR/W0-3; JER WR1,L3_9;!        ADDR    L3_9!

L0_9)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_9;

L1_9)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_SYSFAULTCODES_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_9;

L2_9)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_SYSFAULTCODES_FAULTNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_9;

L3_9)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_SYSFAULTCODES_FLTTEXT_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-8;
        JLN     LOOP_9;
EXIT_9)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_SYSTEMFIELDS_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_SYSTEMFIELDS_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_10)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_10;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,4
        ADDR    EXIT_10!
LHC CR/W0-4; JGT WR1,EXIT_10;
LHC CR/W0-0; JER WR1,L0_10;!        ADDR    L0_10!
LHC CR/W0-1; JER WR1,L1_10;!        ADDR    L1_10!
LHC CR/W0-2; JER WR1,L2_10;!        ADDR    L2_10!
LHC CR/W0-3; JER WR1,L3_10;!        ADDR    L3_10!
LHC CR/W0-4; JER WR1,L4_10;!        ADDR    L4_10!

L0_10)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_10;

L1_10)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_SYSTEMFIELDS_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_10;

L2_10)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_SYSTEMFIELDS_TROWNO_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_10;

L3_10)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_SYSTEMFIELDS_ROWGEN_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_10;

L4_10)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_SYSTEMFIELDS_LOCK_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_10;
EXIT_10)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_TEST1_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_TEST1_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_11)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_11;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,9
        ADDR    EXIT_11!
LHC CR/W0-9; JGT WR1,EXIT_11;
LHC CR/W0-0; JER WR1,L0_11;!        ADDR    L0_11!
LHC CR/W0-1; JER WR1,L1_11;!        ADDR    L1_11!
LHC CR/W0-2; JER WR1,L2_11;!        ADDR    L2_11!
LHC CR/W0-3; JER WR1,L3_11;!        ADDR    L3_11!
LHC CR/W0-4; JER WR1,L4_11;!        ADDR    L4_11!
LHC CR/W0-5; JER WR1,L5_11;!        ADDR    L5_11!
LHC CR/W0-6; JER WR1,L6_11;!        ADDR    L6_11!
LHC CR/W0-7; JER WR1,L7_11;!        ADDR    L7_11!
LHC CR/W0-8; JER WR1,L8_11;!        ADDR    L8_11!
LHC CR/W0-9; JER WR1,L9_11;!        ADDR    L9_11!

L0_11)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_11;

L1_11)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_TEST1_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_11;

L2_11)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TEST1_COL1_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-8;
        JLN     LOOP_11;

L3_11)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TEST1_COL2_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_11;

L4_11)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TEST1_COL3_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_TEST1_COL3_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_11;

L5_11)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TEST1_COL4_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-8;
        JLN     LOOP_11;

L6_11)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TEST1_COL5_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_TEST1_COL5_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-4;
        JLN     LOOP_11;

L7_11)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TEST1_COL6_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_TEST1_COL6_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    AWCD    SQLX_DR3-16;
        JLN     LOOP_11;

L8_11)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TEST1_COL7_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_TEST1_COL7_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_11;

L9_11)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TEST1_COL8_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLX_TempData;
    RSS     WR2-SQLC_TEST1_COL8_Data/W0;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TEST1_COL8_Data/W1;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TEST1_COL8_Data/W2;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TEST1_COL8_Data/W3;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TEST1_COL8_Data/W4;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TEST1_COL8_Data/W5;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TEST1_COL8_Data/W6;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TEST1_COL8_Data/W7;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_11;
EXIT_11)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;
!------------------------------------------------!
!       sUnpack !
!------------------------------------------------!

PROGRAM SQLS_PROGRAMS_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_PROGRAMS_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_12)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_12;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,3
        ADDR    EXIT_12!
LHC CR/W0-3; JGT WR1,EXIT_12;
LHC CR/W0-0; JER WR1,EXIT_12;!        ADDR    EXIT_12!
LHC CR/W0-1; JER WR1,EXIT_12;!        ADDR    EXIT_12!
LHC CR/W0-2; JER WR1,L2_12;!        ADDR L2_12!
LHC CR/W0-3; JER WR1,L3_12;!        ADDR L3_12!

L2_12)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_PROGRAMS_NAME_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-4;
        JLN     LOOP_12;

L3_12)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE3_12;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_PROGRAMS_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_12;
UPDATE3_12)
! read column data into register WR3.!
        RS      WR3-SQLC_PROGRAMS_BLKREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_PROGRAMS_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_PROGRAMS_BLKREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD3_12;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_PROGRAMS_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_12;
ADD3_12)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_PROGRAMS_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_12;

EXIT_12)
END PROGRAM;

PROGRAM SQLS_TABLES_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_TABLES_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_13)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_13;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,20
        ADDR    EXIT_13!
LHC CR/W0-20; JGT WR1,EXIT_13;
LHC CR/W0-0; JER WR1,EXIT_13;!        ADDR    EXIT_13!
LHC CR/W0-1; JER WR1,EXIT_13;!        ADDR    EXIT_13!
LHC CR/W0-2; JER WR1,L2_13;!        ADDR L2_13!
LHC CR/W0-3; JER WR1,L3_13;!        ADDR L3_13!
LHC CR/W0-4; JER WR1,L4_13;!        ADDR L4_13!
LHC CR/W0-5; JER WR1,L5_13;!        ADDR L5_13!
LHC CR/W0-6; JER WR1,L6_13;!        ADDR L6_13!
LHC CR/W0-7; JER WR1,L7_13;!        ADDR L7_13!
LHC CR/W0-8; JER WR1,L8_13;!        ADDR L8_13!
LHC CR/W0-9; JER WR1,L9_13;!        ADDR L9_13!
LHC CR/W0-10; JER WR1,L10_13;!        ADDR L10_13!
LHC CR/W0-11; JER WR1,L11_13;!        ADDR L11_13!
LHC CR/W0-12; JER WR1,L12_13;!        ADDR L12_13!
LHC CR/W0-13; JER WR1,L13_13;!        ADDR L13_13!
LHC CR/W0-14; JER WR1,L14_13;!        ADDR L14_13!
LHC CR/W0-15; JER WR1,L15_13;!        ADDR L15_13!
LHC CR/W0-16; JER WR1,L16_13;!        ADDR L16_13!
LHC CR/W0-17; JER WR1,L17_13;!        ADDR L17_13!
LHC CR/W0-18; JER WR1,L18_13;!        ADDR L18_13!
LHC CR/W0-19; JER WR1,L19_13;!        ADDR L19_13!
LHC CR/W0-20; JER WR1,L20_13;!        ADDR L20_13!

L2_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_TABLES_NAME_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-8;
        JLN     LOOP_13;

L3_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE3_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE3_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_BLKREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_BLKREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD3_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD3_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L4_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE4_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_TABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE4_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_TABREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_TABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_TABREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD4_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_TABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD4_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_TABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L5_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_TABLES_DESCR_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        AWCD    WR0-16;
        JLN     LOOP_13;

L6_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TABLES_SAEIDT_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_TABLES_SAEIDT_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;

L7_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE7_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_ESTEPT_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE7_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_ESTEPT_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_ESTEPT_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_ESTEPT_Data;
! should we add the values together?!
        JEC     WR2,1,ADD7_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_ESTEPT_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD7_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_ESTEPT_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L8_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE8_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_MAXST_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE8_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_MAXST_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_MAXST_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_MAXST_Data;
! should we add the values together?!
        JEC     WR2,1,ADD8_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_MAXST_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD8_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_MAXST_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L9_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE9_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_ALLOCST_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE9_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_ALLOCST_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_ALLOCST_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_ALLOCST_Data;
! should we add the values together?!
        JEC     WR2,1,ADD9_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_ALLOCST_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD9_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_ALLOCST_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L10_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE10_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_USEDST_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE10_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_USEDST_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_USEDST_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_USEDST_Data;
! should we add the values together?!
        JEC     WR2,1,ADD10_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_USEDST_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD10_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_USEDST_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L11_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TABLES_SAEIDW_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_TABLES_SAEIDW_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;

L12_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE12_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_ESTEPW_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE12_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_ESTEPW_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_ESTEPW_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_ESTEPW_Data;
! should we add the values together?!
        JEC     WR2,1,ADD12_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_ESTEPW_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD12_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_ESTEPW_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L13_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE13_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_MAXSW_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE13_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_MAXSW_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_MAXSW_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_MAXSW_Data;
! should we add the values together?!
        JEC     WR2,1,ADD13_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_MAXSW_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD13_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_MAXSW_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L14_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE14_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_ALLOCSW_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE14_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_ALLOCSW_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_ALLOCSW_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_ALLOCSW_Data;
! should we add the values together?!
        JEC     WR2,1,ADD14_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_ALLOCSW_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD14_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_ALLOCSW_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L15_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE15_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_USEDSW_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE15_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_USEDSW_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_USEDSW_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_USEDSW_Data;
! should we add the values together?!
        JEC     WR2,1,ADD15_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_USEDSW_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD15_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_USEDSW_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L16_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_TABLES_STATE_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;

L17_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE17_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_RAUCAT_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE17_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_RAUCAT_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_RAUCAT_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_RAUCAT_Data;
! should we add the values together?!
        JEC     WR2,1,ADD17_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_RAUCAT_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD17_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_RAUCAT_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L18_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE18_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_WAUCAT_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE18_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_WAUCAT_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_WAUCAT_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_WAUCAT_Data;
! should we add the values together?!
        JEC     WR2,1,ADD18_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_WAUCAT_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD18_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_WAUCAT_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

L19_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_TABLES_LOCATE_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;

L20_13)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE20_13;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_NOFLTCO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_13;
UPDATE20_13)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLES_NOFLTCO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLES_NOFLTCO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLES_NOFLTCO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD20_13;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLES_NOFLTCO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;
ADD20_13)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLES_NOFLTCO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_13;

EXIT_13)
END PROGRAM;

PROGRAM SQLS_FIELDS_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_FIELDS_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_14)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_14;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,27
        ADDR    EXIT_14!
LHC CR/W0-27; JGT WR1,EXIT_14;
LHC CR/W0-0; JER WR1,EXIT_14;!        ADDR    EXIT_14!
LHC CR/W0-1; JER WR1,EXIT_14;!        ADDR    EXIT_14!
LHC CR/W0-2; JER WR1,L2_14;!        ADDR L2_14!
LHC CR/W0-3; JER WR1,L3_14;!        ADDR L3_14!
LHC CR/W0-4; JER WR1,L4_14;!        ADDR L4_14!
LHC CR/W0-5; JER WR1,L5_14;!        ADDR L5_14!
LHC CR/W0-6; JER WR1,L6_14;!        ADDR L6_14!
LHC CR/W0-7; JER WR1,L7_14;!        ADDR L7_14!
LHC CR/W0-8; JER WR1,L8_14;!        ADDR L8_14!
LHC CR/W0-9; JER WR1,L9_14;!        ADDR L9_14!
LHC CR/W0-10; JER WR1,L10_14;!        ADDR L10_14!
LHC CR/W0-11; JER WR1,L11_14;!        ADDR L11_14!
LHC CR/W0-12; JER WR1,L12_14;!        ADDR L12_14!
LHC CR/W0-13; JER WR1,L13_14;!        ADDR L13_14!
LHC CR/W0-14; JER WR1,L14_14;!        ADDR L14_14!
LHC CR/W0-15; JER WR1,L15_14;!        ADDR L15_14!
LHC CR/W0-16; JER WR1,L16_14;!        ADDR L16_14!
LHC CR/W0-17; JER WR1,L17_14;!        ADDR L17_14!
LHC CR/W0-18; JER WR1,L18_14;!        ADDR L18_14!
LHC CR/W0-19; JER WR1,L19_14;!        ADDR L19_14!
LHC CR/W0-20; JER WR1,L20_14;!        ADDR L20_14!
LHC CR/W0-21; JER WR1,L21_14;!        ADDR L21_14!
LHC CR/W0-22; JER WR1,L22_14;!        ADDR L22_14!
LHC CR/W0-23; JER WR1,L23_14;!        ADDR L23_14!
LHC CR/W0-24; JER WR1,L24_14;!        ADDR L24_14!
LHC CR/W0-25; JER WR1,L25_14;!        ADDR L25_14!
LHC CR/W0-26; JER WR1,L26_14;!        ADDR L26_14!
LHC CR/W0-27; JER WR1,L27_14;!        ADDR L27_14!

L2_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_NAME_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-4;
        JLN     LOOP_14;

L3_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE3_14;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_TABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;
UPDATE3_14)
! read column data into register WR3.!
        RS      WR3-SQLC_FIELDS_TABREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_TABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FIELDS_TABREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD3_14;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FIELDS_TABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;
ADD3_14)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FIELDS_TABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;

L4_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE4_14;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;
UPDATE4_14)
! read column data into register WR3.!
        RS      WR3-SQLC_FIELDS_BLKREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FIELDS_BLKREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD4_14;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FIELDS_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;
ADD4_14)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FIELDS_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;

L5_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE5_14;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_FIELDNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;
UPDATE5_14)
! read column data into register WR3.!
        RS      WR3-SQLC_FIELDS_FIELDNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_FIELDNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FIELDS_FIELDNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD5_14;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FIELDS_FIELDNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;
ADD5_14)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FIELDS_FIELDNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;

L6_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_DESCR_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        AWCD    WR0-16;
        JLN     LOOP_14;

L7_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_VISIBIL_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L8_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE8_14;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_PRWIDTH_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;
UPDATE8_14)
! read column data into register WR3.!
        RS      WR3-SQLC_FIELDS_PRWIDTH_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_PRWIDTH_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FIELDS_PRWIDTH_Data;
! should we add the values together?!
        JEC     WR2,1,ADD8_14;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FIELDS_PRWIDTH_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;
ADD8_14)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FIELDS_PRWIDTH_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;

L9_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_NULLPER_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L10_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_DATATYP_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L11_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE11_14;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_BADDRES_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;
UPDATE11_14)
! read column data into register WR3.!
        RS      WR3-SQLC_FIELDS_BADDRES_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_BADDRES_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FIELDS_BADDRES_Data;
! should we add the values together?!
        JEC     WR2,1,ADD11_14;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FIELDS_BADDRES_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;
ADD11_14)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FIELDS_BADDRES_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;

L12_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_FIELDS_MIN_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_MIN_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L13_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_FIELDS_MAX_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_MAX_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L14_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE14_14;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_SIZE_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;
UPDATE14_14)
! read column data into register WR3.!
        RS      WR3-SQLC_FIELDS_SIZE_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FIELDS_SIZE_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FIELDS_SIZE_Data;
! should we add the values together?!
        JEC     WR2,1,ADD14_14;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FIELDS_SIZE_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;
ADD14_14)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FIELDS_SIZE_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_14;

L15_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_FIELDS_DIDNR_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_DIDNR_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L16_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_FIELDS_DIDPOS_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_DIDPOS_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L17_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_PCLEAR_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L18_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_PRELOAD_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L19_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_PDUMP_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L20_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_PSTATIC_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L21_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_VOLATIL_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L22_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_FIELDS_DEFBITS_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_DEFBITS_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L23_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_FIELDS_DEFSTR_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_DEFSTR_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        AWCD    WR0-16;
        JLN     LOOP_14;

L24_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_FIELDS_DEFNSTR_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_DEFNSTR_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        AWCD    WR0-16;
        JLN     LOOP_14;

L25_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_FIELDS_DEFPNS_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
    LBNBA   WR1-SQLX_TempData;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_FIELDS_DEFPNS_Data/W0-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_FIELDS_DEFPNS_Data/W1-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_FIELDS_DEFPNS_Data/W2-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_FIELDS_DEFPNS_Data/W3-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_FIELDS_DEFPNS_Data/W4-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_FIELDS_DEFPNS_Data/W5-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_FIELDS_DEFPNS_Data/W6-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_FIELDS_DEFPNS_Data/W7-WR5;
    ACC     WR0-1;
        JLN     LOOP_14;

L26_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_FIELDS_DEFSYMB_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_DEFSYMB_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

L27_14)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_FIELDS_TROWNO_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_FIELDS_TROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_14;

EXIT_14)
END PROGRAM;

PROGRAM SQLS_KEYS_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_KEYS_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_15)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_15;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,6
        ADDR    EXIT_15!
LHC CR/W0-6; JGT WR1,EXIT_15;
LHC CR/W0-0; JER WR1,EXIT_15;!        ADDR    EXIT_15!
LHC CR/W0-1; JER WR1,EXIT_15;!        ADDR    EXIT_15!
LHC CR/W0-2; JER WR1,L2_15;!        ADDR L2_15!
LHC CR/W0-3; JER WR1,L3_15;!        ADDR L3_15!
LHC CR/W0-4; JER WR1,L4_15;!        ADDR L4_15!
LHC CR/W0-5; JER WR1,L5_15;!        ADDR L5_15!
LHC CR/W0-6; JER WR1,L6_15;!        ADDR L6_15!

L2_15)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE2_15;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYS_TROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_15;
UPDATE2_15)
! read column data into register WR3.!
        RS      WR3-SQLC_KEYS_TROWNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYS_TROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_KEYS_TROWNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD2_15;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_KEYS_TROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_15;
ADD2_15)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_KEYS_TROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_15;

L3_15)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE3_15;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYS_KEYNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_15;
UPDATE3_15)
! read column data into register WR3.!
        RS      WR3-SQLC_KEYS_KEYNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYS_KEYNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_KEYS_KEYNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD3_15;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_KEYS_KEYNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_15;
ADD3_15)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_KEYS_KEYNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_15;

L4_15)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE4_15;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYS_TABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_15;
UPDATE4_15)
! read column data into register WR3.!
        RS      WR3-SQLC_KEYS_TABREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYS_TABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_KEYS_TABREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD4_15;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_KEYS_TABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_15;
ADD4_15)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_KEYS_TABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_15;

L5_15)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE5_15;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYS_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_15;
UPDATE5_15)
! read column data into register WR3.!
        RS      WR3-SQLC_KEYS_BLKREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYS_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_KEYS_BLKREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD5_15;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_KEYS_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_15;
ADD5_15)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_KEYS_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_15;

L6_15)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_KEYS_KEYTYPE_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_15;

EXIT_15)
END PROGRAM;

PROGRAM SQLS_KEYFIELDS_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_KEYFIELDS_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_16)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_16;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,7
        ADDR    EXIT_16!
LHC CR/W0-7; JGT WR1,EXIT_16;
LHC CR/W0-0; JER WR1,EXIT_16;!        ADDR    EXIT_16!
LHC CR/W0-1; JER WR1,EXIT_16;!        ADDR    EXIT_16!
LHC CR/W0-2; JER WR1,L2_16;!        ADDR L2_16!
LHC CR/W0-3; JER WR1,L3_16;!        ADDR L3_16!
LHC CR/W0-4; JER WR1,L4_16;!        ADDR L4_16!
LHC CR/W0-5; JER WR1,L5_16;!        ADDR L5_16!
LHC CR/W0-6; JER WR1,L6_16;!        ADDR L6_16!
LHC CR/W0-7; JER WR1,L7_16;!        ADDR L7_16!

L2_16)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE2_16;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_TROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_16;
UPDATE2_16)
! read column data into register WR3.!
        RS      WR3-SQLC_KEYFIELDS_TROWNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_TROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_KEYFIELDS_TROWNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD2_16;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_KEYFIELDS_TROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;
ADD2_16)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_KEYFIELDS_TROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;

L3_16)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE3_16;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_KEYNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_16;
UPDATE3_16)
! read column data into register WR3.!
        RS      WR3-SQLC_KEYFIELDS_KEYNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_KEYNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_KEYFIELDS_KEYNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD3_16;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_KEYFIELDS_KEYNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;
ADD3_16)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_KEYFIELDS_KEYNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;

L4_16)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE4_16;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_TABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_16;
UPDATE4_16)
! read column data into register WR3.!
        RS      WR3-SQLC_KEYFIELDS_TABREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_TABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_KEYFIELDS_TABREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD4_16;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_KEYFIELDS_TABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;
ADD4_16)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_KEYFIELDS_TABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;

L5_16)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE5_16;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_16;
UPDATE5_16)
! read column data into register WR3.!
        RS      WR3-SQLC_KEYFIELDS_BLKREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_KEYFIELDS_BLKREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD5_16;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_KEYFIELDS_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;
ADD5_16)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_KEYFIELDS_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;

L6_16)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE6_16;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_COMPNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_16;
UPDATE6_16)
! read column data into register WR3.!
        RS      WR3-SQLC_KEYFIELDS_COMPNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_COMPNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_KEYFIELDS_COMPNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD6_16;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_KEYFIELDS_COMPNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;
ADD6_16)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_KEYFIELDS_COMPNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;

L7_16)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE7_16;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_FROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_16;
UPDATE7_16)
! read column data into register WR3.!
        RS      WR3-SQLC_KEYFIELDS_FROWNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_KEYFIELDS_FROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_KEYFIELDS_FROWNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD7_16;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_KEYFIELDS_FROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;
ADD7_16)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_KEYFIELDS_FROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_16;

EXIT_16)
END PROGRAM;

PROGRAM SQLS_FOREIGNKEYS_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_FOREIGNKEYS_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_17)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_17;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,10
        ADDR    EXIT_17!
LHC CR/W0-10; JGT WR1,EXIT_17;
LHC CR/W0-0; JER WR1,EXIT_17;!        ADDR    EXIT_17!
LHC CR/W0-1; JER WR1,EXIT_17;!        ADDR    EXIT_17!
LHC CR/W0-2; JER WR1,L2_17;!        ADDR L2_17!
LHC CR/W0-3; JER WR1,L3_17;!        ADDR L3_17!
LHC CR/W0-4; JER WR1,L4_17;!        ADDR L4_17!
LHC CR/W0-5; JER WR1,L5_17;!        ADDR L5_17!
LHC CR/W0-6; JER WR1,L6_17;!        ADDR L6_17!
LHC CR/W0-7; JER WR1,L7_17;!        ADDR L7_17!
LHC CR/W0-8; JER WR1,L8_17;!        ADDR L8_17!
LHC CR/W0-9; JER WR1,L9_17;!        ADDR L9_17!
LHC CR/W0-10; JER WR1,L10_17;!        ADDR L10_17!

L2_17)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE2_17;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_TROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_17;
UPDATE2_17)
! read column data into register WR3.!
        RS      WR3-SQLC_FOREIGNKEYS_TROWNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_TROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FOREIGNKEYS_TROWNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD2_17;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FOREIGNKEYS_TROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;
ADD2_17)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FOREIGNKEYS_TROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;

L3_17)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE3_17;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_ORDNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_17;
UPDATE3_17)
! read column data into register WR3.!
        RS      WR3-SQLC_FOREIGNKEYS_ORDNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_ORDNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FOREIGNKEYS_ORDNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD3_17;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FOREIGNKEYS_ORDNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;
ADD3_17)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FOREIGNKEYS_ORDNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;

L4_17)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE4_17;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_17;
UPDATE4_17)
! read column data into register WR3.!
        RS      WR3-SQLC_FOREIGNKEYS_BLKREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_BLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FOREIGNKEYS_BLKREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD4_17;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FOREIGNKEYS_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;
ADD4_17)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FOREIGNKEYS_BLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;

L5_17)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE5_17;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_TABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_17;
UPDATE5_17)
! read column data into register WR3.!
        RS      WR3-SQLC_FOREIGNKEYS_TABREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_TABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FOREIGNKEYS_TABREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD5_17;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FOREIGNKEYS_TABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;
ADD5_17)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FOREIGNKEYS_TABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;

L6_17)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE6_17;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_KEYNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_17;
UPDATE6_17)
! read column data into register WR3.!
        RS      WR3-SQLC_FOREIGNKEYS_KEYNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_KEYNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FOREIGNKEYS_KEYNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD6_17;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FOREIGNKEYS_KEYNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;
ADD6_17)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FOREIGNKEYS_KEYNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;

L7_17)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE7_17;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_FTROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_17;
UPDATE7_17)
! read column data into register WR3.!
        RS      WR3-SQLC_FOREIGNKEYS_FTROWNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_FTROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FOREIGNKEYS_FTROWNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD7_17;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FOREIGNKEYS_FTROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;
ADD7_17)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FOREIGNKEYS_FTROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;

L8_17)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE8_17;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_FTABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_17;
UPDATE8_17)
! read column data into register WR3.!
        RS      WR3-SQLC_FOREIGNKEYS_FTABREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_FTABREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FOREIGNKEYS_FTABREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD8_17;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FOREIGNKEYS_FTABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;
ADD8_17)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FOREIGNKEYS_FTABREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;

L9_17)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE9_17;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_FBLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_17;
UPDATE9_17)
! read column data into register WR3.!
        RS      WR3-SQLC_FOREIGNKEYS_FBLKREF_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_FBLKREF_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_FOREIGNKEYS_FBLKREF_Data;
! should we add the values together?!
        JEC     WR2,1,ADD9_17;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_FOREIGNKEYS_FBLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;
ADD9_17)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_FOREIGNKEYS_FBLKREF_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_17;

L10_17)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_FOREIGNKEYS_COND_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_17;

EXIT_17)
END PROGRAM;

PROGRAM SQLS_SYMBOLS_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_SYMBOLS_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_18)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_18;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,4
        ADDR    EXIT_18!
LHC CR/W0-4; JGT WR1,EXIT_18;
LHC CR/W0-0; JER WR1,EXIT_18;!        ADDR    EXIT_18!
LHC CR/W0-1; JER WR1,EXIT_18;!        ADDR    EXIT_18!
LHC CR/W0-2; JER WR1,L2_18;!        ADDR L2_18!
LHC CR/W0-3; JER WR1,L3_18;!        ADDR L3_18!
LHC CR/W0-4; JER WR1,L4_18;!        ADDR L4_18!

L2_18)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE2_18;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYMBOLS_FROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_18;
UPDATE2_18)
! read column data into register WR3.!
        RS      WR3-SQLC_SYMBOLS_FROWNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYMBOLS_FROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_SYMBOLS_FROWNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD2_18;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_SYMBOLS_FROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_18;
ADD2_18)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_SYMBOLS_FROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_18;

L3_18)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_SYMBOLS_SYMBOL_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-4;
        JLN     LOOP_18;

L4_18)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE4_18;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYMBOLS_SYMVAL_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_18;
UPDATE4_18)
! read column data into register WR3.!
        RS      WR3-SQLC_SYMBOLS_SYMVAL_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYMBOLS_SYMVAL_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_SYMBOLS_SYMVAL_Data;
! should we add the values together?!
        JEC     WR2,1,ADD4_18;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_SYMBOLS_SYMVAL_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_18;
ADD4_18)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_SYMBOLS_SYMVAL_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_18;

EXIT_18)
END PROGRAM;

PROGRAM SQLS_TOWFAULTCODES_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_TOWFAULTCODES_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_19)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_19;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,4
        ADDR    EXIT_19!
LHC CR/W0-4; JGT WR1,EXIT_19;
LHC CR/W0-0; JER WR1,EXIT_19;!        ADDR    EXIT_19!
LHC CR/W0-1; JER WR1,EXIT_19;!        ADDR    EXIT_19!
LHC CR/W0-2; JER WR1,L2_19;!        ADDR L2_19!
LHC CR/W0-3; JER WR1,L3_19;!        ADDR L3_19!
LHC CR/W0-4; JER WR1,L4_19;!        ADDR L4_19!

L2_19)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE2_19;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TOWFAULTCODES_TROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_19;
UPDATE2_19)
! read column data into register WR3.!
        RS      WR3-SQLC_TOWFAULTCODES_TROWNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TOWFAULTCODES_TROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TOWFAULTCODES_TROWNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD2_19;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TOWFAULTCODES_TROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_19;
ADD2_19)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TOWFAULTCODES_TROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_19;

L3_19)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE3_19;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TOWFAULTCODES_FAULTNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_19;
UPDATE3_19)
! read column data into register WR3.!
        RS      WR3-SQLC_TOWFAULTCODES_FAULTNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TOWFAULTCODES_FAULTNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TOWFAULTCODES_FAULTNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD3_19;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TOWFAULTCODES_FAULTNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_19;
ADD3_19)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TOWFAULTCODES_FAULTNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_19;

L4_19)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_TOWFAULTCODES_FLTTEXT_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        AWCD    WR0-16;
        JLN     LOOP_19;

EXIT_19)
END PROGRAM;

PROGRAM SQLS_SYSFAULTCODES_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_SYSFAULTCODES_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_20)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_20;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,3
        ADDR    EXIT_20!
LHC CR/W0-3; JGT WR1,EXIT_20;
LHC CR/W0-0; JER WR1,EXIT_20;!        ADDR    EXIT_20!
LHC CR/W0-1; JER WR1,EXIT_20;!        ADDR    EXIT_20!
LHC CR/W0-2; JER WR1,L2_20;!        ADDR L2_20!
LHC CR/W0-3; JER WR1,L3_20;!        ADDR L3_20!

L2_20)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE2_20;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYSFAULTCODES_FAULTNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_20;
UPDATE2_20)
! read column data into register WR3.!
        RS      WR3-SQLC_SYSFAULTCODES_FAULTNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYSFAULTCODES_FAULTNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_SYSFAULTCODES_FAULTNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD2_20;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_SYSFAULTCODES_FAULTNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_20;
ADD2_20)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_SYSFAULTCODES_FAULTNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_20;

L3_20)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_SYSFAULTCODES_FLTTEXT_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-8;
        JLN     LOOP_20;

EXIT_20)
END PROGRAM;

PROGRAM SQLS_SYSTEMFIELDS_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_SYSTEMFIELDS_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_21)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_21;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,4
        ADDR    EXIT_21!
LHC CR/W0-4; JGT WR1,EXIT_21;
LHC CR/W0-0; JER WR1,EXIT_21;!        ADDR    EXIT_21!
LHC CR/W0-1; JER WR1,EXIT_21;!        ADDR    EXIT_21!
LHC CR/W0-2; JER WR1,L2_21;!        ADDR L2_21!
LHC CR/W0-3; JER WR1,L3_21;!        ADDR L3_21!
LHC CR/W0-4; JER WR1,L4_21;!        ADDR L4_21!

L2_21)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE2_21;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYSTEMFIELDS_TROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_21;
UPDATE2_21)
! read column data into register WR3.!
        RS      WR3-SQLC_SYSTEMFIELDS_TROWNO_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYSTEMFIELDS_TROWNO_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_SYSTEMFIELDS_TROWNO_Data;
! should we add the values together?!
        JEC     WR2,1,ADD2_21;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_SYSTEMFIELDS_TROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_21;
ADD2_21)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_SYSTEMFIELDS_TROWNO_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_21;

L3_21)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE3_21;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYSTEMFIELDS_ROWGEN_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_21;
UPDATE3_21)
! read column data into register WR3.!
        RS      WR3-SQLC_SYSTEMFIELDS_ROWGEN_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYSTEMFIELDS_ROWGEN_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_SYSTEMFIELDS_ROWGEN_Data;
! should we add the values together?!
        JEC     WR2,1,ADD3_21;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_SYSTEMFIELDS_ROWGEN_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_21;
ADD3_21)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_SYSTEMFIELDS_ROWGEN_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_21;

L4_21)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE4_21;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYSTEMFIELDS_LOCK_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_21;
UPDATE4_21)
! read column data into register WR3.!
        RS      WR3-SQLC_SYSTEMFIELDS_LOCK_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_SYSTEMFIELDS_LOCK_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_SYSTEMFIELDS_LOCK_Data;
! should we add the values together?!
        JEC     WR2,1,ADD4_21;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_SYSTEMFIELDS_LOCK_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_21;
ADD4_21)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_SYSTEMFIELDS_LOCK_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_21;

EXIT_21)
END PROGRAM;

PROGRAM SQLS_TEST1_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_TEST1_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_22)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_22;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,9
        ADDR    EXIT_22!
LHC CR/W0-9; JGT WR1,EXIT_22;
LHC CR/W0-0; JER WR1,EXIT_22;!        ADDR    EXIT_22!
LHC CR/W0-1; JER WR1,EXIT_22;!        ADDR    EXIT_22!
LHC CR/W0-2; JER WR1,L2_22;!        ADDR L2_22!
LHC CR/W0-3; JER WR1,L3_22;!        ADDR L3_22!
LHC CR/W0-4; JER WR1,L4_22;!        ADDR L4_22!
LHC CR/W0-5; JER WR1,L5_22;!        ADDR L5_22!
LHC CR/W0-6; JER WR1,L6_22;!        ADDR L6_22!
LHC CR/W0-7; JER WR1,L7_22;!        ADDR L7_22!
LHC CR/W0-8; JER WR1,L8_22;!        ADDR L8_22!
LHC CR/W0-9; JER WR1,L9_22;!        ADDR L9_22!

L2_22)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_TEST1_COL1_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-8;
        JLN     LOOP_22;

L3_22)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE3_22;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TEST1_COL2_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_22;
UPDATE3_22)
! read column data into register WR3.!
        RS      WR3-SQLC_TEST1_COL2_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TEST1_COL2_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TEST1_COL2_Data;
! should we add the values together?!
        JEC     WR2,1,ADD3_22;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TEST1_COL2_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_22;
ADD3_22)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TEST1_COL2_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_22;

L4_22)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TEST1_COL3_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_TEST1_COL3_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_22;

L5_22)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_TEST1_COL4_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-8;
        JLN     LOOP_22;

L6_22)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TEST1_COL5_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_TEST1_COL5_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-4;
        JLN     LOOP_22;

L7_22)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TEST1_COL6_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_TEST1_COL6_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        AWCD    WR0-16;
        JLN     LOOP_22;

L8_22)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TEST1_COL7_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_TEST1_COL7_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_22;

L9_22)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TEST1_COL8_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
    LBNBA   WR1-SQLX_TempData;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TEST1_COL8_Data/W0-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TEST1_COL8_Data/W1-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TEST1_COL8_Data/W2-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TEST1_COL8_Data/W3-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TEST1_COL8_Data/W4-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TEST1_COL8_Data/W5-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TEST1_COL8_Data/W6-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TEST1_COL8_Data/W7-WR5;
    ACC     WR0-1;
        JLN     LOOP_22;

EXIT_22)
END PROGRAM;
!------------------------------------------------!
!       sPackKey !
!------------------------------------------------!

PROGRAM SQLS_PROGRAMS_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_PROGRAMS_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,2!
LHC CR/W0-2;
JGT SQLX_KeyNumber,EXIT_23;!        ADDR    EXIT_23!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_23;!        ADDR    L0_23!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_23;!        ADDR    EXIT_23!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_23;!        ADDR    L2_23!

L0_23)
        MFR     SQLX_DR23-SQLM_PROGRAMS_OperRow;
        JLN     EXIT_23;

L2_23)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_PROGRAMS_BLKREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_23;

EXIT_23)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_TABLES_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_TABLES_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,4!
LHC CR/W0-4;
JGT SQLX_KeyNumber,EXIT_24;!        ADDR    EXIT_24!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_24;!        ADDR    L0_24!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_24;!        ADDR    EXIT_24!
LHC CR/W0-2; JER SQLX_KeyNumber,L0_24;!        ADDR    L0_24!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_24;!        ADDR    L3_24!
LHC CR/W0-4; JER SQLX_KeyNumber,L4_24;!        ADDR    L4_24!

L0_24)
        MFR     SQLX_DR23-SQLM_TABLES_OperRow;
        JLN     EXIT_24;

L3_24)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-8;
        LBNBA   WR1-SQLC_TABLES_NAME_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_TABLES_BLKREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_24;

L4_24)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_TABLES_BLKREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_24;

EXIT_24)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_FIELDS_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_FIELDS_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,5!
LHC CR/W0-5;
JGT SQLX_KeyNumber,EXIT_25;!        ADDR    EXIT_25!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_25;!        ADDR    L0_25!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_25;!        ADDR    EXIT_25!
LHC CR/W0-2; JER SQLX_KeyNumber,L0_25;!        ADDR    L0_25!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_25;!        ADDR    L3_25!
LHC CR/W0-4; JER SQLX_KeyNumber,L4_25;!        ADDR    L4_25!
LHC CR/W0-5; JER SQLX_KeyNumber,L5_25;!        ADDR    L5_25!

L0_25)
        MFR     SQLX_DR23-SQLM_FIELDS_OperRow;
        JLN     EXIT_25;

L3_25)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-4;
        LBNBA   WR1-SQLC_FIELDS_NAME_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FIELDS_TABREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FIELDS_BLKREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_25;

L4_25)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FIELDS_TABREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FIELDS_BLKREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FIELDS_FIELDNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_25;

L5_25)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FIELDS_TROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FIELDS_TROWNO_Null;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_25;

EXIT_25)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_KEYS_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_KEYS_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,4!
LHC CR/W0-4;
JGT SQLX_KeyNumber,EXIT_26;!        ADDR    EXIT_26!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_26;!        ADDR    L0_26!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_26;!        ADDR    EXIT_26!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_26;!        ADDR    L2_26!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_26;!        ADDR    L3_26!
LHC CR/W0-4; JER SQLX_KeyNumber,L4_26;!        ADDR    L4_26!

L0_26)
        MFR     SQLX_DR23-SQLM_KEYS_OperRow;
        JLN     EXIT_26;

L2_26)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYS_TROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYS_KEYNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_26;

L3_26)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYS_BLKREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYS_TABREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYS_KEYNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_26;

L4_26)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYS_TROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_26;

EXIT_26)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_KEYFIELDS_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_KEYFIELDS_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,3!
LHC CR/W0-3;
JGT SQLX_KeyNumber,EXIT_27;!        ADDR    EXIT_27!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_27;!        ADDR    L0_27!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_27;!        ADDR    EXIT_27!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_27;!        ADDR    L2_27!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_27;!        ADDR    L3_27!

L0_27)
        MFR     SQLX_DR23-SQLM_KEYFIELDS_OperRow;
        JLN     EXIT_27;

L2_27)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYFIELDS_TROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYFIELDS_KEYNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYFIELDS_COMPNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_27;

L3_27)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYFIELDS_BLKREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYFIELDS_TABREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYFIELDS_KEYNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_KEYFIELDS_COMPNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_27;

EXIT_27)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_FOREIGNKEYS_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_FOREIGNKEYS_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,5!
LHC CR/W0-5;
JGT SQLX_KeyNumber,EXIT_28;!        ADDR    EXIT_28!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_28;!        ADDR    L0_28!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_28;!        ADDR    EXIT_28!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_28;!        ADDR    L2_28!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_28;!        ADDR    L3_28!
LHC CR/W0-4; JER SQLX_KeyNumber,L4_28;!        ADDR    L4_28!
LHC CR/W0-5; JER SQLX_KeyNumber,L5_28;!        ADDR    L5_28!

L0_28)
        MFR     SQLX_DR23-SQLM_FOREIGNKEYS_OperRow;
        JLN     EXIT_28;

L2_28)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_TROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_ORDNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_28;

L3_28)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_ORDNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_BLKREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_TABREF_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_28;

L4_28)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_TROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_28;

L5_28)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_FTROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_28;

EXIT_28)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_SYMBOLS_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_SYMBOLS_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,3!
LHC CR/W0-3;
JGT SQLX_KeyNumber,EXIT_29;!        ADDR    EXIT_29!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_29;!        ADDR    L0_29!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_29;!        ADDR    EXIT_29!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_29;!        ADDR    L2_29!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_29;!        ADDR    L3_29!

L0_29)
        MFR     SQLX_DR23-SQLM_SYMBOLS_OperRow;
        JLN     EXIT_29;

L2_29)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_SYMBOLS_FROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-4;
        LBNBA   WR1-SQLC_SYMBOLS_SYMBOL_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_29;

L3_29)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_SYMBOLS_FROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_SYMBOLS_SYMVAL_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_29;

EXIT_29)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_TOWFAULTCODES_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_TOWFAULTCODES_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,2!
LHC CR/W0-2;
JGT SQLX_KeyNumber,EXIT_30;!        ADDR    EXIT_30!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_30;!        ADDR    L0_30!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_30;!        ADDR    EXIT_30!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_30;!        ADDR    L2_30!

L0_30)
        MFR     SQLX_DR23-SQLM_TOWFAULTCODES_OperRow;
        JLN     EXIT_30;

L2_30)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_TOWFAULTCODES_TROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_TOWFAULTCODES_FAULTNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_30;

EXIT_30)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_SYSFAULTCODES_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_SYSFAULTCODES_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,2!
LHC CR/W0-2;
JGT SQLX_KeyNumber,EXIT_31;!        ADDR    EXIT_31!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_31;!        ADDR    L0_31!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_31;!        ADDR    EXIT_31!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_31;!        ADDR    L2_31!

L0_31)
        MFR     SQLX_DR23-SQLM_SYSFAULTCODES_OperRow;
        JLN     EXIT_31;

L2_31)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_SYSFAULTCODES_FAULTNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_31;

EXIT_31)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_SYSTEMFIELDS_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_SYSTEMFIELDS_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,3!
LHC CR/W0-3;
JGT SQLX_KeyNumber,EXIT_32;!        ADDR    EXIT_32!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_32;!        ADDR    L0_32!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_32;!        ADDR    EXIT_32!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_32;!        ADDR    L2_32!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_32;!        ADDR    L3_32!

L0_32)
        MFR     SQLX_DR23-SQLM_SYSTEMFIELDS_OperRow;
        JLN     EXIT_32;

L2_32)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_SYSTEMFIELDS_TROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_32;

L3_32)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_SYSTEMFIELDS_TROWNO_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_32;

EXIT_32)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_TEST1_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_TEST1_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,3!
LHC CR/W0-3;
JGT SQLX_KeyNumber,EXIT_33;!        ADDR    EXIT_33!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_33;!        ADDR    L0_33!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_33;!        ADDR    EXIT_33!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_33;!        ADDR    L2_33!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_33;!        ADDR    L3_33!

L0_33)
        MFR     SQLX_DR23-SQLM_TEST1_OperRow;
        JLN     EXIT_33;

L2_33)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-8;
        LBNBA   WR1-SQLC_TEST1_COL1_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_TEST1_COL2_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_33;

L3_33)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-4;
        LBNBA   WR1-SQLC_TEST1_COL5_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_TEST1_COL5_Null;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_33;

EXIT_33)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

!------------------------------------------------!
!       sUnPackKey !
!------------------------------------------------!

PROGRAM SQLS_PROGRAMS_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_PROGRAMS_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,2!
LHC CR/W0-2;
JGT SQLX_KeyNumber,EXIT_34;!        ADDR    EXIT_34!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_34;!        ADDR    L0_34!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_34;!        ADDR    L1_34!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_34;!        ADDR    L2_34!

L0_34)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_PROGRAMS_OperRow-SQLX_DR23;
        JLN     EXIT_34;

L1_34)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_PROGRAMS_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_34;

L2_34)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_PROGRAMS_BLKREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_34;

EXIT_34)
END PROGRAM;

PROGRAM SQLS_TABLES_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_TABLES_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,4!
LHC CR/W0-4;
JGT SQLX_KeyNumber,EXIT_35;!        ADDR    EXIT_35!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_35;!        ADDR    L0_35!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_35;!        ADDR    L1_35!
LHC CR/W0-2; JER SQLX_KeyNumber,L0_35;!        ADDR    L0_35!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_35;!        ADDR    L3_35!
LHC CR/W0-4; JER SQLX_KeyNumber,L4_35;!        ADDR    L4_35!

L0_35)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_TABLES_OperRow-SQLX_DR23;
        JLN     EXIT_35;

L1_35)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_TABLES_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_35;

L3_35)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-8;
        LBNBA   WR1-SQLC_TABLES_NAME_Data;
        LCC     WR3-8;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_TABLES_BLKREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_35;

L4_35)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_TABLES_BLKREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_35;

EXIT_35)
END PROGRAM;

PROGRAM SQLS_FIELDS_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_FIELDS_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,5!
LHC CR/W0-5;
JGT SQLX_KeyNumber,EXIT_36;!        ADDR    EXIT_36!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_36;!        ADDR    L0_36!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_36;!        ADDR    L1_36!
LHC CR/W0-2; JER SQLX_KeyNumber,L0_36;!        ADDR    L0_36!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_36;!        ADDR    L3_36!
LHC CR/W0-4; JER SQLX_KeyNumber,L4_36;!        ADDR    L4_36!
LHC CR/W0-5; JER SQLX_KeyNumber,L5_36;!        ADDR    L5_36!

L0_36)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_FIELDS_OperRow-SQLX_DR23;
        JLN     EXIT_36;

L1_36)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_FIELDS_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_36;

L3_36)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-4;
        LBNBA   WR1-SQLC_FIELDS_NAME_Data;
        LCC     WR3-4;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FIELDS_TABREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FIELDS_BLKREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_36;

L4_36)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FIELDS_TABREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FIELDS_BLKREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FIELDS_FIELDNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_36;

L5_36)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FIELDS_TROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FIELDS_TROWNO_Null;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_36;

EXIT_36)
END PROGRAM;

PROGRAM SQLS_KEYS_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_KEYS_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,4!
LHC CR/W0-4;
JGT SQLX_KeyNumber,EXIT_37;!        ADDR    EXIT_37!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_37;!        ADDR    L0_37!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_37;!        ADDR    L1_37!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_37;!        ADDR    L2_37!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_37;!        ADDR    L3_37!
LHC CR/W0-4; JER SQLX_KeyNumber,L4_37;!        ADDR    L4_37!

L0_37)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_KEYS_OperRow-SQLX_DR23;
        JLN     EXIT_37;

L1_37)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_KEYS_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_37;

L2_37)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYS_TROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYS_KEYNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_37;

L3_37)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYS_BLKREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYS_TABREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYS_KEYNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_37;

L4_37)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYS_TROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_37;

EXIT_37)
END PROGRAM;

PROGRAM SQLS_KEYFIELDS_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_KEYFIELDS_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,3!
LHC CR/W0-3;
JGT SQLX_KeyNumber,EXIT_38;!        ADDR    EXIT_38!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_38;!        ADDR    L0_38!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_38;!        ADDR    L1_38!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_38;!        ADDR    L2_38!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_38;!        ADDR    L3_38!

L0_38)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_KEYFIELDS_OperRow-SQLX_DR23;
        JLN     EXIT_38;

L1_38)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_KEYFIELDS_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_38;

L2_38)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYFIELDS_TROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYFIELDS_KEYNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYFIELDS_COMPNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_38;

L3_38)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYFIELDS_BLKREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYFIELDS_TABREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYFIELDS_KEYNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_KEYFIELDS_COMPNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_38;

EXIT_38)
END PROGRAM;

PROGRAM SQLS_FOREIGNKEYS_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_FOREIGNKEYS_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,5!
LHC CR/W0-5;
JGT SQLX_KeyNumber,EXIT_39;!        ADDR    EXIT_39!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_39;!        ADDR    L0_39!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_39;!        ADDR    L1_39!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_39;!        ADDR    L2_39!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_39;!        ADDR    L3_39!
LHC CR/W0-4; JER SQLX_KeyNumber,L4_39;!        ADDR    L4_39!
LHC CR/W0-5; JER SQLX_KeyNumber,L5_39;!        ADDR    L5_39!

L0_39)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_FOREIGNKEYS_OperRow-SQLX_DR23;
        JLN     EXIT_39;

L1_39)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_FOREIGNKEYS_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_39;

L2_39)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_TROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_ORDNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_39;

L3_39)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_ORDNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_BLKREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_TABREF_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_39;

L4_39)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_TROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_39;

L5_39)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_FOREIGNKEYS_FTROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_39;

EXIT_39)
END PROGRAM;

PROGRAM SQLS_SYMBOLS_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_SYMBOLS_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,3!
LHC CR/W0-3;
JGT SQLX_KeyNumber,EXIT_40;!        ADDR    EXIT_40!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_40;!        ADDR    L0_40!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_40;!        ADDR    L1_40!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_40;!        ADDR    L2_40!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_40;!        ADDR    L3_40!

L0_40)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_SYMBOLS_OperRow-SQLX_DR23;
        JLN     EXIT_40;

L1_40)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_SYMBOLS_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_40;

L2_40)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_SYMBOLS_FROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-4;
        LBNBA   WR1-SQLC_SYMBOLS_SYMBOL_Data;
        LCC     WR3-4;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_40;

L3_40)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_SYMBOLS_FROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_SYMBOLS_SYMVAL_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_40;

EXIT_40)
END PROGRAM;

PROGRAM SQLS_TOWFAULTCODES_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_TOWFAULTCODES_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,2!
LHC CR/W0-2;
JGT SQLX_KeyNumber,EXIT_41;!        ADDR    EXIT_41!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_41;!        ADDR    L0_41!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_41;!        ADDR    L1_41!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_41;!        ADDR    L2_41!

L0_41)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_TOWFAULTCODES_OperRow-SQLX_DR23;
        JLN     EXIT_41;

L1_41)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_TOWFAULTCODES_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_41;

L2_41)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_TOWFAULTCODES_TROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_TOWFAULTCODES_FAULTNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_41;

EXIT_41)
END PROGRAM;

PROGRAM SQLS_SYSFAULTCODES_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_SYSFAULTCODES_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,2!
LHC CR/W0-2;
JGT SQLX_KeyNumber,EXIT_42;!        ADDR    EXIT_42!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_42;!        ADDR    L0_42!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_42;!        ADDR    L1_42!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_42;!        ADDR    L2_42!

L0_42)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_SYSFAULTCODES_OperRow-SQLX_DR23;
        JLN     EXIT_42;

L1_42)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_SYSFAULTCODES_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_42;

L2_42)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_SYSFAULTCODES_FAULTNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_42;

EXIT_42)
END PROGRAM;

PROGRAM SQLS_SYSTEMFIELDS_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_SYSTEMFIELDS_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,3!
LHC CR/W0-3;
JGT SQLX_KeyNumber,EXIT_43;!        ADDR    EXIT_43!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_43;!        ADDR    L0_43!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_43;!        ADDR    L1_43!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_43;!        ADDR    L2_43!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_43;!        ADDR    L3_43!

L0_43)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_SYSTEMFIELDS_OperRow-SQLX_DR23;
        JLN     EXIT_43;

L1_43)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_SYSTEMFIELDS_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_43;

L2_43)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_SYSTEMFIELDS_TROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_43;

L3_43)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-1;
        LBNBA   WR1-SQLC_SYSTEMFIELDS_TROWNO_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_43;

EXIT_43)
END PROGRAM;

PROGRAM SQLS_TEST1_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_TEST1_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,3!
LHC CR/W0-3;
JGT SQLX_KeyNumber,EXIT_44;!        ADDR    EXIT_44!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_44;!        ADDR    L0_44!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_44;!        ADDR    L1_44!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_44;!        ADDR    L2_44!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_44;!        ADDR    L3_44!

L0_44)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_TEST1_OperRow-SQLX_DR23;
        JLN     EXIT_44;

L1_44)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_TEST1_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_44;

L2_44)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-8;
        LBNBA   WR1-SQLC_TEST1_COL1_Data;
        LCC     WR3-8;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_TEST1_COL2_Data;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_44;

L3_44)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-4;
        LBNBA   WR1-SQLC_TEST1_COL5_Data;
        LCC     WR3-4;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_TEST1_COL5_Null;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_44;

EXIT_44)
END PROGRAM;
!------------------------------------------------!
!       sKeyTestN !
!------------------------------------------------!

PROGRAM SQLS_PROGRAMS_KeyTest2; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_45;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_PROGRAMS_OperRow;
        RS      WR1-SQLC_PROGRAMS_BLKREF_Data;
        MFR     PR0-SQLM_PROGRAMS_WorkRow;
        RS      CR-SQLC_PROGRAMS_BLKREF_Data;
        JLT     WR1,LESS_45;
        JGT     WR1,GREATER_45;

EQUAL_45)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_45;

LESS_45)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_45;

GREATER_45)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_45)
END PROGRAM;

PROGRAM SQLS_TABLES_KeyTest3; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_46;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which string variable is less using the new assembler
  instruction CS. !
        MFR     WR1-SQLM_TABLES_OperRow;
        MFR     WR2-SQLM_TABLES_WorkRow;
        CS      SQLC_TABLES_NAME_Data,WR1,
                SQLC_TABLES_NAME_Data,WR2;
        MFR     SQLX_KeyTest-CR;
        JUC     CR,1,EXIT_46;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_46;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_TABLES_OperRow;
        RS      WR1-SQLC_TABLES_BLKREF_Data;
        MFR     PR0-SQLM_TABLES_WorkRow;
        RS      CR-SQLC_TABLES_BLKREF_Data;
        JLT     WR1,LESS_46;
        JGT     WR1,GREATER_46;

EQUAL_46)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_46;

LESS_46)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_46;

GREATER_46)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_46)
END PROGRAM;

PROGRAM SQLS_TABLES_KeyTest4; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_47;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_TABLES_OperRow;
        RS      WR1-SQLC_TABLES_BLKREF_Data;
        MFR     PR0-SQLM_TABLES_WorkRow;
        RS      CR-SQLC_TABLES_BLKREF_Data;
        JLT     WR1,LESS_47;
        JGT     WR1,GREATER_47;

EQUAL_47)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_47;

LESS_47)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_47;

GREATER_47)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_47)
END PROGRAM;

PROGRAM SQLS_FIELDS_KeyTest3; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_48;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which string variable is less using the new assembler
  instruction CS. !
        MFR     WR1-SQLM_FIELDS_OperRow;
        MFR     WR2-SQLM_FIELDS_WorkRow;
        CS      SQLC_FIELDS_NAME_Data,WR1,
                SQLC_FIELDS_NAME_Data,WR2;
        MFR     SQLX_KeyTest-CR;
        JUC     CR,1,EXIT_48;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_48;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FIELDS_OperRow;
        RS      WR1-SQLC_FIELDS_TABREF_Data;
        MFR     PR0-SQLM_FIELDS_WorkRow;
        RS      CR-SQLC_FIELDS_TABREF_Data;
        JLT     WR1,LESS_48;
        JGT     WR1,GREATER_48;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_48;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FIELDS_OperRow;
        RS      WR1-SQLC_FIELDS_BLKREF_Data;
        MFR     PR0-SQLM_FIELDS_WorkRow;
        RS      CR-SQLC_FIELDS_BLKREF_Data;
        JLT     WR1,LESS_48;
        JGT     WR1,GREATER_48;

EQUAL_48)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_48;

LESS_48)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_48;

GREATER_48)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_48)
END PROGRAM;

PROGRAM SQLS_FIELDS_KeyTest4; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_49;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FIELDS_OperRow;
        RS      WR1-SQLC_FIELDS_TABREF_Data;
        MFR     PR0-SQLM_FIELDS_WorkRow;
        RS      CR-SQLC_FIELDS_TABREF_Data;
        JLT     WR1,LESS_49;
        JGT     WR1,GREATER_49;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_49;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FIELDS_OperRow;
        RS      WR1-SQLC_FIELDS_BLKREF_Data;
        MFR     PR0-SQLM_FIELDS_WorkRow;
        RS      CR-SQLC_FIELDS_BLKREF_Data;
        JLT     WR1,LESS_49;
        JGT     WR1,GREATER_49;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_49;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FIELDS_OperRow;
        RS      WR1-SQLC_FIELDS_FIELDNO_Data;
        MFR     PR0-SQLM_FIELDS_WorkRow;
        RS      CR-SQLC_FIELDS_FIELDNO_Data;
        JLT     WR1,LESS_49;
        JGT     WR1,GREATER_49;

EQUAL_49)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_49;

LESS_49)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_49;

GREATER_49)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_49)
END PROGRAM;

PROGRAM SQLS_FIELDS_KeyTest5; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_50;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! If the component have a null indicator check the values. A column
  which is null (1) is always lower than a row which is not null (0). !
        MFR     PR0-SQLM_FIELDS_OperRow;
        RS      WR1-SQLC_FIELDS_TROWNO_Null;
        MFR     PR0-SQLM_FIELDS_WorkRow;
        RS      CR-SQLC_FIELDS_TROWNO_Null;
        JLT     WR1,GREATER_50;
        JGT     WR1,LESS_50;
        JEC     WR1,1,L27_50;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FIELDS_OperRow;
        RS      WR1-SQLC_FIELDS_TROWNO_Data;
        MFR     PR0-SQLM_FIELDS_WorkRow;
        RS      CR-SQLC_FIELDS_TROWNO_Data;
        JLT     WR1,LESS_50;
        JGT     WR1,GREATER_50;
L27_50)

EQUAL_50)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_50;

LESS_50)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_50;

GREATER_50)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_50)
END PROGRAM;

PROGRAM SQLS_KEYS_KeyTest2; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_51;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYS_OperRow;
        RS      WR1-SQLC_KEYS_TROWNO_Data;
        MFR     PR0-SQLM_KEYS_WorkRow;
        RS      CR-SQLC_KEYS_TROWNO_Data;
        JLT     WR1,LESS_51;
        JGT     WR1,GREATER_51;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_51;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYS_OperRow;
        RS      WR1-SQLC_KEYS_KEYNO_Data;
        MFR     PR0-SQLM_KEYS_WorkRow;
        RS      CR-SQLC_KEYS_KEYNO_Data;
        JLT     WR1,LESS_51;
        JGT     WR1,GREATER_51;

EQUAL_51)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_51;

LESS_51)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_51;

GREATER_51)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_51)
END PROGRAM;

PROGRAM SQLS_KEYS_KeyTest3; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_52;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYS_OperRow;
        RS      WR1-SQLC_KEYS_BLKREF_Data;
        MFR     PR0-SQLM_KEYS_WorkRow;
        RS      CR-SQLC_KEYS_BLKREF_Data;
        JLT     WR1,LESS_52;
        JGT     WR1,GREATER_52;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_52;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYS_OperRow;
        RS      WR1-SQLC_KEYS_TABREF_Data;
        MFR     PR0-SQLM_KEYS_WorkRow;
        RS      CR-SQLC_KEYS_TABREF_Data;
        JLT     WR1,LESS_52;
        JGT     WR1,GREATER_52;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_52;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYS_OperRow;
        RS      WR1-SQLC_KEYS_KEYNO_Data;
        MFR     PR0-SQLM_KEYS_WorkRow;
        RS      CR-SQLC_KEYS_KEYNO_Data;
        JLT     WR1,LESS_52;
        JGT     WR1,GREATER_52;

EQUAL_52)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_52;

LESS_52)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_52;

GREATER_52)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_52)
END PROGRAM;

PROGRAM SQLS_KEYS_KeyTest4; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_53;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYS_OperRow;
        RS      WR1-SQLC_KEYS_TROWNO_Data;
        MFR     PR0-SQLM_KEYS_WorkRow;
        RS      CR-SQLC_KEYS_TROWNO_Data;
        JLT     WR1,LESS_53;
        JGT     WR1,GREATER_53;

EQUAL_53)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_53;

LESS_53)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_53;

GREATER_53)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_53)
END PROGRAM;

PROGRAM SQLS_KEYFIELDS_KeyTest2; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_54;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYFIELDS_OperRow;
        RS      WR1-SQLC_KEYFIELDS_TROWNO_Data;
        MFR     PR0-SQLM_KEYFIELDS_WorkRow;
        RS      CR-SQLC_KEYFIELDS_TROWNO_Data;
        JLT     WR1,LESS_54;
        JGT     WR1,GREATER_54;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_54;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYFIELDS_OperRow;
        RS      WR1-SQLC_KEYFIELDS_KEYNO_Data;
        MFR     PR0-SQLM_KEYFIELDS_WorkRow;
        RS      CR-SQLC_KEYFIELDS_KEYNO_Data;
        JLT     WR1,LESS_54;
        JGT     WR1,GREATER_54;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_54;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYFIELDS_OperRow;
        RS      WR1-SQLC_KEYFIELDS_COMPNO_Data;
        MFR     PR0-SQLM_KEYFIELDS_WorkRow;
        RS      CR-SQLC_KEYFIELDS_COMPNO_Data;
        JLT     WR1,LESS_54;
        JGT     WR1,GREATER_54;

EQUAL_54)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_54;

LESS_54)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_54;

GREATER_54)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_54)
END PROGRAM;

PROGRAM SQLS_KEYFIELDS_KeyTest3; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_55;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYFIELDS_OperRow;
        RS      WR1-SQLC_KEYFIELDS_BLKREF_Data;
        MFR     PR0-SQLM_KEYFIELDS_WorkRow;
        RS      CR-SQLC_KEYFIELDS_BLKREF_Data;
        JLT     WR1,LESS_55;
        JGT     WR1,GREATER_55;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_55;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYFIELDS_OperRow;
        RS      WR1-SQLC_KEYFIELDS_TABREF_Data;
        MFR     PR0-SQLM_KEYFIELDS_WorkRow;
        RS      CR-SQLC_KEYFIELDS_TABREF_Data;
        JLT     WR1,LESS_55;
        JGT     WR1,GREATER_55;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_55;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYFIELDS_OperRow;
        RS      WR1-SQLC_KEYFIELDS_KEYNO_Data;
        MFR     PR0-SQLM_KEYFIELDS_WorkRow;
        RS      CR-SQLC_KEYFIELDS_KEYNO_Data;
        JLT     WR1,LESS_55;
        JGT     WR1,GREATER_55;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_55;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_KEYFIELDS_OperRow;
        RS      WR1-SQLC_KEYFIELDS_COMPNO_Data;
        MFR     PR0-SQLM_KEYFIELDS_WorkRow;
        RS      CR-SQLC_KEYFIELDS_COMPNO_Data;
        JLT     WR1,LESS_55;
        JGT     WR1,GREATER_55;

EQUAL_55)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_55;

LESS_55)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_55;

GREATER_55)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_55)
END PROGRAM;

PROGRAM SQLS_FOREIGNKEYS_KeyTest2; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_56;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FOREIGNKEYS_OperRow;
        RS      WR1-SQLC_FOREIGNKEYS_TROWNO_Data;
        MFR     PR0-SQLM_FOREIGNKEYS_WorkRow;
        RS      CR-SQLC_FOREIGNKEYS_TROWNO_Data;
        JLT     WR1,LESS_56;
        JGT     WR1,GREATER_56;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_56;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FOREIGNKEYS_OperRow;
        RS      WR1-SQLC_FOREIGNKEYS_ORDNO_Data;
        MFR     PR0-SQLM_FOREIGNKEYS_WorkRow;
        RS      CR-SQLC_FOREIGNKEYS_ORDNO_Data;
        JLT     WR1,LESS_56;
        JGT     WR1,GREATER_56;

EQUAL_56)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_56;

LESS_56)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_56;

GREATER_56)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_56)
END PROGRAM;

PROGRAM SQLS_FOREIGNKEYS_KeyTest3; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_57;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FOREIGNKEYS_OperRow;
        RS      WR1-SQLC_FOREIGNKEYS_ORDNO_Data;
        MFR     PR0-SQLM_FOREIGNKEYS_WorkRow;
        RS      CR-SQLC_FOREIGNKEYS_ORDNO_Data;
        JLT     WR1,LESS_57;
        JGT     WR1,GREATER_57;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_57;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FOREIGNKEYS_OperRow;
        RS      WR1-SQLC_FOREIGNKEYS_BLKREF_Data;
        MFR     PR0-SQLM_FOREIGNKEYS_WorkRow;
        RS      CR-SQLC_FOREIGNKEYS_BLKREF_Data;
        JLT     WR1,LESS_57;
        JGT     WR1,GREATER_57;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_57;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FOREIGNKEYS_OperRow;
        RS      WR1-SQLC_FOREIGNKEYS_TABREF_Data;
        MFR     PR0-SQLM_FOREIGNKEYS_WorkRow;
        RS      CR-SQLC_FOREIGNKEYS_TABREF_Data;
        JLT     WR1,LESS_57;
        JGT     WR1,GREATER_57;

EQUAL_57)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_57;

LESS_57)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_57;

GREATER_57)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_57)
END PROGRAM;

PROGRAM SQLS_FOREIGNKEYS_KeyTest4; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_58;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FOREIGNKEYS_OperRow;
        RS      WR1-SQLC_FOREIGNKEYS_TROWNO_Data;
        MFR     PR0-SQLM_FOREIGNKEYS_WorkRow;
        RS      CR-SQLC_FOREIGNKEYS_TROWNO_Data;
        JLT     WR1,LESS_58;
        JGT     WR1,GREATER_58;

EQUAL_58)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_58;

LESS_58)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_58;

GREATER_58)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_58)
END PROGRAM;

PROGRAM SQLS_FOREIGNKEYS_KeyTest5; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_59;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_FOREIGNKEYS_OperRow;
        RS      WR1-SQLC_FOREIGNKEYS_FTROWNO_Data;
        MFR     PR0-SQLM_FOREIGNKEYS_WorkRow;
        RS      CR-SQLC_FOREIGNKEYS_FTROWNO_Data;
        JLT     WR1,LESS_59;
        JGT     WR1,GREATER_59;

EQUAL_59)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_59;

LESS_59)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_59;

GREATER_59)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_59)
END PROGRAM;

PROGRAM SQLS_SYMBOLS_KeyTest2; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_60;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_SYMBOLS_OperRow;
        RS      WR1-SQLC_SYMBOLS_FROWNO_Data;
        MFR     PR0-SQLM_SYMBOLS_WorkRow;
        RS      CR-SQLC_SYMBOLS_FROWNO_Data;
        JLT     WR1,LESS_60;
        JGT     WR1,GREATER_60;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_60;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which string variable is less using the new assembler
  instruction CS. !
        MFR     WR1-SQLM_SYMBOLS_OperRow;
        MFR     WR2-SQLM_SYMBOLS_WorkRow;
        CS      SQLC_SYMBOLS_SYMBOL_Data,WR1,
                SQLC_SYMBOLS_SYMBOL_Data,WR2;
        MFR     SQLX_KeyTest-CR;
        JUC     CR,1,EXIT_60;

EQUAL_60)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_60;

LESS_60)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_60;

GREATER_60)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_60)
END PROGRAM;

PROGRAM SQLS_SYMBOLS_KeyTest3; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_61;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_SYMBOLS_OperRow;
        RS      WR1-SQLC_SYMBOLS_FROWNO_Data;
        MFR     PR0-SQLM_SYMBOLS_WorkRow;
        RS      CR-SQLC_SYMBOLS_FROWNO_Data;
        JLT     WR1,LESS_61;
        JGT     WR1,GREATER_61;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_61;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_SYMBOLS_OperRow;
        RS      WR1-SQLC_SYMBOLS_SYMVAL_Data;
        MFR     PR0-SQLM_SYMBOLS_WorkRow;
        RS      CR-SQLC_SYMBOLS_SYMVAL_Data;
        JLT     WR1,LESS_61;
        JGT     WR1,GREATER_61;

EQUAL_61)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_61;

LESS_61)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_61;

GREATER_61)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_61)
END PROGRAM;

PROGRAM SQLS_TOWFAULTCODES_KeyTest2; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_62;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_TOWFAULTCODES_OperRow;
        RS      WR1-SQLC_TOWFAULTCODES_TROWNO_Data;
        MFR     PR0-SQLM_TOWFAULTCODES_WorkRow;
        RS      CR-SQLC_TOWFAULTCODES_TROWNO_Data;
        JLT     WR1,LESS_62;
        JGT     WR1,GREATER_62;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_62;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_TOWFAULTCODES_OperRow;
        RS      WR1-SQLC_TOWFAULTCODES_FAULTNO_Data;
        MFR     PR0-SQLM_TOWFAULTCODES_WorkRow;
        RS      CR-SQLC_TOWFAULTCODES_FAULTNO_Data;
        JLT     WR1,LESS_62;
        JGT     WR1,GREATER_62;

EQUAL_62)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_62;

LESS_62)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_62;

GREATER_62)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_62)
END PROGRAM;

PROGRAM SQLS_SYSFAULTCODES_KeyTest2; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_63;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_SYSFAULTCODES_OperRow;
        RS      WR1-SQLC_SYSFAULTCODES_FAULTNO_Data;
        MFR     PR0-SQLM_SYSFAULTCODES_WorkRow;
        RS      CR-SQLC_SYSFAULTCODES_FAULTNO_Data;
        JLT     WR1,LESS_63;
        JGT     WR1,GREATER_63;

EQUAL_63)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_63;

LESS_63)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_63;

GREATER_63)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_63)
END PROGRAM;

PROGRAM SQLS_SYSTEMFIELDS_KeyTest2; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_64;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_SYSTEMFIELDS_OperRow;
        RS      WR1-SQLC_SYSTEMFIELDS_TROWNO_Data;
        MFR     PR0-SQLM_SYSTEMFIELDS_WorkRow;
        RS      CR-SQLC_SYSTEMFIELDS_TROWNO_Data;
        JLT     WR1,LESS_64;
        JGT     WR1,GREATER_64;

EQUAL_64)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_64;

LESS_64)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_64;

GREATER_64)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_64)
END PROGRAM;

PROGRAM SQLS_SYSTEMFIELDS_KeyTest3; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_65;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_SYSTEMFIELDS_OperRow;
        RS      WR1-SQLC_SYSTEMFIELDS_TROWNO_Data;
        MFR     PR0-SQLM_SYSTEMFIELDS_WorkRow;
        RS      CR-SQLC_SYSTEMFIELDS_TROWNO_Data;
        JLT     WR1,LESS_65;
        JGT     WR1,GREATER_65;

EQUAL_65)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_65;

LESS_65)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_65;

GREATER_65)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_65)
END PROGRAM;

PROGRAM SQLS_TEST1_KeyTest2; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_66;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which string variable is less using the new assembler
  instruction CS. !
        MFR     WR1-SQLM_TEST1_OperRow;
        MFR     WR2-SQLM_TEST1_WorkRow;
        CS      SQLC_TEST1_COL1_Data,WR1,
                SQLC_TEST1_COL1_Data,WR2;
        MFR     SQLX_KeyTest-CR;
        JUC     CR,1,EXIT_66;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_66;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which field variabel value is less. !
        MFR     PR0-SQLM_TEST1_OperRow;
        RS      WR1-SQLC_TEST1_COL2_Data;
        MFR     PR0-SQLM_TEST1_WorkRow;
        RS      CR-SQLC_TEST1_COL2_Data;
        JLT     WR1,LESS_66;
        JGT     WR1,GREATER_66;

EQUAL_66)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_66;

LESS_66)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_66;

GREATER_66)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_66)
END PROGRAM;

PROGRAM SQLS_TEST1_KeyTest3; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_67;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! If the component have a null indicator check the values. A column
  which is null (1) is always lower than a row which is not null (0). !
        MFR     PR0-SQLM_TEST1_OperRow;
        RS      WR1-SQLC_TEST1_COL5_Null;
        MFR     PR0-SQLM_TEST1_WorkRow;
        RS      CR-SQLC_TEST1_COL5_Null;
        JLT     WR1,GREATER_67;
        JGT     WR1,LESS_67;
        JEC     WR1,1,L6_67;
! Check which string variable is less using the new assembler
  instruction CS. !
        MFR     WR1-SQLM_TEST1_OperRow;
        MFR     WR2-SQLM_TEST1_WorkRow;
        CS      SQLC_TEST1_COL5_Data,WR1,
                SQLC_TEST1_COL5_Data,WR2;
        MFR     SQLX_KeyTest-CR;
        JUC     CR,1,EXIT_67;
L6_67)

EQUAL_67)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_67;

LESS_67)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_67;

GREATER_67)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_67)
END PROGRAM;
!------------------------------------------------!
!       genSigSurv !
!------------------------------------------------!

!------------------------------------------------!
!       tuAsaCode !
!------------------------------------------------!
!------------------------------------------------!
!       comAsaCode !
!------------------------------------------------!
!------------------------------------------------!
!       sPackX !
!------------------------------------------------!

PROGRAM SQLS_Pack1; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-4;
    RSI     DR11-FLDNAME,WR0,4;
    MFR     SQLX_DR11-DR11;
    MFR     SQLX_DR12-DR12;
    MFR     SQLX_DR13-DR13;
    MFR     SQLX_DR14-DR14;
END PROGRAM;

PROGRAM SQLS_Pack2; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR9-TABNAME,WR0,8;
    MFR     SQLX_DR9-DR9;
    MFR     SQLX_DR10-DR10;
    MFR     SQLX_DR11-DR11;
    MFR     SQLX_DR12-DR12;
    MFR     SQLX_DR13-DR13;
    MFR     SQLX_DR14-DR14;
    MFR     SQLX_DR15-DR15;
    MFR     SQLX_DR16-DR16;
END PROGRAM;

PROGRAM SQLS_Pack3; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-SQLM_1,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack4; ASA210C;
    LCC     IR-0;
    LHC     WR0/W0-16;
    RSI     DR8-B,WR0,16;
    MFR     SQLX_DR8-DR8;
    MFR     SQLX_DR9-DR9;
    MFR     SQLX_DR10-DR10;
    MFR     SQLX_DR11-DR11;
    MFR     SQLX_DR12-DR12;
    MFR     SQLX_DR13-DR13;
    MFR     SQLX_DR14-DR14;
    MFR     SQLX_DR15-DR15;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack5; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR7-A,WR0,8;
    MFR     SQLX_DR7-DR7;
    MFR     SQLX_DR8-DR8;
    MFR     SQLX_DR9-DR9;
    MFR     SQLX_DR10-DR10;
    MFR     SQLX_DR11-DR11;
    MFR     SQLX_DR12-DR12;
    MFR     SQLX_DR13-DR13;
    MFR     SQLX_DR14-DR14;
END PROGRAM;
!------------------------------------------------!
!       sUnPackX !
!------------------------------------------------!
!------------------------------------------------!
!       sCmpStringX !
!------------------------------------------------!

PROGRAM SQLS_CmpString1; ASA210C;
    MFR     WR0-SQLM_TEST1_OperRow;
    CS      SQLC_TEST1_COL1_Data,WR0,(A * B) / C,WR1;
    MFR     SQLX_KeyTest-CR;
END PROGRAM;

PROGRAM SQLS_CmpString2; ASA210C;
    MFR     WR0-SQLM_TEST1_OperRow;
    CS      SQLC_TEST1_COL1_Data,WR0,2,WR1;
    MFR     SQLX_KeyTest-CR;
END PROGRAM;
!------------------------------------------------!
!       genSigSurv !
!------------------------------------------------!

!------------------------------------------------!
!       towData !
!------------------------------------------------!
DATA;
!------------------------------------------------!
!       comData !
!------------------------------------------------!
!------------------------------------------------!
! Versions used for PLEX-SQL expansion:          !
! CCL: 1.06                                      !
! PZ : 1.02                                      !
!------------------------------------------------!
! Initialize Protected Region !
    SIZE OF PROTECTION=100;
    SQLM_ProtectedAllocated=100;
    SQLM_ProtectedLast=100;
! Set size of table information area. !
    SIZE OF SQLT_TableInfo = 11;
! Initialize Table !
! Set initialize size of table. !
    SIZE OF SQLT_PROGRAMS_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 0;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 0;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 0;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 0;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 0;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 0;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 0;
! Allocate the system rows !
    SET SQLC_PROGRAMS_Allocated  = 1 FOR SQLM_PROGRAMS_GuardRow   = 0;
    SET SQLC_PROGRAMS_Allocated  = 1 FOR SQLM_PROGRAMS_NilRow     = 1;
    SET SQLC_PROGRAMS_Allocated  = 1 FOR SQLM_PROGRAMS_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_PROGRAMS_Color2     = 1 FOR SQLM_PROGRAMS_RootRow    = 2;
    SET SQLC_PROGRAMS_Left2      = 0 FOR SQLM_PROGRAMS_RootRow    = 2;
    SET SQLC_PROGRAMS_Right2     = 1 FOR SQLM_PROGRAMS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_PROGRAMS_Color2     = 1 FOR SQLM_PROGRAMS_NilRow     = 1;
    SET SQLC_PROGRAMS_Left2      = 0 FOR SQLM_PROGRAMS_NilRow     = 1;
    SET SQLC_PROGRAMS_Right2     = 0 FOR SQLM_PROGRAMS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_PROGRAMS_Color2     = 0 FOR SQLM_PROGRAMS_GuardRow   = 0;
    SET SQLC_PROGRAMS_Left2       = 1 FOR SQLM_PROGRAMS_GuardRow   = 0;
    SET SQLC_PROGRAMS_Right2       = 1 FOR SQLM_PROGRAMS_GuardRow   = 0;
! Set initialize size of table. !
    SIZE OF SQLT_TABLES_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 1;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 1;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 1;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 1;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 1;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 1;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 1;
! Allocate the system rows !
    SET SQLC_TABLES_Allocated  = 1 FOR SQLM_TABLES_GuardRow   = 0;
    SET SQLC_TABLES_Allocated  = 1 FOR SQLM_TABLES_NilRow     = 1;
    SET SQLC_TABLES_Allocated  = 1 FOR SQLM_TABLES_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_TABLES_Color3     = 1 FOR SQLM_TABLES_RootRow    = 2;
    SET SQLC_TABLES_Left3      = 0 FOR SQLM_TABLES_RootRow    = 2;
    SET SQLC_TABLES_Right3     = 1 FOR SQLM_TABLES_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_TABLES_Color3     = 1 FOR SQLM_TABLES_NilRow     = 1;
    SET SQLC_TABLES_Left3      = 0 FOR SQLM_TABLES_NilRow     = 1;
    SET SQLC_TABLES_Right3     = 0 FOR SQLM_TABLES_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_TABLES_Color3     = 0 FOR SQLM_TABLES_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_TABLES_Color4     = 1 FOR SQLM_TABLES_RootRow    = 2;
    SET SQLC_TABLES_Left4      = 0 FOR SQLM_TABLES_RootRow    = 2;
    SET SQLC_TABLES_Right4     = 1 FOR SQLM_TABLES_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_TABLES_Color4     = 1 FOR SQLM_TABLES_NilRow     = 1;
    SET SQLC_TABLES_Left4      = 0 FOR SQLM_TABLES_NilRow     = 1;
    SET SQLC_TABLES_Right4     = 0 FOR SQLM_TABLES_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_TABLES_Color4     = 0 FOR SQLM_TABLES_GuardRow   = 0;
    SET SQLC_TABLES_Left3       = 1 FOR SQLM_TABLES_GuardRow   = 0;
! Set initialize size of table. !
    SIZE OF SQLT_FIELDS_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 2;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 2;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 2;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 2;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 2;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 2;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 2;
! Allocate the system rows !
    SET SQLC_FIELDS_Allocated  = 1 FOR SQLM_FIELDS_GuardRow   = 0;
    SET SQLC_FIELDS_Allocated  = 1 FOR SQLM_FIELDS_NilRow     = 1;
    SET SQLC_FIELDS_Allocated  = 1 FOR SQLM_FIELDS_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_FIELDS_Color3     = 1 FOR SQLM_FIELDS_RootRow    = 2;
    SET SQLC_FIELDS_Left3      = 0 FOR SQLM_FIELDS_RootRow    = 2;
    SET SQLC_FIELDS_Right3     = 1 FOR SQLM_FIELDS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_FIELDS_Color3     = 1 FOR SQLM_FIELDS_NilRow     = 1;
    SET SQLC_FIELDS_Left3      = 0 FOR SQLM_FIELDS_NilRow     = 1;
    SET SQLC_FIELDS_Right3     = 0 FOR SQLM_FIELDS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_FIELDS_Color3     = 0 FOR SQLM_FIELDS_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_FIELDS_Color4     = 1 FOR SQLM_FIELDS_RootRow    = 2;
    SET SQLC_FIELDS_Left4      = 0 FOR SQLM_FIELDS_RootRow    = 2;
    SET SQLC_FIELDS_Right4     = 1 FOR SQLM_FIELDS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_FIELDS_Color4     = 1 FOR SQLM_FIELDS_NilRow     = 1;
    SET SQLC_FIELDS_Left4      = 0 FOR SQLM_FIELDS_NilRow     = 1;
    SET SQLC_FIELDS_Right4     = 0 FOR SQLM_FIELDS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_FIELDS_Color4     = 0 FOR SQLM_FIELDS_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_FIELDS_Color5     = 1 FOR SQLM_FIELDS_RootRow    = 2;
    SET SQLC_FIELDS_Left5      = 0 FOR SQLM_FIELDS_RootRow    = 2;
    SET SQLC_FIELDS_Right5     = 1 FOR SQLM_FIELDS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_FIELDS_Color5     = 1 FOR SQLM_FIELDS_NilRow     = 1;
    SET SQLC_FIELDS_Left5      = 0 FOR SQLM_FIELDS_NilRow     = 1;
    SET SQLC_FIELDS_Right5     = 0 FOR SQLM_FIELDS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_FIELDS_Color5     = 0 FOR SQLM_FIELDS_GuardRow   = 0;
    SET SQLC_FIELDS_Left3       = 1 FOR SQLM_FIELDS_GuardRow   = 0;
! Set initialize size of table. !
    SIZE OF SQLT_KEYS_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 3;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 3;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 3;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 3;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 3;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 3;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 3;
! Allocate the system rows !
    SET SQLC_KEYS_Allocated  = 1 FOR SQLM_KEYS_GuardRow   = 0;
    SET SQLC_KEYS_Allocated  = 1 FOR SQLM_KEYS_NilRow     = 1;
    SET SQLC_KEYS_Allocated  = 1 FOR SQLM_KEYS_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_KEYS_Color2     = 1 FOR SQLM_KEYS_RootRow    = 2;
    SET SQLC_KEYS_Left2      = 0 FOR SQLM_KEYS_RootRow    = 2;
    SET SQLC_KEYS_Right2     = 1 FOR SQLM_KEYS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_KEYS_Color2     = 1 FOR SQLM_KEYS_NilRow     = 1;
    SET SQLC_KEYS_Left2      = 0 FOR SQLM_KEYS_NilRow     = 1;
    SET SQLC_KEYS_Right2     = 0 FOR SQLM_KEYS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_KEYS_Color2     = 0 FOR SQLM_KEYS_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_KEYS_Color3     = 1 FOR SQLM_KEYS_RootRow    = 2;
    SET SQLC_KEYS_Left3      = 0 FOR SQLM_KEYS_RootRow    = 2;
    SET SQLC_KEYS_Right3     = 1 FOR SQLM_KEYS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_KEYS_Color3     = 1 FOR SQLM_KEYS_NilRow     = 1;
    SET SQLC_KEYS_Left3      = 0 FOR SQLM_KEYS_NilRow     = 1;
    SET SQLC_KEYS_Right3     = 0 FOR SQLM_KEYS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_KEYS_Color3     = 0 FOR SQLM_KEYS_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_KEYS_Color4     = 1 FOR SQLM_KEYS_RootRow    = 2;
    SET SQLC_KEYS_Left4      = 0 FOR SQLM_KEYS_RootRow    = 2;
    SET SQLC_KEYS_Right4     = 1 FOR SQLM_KEYS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_KEYS_Color4     = 1 FOR SQLM_KEYS_NilRow     = 1;
    SET SQLC_KEYS_Left4      = 0 FOR SQLM_KEYS_NilRow     = 1;
    SET SQLC_KEYS_Right4     = 0 FOR SQLM_KEYS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_KEYS_Color4     = 0 FOR SQLM_KEYS_GuardRow   = 0;
    SET SQLC_KEYS_Left2       = 1 FOR SQLM_KEYS_GuardRow   = 0;
    SET SQLC_KEYS_Right2       = 1 FOR SQLM_KEYS_GuardRow   = 0;
! Set initialize size of table. !
    SIZE OF SQLT_KEYFIELDS_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 4;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 4;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 4;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 4;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 4;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 4;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 4;
! Allocate the system rows !
    SET SQLC_KEYFIELDS_Allocated  = 1 FOR SQLM_KEYFIELDS_GuardRow   = 0;
    SET SQLC_KEYFIELDS_Allocated  = 1 FOR SQLM_KEYFIELDS_NilRow     = 1;
    SET SQLC_KEYFIELDS_Allocated  = 1 FOR SQLM_KEYFIELDS_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_KEYFIELDS_Color2     = 1 FOR SQLM_KEYFIELDS_RootRow    = 2;
    SET SQLC_KEYFIELDS_Left2      = 0 FOR SQLM_KEYFIELDS_RootRow    = 2;
    SET SQLC_KEYFIELDS_Right2     = 1 FOR SQLM_KEYFIELDS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_KEYFIELDS_Color2     = 1 FOR SQLM_KEYFIELDS_NilRow     = 1;
    SET SQLC_KEYFIELDS_Left2      = 0 FOR SQLM_KEYFIELDS_NilRow     = 1;
    SET SQLC_KEYFIELDS_Right2     = 0 FOR SQLM_KEYFIELDS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_KEYFIELDS_Color2     = 0 FOR SQLM_KEYFIELDS_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_KEYFIELDS_Color3     = 1 FOR SQLM_KEYFIELDS_RootRow    = 2;
    SET SQLC_KEYFIELDS_Left3      = 0 FOR SQLM_KEYFIELDS_RootRow    = 2;
    SET SQLC_KEYFIELDS_Right3     = 1 FOR SQLM_KEYFIELDS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_KEYFIELDS_Color3     = 1 FOR SQLM_KEYFIELDS_NilRow     = 1;
    SET SQLC_KEYFIELDS_Left3      = 0 FOR SQLM_KEYFIELDS_NilRow     = 1;
    SET SQLC_KEYFIELDS_Right3     = 0 FOR SQLM_KEYFIELDS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_KEYFIELDS_Color3     = 0 FOR SQLM_KEYFIELDS_GuardRow   = 0;
    SET SQLC_KEYFIELDS_Left2       = 1 FOR SQLM_KEYFIELDS_GuardRow   = 0;
    SET SQLC_KEYFIELDS_Right2       = 1 FOR SQLM_KEYFIELDS_GuardRow   = 0;
! Set initialize size of table. !
    SIZE OF SQLT_FOREIGNKEYS_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 5;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 5;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 5;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 5;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 5;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 5;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 5;
! Allocate the system rows !
    SET SQLC_FOREIGNKEYS_Allocated  = 1 FOR SQLM_FOREIGNKEYS_GuardRow   = 0;
    SET SQLC_FOREIGNKEYS_Allocated  = 1 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
    SET SQLC_FOREIGNKEYS_Allocated  = 1 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_FOREIGNKEYS_Color2     = 1 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
    SET SQLC_FOREIGNKEYS_Left2      = 0 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
    SET SQLC_FOREIGNKEYS_Right2     = 1 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_FOREIGNKEYS_Color2     = 1 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
    SET SQLC_FOREIGNKEYS_Left2      = 0 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
    SET SQLC_FOREIGNKEYS_Right2     = 0 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_FOREIGNKEYS_Color2     = 0 FOR SQLM_FOREIGNKEYS_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_FOREIGNKEYS_Color3     = 1 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
    SET SQLC_FOREIGNKEYS_Left3      = 0 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
    SET SQLC_FOREIGNKEYS_Right3     = 1 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_FOREIGNKEYS_Color3     = 1 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
    SET SQLC_FOREIGNKEYS_Left3      = 0 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
    SET SQLC_FOREIGNKEYS_Right3     = 0 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_FOREIGNKEYS_Color3     = 0 FOR SQLM_FOREIGNKEYS_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_FOREIGNKEYS_Color4     = 1 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
    SET SQLC_FOREIGNKEYS_Left4      = 0 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
    SET SQLC_FOREIGNKEYS_Right4     = 1 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_FOREIGNKEYS_Color4     = 1 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
    SET SQLC_FOREIGNKEYS_Left4      = 0 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
    SET SQLC_FOREIGNKEYS_Right4     = 0 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_FOREIGNKEYS_Color4     = 0 FOR SQLM_FOREIGNKEYS_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_FOREIGNKEYS_Color5     = 1 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
    SET SQLC_FOREIGNKEYS_Left5      = 0 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
    SET SQLC_FOREIGNKEYS_Right5     = 1 FOR SQLM_FOREIGNKEYS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_FOREIGNKEYS_Color5     = 1 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
    SET SQLC_FOREIGNKEYS_Left5      = 0 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
    SET SQLC_FOREIGNKEYS_Right5     = 0 FOR SQLM_FOREIGNKEYS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_FOREIGNKEYS_Color5     = 0 FOR SQLM_FOREIGNKEYS_GuardRow   = 0;
    SET SQLC_FOREIGNKEYS_Left2       = 1 FOR SQLM_FOREIGNKEYS_GuardRow   = 0;
    SET SQLC_FOREIGNKEYS_Right2       = 1 FOR SQLM_FOREIGNKEYS_GuardRow   = 0;
! Set initialize size of table. !
    SIZE OF SQLT_SYMBOLS_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 6;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 6;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 6;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 6;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 6;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 6;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 6;
! Allocate the system rows !
    SET SQLC_SYMBOLS_Allocated  = 1 FOR SQLM_SYMBOLS_GuardRow   = 0;
    SET SQLC_SYMBOLS_Allocated  = 1 FOR SQLM_SYMBOLS_NilRow     = 1;
    SET SQLC_SYMBOLS_Allocated  = 1 FOR SQLM_SYMBOLS_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_SYMBOLS_Color2     = 1 FOR SQLM_SYMBOLS_RootRow    = 2;
    SET SQLC_SYMBOLS_Left2      = 0 FOR SQLM_SYMBOLS_RootRow    = 2;
    SET SQLC_SYMBOLS_Right2     = 1 FOR SQLM_SYMBOLS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_SYMBOLS_Color2     = 1 FOR SQLM_SYMBOLS_NilRow     = 1;
    SET SQLC_SYMBOLS_Left2      = 0 FOR SQLM_SYMBOLS_NilRow     = 1;
    SET SQLC_SYMBOLS_Right2     = 0 FOR SQLM_SYMBOLS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_SYMBOLS_Color2     = 0 FOR SQLM_SYMBOLS_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_SYMBOLS_Color3     = 1 FOR SQLM_SYMBOLS_RootRow    = 2;
    SET SQLC_SYMBOLS_Left3      = 0 FOR SQLM_SYMBOLS_RootRow    = 2;
    SET SQLC_SYMBOLS_Right3     = 1 FOR SQLM_SYMBOLS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_SYMBOLS_Color3     = 1 FOR SQLM_SYMBOLS_NilRow     = 1;
    SET SQLC_SYMBOLS_Left3      = 0 FOR SQLM_SYMBOLS_NilRow     = 1;
    SET SQLC_SYMBOLS_Right3     = 0 FOR SQLM_SYMBOLS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_SYMBOLS_Color3     = 0 FOR SQLM_SYMBOLS_GuardRow   = 0;
    SET SQLC_SYMBOLS_Left2       = 1 FOR SQLM_SYMBOLS_GuardRow   = 0;
    SET SQLC_SYMBOLS_Right2       = 1 FOR SQLM_SYMBOLS_GuardRow   = 0;
! Set initialize size of table. !
    SIZE OF SQLT_TOWFAULTCODES_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 7;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 7;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 7;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 7;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 7;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 7;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 7;
! Allocate the system rows !
    SET SQLC_TOWFAULTCODES_Allocated  = 1 FOR SQLM_TOWFAULTCODES_GuardRow   = 0;
    SET SQLC_TOWFAULTCODES_Allocated  = 1 FOR SQLM_TOWFAULTCODES_NilRow     = 1;
    SET SQLC_TOWFAULTCODES_Allocated  = 1 FOR SQLM_TOWFAULTCODES_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_TOWFAULTCODES_Color2     = 1 FOR SQLM_TOWFAULTCODES_RootRow    = 2;
    SET SQLC_TOWFAULTCODES_Left2      = 0 FOR SQLM_TOWFAULTCODES_RootRow    = 2;
    SET SQLC_TOWFAULTCODES_Right2     = 1 FOR SQLM_TOWFAULTCODES_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_TOWFAULTCODES_Color2     = 1 FOR SQLM_TOWFAULTCODES_NilRow     = 1;
    SET SQLC_TOWFAULTCODES_Left2      = 0 FOR SQLM_TOWFAULTCODES_NilRow     = 1;
    SET SQLC_TOWFAULTCODES_Right2     = 0 FOR SQLM_TOWFAULTCODES_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_TOWFAULTCODES_Color2     = 0 FOR SQLM_TOWFAULTCODES_GuardRow   = 0;
    SET SQLC_TOWFAULTCODES_Left2       = 1 FOR SQLM_TOWFAULTCODES_GuardRow   = 0;
    SET SQLC_TOWFAULTCODES_Right2       = 1 FOR SQLM_TOWFAULTCODES_GuardRow   = 0;
! Set initialize size of table. !
    SIZE OF SQLT_SYSFAULTCODES_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 8;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 8;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 8;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 8;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 8;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 8;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 8;
! Allocate the system rows !
    SET SQLC_SYSFAULTCODES_Allocated  = 1 FOR SQLM_SYSFAULTCODES_GuardRow   = 0;
    SET SQLC_SYSFAULTCODES_Allocated  = 1 FOR SQLM_SYSFAULTCODES_NilRow     = 1;
    SET SQLC_SYSFAULTCODES_Allocated  = 1 FOR SQLM_SYSFAULTCODES_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_SYSFAULTCODES_Color2     = 1 FOR SQLM_SYSFAULTCODES_RootRow    = 2;
    SET SQLC_SYSFAULTCODES_Left2      = 0 FOR SQLM_SYSFAULTCODES_RootRow    = 2;
    SET SQLC_SYSFAULTCODES_Right2     = 1 FOR SQLM_SYSFAULTCODES_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_SYSFAULTCODES_Color2     = 1 FOR SQLM_SYSFAULTCODES_NilRow     = 1;
    SET SQLC_SYSFAULTCODES_Left2      = 0 FOR SQLM_SYSFAULTCODES_NilRow     = 1;
    SET SQLC_SYSFAULTCODES_Right2     = 0 FOR SQLM_SYSFAULTCODES_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_SYSFAULTCODES_Color2     = 0 FOR SQLM_SYSFAULTCODES_GuardRow   = 0;
    SET SQLC_SYSFAULTCODES_Left2       = 1 FOR SQLM_SYSFAULTCODES_GuardRow   = 0;
    SET SQLC_SYSFAULTCODES_Right2       = 1 FOR SQLM_SYSFAULTCODES_GuardRow   = 0;
! Set initialize size of table. !
    SIZE OF SQLT_SYSTEMFIELDS_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 9;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 9;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 9;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 9;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 9;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 9;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 9;
! Allocate the system rows !
    SET SQLC_SYSTEMFIELDS_Allocated  = 1 FOR SQLM_SYSTEMFIELDS_GuardRow   = 0;
    SET SQLC_SYSTEMFIELDS_Allocated  = 1 FOR SQLM_SYSTEMFIELDS_NilRow     = 1;
    SET SQLC_SYSTEMFIELDS_Allocated  = 1 FOR SQLM_SYSTEMFIELDS_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_SYSTEMFIELDS_Color2     = 1 FOR SQLM_SYSTEMFIELDS_RootRow    = 2;
    SET SQLC_SYSTEMFIELDS_Left2      = 0 FOR SQLM_SYSTEMFIELDS_RootRow    = 2;
    SET SQLC_SYSTEMFIELDS_Right2     = 1 FOR SQLM_SYSTEMFIELDS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_SYSTEMFIELDS_Color2     = 1 FOR SQLM_SYSTEMFIELDS_NilRow     = 1;
    SET SQLC_SYSTEMFIELDS_Left2      = 0 FOR SQLM_SYSTEMFIELDS_NilRow     = 1;
    SET SQLC_SYSTEMFIELDS_Right2     = 0 FOR SQLM_SYSTEMFIELDS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_SYSTEMFIELDS_Color2     = 0 FOR SQLM_SYSTEMFIELDS_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_SYSTEMFIELDS_Color3     = 1 FOR SQLM_SYSTEMFIELDS_RootRow    = 2;
    SET SQLC_SYSTEMFIELDS_Left3      = 0 FOR SQLM_SYSTEMFIELDS_RootRow    = 2;
    SET SQLC_SYSTEMFIELDS_Right3     = 1 FOR SQLM_SYSTEMFIELDS_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_SYSTEMFIELDS_Color3     = 1 FOR SQLM_SYSTEMFIELDS_NilRow     = 1;
    SET SQLC_SYSTEMFIELDS_Left3      = 0 FOR SQLM_SYSTEMFIELDS_NilRow     = 1;
    SET SQLC_SYSTEMFIELDS_Right3     = 0 FOR SQLM_SYSTEMFIELDS_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_SYSTEMFIELDS_Color3     = 0 FOR SQLM_SYSTEMFIELDS_GuardRow   = 0;
    SET SQLC_SYSTEMFIELDS_Left2       = 1 FOR SQLM_SYSTEMFIELDS_GuardRow   = 0;
    SET SQLC_SYSTEMFIELDS_Right2       = 1 FOR SQLM_SYSTEMFIELDS_GuardRow   = 0;
! Set initialize size of table. !
    SIZE OF SQLT_TEST1_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 10;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 10;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 10;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 10;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 10;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 10;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 10;
! Allocate the system rows !
    SET SQLC_TEST1_Allocated  = 1 FOR SQLM_TEST1_GuardRow   = 0;
    SET SQLC_TEST1_Allocated  = 1 FOR SQLM_TEST1_NilRow     = 1;
    SET SQLC_TEST1_Allocated  = 1 FOR SQLM_TEST1_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_TEST1_Color2     = 1 FOR SQLM_TEST1_RootRow    = 2;
    SET SQLC_TEST1_Left2      = 0 FOR SQLM_TEST1_RootRow    = 2;
    SET SQLC_TEST1_Right2     = 1 FOR SQLM_TEST1_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_TEST1_Color2     = 1 FOR SQLM_TEST1_NilRow     = 1;
    SET SQLC_TEST1_Left2      = 0 FOR SQLM_TEST1_NilRow     = 1;
    SET SQLC_TEST1_Right2     = 0 FOR SQLM_TEST1_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_TEST1_Color2     = 0 FOR SQLM_TEST1_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_TEST1_Color3     = 1 FOR SQLM_TEST1_RootRow    = 2;
    SET SQLC_TEST1_Left3      = 0 FOR SQLM_TEST1_RootRow    = 2;
    SET SQLC_TEST1_Right3     = 1 FOR SQLM_TEST1_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_TEST1_Color3     = 1 FOR SQLM_TEST1_NilRow     = 1;
    SET SQLC_TEST1_Left3      = 0 FOR SQLM_TEST1_NilRow     = 1;
    SET SQLC_TEST1_Right3     = 0 FOR SQLM_TEST1_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_TEST1_Color3     = 0 FOR SQLM_TEST1_GuardRow   = 0;
    SET SQLC_TEST1_Left2       = 1 FOR SQLM_TEST1_GuardRow   = 0;
    SET SQLC_TEST1_Right2       = 1 FOR SQLM_TEST1_GuardRow   = 0;

!------------------------------------------------!
!       tuData !
!------------------------------------------------!
!------------------------------------------------!
!       comData !
!------------------------------------------------!
END DATA;

!END SQL!



END DOCUMENT;
