DOCUMENT XREFTEST;

DECLARE; 
!BEGIN SQL COMMON 0!








!END SQL!



! Test a PLEX-SQL statement direct after a plex statement !
c1 = c2;
!BEGIN SQL INCLUDE_TABLE 0!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE table2!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!


! Test a PLEX-SQL statement direct after an end comment !
! xxxxx !
!BEGIN SQL INCLUDE 0!
!******************************************************************************!

!EXEC SQL INCLUDE PROTECTION!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!



!BEGIN SQL INCLUDE_TABLE 0!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE table3 CREATE!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!


VARIABLE a 16 DS;
VARIABLE b 16 DS;
VARIABLE c 16 DS;
VARIABLE d 16 DS;

!BEGIN SQL INCLUDE_TABLE 0!
!******************************************************************************!

!EXEC SQL INCLUDE TABLE table1!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!



!BEGIN SQL DECLARE_CURSOR 4!
!******************************************************************************!

!EXEC SQL DECLARE
cursor1
CURSOR
FOR
SELECT col1 FROM table1 WHERE col4 = "abc"!

!------------------------------------------------------------------------------!



!******************************************************************************!
!END SQL!
 

VARIABLE c1 16 DS;
VARIABLE c2 16 DS;
VARIABLE NO 1 DS;


!BEGIN SQL COMMON 0!






!------------------------------------------------!
!       towDeclarations !
!------------------------------------------------!












!------------------------------------------------!
!       comDeclarations !
!------------------------------------------------!
!------------------------------------------------!
!       comDeclProtection !
!------------------------------------------------!
RECORD PROTECTION;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLM_Allocated          1   DS CLEAR;
! Return label reference !
    VARIABLE    SQLX_SQLRETURN          16  DS;
! Cursor references !
    VARIABLE    SQLM_CURSOR1_Cursor          !R! 16 DS CLEAR;
! The block reference to the table user in the current transaction. !
    VARIABLE    SQLBLOCK            16  DS;
! The table reference of a table issuing a local status code. !
    VARIABLE    SQLTABLE            16  DS;
! This variable could be set by the user in user defined code. !
    VARIABLE    SQLLOCALCODE        8  DS;
! The current operation which should be PREPARED, POSTCOMMITED or ROLLBACKED:
$ 0 = insert, 1 = update, 2 = delete !
    VARIABLE    SQLOPERATION        2  DS;
! The current operating row while user defined code are executed. !
    VARIABLE    SQLX_SQLOPERROW         16  DS;
! The current working row while user defined code are executed. !
    VARIABLE    SQLX_SQLWORKROW         16  DS CLEAR;
! The current transaction identity while user defined code are executed. !
    VARIABLE    SQLX_SQLPROTECTED       16  DS;
! The current table reference while userdefined code are executed. !
    VARIABLE    SQLX_SQLTABLEREFERENCE  16  DS;
! Set by unPackX (table user) if there is no null indicator variable for
$ a column which is null. !
    VARIABLE    SQLX_SQLCODE            16  DS;
! This variable holds the current transaction identity. !
    VARIABLE    SQLTRANSID              16  DS CLEAR;
! User defined protected variable. !

! Used to protect pointers from time gaps in table user statements. !
    VARIABLE    SQLM_P(4)               !R! 16  DS;
! Variables generated by the preprocessor. !
!------------------------------------------------!
!       comDeclTempVars !
!------------------------------------------------!
    STRING VARIABLE SQLM_1 7 DS;
    STRING VARIABLE SQLM_2 7 DS;
END RECORD;
! Pointer to protected !
    POINTER     PROTECTEDP   (PROTECTION);
! The size of the protected area. !
    VARIABLE    SQLM_ProtectedAllocated 16  DS RELOAD;
! The last allocated row in the protected area. !
    VARIABLE    SQLM_ProtectedLast      16  DS CLEAR;
! The number of allocated rows in the protected area. !
    VARIABLE    SQLM_ProtectedUsed      16  DS CLEAR;
! Used to lock the protected area for size alteration. !
    VARIABLE    SQLM_ProtectedLock       1  DS CLEAR;

!------------------------------------------------!
!       comDeclSqlCode !
!------------------------------------------------!
! This variable is used to check the result of a SQL statement. !
    VARIABLE    SQLCODE         16 DS;
    STRUCTURE   SQLCODE =
                1   VALUE       8,
                1   SUBCODE     8;
!------------------------------------------------!
!       comDeclPlexTemp !
!------------------------------------------------!
! The data base number !
    VARIABLE    SQLX_DBnumber1      16;
    VARIABLE    SQLX_DBnumber2      16;
! The reference to the current operating row. !
    VARIABLE    SQLX_OperRow        16;
! The return label when a schedule or look up was performed !
    VARIABLE    SQLX_ReturnLabel    16;
! Temporary row reference !
    VARIABLE    SQLX_TempRow        16;
! The result of a key test operation !
    VARIABLE    SQLX_KeyTest        16;
! Reference to this block. Used mainly when scheduling. !
    VARIABLE    cOwnRef      16 DS;
! The file number when the user has not defined a size alteration event !
    VARIABLE    SQLX_FileNumber     16;
! The new table size when the user has not defined a size alteration event !
    VARIABLE    SQLX_NewIndNum      16;
! The restart phase when the user has not defined restart code !
    VARIABLE    SQLX_RestartPhase   16;
! The signal key in a restart phase when no user defined code is present !
    VARIABLE    SQLX_SignalKey      16;
! The size alteration event number when no user defined code is present !
    VARIABLE    SQLX_SizeEvent      16;
! The reference of the calling block. !
    VARIABLE    SQLX_OtherBlock     16;
! A pointer to the PROTECTED area or the transaction id !
    VARIABLE    SQLX_OtherProtected 16;
! The stored reference of the calling block. !
    VARIABLE    CSQLX_OtherBlock     16 DS;
! A stored pointer to the PROTECTED area or the transaction id !
    VARIABLE    CSQLX_OtherProtected 16 DS;
! The return code !
    VARIABLE    SQLX_ReturnCode     16;
! Signal data for use in the assembler functions. !
    VARIABLE    SQLX_DR0     16;
    VARIABLE    SQLX_DR1     16;
    VARIABLE    SQLX_DR2     16;
    VARIABLE    SQLX_DR3     16;
    VARIABLE    SQLX_DR4     16;
    VARIABLE    SQLX_DR5     16;
    VARIABLE    SQLX_DR6     16;
    VARIABLE    SQLX_DR7     16;
    VARIABLE    SQLX_DR8     16;
    VARIABLE    SQLX_DR9     16;
    VARIABLE    SQLX_DR10     16;
    VARIABLE    SQLX_DR11     16;
    VARIABLE    SQLX_DR12     16;
    VARIABLE    SQLX_DR13     16;
    VARIABLE    SQLX_DR14     16;
    VARIABLE    SQLX_DR15     16;
    VARIABLE    SQLX_DR16     16;
    VARIABLE    SQLX_DR17     16;
    VARIABLE    SQLX_DR18     16;
    VARIABLE    SQLX_DR19     16;
    VARIABLE    SQLX_DR20     16;
    VARIABLE    SQLX_DR21     16;
    VARIABLE    SQLX_DR22     16;
    VARIABLE    SQLX_DR23     16;
! A remote table reference !
    VARIABLE    SQLX_TableReference 16;
! The base address of a variable !
    VARIABLE    SQLX_BaseAddress1   16;
    VARIABLE    SQLX_BaseAddress2   16;
! Column reference. !
    VARIABLE    SQLX_ColumnReference    16;
! This index variable is used to temporary store information about
$ columns to pack or unpack (see sPack, sUnPack). !
    VARIABLE    SQLX_Columns(32)    16 DS;
! Key component reference. !
    VARIABLE    SQLX_ComponentReference 16;
! Used when scheduling key insertion/deletion !
    VARIABLE    SQLX_Father              16;
    VARIABLE    SQLX_GrandFather              16;
    VARIABLE    SQLX_GrandGrandFather             16;
! The fault code sought !
    VARIABLE    SQLX_FaultCode      16;
! The key operation. !
    VARIABLE    SQLX_KeyOperation   16;
! The number of key components which is used in key comparisons !
    VARIABLE    SQLX_KeyPrefix      16;
! The number of untested key components in the key prefix !
    VARIABLE    SQLX_KeySuffix      16;
! The key number. !
    VARIABLE    SQLX_KeyNumber        16;
! The new lock of a row !
    VARIABLE    SQLX_Lock           16;
! The old (expected) lock of a row !
    VARIABLE    SQLX_OldLock        16;
! The last right turn in a btree in a search operation !
    VARIABLE    SQLX_RightTurn      16;
! This variable is used to determine when a schedule is necessary !
    VARIABLE    SQLX_Schedule       16;
! The symbol name and value !
    STRING VARIABLE SQLX_Symbol 7 DS;
    VARIABLE    SQLX_SymbolValue    16;
! Delete key variables !
    VARIABLE    SQLX_Delete              16;
    VARIABLE    SQLX_DeleteFather             16;
! Temporary data !
    VARIABLE    SQLX_TempData       16 DS;
! Reference to the current work row. !
    VARIABLE    SQLX_WorkRow        16;
! Reference to the current row !
    VARIABLE    SQLX_Current              16;
! The local error code after user defined code is executed !
    VARIABLE     SQLX_Code           16;

!------------------------------------------------!
!       towTables !
!------------------------------------------------!
RECORD SQLT_TABLE3_Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLC_TABLE3_Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    SQLC_TABLE3_Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    SQLC_TABLE3_DBnumber       32  DS CLEAR;
! The column null indicators and the columns !

    STRING VARIABLE SQLC_TABLE3_COL1_Data 15 DS RELOAD;

    VARIABLE SQLC_TABLE3_COL2_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLE3_COL3_Null 1 DS RELOAD;
    VARIABLE SQLC_TABLE3_COL3_Data 16 DS RELOAD;

    VARIABLE SQLC_TABLE3_COL4_Null 1 DS RELOAD;
    STRING VARIABLE SQLC_TABLE3_COL4_Data 15 DS RELOAD;

    VARIABLE SQLC_TABLE3_COL5_Null 1 DS RELOAD;
    STRING VARIABLE SQLC_TABLE3_COL5_Data 7 DS RELOAD;

    VARIABLE SQLC_TABLE3_COL6_Null 1 DS RELOAD;
    STRING VARIABLE SQLC_TABLE3_COL6_Data 31 DS RELOAD;

    VARIABLE SQLC_TABLE3_COL7_Null 1 DS RELOAD;
    VARIABLE SQLC_TABLE3_COL7_Data 1 DS RELOAD;

    VARIABLE SQLC_TABLE3_COL8_Null 1 DS RELOAD;
    VARIABLE SQLC_TABLE3_COL8_Data 128 DS RELOAD;


! This variable holds color information about nodes. !


    VARIABLE    SQLC_TABLE3_Color         4   DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_TABLE3_Left2         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_TABLE3_Right2        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_TABLE3_Left3         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_TABLE3_Right3        !R! 16 DS RELOAD;
! This variable holds a pointer to the left subtree. !
    VARIABLE    SQLC_TABLE3_Left4         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    SQLC_TABLE3_Right4        !R! 16 DS RELOAD;
END RECORD;

! Structure of the data base number. !
STRUCTURE   SQLC_TABLE3_DBnumber =
    1       SQLC_TABLE3_DBnumber1      16,
    1       SQLC_TABLE3_DBnumber2      16;

! Structure of the packed numstring columns. !
STRUCTURE SQLC_TABLE3_COL8_Data =
    1 LENGTH 16,
    1 W1 16,
    1 W2 16,
    1 W3 16,
    1 W4 16,
    1 W5 16,
    1 W6 16,
    1 W7 16;

! This variable indicates the current color of the node !
STRUCTURE SQLC_TABLE3_Color =
    1 SQLC_TABLE3_Color2 1
    , 1 SQLC_TABLE3_Color3 1
    , 1 SQLC_TABLE3_Color4 1
    ;

! The symbol values. !
NSYMB TABLE3COL7FALSE = 0;
NSYMB TABLE3COL7TRUE = 1;

! Pointers !
    POINTER SQLM_TABLE3_OperRow (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_WorkRow (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_GuardRow (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_NilRow (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_RootRow (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_TempRow (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_GrandGrandFather (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_GrandFather (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_Father (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_Brother (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_Nephew (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_Delete (SQLT_TABLE3_Table);
    POINTER SQLM_TABLE3_DeleteFather (SQLT_TABLE3_Table);
!------------------------------------------------!
!       towTabInfo !
!------------------------------------------------!
RECORD SQLT_TableInfo;
! The location of the first system row. !
    VARIABLE    SQLM_System    !R! 16 DS RELOAD;
! The number of rows in the table area, allocated or not. !
    VARIABLE    SQLM_TableAllocated !R! 16 DS RELOAD;
! The location of the last row which is allocated in the table area. !
    VARIABLE    SQLM_TableLast !R! 16 DS RELOAD;
! The number of allocated rows in the table area. !
    VARIABLE    SQLM_TableUsed !R! 16 DS RELOAD;
! The number of rows in the work area, allocated or not. !
    VARIABLE    SQLM_WorkAllocated  !R! 16 DS RELOAD;
! The location of the last row which is allocated in the work area. !
    VARIABLE    SQLM_WorkLast !R! 16 DS RELOAD;
! The number of allocated rows in the work area. !
    VARIABLE    SQLM_WorkUsed !R! 16 DS RELOAD;
! This variable locks the work area of a table. !
    VARIABLE    SQLM_WorkLock   1   DS CLEAR;
END RECORD;
! This variable holds the current table number. !
    POINTER     SQLM_TableReference (SQLT_TableInfo);


!------------------------------------------------!
!       tuDeclarations !
!------------------------------------------------!
!------------------------------------------------!
!       comDeclarations !
!------------------------------------------------!
!------------------------------------------------!
!       tuDeclRemTab !
!------------------------------------------------!


    VARIABLE SQLM_Remote(2) 32 DS RELOAD;
    STRUCTURE SQLM_Remote =
! This variable holds the block reference of a remote single table. !
        1 block 16,
! This variable holds the table reference of a remote single table. !
        1 table 16;
! The symbol values for all remote tables. !
NSYMB TABLE2COL7FALSE = 0;
NSYMB TABLE2COL7TRUE = 1;
NSYMB TABLE1COL7FALSE = 0;
NSYMB TABLE1COL7TRUE = 1;



!END SQL!
END DECLARE;

DATA;

! Test a PLEX-SQL statement direct after a sector end !

!BEGIN SQL COMMON 0!
!------------------------------------------------!
!       towData !
!------------------------------------------------!
!------------------------------------------------!
!       comData !
!------------------------------------------------!
!------------------------------------------------!
! Versions used for PLEX-SQL expansion:          !
! CCL: 1.06                                      !
! PZ : 1.02                                      !
!------------------------------------------------!
! Initialize Protected Region !
    SIZE OF PROTECTION=100;
    SQLM_ProtectedAllocated=100;
    SQLM_ProtectedLast=100;
! Set size of table information area. !
    SIZE OF SQLT_TableInfo = 1;
! Initialize Table !
! Set initialize size of table. !
    SIZE OF SQLT_TABLE3_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = 0;
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = 0;
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = 0;
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = 0;
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = 0;
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = 0;
    SET SQLM_System   =0 FOR SQLM_Tablereference = 0;
! Allocate the system rows !
    SET SQLC_TABLE3_Allocated  = 1 FOR SQLM_TABLE3_GuardRow   = 0;
    SET SQLC_TABLE3_Allocated  = 1 FOR SQLM_TABLE3_NilRow     = 1;
    SET SQLC_TABLE3_Allocated  = 1 FOR SQLM_TABLE3_RootRow    = 2;
! Initialize all system rows. !
! Initialize root row (mSystem+2) !
    SET SQLC_TABLE3_Color2     = 1 FOR SQLM_TABLE3_RootRow    = 2;
    SET SQLC_TABLE3_Left2      = 0 FOR SQLM_TABLE3_RootRow    = 2;
    SET SQLC_TABLE3_Right2     = 1 FOR SQLM_TABLE3_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_TABLE3_Color2     = 1 FOR SQLM_TABLE3_NilRow     = 1;
    SET SQLC_TABLE3_Left2      = 0 FOR SQLM_TABLE3_NilRow     = 1;
    SET SQLC_TABLE3_Right2     = 0 FOR SQLM_TABLE3_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_TABLE3_Color2     = 0 FOR SQLM_TABLE3_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_TABLE3_Color3     = 1 FOR SQLM_TABLE3_RootRow    = 2;
    SET SQLC_TABLE3_Left3      = 0 FOR SQLM_TABLE3_RootRow    = 2;
    SET SQLC_TABLE3_Right3     = 1 FOR SQLM_TABLE3_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_TABLE3_Color3     = 1 FOR SQLM_TABLE3_NilRow     = 1;
    SET SQLC_TABLE3_Left3      = 0 FOR SQLM_TABLE3_NilRow     = 1;
    SET SQLC_TABLE3_Right3     = 0 FOR SQLM_TABLE3_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_TABLE3_Color3     = 0 FOR SQLM_TABLE3_GuardRow   = 0;
! Initialize root row (mSystem+2) !
    SET SQLC_TABLE3_Color4     = 1 FOR SQLM_TABLE3_RootRow    = 2;
    SET SQLC_TABLE3_Left4      = 0 FOR SQLM_TABLE3_RootRow    = 2;
    SET SQLC_TABLE3_Right4     = 1 FOR SQLM_TABLE3_RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET SQLC_TABLE3_Color4     = 1 FOR SQLM_TABLE3_NilRow     = 1;
    SET SQLC_TABLE3_Left4      = 0 FOR SQLM_TABLE3_NilRow     = 1;
    SET SQLC_TABLE3_Right4     = 0 FOR SQLM_TABLE3_NilRow     = 1;
! Initialize guard row (mSystem) !
    SET SQLC_TABLE3_Color4     = 0 FOR SQLM_TABLE3_GuardRow   = 0;
    SET SQLC_TABLE3_Left2       = 1 FOR SQLM_TABLE3_GuardRow   = 0;
    SET SQLC_TABLE3_Right2       = 1 FOR SQLM_TABLE3_GuardRow   = 0;

!------------------------------------------------!
!       tuData !
!------------------------------------------------!
!------------------------------------------------!
!       comData !
!------------------------------------------------!

!END SQL!
END DATA;
!BEGIN SQL SELECT 0!
!******************************************************************************!

!EXEC SQL SELECT col1 INTO %a FROM table1 WHERE col4 = "abc"!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remSelectStat   !
!--------------------------------------!
! Set default SQLCODE and return label when returning from the row
$ lookup in table owner.!
    PROTECTEDP:SQLX_SQLCODE=0;
    PROTECTEDP:SQLX_SQLRETURN=1;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!



! Pack key and which columns to retreive in the signal. Then send the
$ signal to the table owner.!
    PROTECTEDP:SQLM_1 = "abc";
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack1;  ! pack string into signal registers !
    SQLX_DR15 = 0;
!------------------------------------------------!
!       packRequestX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 2;
    SEND towGetRow REFERENCE SQLM_Remote(1).block WITH
        cOwnRef,
        PROTECTEDP,
        SQLM_Remote(1).table,
        3,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
! Return from table owner. If the lookup was not successful abort the
  select statement!
towGetLab1)
    IF SQLCODE /= 0 GOTO EXITremSelectStat1;
! Unpack wanted columns !
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       unPackX !
!------------------------------------------------!

    DO SQLS_UnPack1;  ! UnPack signal registers into string !
! Loop until no more columns are wanted !
    SQLCODE=PROTECTEDP:SQLX_SQLCODE;
EXITremSelectStat1)


!******************************************************************************!
!END SQL!
 

PROGRAM xreftest; PLEX;

! D A T A   M A N I P U L A T I O N   S T A T E M E N T S	!

! SINGLETON SELECT STATEMENT 					!


a = b;

! Test a PLEX-SQL statement direct after a plex signal statement !
ENTER STTOR WITH
   CRESTCASE,
   CPHASE,
   +,
   +,
   +,
   +,
   CSIGKEY;
!BEGIN SQL ENTER 0!
!******************************************************************************!


!------------------------------------------------!
!       comSttor !
!------------------------------------------------!
! Enter restart phase 1 !
    IF CPHASE = 1 THEN
! Load the block reference of the table owning/using block !
        LOADREF SQLX_TempRow;
        cOwnRef = SQLX_TempRow;
        TRANSFORM BLOCKREF IN TEMP SQLX_TempRow TO BLOCKNUMBER IN TEMP SQLX_TempRow;
! Inform the system that the block contains a table owner and/or table user. !
        SEND STOREFUCODE WITH
            +,
            SQLX_TempRow,
            2,
            135,
            162,
        WAIT FOR STOREFUCODEACK IN RESTART;
RESTART)RETRIEVE STOREFUCODEACK;
    FI;


!******************************************************************************!
!END SQL!

!BEGIN SQL SELECT 1!
!******************************************************************************!

!EXEC SQL SELECT col1, col2 INTO %c1, %c2 FROM table1 
                    WHERE col1	 = "string"!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remSelectStat   !
!--------------------------------------!
! Set default SQLCODE and return label when returning from the row
$ lookup in table owner.!
    PROTECTEDP:SQLX_SQLCODE=0;
    PROTECTEDP:SQLX_SQLRETURN=2;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!




! Pack key and which columns to retreive in the signal. Then send the
$ signal to the table owner.!
    PROTECTEDP:SQLM_1 = "string";
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack2;  ! pack string into signal registers !
!------------------------------------------------!
!       packRequestX !
!------------------------------------------------!
    SQLX_DR5 = 2;
    SQLX_DR6 = 3;
    SQLX_DR7 = 2;
    SEND towGetRow REFERENCE SQLM_Remote(1).block WITH
        cOwnRef,
        PROTECTEDP,
        SQLM_Remote(1).table,
        2,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
! Return from table owner. If the lookup was not successful abort the
  select statement!
towGetLab2)
    IF SQLCODE /= 0 GOTO EXITremSelectStat2;
! Unpack wanted columns !
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       unPackX !
!------------------------------------------------!

    DO SQLS_UnPack2;  ! UnPack signal registers into string !

    C2 = SQLX_DR12;
! Loop until no more columns are wanted !
    SQLCODE=PROTECTEDP:SQLX_SQLCODE;
EXITremSelectStat2)


!******************************************************************************!
!END SQL!

! Ordinary SELECT with no errors !
c1 = c2;

! col1 not compatible with 36*7 !

!BEGIN SQL SELECT 9!
!******************************************************************************!

!EXEC
	 SQL

		SELECT col1, col2 INTO %c1, 
 A couple of comments to confuse line counter 
 A couple of comments to confuse line counter 
 A couple of comments to confuse line counter 
%c2 FROM table1 	
	WHERE col1 = 
		36*7!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remSelectStat   !
!--------------------------------------!
! Set default SQLCODE and return label when returning from the row
$ lookup in table owner.!
    PROTECTEDP:SQLX_SQLCODE=0;
    PROTECTEDP:SQLX_SQLRETURN=3;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!




! Pack key and which columns to retreive in the signal. Then send the
$ signal to the table owner.!
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack3;  ! pack string into signal registers !
!------------------------------------------------!
!       packRequestX !
!------------------------------------------------!
    SQLX_DR5 = 2;
    SQLX_DR6 = 3;
    SQLX_DR7 = 2;
    SEND towGetRow REFERENCE SQLM_Remote(1).block WITH
        cOwnRef,
        PROTECTEDP,
        SQLM_Remote(1).table,
        2,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
! Return from table owner. If the lookup was not successful abort the
  select statement!
towGetLab3)
    IF SQLCODE /= 0 GOTO EXITremSelectStat3;
! Unpack wanted columns !
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       unPackX !
!------------------------------------------------!

    DO SQLS_UnPack3;  ! UnPack signal registers into string !

    C2 = SQLX_DR12;
! Loop until no more columns are wanted !
    SQLCODE=PROTECTEDP:SQLX_SQLCODE;
EXITremSelectStat3)


!******************************************************************************!
!END SQL!




!BEGIN SQL SELECT 3!
!******************************************************************************!

!EXEC SQL SELECT table2.col1, table1.col2 INTO %c1, %c2 

 FROM table1 AS table2
 WHERE table1.col1 = "string"!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remSelectStat   !
!--------------------------------------!
! Set default SQLCODE and return label when returning from the row
$ lookup in table owner.!
    PROTECTEDP:SQLX_SQLCODE=0;
    PROTECTEDP:SQLX_SQLRETURN=4;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!




! Pack key and which columns to retreive in the signal. Then send the
$ signal to the table owner.!
    PROTECTEDP:SQLM_1 = "string";
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack4;  ! pack string into signal registers !
!------------------------------------------------!
!       packRequestX !
!------------------------------------------------!
    SQLX_DR5 = 2;
    SQLX_DR6 = 3;
    SQLX_DR7 = 2;
    SEND towGetRow REFERENCE SQLM_Remote(1).block WITH
        cOwnRef,
        PROTECTEDP,
        SQLM_Remote(1).table,
        2,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
! Return from table owner. If the lookup was not successful abort the
  select statement!
towGetLab4)
    IF SQLCODE /= 0 GOTO EXITremSelectStat4;
! Unpack wanted columns !
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       unPackX !
!------------------------------------------------!

    DO SQLS_UnPack4;  ! UnPack signal registers into string !

    C2 = SQLX_DR12;
! Loop until no more columns are wanted !
    SQLCODE=PROTECTEDP:SQLX_SQLCODE;
EXITremSelectStat4)


!******************************************************************************!
!END SQL!


! UPDATE SINGLE ROW !
! col5 not compatible with "DIGITS" !

!BEGIN SQL UPDATE 7!
!******************************************************************************!

!EXEC SQL


UPDATE table1 SET

       

       col5 = "DIGITS" WHERE col1 = "string"!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       updateStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITupdateStat5;
    FI;
! Pack signal with required data and primary key. Then send update
  signal to transaction handler. !
    PROTECTEDP:SQLX_SQLRETURN=1;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!

    PROTECTEDP:SQLM_2 = "DIGITS";
    PROTECTEDP:SQLM_1 = "string";
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack5;  ! pack string into signal registers !
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 6;
    SQLX_DR7 = 0;

    DO SQLS_Pack6;  ! pack string into signal registers !
    SEND trhChaRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef,
        SQLM_Remote(1).block,
        SQLM_Remote(1).table,
        2
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
trhChaRowLab1)
! If not successful abort command !
    IF SQLCODE /= 0 GOTO EXITupdateStat5;
! Send let field signal to transaction handler until all data is
  transferred to the table. Abort the command if any signal fails. !
EXITupdateStat5)


!******************************************************************************!
!END SQL!



!BEGIN SQL UPDATE_VOLATILE 3!
!******************************************************************************!

!EXEC SQL


UPDATE table2 VOLATILE col5 = "DIGITS" WHERE col9 = 10!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remUpdateVolatileStat!
!--------------------------------------!
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!

! Loop for each hunk of columns to update !
! Update some columns !
    PROTECTEDP:SQLX_SQLRETURN=1;
    PROTECTEDP:SQLM_1 = "DIGITS";
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 6;

    DO SQLS_Pack7;  ! pack string into signal registers !
    SEND towChaVolRow REFERENCE SQLM_Remote(0).block WITH
        cOwnRef,
        PROTECTEDP,
        SQLM_Remote(0).table,
        10,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ;
    EXIT;
towChaVolRowLab1)
! If update failed abort command !
    IF SQLCODE /= 0 GOTO EXITremUpdateVolatileStat6;
EXITremUpdateVolatileStat6)


!******************************************************************************!
!END SQL!



;

a = b;

c


=


d;

! not compatible search conditions !

!BEGIN SQL UPDATE 7!
!******************************************************************************!

!EXEC SQL


UPDATE table1 SET

       col3 = 4,

       col5 = %c WHERE col1 = 35432!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       updateStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITupdateStat7;
    FI;
! Pack signal with required data and primary key. Then send update
  signal to transaction handler. !
    PROTECTEDP:SQLX_SQLRETURN=2;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!

!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack8;  ! pack string into signal registers !
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 2;
    SQLX_DR6 = 4;
    SQLX_DR7 = 6;
    SQLX_DR8 = 0;

    DO SQLS_Pack9;  ! pack string into signal registers !
    SQLX_DR13 = 0;

    SQLX_DR14 = 4;
    SEND trhChaRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef,
        SQLM_Remote(1).block,
        SQLM_Remote(1).table,
        2
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,+
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
trhChaRowLab2)
! If not successful abort command !
    IF SQLCODE /= 0 GOTO EXITupdateStat7;
! Send let field signal to transaction handler until all data is
  transferred to the table. Abort the command if any signal fails. !
EXITupdateStat7)


!******************************************************************************!
!END SQL!


! INSERT INTO table !


!BEGIN SQL INSERT 4!
!******************************************************************************!

!EXEC SQL INSERT into table1
(
col1, col2,

col5, col7) VALUES (1,2,3,4)!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       insertStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITinsertStat8;
    FI;
! Pack signal with required data and primary key. Then send insert
  signal to transaction handler. !
    PROTECTEDP:SQLX_SQLRETURN=1;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!



!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack10;  ! pack string into signal registers !
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 2;
    SQLX_DR6 = 3;
    SQLX_DR7 = 6;
    SQLX_DR8 = 0;

    DO SQLS_Pack11;  ! pack string into signal registers !

    SQLX_DR13 = 2;
    SEND trhInsRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref,
        SQLM_Remote(1).block,
        SQLM_Remote(1).table,
        2                 ! primary key !
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,+
        ,+
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
trhInsRowLab1)
    IF SQLCODE /= 0 GOTO EXITinsertStat8;
! Send let field signal to transaction handler until all data is
  transferred to the table. Abort the command if any signal fails. !
    PROTECTEDP:SQLX_SQLRETURN=1;
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 8;
    SQLX_DR7 = 0;

    SQLX_DR8 = 4;
    SEND trhLetFld WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref,
        +,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ;
    EXIT;
trhLetFldLab1)
    IF SQLCODE /= 0 GOTO EXITinsertStat8;
! Exit !
EXITinsertStat8)


!******************************************************************************!
!END SQL!


! DELETE FROM table !

!BEGIN SQL BEGIN 7!
!******************************************************************************!

!EXEC SQL BEGIN



PROTECTED


REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat9;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat9;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat9;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat9;
PROTECTEDALLOCATEDbeginStat9)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat9)
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!


!BEGIN SQL DELETE 5!
!******************************************************************************!

!EXEC SQL DELETE FROM  table3



WHERE
			col1 = %c!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       deleteStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITdeleteStat10;
    FI;
! Pack signal with primary key. Then send delete signal to transaction
  handler. !
    PROTECTEDP:SQLX_SQLRETURN=1;
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack12;  ! pack string into signal registers !
    SEND trhDelRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef,
        cOwnRef,
        0,
        2
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
trhDelRowLab1)
EXITdeleteStat10)


!******************************************************************************!
!END SQL!



! CURSOR HANDLING !

!BEGIN SQL OPEN_CURSOR 0!
!******************************************************************************!

!EXEC SQL OPEN  cursor1!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remOpenStat     !
!--------------------------------------!
! Check if cursor already is opened, if so report failure !
    IF PROTECTEDP:SQLM_CURSOR1_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITremOpenStat11;
    FI;
! Pack signal with cursor key. Then send open signal to table owner. !
    PROTECTEDP:SQLX_SQLRETURN=1;
    PROTECTEDP:SQLM_1 = "abc";
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack13;  ! pack string into signal registers !
    SQLX_DR15 = 0;
    SEND towOpen REFERENCE SQLM_Remote(1).block WITH
        cOwnRef,
        PROTECTEDP,
        SQLM_Remote(1).table,
        0,
        3,
        +,
        +
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
towOpenLab1)
! If open fails report failure !
    IF SQLCODE /= 0 GOTO EXITremOpenStat11;
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_CURSOR1_Cursor=SQLX_OperRow;
! Exit !
EXITremOpenStat11)


!******************************************************************************!
!END SQL!
 
!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE cursor1!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remCloseStat    !
!--------------------------------------!
! Check if cursor already is closed, if so report failure !
    IF PROTECTEDP:SQLM_CURSOR1_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITremCloseStat12;
    FI;
! Send close signal to table owner. !
    SEND towClose REFERENCE SQLM_Remote(1).block WITH
        PROTECTEDP,
        SQLM_Remote(1).table,
        PROTECTEDP:SQLM_CURSOR1_Cursor
    WAIT FOR towCloseAck IN towCloseLab1;
towCloseLab1)
    RETRIEVE towCloseAck WITH
        PROTECTEDP,
        SQLCODE;
    PROTECTEDP:SQLM_CURSOR1_Cursor=0;
EXITremCloseStat12)


!******************************************************************************!
!END SQL!



!BEGIN SQL FETCH 4!
!******************************************************************************!

!EXEC SQL FETCH
cursor1


INTO  COMMENT  %a!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remFetchStat    !
!--------------------------------------!
! Check if cursor is open, if not report failure. !
    IF PROTECTEDP:SQLM_CURSOR1_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITremFetchStat13;
    FI;
! Pack cursor key and which columns to retrieve in the signal. Then send
$ the signal to the table owner. !
    PROTECTEDP:SQLX_SQLCODE=0;
    PROTECTEDP:SQLX_SQLRETURN=5;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!



!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!
    SQLX_DR23 = PROTECTEDP:SQLM_CURSOR1_Cursor;
    SQLX_DR22 = 3;
    SQLX_DR21 = 1;
    SQLX_DR20 = 0;
!------------------------------------------------!
!       packRequestX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 2;
    SEND towGetRow REFERENCE SQLM_Remote(1).block WITH
        cOwnRef,
        PROTECTEDP,
        SQLM_Remote(1).table,
        1,  ! cursor key !
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
towGetLab5)
    IF SQLCODE /= 0 GOTO EXITremFetchStat13;
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       unPackX !
!------------------------------------------------!

    DO SQLS_UnPack5;  ! UnPack signal registers into string !
! Get required data if more test are needed to see if the right row was
  found. First makes the test with the data taken so far and if the test
  was successful and more data is needed to check more columns, request
  more column data from the table owner. !
    SQLCODE=PROTECTEDP:SQLX_SQLCODE;
EXITremFetchStat13)


!******************************************************************************!
!END SQL!



!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH cursor1 INTO %a!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remFetchStat    !
!--------------------------------------!
! Check if cursor is open, if not report failure. !
    IF PROTECTEDP:SQLM_CURSOR1_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITremFetchStat14;
    FI;
! Pack cursor key and which columns to retrieve in the signal. Then send
$ the signal to the table owner. !
    PROTECTEDP:SQLX_SQLCODE=0;
    PROTECTEDP:SQLX_SQLRETURN=6;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!



!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!
    SQLX_DR23 = PROTECTEDP:SQLM_CURSOR1_Cursor;
    SQLX_DR22 = 3;
    SQLX_DR21 = 1;
    SQLX_DR20 = 0;
!------------------------------------------------!
!       packRequestX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 2;
    SEND towGetRow REFERENCE SQLM_Remote(1).block WITH
        cOwnRef,
        PROTECTEDP,
        SQLM_Remote(1).table,
        1,  ! cursor key !
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
towGetLab6)
    IF SQLCODE /= 0 GOTO EXITremFetchStat14;
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       unPackX !
!------------------------------------------------!

    DO SQLS_UnPack6;  ! UnPack signal registers into string !
! Get required data if more test are needed to see if the right row was
  found. First makes the test with the data taken so far and if the test
  was successful and more data is needed to check more columns, request
  more column data from the table owner. !
    SQLCODE=PROTECTEDP:SQLX_SQLCODE;
EXITremFetchStat14)


!******************************************************************************!
!END SQL!
 
!BEGIN SQL FETCH 4!
!******************************************************************************!

!EXEC SQL FETCH cursor1 INTO 



%a!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remFetchStat    !
!--------------------------------------!
! Check if cursor is open, if not report failure. !
    IF PROTECTEDP:SQLM_CURSOR1_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITremFetchStat15;
    FI;
! Pack cursor key and which columns to retrieve in the signal. Then send
$ the signal to the table owner. !
    PROTECTEDP:SQLX_SQLCODE=0;
    PROTECTEDP:SQLX_SQLRETURN=7;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!



!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!
    SQLX_DR23 = PROTECTEDP:SQLM_CURSOR1_Cursor;
    SQLX_DR22 = 3;
    SQLX_DR21 = 1;
    SQLX_DR20 = 0;
!------------------------------------------------!
!       packRequestX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 2;
    SEND towGetRow REFERENCE SQLM_Remote(1).block WITH
        cOwnRef,
        PROTECTEDP,
        SQLM_Remote(1).table,
        1,  ! cursor key !
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
towGetLab7)
    IF SQLCODE /= 0 GOTO EXITremFetchStat15;
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       unPackX !
!------------------------------------------------!

    DO SQLS_UnPack7;  ! UnPack signal registers into string !
! Get required data if more test are needed to see if the right row was
  found. First makes the test with the data taken so far and if the test
  was successful and more data is needed to check more columns, request
  more column data from the table owner. !
    SQLCODE=PROTECTEDP:SQLX_SQLCODE;
EXITremFetchStat15)


!******************************************************************************!
!END SQL!

!BEGIN SQL START 2!
!******************************************************************************!

!EXEC SQL START TRANSACTION

%NISSE!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       startStat!
!--------------------------------------!
! Check if inside a transaction, if so report failure !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
        SQLCODE=3+15 <= 8;
        GOTO trhStaTransLab1;
    FI;
    PROTECTEDP:SQLX_SQLRETURN=1;
    SEND trhStaTrans WITH
        PROTECTEDP,
        cOwnRef,
        1,
        NISSE;
    EXIT;
trhStaTransLab1)


!******************************************************************************!
!END SQL!


!BEGIN SQL PREPARE 0!
!******************************************************************************!

!EXEC SQL PREPARE TRANSACTION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       prepareStat     !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhVerTransLab1;
    FI;
! Request to prepare a transaction for commit. !
    PROTECTEDP:SQLX_SQLRETURN=1;
    SEND trhVerTrans WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref;
    EXIT;
trhVerTransLab1)


!******************************************************************************!
!END SQL!
 
!BEGIN SQL START 0!
!******************************************************************************!

!EXEC SQL START WORK!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       startStat!
!--------------------------------------!
! Check if inside a transaction, if so report failure !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
        SQLCODE=3+15 <= 8;
        GOTO trhStaTransLab2;
    FI;
    PROTECTEDP:SQLX_SQLRETURN=2;
    SEND trhStaTrans WITH
        PROTECTEDP,
        cOwnRef,
        1,
        "";
    EXIT;
trhStaTransLab2)


!******************************************************************************!
!END SQL!
 
!BEGIN SQL PREPARE 1!
!******************************************************************************!

!EXEC SQL PREPARE WORK
!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       prepareStat     !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhVerTransLab2;
    FI;
! Request to prepare a transaction for commit. !
    PROTECTEDP:SQLX_SQLRETURN=2;
    SEND trhVerTrans WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref;
    EXIT;
trhVerTransLab2)


!******************************************************************************!
!END SQL!


!BEGIN SQL ROLLBACK 6!
!******************************************************************************!

!EXEC SQL ROLLBACK 





TRANSACTION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       rollbackStat    !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhRollBckLab1;
    FI;
! Request to rollback a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=1;
    SEND trhRollBck WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhRollBckLab1)
! Close the transaction !
    PROTECTEDP:SQLTRANSID=0;


!******************************************************************************!
!END SQL!


!BEGIN SQL ROLLBACK 4!
!******************************************************************************!

!EXEC SQL ROLLBACK WORK



!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       rollbackStat    !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhRollBckLab2;
    FI;
! Request to rollback a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=2;
    SEND trhRollBck WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhRollBckLab2)
! Close the transaction !
    PROTECTEDP:SQLTRANSID=0;


!******************************************************************************!
!END SQL!


!BEGIN SQL COMMIT 2!
!******************************************************************************!

!EXEC SQL COMMIT

TRANSACTION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       commitStat      !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhComTransLab1;
    FI;
! Request to commit a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=1;
    SEND trhComTrans WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhComTransLab1)
! Close transaction !
    PROTECTEDP:SQLTRANSID=0;


!******************************************************************************!
!END SQL!

!BEGIN SQL ROLLBACK 1!
!******************************************************************************!

!EXEC SQL ROLLBACK
TRANSACTION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       rollbackStat    !
!--------------------------------------!
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO trhRollBckLab3;
    FI;
! Request to rollback a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=3;
    SEND trhRollBck WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhRollBckLab3)
! Close the transaction !
    PROTECTEDP:SQLTRANSID=0;


!******************************************************************************!
!END SQL!


!BEGIN SQL UPDATE 2!
!******************************************************************************!

!EXEC SQL UPDATE table3 set col7 = %a 
WHERE
CURRENT OF cursor1!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       updateStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITupdateStat24;
    FI;
! Pack signal with required data and primary key. Then send update
  signal to transaction handler. !
    PROTECTEDP:SQLX_SQLRETURN=3;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!

!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack14;  ! pack string into signal registers !
    SQLX_DR15 = 0;
!------------------------------------------------!
!       packX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 8;
    SQLX_DR7 = 0;

    SQLX_DR8 = A;
    SEND trhChaRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef,
        cOwnRef,
        0,
        3
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
trhChaRowLab3)
! If not successful abort command !
    IF SQLCODE /= 0 GOTO EXITupdateStat24;
! Send let field signal to transaction handler until all data is
  transferred to the table. Abort the command if any signal fails. !
EXITupdateStat24)


!******************************************************************************!
!END SQL!


!BEGIN SQL END 0!
!******************************************************************************!

!EXEC SQL END PROTECTED REGION!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_CURSOR1_Cursor /= 0 THEN
        SEND towClose REFERENCE SQLM_Remote(1).block WITH
            PROTECTEDP,
            SQLM_Remote(1).table,
            PROTECTEDP:SQLM_CURSOR1_Cursor;
        WAIT FOR towCloseAck IN TOWCLOSEACK25;
TOWCLOSEACK25)
        RETRIEVE towCloseAck WITH
            PROTECTEDP;
    FI;
    PROTECTEDP:SQLM_CURSOR1_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=4;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab4)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;


!******************************************************************************!
!END SQL!


!BEGIN SQL GET_DB_NUMBER 9!
!******************************************************************************!

!EXEC
SQL GET
DBNUMBER 






INTO %NO!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       getDbnumberStat !
!--------------------------------------!
    SEND trhGetDBno WITH
        PROTECTEDP,
        cOwnRef
        WAIT FOR trhGetDBnoAck IN RETURNLABELgetDbnumberStat26;
RETURNLABELgetDbnumberStat26)
    RETRIEVE trhgetDBnoAck WITH
        NO.PART1,
        NO.PART2;


!******************************************************************************!
!END SQL!


!BEGIN SQL FETCH 0!
!******************************************************************************!

!EXEC SQL FETCH cursor1 into %a!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remFetchStat    !
!--------------------------------------!
! Check if cursor is open, if not report failure. !
    IF PROTECTEDP:SQLM_CURSOR1_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITremFetchStat27;
    FI;
! Pack cursor key and which columns to retrieve in the signal. Then send
$ the signal to the table owner. !
    PROTECTEDP:SQLX_SQLCODE=0;
    PROTECTEDP:SQLX_SQLRETURN=8;
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!



!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!
    SQLX_DR23 = PROTECTEDP:SQLM_CURSOR1_Cursor;
    SQLX_DR22 = 3;
    SQLX_DR21 = 1;
    SQLX_DR20 = 0;
!------------------------------------------------!
!       packRequestX !
!------------------------------------------------!
    SQLX_DR5 = 1;
    SQLX_DR6 = 2;
    SEND towGetRow REFERENCE SQLM_Remote(1).block WITH
        cOwnRef,
        PROTECTEDP,
        SQLM_Remote(1).table,
        1,  ! cursor key !
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
towGetLab8)
    IF SQLCODE /= 0 GOTO EXITremFetchStat27;
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
!------------------------------------------------!
!       unPackX !
!------------------------------------------------!

    DO SQLS_UnPack8;  ! UnPack signal registers into string !
! Get required data if more test are needed to see if the right row was
  found. First makes the test with the data taken so far and if the test
  was successful and more data is needed to check more columns, request
  more column data from the table owner. !
    SQLCODE=PROTECTEDP:SQLX_SQLCODE;
EXITremFetchStat27)


!******************************************************************************!
!END SQL!

!BEGIN SQL DELETE 0!
!******************************************************************************!

!EXEC SQL DELETE FROM  table3 WHERE current of cursor1!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       deleteStat      !
!--------------------------------------!
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITdeleteStat28;
    FI;
! Pack signal with primary key. Then send delete signal to transaction
  handler. !
    PROTECTEDP:SQLX_SQLRETURN=2;
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!

    DO SQLS_Pack15;  ! pack string into signal registers !
    SQLX_DR15 = 0;
    SEND trhDelRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef,
        cOwnRef,
        0,
        3
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,+
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
trhDelRowLab2)
EXITdeleteStat28)


!******************************************************************************!
!END SQL!

!BEGIN SQL CLOSE_CURSOR 0!
!******************************************************************************!

!EXEC SQL CLOSE cursor1!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       remCloseStat    !
!--------------------------------------!
! Check if cursor already is closed, if so report failure !
    IF PROTECTEDP:SQLM_CURSOR1_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITremCloseStat29;
    FI;
! Send close signal to table owner. !
    SEND towClose REFERENCE SQLM_Remote(1).block WITH
        PROTECTEDP,
        SQLM_Remote(1).table,
        PROTECTEDP:SQLM_CURSOR1_Cursor
    WAIT FOR towCloseAck IN towCloseLab2;
towCloseLab2)
    RETRIEVE towCloseAck WITH
        PROTECTEDP,
        SQLCODE;
    PROTECTEDP:SQLM_CURSOR1_Cursor=0;
EXITremCloseStat29)


!******************************************************************************!
!END SQL!



%c;

!BEGIN SQL CONTINUE 3!
!******************************************************************************!

!EXEC SQL CONTINUE AT

LEVEL B		
			DELAY 12 MS!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       continueStat    !
!--------------------------------------!
    SEND CONTINUEB REFERENCE cOwnRef WITH
        PROTECTEDP,
        1
        DELAY 12 MS
        ;
    EXIT;
continueBLab1)


!******************************************************************************!
!END SQL!

PREP1)
   
!BEGIN SQL SELECT 0!
!******************************************************************************!

!EXEC SQL SELECT col1,col3 into %a,%c FROM table3 WHERE CURRENT OF WORK!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TABLE3_OperRow = PROTECTEDP:SQLX_SQLWORKROW;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    A = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL1_Data;

    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    C = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Data;


!******************************************************************************!
!END SQL!

   
!BEGIN SQL SELECT 0!
!******************************************************************************!

!EXEC SQL SELECT col1,col3 into %a,%c FROM table3 WHERE CURRENT OF ORIGINAL!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TABLE3_OperRow = PROTECTEDP:SQLX_SQLOPERROW;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    A = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL1_Data;

    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    C = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Data;


!******************************************************************************!
!END SQL!

   GOTO PREPRET;

POST1)
   
!BEGIN SQL SELECT 0!
!******************************************************************************!

!EXEC SQL SELECT col1,col3 into %a,%c FROM table3 WHERE CURRENT OF WORK!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TABLE3_OperRow = PROTECTEDP:SQLX_SQLWORKROW;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    A = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL1_Data;

    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    C = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Data;


!******************************************************************************!
!END SQL!

   
!BEGIN SQL SELECT 0!
!******************************************************************************!

!EXEC SQL SELECT col1,col3 into %a,%c FROM table3 WHERE CURRENT OF ORIGINAL!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TABLE3_OperRow = PROTECTEDP:SQLX_SQLOPERROW;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    A = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL1_Data;

    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    C = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Data;


!******************************************************************************!
!END SQL!

   GOTO POSTRET;

ROLL1)
   
!BEGIN SQL SELECT 0!
!******************************************************************************!

!EXEC SQL SELECT col1,col3 into %a,%c FROM table3 WHERE CURRENT OF WORK!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TABLE3_OperRow = PROTECTEDP:SQLX_SQLWORKROW;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    A = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL1_Data;

    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    C = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Data;


!******************************************************************************!
!END SQL!

   
!BEGIN SQL SELECT 0!
!******************************************************************************!

!EXEC SQL SELECT col1,col3 into %a,%c FROM table3 WHERE CURRENT OF ORIGINAL!

!------------------------------------------------------------------------------!

!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
    SQLM_TABLE3_OperRow = PROTECTEDP:SQLX_SQLOPERROW;
    SQLCODE=0;
!  retrieve data from work row. !
!------------------------------------------------!
!       getData !
!------------------------------------------------!

    A = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL1_Data;

    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
    C = SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Data;


!******************************************************************************!
!END SQL!

   GOTO ROLLRET;



!BEGIN SQL COMMON 0!
!------------------------------------------------!
!       comGiveFs !
!------------------------------------------------!
    ENTER GIVEFS WITH
        SQLX_SizeEvent,
        +;
    CASE SQLX_SizeEvent IS
    WHEN 10 DO GOTO SAE10L1;
    WHEN 20 DO GOTO SAE20L1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! No appropriate Size Alteration Event was found. !
    SEND GIVEFSEND WITH #100;
    EXIT;

!------------------------------------------------!
!       comContFs !
!------------------------------------------------!
    ENTER CONTFS WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum;
! Select Size Alteration Event !
    CASE SQLX_SizeEvent IS
    WHEN 10 DO GOTO SAE10L2;
    WHEN 20 DO GOTO SAE20L2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! The size alteration event was of no interest !
    SEND CONTFSEND WITH 1;
    EXIT;

!------------------------------------------------!
!       comSetFs !
!------------------------------------------------!
    ENTER SETFS WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum;
! Select Size Alteration Event !
    CASE SQLX_SizeEvent IS
    WHEN 10 DO GOTO SAE10L3;
    WHEN 20 DO GOTO SAE20L3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Ignore non-interesting size alteration events !
    SEND SETFSEND;
    EXIT;

!------------------------------------------------!
!       towPlexCode !
!------------------------------------------------!
!------------------------------------------------!
!       comPlexCode !
!------------------------------------------------!
!------------------------------------------------!
!       towResPart !
!------------------------------------------------!
    ENTER towResPart WITH
        SQLX_OtherBlock,        ! Other users block number !
        SQLX_OtherProtected,    ! Other users protected pointer !
        SQLX_RestartPhase;      ! Our internal restart phase !
   ! Store block ref and pointer !
    CSQLX_OtherBlock = SQLX_OtherBlock;
    CSQLX_OtherProtected = SQLX_OtherProtected;
! Select code to execute the specified restart code !
    CASE SQLX_RestartPhase IS
    WHEN 1 DO GOTO RESTARTPHASE1;
    WHEN 3 DO GOTO RESTARTPHASE3;
    WHEN 4 DO GOTO RESTARTPHASE4;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Return execution to Data Dictionary or Transaction Handler !
RESTARTEND)
    SEND towResPartR REFERENCE CSQLX_OtherBlock WITH
        CSQLX_OtherProtected,    ! Other users protected pointer !
        0;                  ! Return code !
    EXIT;
!------------------------------------------------!
!       comGiveFsSae !
!------------------------------------------------!
SAE10L1)
    SQLM_TableReference = 0;
    FILENUMBER FOR SQLC_TABLE3_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        65000+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
    EXIT;
SAE20L1)
    SQLM_TableReference = 0;
    FILENUMBER FOR SQLC_TABLE3_Allocated TO SQLX_FileNumber;
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
        SQLM_TableReference:SQLM_TableAllocated+500+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
    EXIT;
!------------------------------------------------!
!       comContFsSae !
!------------------------------------------------!

BEGIN SQLS_TABLE3_SAEDecrease;
    SQLM_TABLE3_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TABLE3_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_TABLE3_OperRow=
        SQLM_TABLE3_GuardRow-SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2=
        SQLM_TABLE3_GuardRow:SQLC_TABLE3_Color2;    
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3=
        SQLM_TABLE3_GuardRow:SQLC_TABLE3_Color3;    
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4=
        SQLM_TABLE3_GuardRow:SQLC_TABLE3_Color4;    
    IF SQLM_TABLE3_GuardRow:SQLC_TABLE3_Left2 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
            SQLM_TABLE3_NilRow-SQLM_TABLE3_WorkRow;
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
            SQLM_TABLE3_GuardRow:SQLC_TABLE3_Left2;
    FI;
    IF SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
              SQLM_TABLE3_NilRow-SQLM_TABLE3_WorkRow;
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
            SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2;
    FI;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated=1;
! Move Nil Row !
    SQLM_TABLE3_OperRow=
        SQLM_TABLE3_NilRow-SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2=
        SQLM_TABLE3_NilRow:SQLC_TABLE3_Color2;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
        SQLM_TABLE3_GuardRow-SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2 =
        SQLM_TABLE3_GuardRow-SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3=
        SQLM_TABLE3_NilRow:SQLC_TABLE3_Color3;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
        SQLM_TABLE3_GuardRow-SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3 =
        SQLM_TABLE3_GuardRow-SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4=
        SQLM_TABLE3_NilRow:SQLC_TABLE3_Color4;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
        SQLM_TABLE3_GuardRow-SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4 =
        SQLM_TABLE3_GuardRow-SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated=1;
! Move Root Row !
    SQLM_TABLE3_OperRow=
        SQLM_TABLE3_RootRow-SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2=
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Color2;    
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Right2 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
            SQLM_TABLE3_NilRow-SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Right2;    
    FI;
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Left2 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
            SQLM_TABLE3_NilRow-SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Left2;    
    FI;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3=
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Color3;    
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Right3 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
            SQLM_TABLE3_NilRow-SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Right3;    
    FI;
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Left3 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3=
            SQLM_TABLE3_NilRow-SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Left3;    
    FI;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4=
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Color4;    
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Right4 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
            SQLM_TABLE3_NilRow-SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Right4;    
    FI;
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Left4 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4=
            SQLM_TABLE3_NilRow-SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Left4;    
    FI;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated=1;
END SQLS_TABLE3_SAEDecrease;
SAE10L2)
    SQLM_TableReference=0;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE110;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE110;
    IF SQLX_NewIndNum > 65000 GOTO FAILURE110;
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE110;
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE210;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated THEN
! Remove rows from free list !
        SQLM_TABLE3_NilRow=SQLM_TableReference:SQLM_System+1;
        SQLM_TABLE3_GuardRow=SQLM_TableReference:SQLM_System;
        SQLM_TABLE3_WorkRow=SQLM_TABLE3_GuardRow;
        SQLM_TABLE3_OperRow=
            SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2;
LOOP10)
        IF SQLM_TABLE3_OperRow = SQLM_TABLE3_NilRow
            GOTO EXIT10;
        IF SQLM_TABLE3_OperRow >= SQLX_NewIndNum THEN
            IF SQLM_TABLE3_WorkRow = SQLM_TABLE3_GuardRow THEN
                SQLM_TABLE3_WorkRow:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
            ELSE
                SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
            FI;
            SQLM_TABLE3_OperRow=
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
        ELSE
            SQLM_TABLE3_WorkRow=SQLM_TABLE3_OperRow;
            SQLM_TABLE3_OperRow=
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
        FI;
        GOTO LOOP10;
EXIT10)
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TABLE3_WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_TABLE3_SAEDecrease;
! Remap NIL pointers !
        SQLM_TABLE3_WorkRow=
            SQLM_TABLE3_NilRow-SQLM_TABLE3_WorkRow;
        IF SQLX_NewIndNum>0 THEN
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_WorkRow;
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_WorkRow;
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_WorkRow;
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_WorkRow;
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_WorkRow;
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLX_NewIndNum-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE110)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE210)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY 100 MS;
    EXIT;
SAE20L2)
    SQLM_TableReference=0;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE110;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF SQLX_NewIndNum < 0 GOTO FAILURE120;
    IF SQLX_NewIndNum > 500 GOTO FAILURE120;
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE220;
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF SQLX_NewIndNum < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TABLE3_WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-SQLX_NewIndNum;
! Move the system rows and remap NIL pointers !
        DO SQLS_TABLE3_SAEDecrease;
! Remap NIL pointers !
        SQLM_TABLE3_WorkRow=
            SQLM_TABLE3_NilRow-SQLM_TABLE3_WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_WorkRow;
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_WorkRow;
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_WorkRow;
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_WorkRow;
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_WorkRow;
            FOR ALL SQLM_TABLE3_OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_NilRow
                DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_WorkRow;
        FI;
    FI;
! Everything seems fine !
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE120)
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE220)
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
    SEND CONTFS REFERENCE cOwnRef WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY 100 MS;
    EXIT;
!------------------------------------------------!
!       comSetFsSae !
!------------------------------------------------!

BEGIN SQLS_TABLE3_SAEIncrease;
    SQLM_TABLE3_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TABLE3_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    SQLM_TABLE3_OperRow=
        SQLM_TABLE3_GuardRow+SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2=
        SQLM_TABLE3_GuardRow:SQLC_TABLE3_Color2;    
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3=
        SQLM_TABLE3_GuardRow:SQLC_TABLE3_Color3;    
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4=
        SQLM_TABLE3_GuardRow:SQLC_TABLE3_Color4;    
    IF SQLM_TABLE3_GuardRow:SQLC_TABLE3_Left2=
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
            SQLM_TABLE3_NilRow+SQLM_TABLE3_WorkRow;
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
            SQLM_TABLE3_GuardRow:SQLC_TABLE3_Left2;
    FI;
    IF SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2=
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
            SQLM_TABLE3_NilRow+SQLM_TABLE3_WorkRow;
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
            SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2;
    FI;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated=1;
! Move Nil Row !
    SQLM_TABLE3_OperRow=
        SQLM_TABLE3_NilRow+SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2=
        SQLM_TABLE3_NilRow:SQLC_TABLE3_Color2;    
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
        SQLM_TABLE3_GuardRow+SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2 =
        SQLM_TABLE3_GuardRow+SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3=
        SQLM_TABLE3_NilRow:SQLC_TABLE3_Color3;    
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
        SQLM_TABLE3_GuardRow+SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3 =
        SQLM_TABLE3_GuardRow+SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4=
        SQLM_TABLE3_NilRow:SQLC_TABLE3_Color4;    
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
        SQLM_TABLE3_GuardRow+SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4 =
        SQLM_TABLE3_GuardRow+SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated=1;
! Move Root Row !
    SQLM_TABLE3_OperRow=
        SQLM_TABLE3_RootRow+SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2=
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Color2;    
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Right2 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
            SQLM_TABLE3_NilRow+SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Right2;    
    FI;
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Left2 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
            SQLM_TABLE3_NilRow+SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Left2;    
    FI;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3=
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Color3;    
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Right3 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
            SQLM_TABLE3_NilRow+SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Right3;    
    FI;
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Left3 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3=
            SQLM_TABLE3_NilRow+SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Left3;    
    FI;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4=
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Color4;    
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Right4 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
            SQLM_TABLE3_NilRow+SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Right4;    
    FI;
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Left4 =
        SQLM_TABLE3_NilRow
    THEN
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4=
            SQLM_TABLE3_NilRow+SQLM_TABLE3_WorkRow;    
    ELSE
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4=
            SQLM_TABLE3_RootRow:SQLC_TABLE3_Left4;    
    FI;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated=1;
! Clear allocate bits in new area !
    FOR ALL SQLM_TABLE3_OperRow
        FROM SQLM_TableReference:SQLM_System+
            SQLM_TABLE3_WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
        DO SQLS_TABLE3_SAEClear;
! Remap NIL pointers !
    SQLM_TABLE3_WorkRow=
        SQLM_TABLE3_WorkRow+SQLM_TABLE3_NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
        FOR ALL SQLM_TABLE3_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
                SQLM_TABLE3_NilRow
            DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=
                SQLM_TABLE3_WorkRow;
        FOR ALL SQLM_TABLE3_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
                SQLM_TABLE3_NilRow
            DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
                SQLM_TABLE3_WorkRow;
        FOR ALL SQLM_TABLE3_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
                SQLM_TABLE3_NilRow
            DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=
                SQLM_TABLE3_WorkRow;
        FOR ALL SQLM_TABLE3_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3=
                SQLM_TABLE3_NilRow
            DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3=
                SQLM_TABLE3_WorkRow;
        FOR ALL SQLM_TABLE3_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
                SQLM_TABLE3_NilRow
            DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=
                SQLM_TABLE3_WorkRow;
        FOR ALL SQLM_TABLE3_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4=
                SQLM_TABLE3_NilRow
            DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4=
                SQLM_TABLE3_WorkRow;
    FI;
END SQLS_TABLE3_SAEIncrease;

BEGIN SQLS_TABLE3_SAEClear;
! Clear allocate bit. !
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated=0;
! Clear btree pointers. !
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=0;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2=0;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3=0;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3=0;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4=0;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4=0;
END SQLS_TABLE3_SAEClear;
SAE10L3)
    SQLM_TableReference=0;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TABLE3_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_TABLE3_SAEIncrease;
! Link in new rows into the free list (first in list) !
        ON SQLM_TABLE3_OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated
            UPTO SQLX_NewIndNum-2
            DO SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
                SQLM_TABLE3_OperRow+1;
        NO;
        SQLM_TABLE3_OperRow=SQLX_NewIndNum-1;
        SQLM_TABLE3_GuardRow=SQLM_TableReference:SQLM_WorkAllocated+SQLX_NewIndNum;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2=
            SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2;
        SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2=
            SQLM_TableReference:SQLM_TableAllocated;
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
SAE20L3)
    SQLM_TableReference=0;
    SQLX_NewIndNum=SQLX_NewIndNum-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF SQLX_NewIndNum > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        SQLM_TABLE3_WorkRow=
            SQLX_NewIndNum-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO SQLS_TABLE3_SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=SQLX_NewIndNum;
    SQLM_TableReference:SQLM_System=SQLX_NewIndNum+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
    SEND SETFSEND;
    EXIT;
!------------------------------------------------!
!       towGetRow !
!------------------------------------------------!
    ENTER towGetRow WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow0_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_TABLE3_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor0_0;
        WHEN 2 DO GOTO towGetRowCursor0_2;
        WHEN 3 DO GOTO towGetRowCursor0_3;
        WHEN 4 DO GOTO towGetRowCursor0_4;
        OTHERWISE DO ! nothing ! ;
        ESAC;

    WHEN 2 DO GOTO towGetRow0_2;
    WHEN 3 DO GOTO towGetRow0_3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
towGetRow0_0)
! get row number.!
    DO SQLS_TABLE3_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_TABLE3_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TABLE3_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow0_2)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree0_2;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree0_2;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow1;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow1;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree0_2;
WORKALLOCATEallocateWorkRow1)
    IF SQLM_TABLE3_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLE3_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=1;
!store packed key in work row!
    DO SQLS_TABLE3_UnPackKey;
!find an operating row.!
    SQLM_TABLE3_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right2,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        1;
    EXIT;
towGetSchLab1)
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_TABLE3_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_TABLE3_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree0_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree0_2)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
towGetRow0_3)
! Allocate a workrow.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowGetRowTableKeyBTree0_3;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowGetRowTableKeyBTree0_3;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow2;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow2;
!
$ We should never get here
!
    GOTO WORKFULLtowGetRowTableKeyBTree0_3;
WORKALLOCATEallocateWorkRow2)
    IF SQLM_TABLE3_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLE3_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=1;
!store packed key in work row!
    DO SQLS_TABLE3_UnPackKey;
!find an operating row.!
    SQLM_TABLE3_RootRow = SQLM_TableReference:SQLM_System + 2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right3,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        2;
    EXIT;
towGetSchLab2)
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if row is found, if not report failure!
    IF SQLM_TABLE3_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_TABLE3_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree0_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree0_3)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;

!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
towGetRowCursor0_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2;
        SQLX_WorkRow = SQLM_TABLE3_WorkRow;
    ELSIF SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2 = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_TABLE3_WorkRow;
    ELSE
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2,
            SQLM_TABLE3_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            +,
            +,
            3;
        EXIT;
    FI;
towGetSchLab3)
    SQLM_TABLE3_WorkRow = SQLX_WorkRow;
    SQLM_TABLE3_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_TABLE3_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated = 0 THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2 =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2 =
            SQLM_TABLE3_OperRow;
    FI;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_DBnumber2 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2;
! pack data in signal.!
    DO SQLS_TABLE3_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 1 THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor0_2)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_TABLE3_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right2,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        4;
    EXIT;
towGetSchLab4)
    SQLM_TABLE3_WorkRow = SQLX_WorkRow;
    SQLM_TABLE3_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_TABLE3_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_TABLE3_WorkRow:
            SQLC_TABLE3_COL1_Data=
                SQLM_TABLE3_OperRow:
                    SQLC_TABLE3_COL1_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2 =
        SQLM_TABLE3_OperRow;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_DBnumber2 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2;
! pack data in signal.!
    DO SQLS_TABLE3_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 1 THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor0_3)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_TABLE3_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right3,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        5;
    EXIT;
towGetSchLab5)
    SQLM_TABLE3_WorkRow = SQLX_WorkRow;
    SQLM_TABLE3_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_TABLE3_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_TABLE3_WorkRow:
            SQLC_TABLE3_COL4_Null=
                SQLM_TABLE3_OperRow:
                    SQLC_TABLE3_COL4_Null;
        SQLM_TABLE3_WorkRow:
            SQLC_TABLE3_COL4_Data=
                SQLM_TABLE3_OperRow:
                    SQLC_TABLE3_COL4_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2 =
        SQLM_TABLE3_OperRow;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_DBnumber2 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2;
! pack data in signal.!
    DO SQLS_TABLE3_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 1 THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
towGetRowCursor0_4)
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = 1;
    FI;
    SQLM_TABLE3_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right4,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
        6;
    EXIT;
towGetSchLab6)
    SQLM_TABLE3_WorkRow = SQLX_WorkRow;
    SQLM_TABLE3_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_TABLE3_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
    WHEN 1 DO
        SQLM_TABLE3_WorkRow:
            SQLC_TABLE3_COL5_Null=
                SQLM_TABLE3_OperRow:
                    SQLC_TABLE3_COL5_Null;
        SQLM_TABLE3_WorkRow:
            SQLC_TABLE3_COL5_Data=
                SQLM_TABLE3_OperRow:
                    SQLC_TABLE3_COL5_Data;
    OTHERWISE DO;
    ESAC;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2 =
        SQLM_TABLE3_OperRow;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_DBnumber2 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2;
! pack data in signal.!
    DO SQLS_TABLE3_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 1 THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock=2;
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 0;
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towGetFld !
!------------------------------------------------!
    ENTER towGetFld WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_OperRow,
        SQLX_DBnumber2,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
! set operating row.!
    SQLM_TABLE3_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_TABLE3_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TABLE3_Pack;
! check if read lock, if so report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
;
    EXIT;
!------------------------------------------------!
!       towGetKey !
!------------------------------------------------!
    ENTER towGetKey WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_OperRow,
        SQLX_DBnumber2,
        SQLX_KeyNumber;
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
! set operating row.!
    SQLM_TABLE3_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_TABLE3_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated = 0 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2 /=
        SQLX_DBnumber2
    THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_TABLE3_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 1 THEN
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
            ,SQLX_DR3
            ,SQLX_DR4
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,SQLX_DR20
            ,SQLX_DR21
            ,SQLX_DR22
            ,SQLX_DR23
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    EXIT;
!------------------------------------------------!
!       towOpen !
!------------------------------------------------!
    ENTER towOpen WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_KeyNumber,
        +,
        +
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
! allocate a work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowOpenTable0;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowOpenTable0;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow3;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow3;
!
$ We should never get here
!
    GOTO WORKFULLtowOpenTable0;
WORKALLOCATEallocateWorkRow3)
    IF SQLM_TABLE3_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLE3_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock=2;
! unpack key into work row.!
    DO SQLS_TABLE3_UnPackKey;
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_TABLE3_OperRow = SQLM_TABLE3_OperRow+1;
        FI;
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2 =
            SQLM_TABLE3_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2 = 0;
        ELSE
            SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2 =
                65535;
        FI;
    ESAC;
! send back success.!
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLE3_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable0)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable0)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towClose !
!------------------------------------------------!
    RECEIVE towClose WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow;
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
    SQLM_TABLE3_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! send back success.!
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towChaVolRow !
!------------------------------------------------!
!------------------------------------------------!
!       towInsRow !
!------------------------------------------------!
    ENTER towInsRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
!------------------------------------------------!
!       towInsRowTableBTree !
!------------------------------------------------!
    SQLM_TABLE3_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_TABLE3_NilRow = SQLM_TABLE3_GuardRow + 1;
! get free row.!
!------------------------------------------------!
!       getFromFreeList !
!------------------------------------------------!
! Get first row from free list !
SQLM_TABLE3_WorkRow =
    SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2;
IF SQLM_TABLE3_WorkRow /= SQLM_TABLE3_NilRow THEN
    SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2 =
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2;
FI;
    IF SQLM_TABLE3_WorkRow = SQLM_TABLE3_NilRow THEN
        SEND towInsRowR WITH
            SQLX_OtherProtected,
!  Error: Table full !
            3+9 <= 8;
        EXIT;
    FI;
! allocate row and unpack primary key.!
    SQLM_TABLE3_Workrow:SQLC_TABLE3_Allocated = 1;
    DO SQLS_TABLE3_UnpackKey;
! insert row in insert list (double linked).!
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_GuardRow:SQLC_TABLE3_Left2;
IF SQLM_TABLE3_TempRow /= SQLM_TABLE3_NilRow THEN
    SQLM_TABLE3_TempRow:SQLC_TABLE3_Right2 =
        SQLM_TABLE3_WorkRow;
FI;
SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_TempRow;
SQLM_TABLE3_GuardRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_WorkRow;
SQLM_TABLE3_WorkRow:SQLC_TABLE3_Right2 =
    SQLM_TABLE3_GuardRow;
! check if primary key is in insert list, if so jump to error.!
    SQLM_TABLE3_OperRow = SQLM_TABLE3_GuardRow;
    SQLX_Schedule = 0;
    SQLX_KeyPrefix = 1;
towInsSchLab1)
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towInsSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            1,
            SQLM_TABLE3_WorkRow,
            SQLM_TABLE3_OperRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            +,
            +,
            +,
            SQLX_KeyPrefix;
        EXIT;
    FI;
    SQLM_TABLE3_OperRow =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
    IF SQLM_TABLE3_OperRow /= SQLM_TABLE3_NilRow THEN
        IF SQLM_TABLE3_OperRow /= SQLM_TABLE3_WorkRow THEN
            DO SQLS_TABLE3_KeyTest2;
            IF SQLX_KeyTest = 1 GOTO ERRORtowInsRowTableBTree0;
        FI;
        GOTO towInsSchLab1;
    FI;
! check if primary key IS in tree, if so jump to error.!
    SQLM_TABLE3_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right2,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        7;
    EXIT;
towGetSchLab7)
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_OperRow=SQLX_Operrow;
    IF SQLM_TABLE3_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowInsRowTableBTree0;
! set default values and unpack data from D7 to D21.!
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL3_Null = 1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL4_Null = 0;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL4_Data = "xxx";
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL5_Null = 1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL6_Null = 1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL7_Null = 1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Null = 1;
    DO SQLS_TABLE3_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_TABLE3_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_TABLE3_WorkRow;
    FI;
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLE3_WorkRow;
    EXIT;
ERRORtowInsRowTableBTree0)
    SQLM_TABLE3_OperRow = SQLM_TABLE3_WorkRow;
    SQLM_TABLE3_GuardRow = SQLM_TableReference:SQLM_System;
! remove row from insert list.!
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
SQLM_TABLE3_TempRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;

IF SQLM_TABLE3_TempRow /= SQLM_TABLE3_NilRow THEN
    SQLM_TABLE3_TempRow:SQLC_TABLE3_Right2 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
FI;
! insert row in free list.!
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2;
SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2 =
    SQLM_TABLE3_OperRow;
! deallocate row.!
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0;
! send failure.!
    SEND towInsRowR WITH
        SQLX_OtherProtected,
! Search failure: Row already exists !
        2+5 <= 8;
    EXIT;
!------------------------------------------------!
!       towInsSch !
!------------------------------------------------!
    ENTER towInsSch WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLX_ReturnLabel,
        SQLM_TABLE3_WorkRow,
        SQLM_TABLE3_OperRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
,
        +,
        +,
        +,
        SQLX_KeyPrefix;
    SQLX_Schedule = 0;
    SQLM_TABLE3_NilRow=SQLM_TableReference:SQLM_System+1;
    GOTO towInsSchLab1;
!------------------------------------------------!
!       towChaRow !
!------------------------------------------------!
    ENTER towChaRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towChaRowTableKeyRow0;
    WHEN 1 DO GOTO towChaRowTableKeyCursor0;
    WHEN 2 DO GOTO towChaRowTableKeyBTree0;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
towChaRowTableKeyRow0)
! unpack key (set pOperRow).!
    DO SQLS_TABLE3_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_TABLE3_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TABLE3_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree0;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree0;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow4;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow4;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree0;
WORKALLOCATEallocateWorkRow4)
    IF SQLM_TABLE3_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLE3_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=1;
    GOTO towChaRowTableKeyContinue0;
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
towChaRowTableKeyCursor0)
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_TABLE3_UnPackkey;
    SQLM_TABLE3_OperRow =
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 2 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_TABLE3_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated = 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_TABLE3_WorkRow:SQLC_TABLE3_DBnumber2 /=
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
    THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 0 THEN
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TABLE3_OperRow;
        EXIT;
    FI;
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree0;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree0;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow5;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow5;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree0;
WORKALLOCATEallocateWorkRow5)
    IF SQLM_TABLE3_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLE3_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=1;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Color2 = 1;
    GOTO towChaRowTableKeyContinue0;
!------------------------------------------------!
!       towChaRowTableKeyBTree !
!------------------------------------------------!
towChaRowTableKeyBTree0)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowChaRowTableKeyBTree0;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowChaRowTableKeyBTree0;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow6;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow6;
!
$ We should never get here
!
    GOTO WORKFULLtowChaRowTableKeyBTree0;
WORKALLOCATEallocateWorkRow6)
    IF SQLM_TABLE3_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLE3_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=1;
! unpack key into the work row.!
    DO SQLS_TABLE3_UnPackKey;
! find an operating row.!
    SQLM_TABLE3_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right2,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        8;
    EXIT;
towGetSchLab8)
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_OperRow=SQLX_Operrow;
! check if row is not allocated, if so deallocate work row and report failure.!
    IF SQLM_TABLE3_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 0 THEN
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0;
        SEND towChaRowR WITH
            SQLX_OtherProtected,
            2+2 <= 8,
! Search failure: Row locked for update or delete !
            SQLM_TABLE3_OperRow;
        EXIT;
    FI;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Color2 = 1;
    GOTO towChaRowTableKeyContinue0;
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
towChaRowTableKeyContinue0)
! lock operating row.!
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock = 1;
! copy each column except primary key components.!
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL2_Data =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL2_Data;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL3_Null =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Null;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL3_Data =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Data;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL4_Null =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL4_Null;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL4_Data =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL4_Data;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL5_Null =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL5_Null;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL5_Data =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL5_Data;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL6_Null =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL6_Null;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL6_Data =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL6_Data;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL7_Null =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL7_Null;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL7_Data =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL7_Data;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Null =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Null;
!------------------------------------------------!
!       copyPackNum !
!------------------------------------------------!

    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.LENGTH =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.LENGTH;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W1 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W2 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W2;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W3 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W3;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W4 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W4;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W5 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W5;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W6 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W6;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W7 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W7;
! unpack column data.!
    DO SQLS_TABLE3_UnPack;
! insert row in insert list (double linked).!
    SQLM_TABLE3_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_TABLE3_NilRow = SQLM_TABLE3_GuardRow + 1;
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
! insert row in insertlist.!
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_GuardRow:SQLC_TABLE3_Left2;
IF SQLM_TABLE3_TempRow /= SQLM_TABLE3_NilRow THEN
    SQLM_TABLE3_TempRow:SQLC_TABLE3_Right2 =
        SQLM_TABLE3_WorkRow;
FI;
SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_TempRow;
SQLM_TABLE3_GuardRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_WorkRow;
SQLM_TABLE3_WorkRow:SQLC_TABLE3_Right2 =
    SQLM_TABLE3_GuardRow;
! send back success.!
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Color2=1;
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_WorkRow,
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree0)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree0)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRow !
!------------------------------------------------!
    ENTER towDelRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +,
        +,
        +
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towDelRowTableKeyRow0;
    WHEN 1 DO GOTO towDelRowTableKeyCursor0;
    WHEN 2 DO GOTO towDelRowTableKeyBTree0;
    OTHERWISE DO;
    ESAC;
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
towDelRowTableKeyRow0)
! unpack key (set pOperRow).!
    DO SQLS_TABLE3_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_TABLE3_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue0;
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
towDelRowTableKeyCursor0)
! unpack key (set pOperRow).!
    DO SQLS_TABLE3_UnPackkey;
    SQLM_TABLE3_OperRow =
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2;
! check if a row was not found, if so report failure.!
    IF SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 2 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_TABLE3_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated = 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_TABLE3_WorkRow:SQLC_TABLE3_DBnumber2 /=
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2
    THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue0;
!------------------------------------------------!
!       towDelRowTableKeyBTree !
!------------------------------------------------!
towDelRowTableKeyBTree0)
! allocate work row.!
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO WORKLOCKtowDelRowTableKeyBTree0;
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO WORKFULLtowDelRowTableKeyBTree0;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow7;
    FOR FIRST SQLM_TABLE3_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow7;
!
$ We should never get here
!
    GOTO WORKFULLtowDelRowTableKeyBTree0;
WORKALLOCATEallocateWorkRow7)
    IF SQLM_TABLE3_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_TABLE3_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=1;
! unpack key into work row.!
    DO SQLS_TABLE3_UnPackKey;
! find an operating row.!
    SQLM_TABLE3_RootRow = SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right2,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        3,
        1,
        +,
        9;
    EXIT;
towGetSchLab9)
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_OperRow=SQLX_Operrow;
! deallocate work row.!
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! check if a row is not found, if so report failure.!
    IF SQLM_TABLE3_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue0;

! Work area is locked !
WORKLOCKtowDelRowTableKeyBTree0)
    SEND towdelRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused!
        3 + 18 <= 8;
    EXIT;

! Work area is full!
WORKFULLtowDelRowTableKeyBTree0)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
towDelRowTableKeyContinue0)
! check if row is locked, if so report failure.!
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock > 0 THEN
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_TABLE3_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock  = 1;
! send back success.!
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_TABLE3_OperRow;
    EXIT;
!------------------------------------------------!
!       towLetFld !
!------------------------------------------------!
    ENTER towLetFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow,
        +,
        +,
        +
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
    SQLM_TABLE3_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_TABLE3_UnPack;
! send back success.!
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towVerRow !
!------------------------------------------------!
    ENTER towVerRow WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow;
    CASE SQLM_TableReference IS
    WHEN 0 DO GOTO towVerRowTable0;
    OTHERWISE DO
        SEND towVerRowR WITH
            SQLX_OtherProtected,
            0;
        EXIT;
    ESAC;
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
towVerRowTable0)
! execute user defined code !
!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat37;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat37;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat37;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat37;
PROTECTEDALLOCATEDbeginStat37)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat37)
ENABLE INTERRUPT;
! Error: Protected region congestion, too many simultaneous users !
    IF SQLCODE = 3 + 17 <= 8 THEN
        SEND towVerRowR WITH
            SQLX_OtherProtected,
            SQLCODE;
        EXIT;
    FI;
    PROTECTEDP:SQLLOCALCODE=0;
    PROTECTEDP:SQLBLOCK=SQLX_OtherBlock;
    PROTECTEDP:SQLOPERATION=SQLX_KeyOperation;
    PROTECTEDP:SQLX_SQLPROTECTED=SQLX_OtherProtected;
    PROTECTEDP:SQLX_SQLTABLEREFERENCE=SQLM_TableReference;
    PROTECTEDP:SQLX_SQLOPERROW=SQLX_OperRow;
    PROTECTEDP:SQLX_SQLWORKROW=SQLX_WorkRow;
    GOTO PREP1;
PREPRET)
    SQLX_OtherBlock=PROTECTEDP:SQLBLOCK;
    SQLX_KeyOperation=PROTECTEDP:SQLOPERATION;
    SQLX_OtherProtected=PROTECTEDP:SQLX_SQLPROTECTED;
    SQLM_TableReference=PROTECTEDP:SQLX_SQLTABLEREFERENCE;
    SQLX_OperRow=PROTECTEDP:SQLX_SQLOPERROW;
    SQLX_WorkRow=PROTECTEDP:SQLX_SQLWORKROW;
    SQLX_Code=PROTECTEDP:SQLLOCALCODE;
!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_CURSOR1_Cursor /= 0 THEN
        SEND towClose REFERENCE SQLM_Remote(1).block WITH
            PROTECTEDP,
            SQLM_Remote(1).table,
            PROTECTEDP:SQLM_CURSOR1_Cursor;
        WAIT FOR towCloseAck IN TOWCLOSEACK38;
TOWCLOSEACK38)
        RETRIEVE towCloseAck WITH
            PROTECTEDP;
    FI;
    PROTECTEDP:SQLM_CURSOR1_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=5;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab5)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;
    IF SQLX_Code /= 0 THEN
        SEND towVerRowR WITH
            SQLX_OtherProtected,
! Table local status code: !
            4 + SQLX_Code <= 8;
        EXIT;
    FI;
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable0;
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
! check alternate keys in insert list !
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_OperRow=SQLM_TableReference:SQLM_System;
    SQLM_TABLE3_NilRow=SQLM_TABLE3_OperRow+1;
    SQLX_Schedule=0;
LOOP1towVerRowTable0)
    SQLM_TABLE3_OperRow=SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
    IF SQLM_TABLE3_OperRow = SQLM_TABLE3_NilRow GOTO END1towVerRowTable0;
    IF SQLM_TABLE3_OperRow = SQLX_OperRow GOTO LOOP1towVerRowTable0;
    IF SQLM_TABLE3_OperRow = SQLX_WorkRow GOTO LOOP1towVerRowTable0;
    SQLX_KeyNumber=2;
LOOP2towVerRowTable0)
    SQLX_KeyNumber=SQLX_KeyNumber+1;
towVerSchLab1)
    CASE SQLX_KeyNumber IS
    WHEN 3 DO
        SQLX_Schedule=SQLX_Schedule+1;
        IF SQLX_Schedule > 16 THEN
            SEND towVerSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLX_OtherBlock,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLM_TABLE3_OperRow,
                SQLX_KeyNumber,
                1;
            EXIT;
        FI;
        SQLX_KeyPrefix=1;
        DO SQLS_TABLE3_KeyTest3;
    WHEN 4 DO GOTO LOOP1towVerRowTable0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    IF SQLX_KeyTest = 1 GOTO ERRORtowVerRowTable;
    GOTO LOOP2towVerRowTable0;
END1towVerRowTable0)
! check IF alternate key IS in btree !
    SQLM_TABLE3_OperRow=SQLX_OperRow;
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    IF SQLX_KeyOperation=1 THEN
        SQLX_KeyPrefix=1;
        DO SQLS_TABLE3_KeyTest3;
! used later in commit !
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_Color3=SQLX_KeyTest;
        IF SQLX_KeyTest=1 GOTO CONTINUE2towVerRowTable0_3;
    FI;
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        3,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right3,
        SQLX_WorkRow,
        SQLX_KeyOperation, ! use DR5 !
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        1,
        SQLX_OperRow,
        10;
    EXIT;
towGetSchLab10)
    SQLX_KeyOperation = SQLX_DR5;
    SQLM_TABLE3_OperRow=SQLX_OperRow;
    SQLX_OperRow=SQLX_RightTurn;
    IF SQLM_TABLE3_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowVerRowTable;
CONTINUE2towVerRowTable0_3)
! Check columns !
    SQLM_TABLE3_OperRow=SQLX_WorkRow;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!



    IF SQLM_TABLE3_OperRow:
            SQLC_TABLE3_COL3_Null = 1
        GOTO FAILUREtowVerRowTable0;




    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Data < 0
        GOTO FAILUREtowVerRowTable0;
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!







    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_COL2_Data < 0
        GOTO FAILUREtowVerRowTable0;


    GOTO CONTINUE1towVerRowTable0;
FAILUREtowVerRowTable0)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
CONTINUE1towVerRowTable0)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
ERRORtowVerRowTable)
! Send back uniqness error !
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Uniqueness constraint failure !
        3 + 3 <= 8;
    EXIT;
!------------------------------------------------!
!       towVerSch !
!------------------------------------------------!
    ENTER towVerSch WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_WorkRow,
        SQLX_TempRow,
        SQLX_KeyNumber,
        SQLX_ReturnLabel;
    SQLX_Schedule=0;
    SQLM_TABLE3_NilRow=SQLM_TableReference:SQLM_System+1;
    GOTO towVerSchLab1;
!------------------------------------------------!
!       towComRow !
!------------------------------------------------!
    ENTER towComRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2;
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
    SQLM_TABLE3_OperRow=SQLX_OperRow;
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
! test if we need to update key (only update) !
! wait until no one is locking the tree !
towComSchLab1)
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TABLE3_NilRow=SQLM_TABLE3_RootRow-1;
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Left4=SQLM_TABLE3_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            1;
        EXIT;
    FI;
    SQLM_TABLE3_RootRow:SQLC_TABLE3_Left4=SQLM_TABLE3_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab1;
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        4,
        1,
        1,
        +,
        SQLM_TABLE3_RootRow,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right4,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab1)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable0_4;
    SQLM_TABLE3_OperRow=SQLX_OperRow;
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL5_Null=
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL5_Null;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL5_Data=
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL5_Data;
LABEL1towComRowTable0_4)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab1;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        4,
        1,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab1)
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TABLE3_RootRow:SQLC_TABLE3_Left4=0;
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab2;
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    IF SQLM_TABLE3_WorkRow:SQLC_TABLE3_Color3=1
        GOTO LABEL2towComRowTable0_3;
! wait until no one is locking the tree !
towComSchLab2)
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TABLE3_NilRow=SQLM_TABLE3_RootRow-1;
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Left3=SQLM_TABLE3_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            2;
        EXIT;
    FI;
    SQLM_TABLE3_RootRow:SQLC_TABLE3_Left3=SQLM_TABLE3_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab2;
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        2,
        1,
        +,
        SQLM_TABLE3_RootRow,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right3,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab2)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable0_3;
    SQLM_TABLE3_OperRow=SQLX_OperRow;
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL4_Null=
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL4_Null;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL4_Data=
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL4_Data;
LABEL1towComRowTable0_3)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab2;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        3,
        2,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab2)
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TABLE3_RootRow:SQLC_TABLE3_Left3=0;
LABEL2towComRowTable0_3)
! test if we need to update key (only update) !
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab3;
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    IF SQLM_TABLE3_WorkRow:SQLC_TABLE3_Color2=1
        GOTO LABEL2towComRowTable0_2;
! wait until no one is locking the tree !
towComSchLab3)
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TABLE3_NilRow=SQLM_TABLE3_RootRow-1;
    IF SQLM_TABLE3_RootRow:SQLC_TABLE3_Left2=SQLM_TABLE3_NilRow THEN
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            3;
        EXIT;
    FI;
    SQLM_TABLE3_RootRow:SQLC_TABLE3_Left2=SQLM_TABLE3_NilRow;
! remove old key in tree (only for update and delete) !
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab3;
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        3,
        1,
        +,
        SQLM_TABLE3_RootRow,
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right2,
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab3)
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable0_2;
    SQLM_TABLE3_OperRow=SQLX_OperRow;
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL1_Data=
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL1_Data;
LABEL1towComRowTable0_2)
! insert new key (only for insert and update) !
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab3;
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        2,
        3,
        1,
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab3)
    SQLM_TABLE3_RootRow=SQLM_TableReference:SQLM_System+2;
    SQLM_TABLE3_RootRow:SQLC_TABLE3_Left2=0;
LABEL2towComRowTable0_2)
    SQLM_TABLE3_OperRow=SQLX_OperRow;
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber1 = SQLX_DBnumber1;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
        SQLM_TABLE3_OperRow=SQLX_WorkRow;
        SQLM_TABLE3_NilRow=SQLM_TableReference:SQLM_System+1;
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
SQLM_TABLE3_TempRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;

IF SQLM_TABLE3_TempRow /= SQLM_TABLE3_NilRow THEN
    SQLM_TABLE3_TempRow:SQLC_TABLE3_Right2 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
FI;
        SQLM_TABLE3_OperRow=SQLX_WorkRow;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL2_Data=
            SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL2_Data;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Null=
            SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL3_Null;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL3_Data=
            SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL3_Data;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL6_Null=
            SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL6_Null;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL6_Data=
            SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL6_Data;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL7_Null=
            SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL7_Null;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL7_Data=
            SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL7_Data;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Null=
            SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Null;
!------------------------------------------------!
!       copyPackNum !
!------------------------------------------------!

    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.LENGTH =
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.LENGTH;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W1 =
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W1;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W2 =
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W2;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W3 =
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W3;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W4 =
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W4;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W5 =
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W5;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W6 =
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W6;
    SQLM_TABLE3_OperRow:SQLC_TABLE3_COL8_Data.W7 =
        SQLM_TABLE3_WorkRow:SQLC_TABLE3_COL8_Data.W7;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
! update the data base number of the row. !
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber1 = SQLX_DBnumber1;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated=0;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable0;
towComSchLab4)
    IF SQLM_TABLE3_OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        SQLM_TABLE3_WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF SQLM_TABLE3_WorkRow > 24000 THEN
            FOR FIRST SQLM_TABLE3_WorkRow
                FROM SQLM_TABLE3_WorkRow-1
                UNTIL SQLM_TABLE3_WorkRow-24000
                WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 1
                GOTO FOUNDtowComRowTable0;
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                4;
            EXIT;
        ELSE
            FOR FIRST SQLM_TABLE3_WorkRow
                FROM SQLM_TABLE3_WorkRow-1
                WHERE SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated = 1
                GOTO FOUNDtowComRowTable0;
            SQLM_TABLE3_WorkRow=0;
        FI;
FOUNDtowComRowTable0)
        SQLM_TableReference:SQLM_TableLast=SQLM_TABLE3_WorkRow;
    FI;
CONTINUEtowComRowTable0)
! send back success !
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towComSch !
!------------------------------------------------!
    ENTER towComSch WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        SQLX_ReturnLabel;
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComSchLab1;
    WHEN 2 DO GOTO towComSchLab2;
    WHEN 3 DO GOTO towComSchLab3;
    WHEN 4 DO GOTO towComSchLab4;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKey !
!------------------------------------------------!
    ENTER towComInsKey WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        SQLX_KeyNumber,
        SQLX_ReturnLabel,
        SQLX_KeyPrefix,
        SQLX_GrandGrandFather,
        SQLX_GrandFather,
        SQLX_Father,
        SQLX_Current;
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComInsKeyTableKey0_2;
    WHEN 3 DO GOTO towComInsKeyTableKey0_3;
    WHEN 4 DO GOTO towComInsKeyTableKey0_4;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey0_2)
! Setup pointers and clear loop counter. !
    SQLM_TABLE3_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_TABLE3_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_TABLE3_GrandFather=SQLX_GrandFather;
    SQLM_TABLE3_Father=SQLX_Father;
    SQLM_TABLE3_OperRow=SQLX_Current;
    SQLM_TABLE3_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_TABLE3_OperRow = SQLM_TABLE3_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey0_2;
    FI;
LOOPtowComInsKeyTableKey0_2)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TABLE3_GrandGrandFather,
            SQLM_TABLE3_GrandFather,
            SQLM_TABLE3_Father,
            SQLM_TABLE3_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_TABLE3_OperRow = SQLM_TABLE3_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey0_2;
! Test key to be inserted against 'root' node. !
    DO SQLS_TABLE3_KeyTest2;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey0_2;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey0_2)
    SQLM_TABLE3_GrandGrandFather = SQLM_TABLE3_GrandFather;
    SQLM_TABLE3_GrandFather = SQLM_TABLE3_Father;
    SQLM_TABLE3_Father = SQLM_TABLE3_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TABLE3_OperRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
    ELSE
        SQLM_TABLE3_OperRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_TABLE3_TempRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
    IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2 = 0 THEN
        SQLM_TABLE3_TempRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
        IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2 = 0 THEN
! Top of a 4-node. !
            IF SQLM_TABLE3_OperRow = SQLM_TABLE3_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_TABLE3_OperRow=SQLM_TABLE3_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
SQLM_TABLE3_TempRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;

IF SQLM_TABLE3_TempRow /= SQLM_TABLE3_NilRow THEN
    SQLM_TABLE3_TempRow:SQLC_TABLE3_Right2 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
FI;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2 = 0;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2  =
                    SQLM_TABLE3_NilRow;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2 =
                    SQLM_TABLE3_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_TABLE3_WorkRow = SQLM_TABLE3_Father;
                DO SQLS_TABLE3_KeyTest2;
DISABLE INTERRUPT;
                SQLM_TABLE3_WorkRow = SQLM_TABLE3_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_TABLE3_Father:SQLC_TABLE3_Left2 =
                        SQLM_TABLE3_OperRow;
                ELSE
                    SQLM_TABLE3_Father:SQLC_TABLE3_Right2 =
                        SQLM_TABLE3_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2 = 1;
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2 = 1;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_TABLE3_Father:SQLC_TABLE3_Color2 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left2 =
                   SQLM_TABLE3_Father
                THEN
                    IF SQLM_TABLE3_Father:SQLC_TABLE3_Right2 =
                       SQLM_TABLE3_OperRow
                    THEN
! Double rotation !
                        SQLM_TABLE3_Father:SQLC_TABLE3_Right2 =
                            SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
                        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2 =
                            SQLM_TABLE3_Father;
                        SQLM_TABLE3_Father =
                            SQLM_TABLE3_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left2 =
                        SQLM_TABLE3_Father:SQLC_TABLE3_Right2;
                    SQLM_TABLE3_Father:SQLC_TABLE3_Right2 =
                        SQLM_TABLE3_GrandFather;
                ELSE
                    IF SQLM_TABLE3_Father:SQLC_TABLE3_Left2 =
                        SQLM_TABLE3_OperRow
                    THEN
! Double rotation !
                        SQLM_TABLE3_Father:SQLC_TABLE3_Left2 =
                            SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
                        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2 =
                            SQLM_TABLE3_Father;
                        SQLM_TABLE3_Father =
                            SQLM_TABLE3_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right2 =
                        SQLM_TABLE3_Father:SQLC_TABLE3_Left2;
                    SQLM_TABLE3_Father:SQLC_TABLE3_Left2 =
                        SQLM_TABLE3_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_Father:SQLC_TABLE3_Left2;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2 = 0;
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_Father:SQLC_TABLE3_Right2;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2 = 0;
                SQLM_TABLE3_Father:SQLC_TABLE3_Color2 = 1;
! Relink nodes !
                IF SQLM_TABLE3_GrandGrandFather:SQLC_TABLE3_Right2 =
                    SQLM_TABLE3_GrandFather
                THEN
                    SQLM_TABLE3_GrandGrandFather:SQLC_TABLE3_Right2 =
                        SQLM_TABLE3_Father;
                ELSE
                    SQLM_TABLE3_GrandGrandFather:SQLC_TABLE3_Left2 =
                        SQLM_TABLE3_Father;
                FI;
                SQLM_TABLE3_GrandFather =
                    SQLM_TABLE3_Father;
                SQLM_TABLE3_OperRow =
                    SQLM_TABLE3_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey0_2;
! Aftermath !
ENDLOOPtowComInsKeyTableKey0_2)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_TABLE3_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_TABLE3_TempRow =
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right2;
    SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey0_3)
! Setup pointers and clear loop counter. !
    SQLM_TABLE3_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_TABLE3_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_TABLE3_GrandFather=SQLX_GrandFather;
    SQLM_TABLE3_Father=SQLX_Father;
    SQLM_TABLE3_OperRow=SQLX_Current;
    SQLM_TABLE3_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_TABLE3_OperRow = SQLM_TABLE3_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey0_3;
    FI;
LOOPtowComInsKeyTableKey0_3)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TABLE3_GrandGrandFather,
            SQLM_TABLE3_GrandFather,
            SQLM_TABLE3_Father,
            SQLM_TABLE3_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_TABLE3_OperRow = SQLM_TABLE3_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey0_3;
! Test key to be inserted against 'root' node. !
    DO SQLS_TABLE3_KeyTest3;
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey0_3;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey0_3)
    SQLM_TABLE3_GrandGrandFather = SQLM_TABLE3_GrandFather;
    SQLM_TABLE3_GrandFather = SQLM_TABLE3_Father;
    SQLM_TABLE3_Father = SQLM_TABLE3_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TABLE3_OperRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3;
    ELSE
        SQLM_TABLE3_OperRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_TABLE3_TempRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3;
    IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3 = 0 THEN
        SQLM_TABLE3_TempRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3;
        IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3 = 0 THEN
! Top of a 4-node. !
            IF SQLM_TABLE3_OperRow = SQLM_TABLE3_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_TABLE3_OperRow=SQLM_TABLE3_WorkRow;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3 = 0;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3  =
                    SQLM_TABLE3_NilRow;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3 =
                    SQLM_TABLE3_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_TABLE3_WorkRow = SQLM_TABLE3_Father;
                DO SQLS_TABLE3_KeyTest3;
DISABLE INTERRUPT;
                SQLM_TABLE3_WorkRow = SQLM_TABLE3_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_TABLE3_Father:SQLC_TABLE3_Left3 =
                        SQLM_TABLE3_OperRow;
                ELSE
                    SQLM_TABLE3_Father:SQLC_TABLE3_Right3 =
                        SQLM_TABLE3_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3 = 1;
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3 = 1;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_TABLE3_Father:SQLC_TABLE3_Color3 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left3 =
                   SQLM_TABLE3_Father
                THEN
                    IF SQLM_TABLE3_Father:SQLC_TABLE3_Right3 =
                       SQLM_TABLE3_OperRow
                    THEN
! Double rotation !
                        SQLM_TABLE3_Father:SQLC_TABLE3_Right3 =
                            SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3;
                        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3 =
                            SQLM_TABLE3_Father;
                        SQLM_TABLE3_Father =
                            SQLM_TABLE3_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left3 =
                        SQLM_TABLE3_Father:SQLC_TABLE3_Right3;
                    SQLM_TABLE3_Father:SQLC_TABLE3_Right3 =
                        SQLM_TABLE3_GrandFather;
                ELSE
                    IF SQLM_TABLE3_Father:SQLC_TABLE3_Left3 =
                        SQLM_TABLE3_OperRow
                    THEN
! Double rotation !
                        SQLM_TABLE3_Father:SQLC_TABLE3_Left3 =
                            SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3;
                        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3 =
                            SQLM_TABLE3_Father;
                        SQLM_TABLE3_Father =
                            SQLM_TABLE3_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right3 =
                        SQLM_TABLE3_Father:SQLC_TABLE3_Left3;
                    SQLM_TABLE3_Father:SQLC_TABLE3_Left3 =
                        SQLM_TABLE3_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_Father:SQLC_TABLE3_Left3;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3 = 0;
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_Father:SQLC_TABLE3_Right3;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3 = 0;
                SQLM_TABLE3_Father:SQLC_TABLE3_Color3 = 1;
! Relink nodes !
                IF SQLM_TABLE3_GrandGrandFather:SQLC_TABLE3_Right3 =
                    SQLM_TABLE3_GrandFather
                THEN
                    SQLM_TABLE3_GrandGrandFather:SQLC_TABLE3_Right3 =
                        SQLM_TABLE3_Father;
                ELSE
                    SQLM_TABLE3_GrandGrandFather:SQLC_TABLE3_Left3 =
                        SQLM_TABLE3_Father;
                FI;
                SQLM_TABLE3_GrandFather =
                    SQLM_TABLE3_Father;
                SQLM_TABLE3_OperRow =
                    SQLM_TABLE3_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey0_3;
! Aftermath !
ENDLOOPtowComInsKeyTableKey0_3)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_TABLE3_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_TABLE3_TempRow =
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right3;
    SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
towComInsKeyTableKey0_4)
! Setup pointers and clear loop counter. !
    SQLM_TABLE3_NilRow = SQLM_TableReference:SQLM_System+1;
    SQLM_TABLE3_GrandGrandFather=SQLX_GrandGrandFather;
    SQLM_TABLE3_GrandFather=SQLX_GrandFather;
    SQLM_TABLE3_Father=SQLX_Father;
    SQLM_TABLE3_OperRow=SQLX_Current;
    SQLM_TABLE3_WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF SQLM_TABLE3_OperRow = SQLM_TABLE3_NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey0_4;
    FI;
LOOPtowComInsKeyTableKey0_4)
! Check if scheduling is necessary, if so schedule. !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TABLE3_GrandGrandFather,
            SQLM_TABLE3_GrandFather,
            SQLM_TABLE3_Father,
            SQLM_TABLE3_OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF SQLM_TABLE3_OperRow = SQLM_TABLE3_NilRow
        GOTO ENDLOOPtowComInsKeyTableKey0_4;
! Test key to be inserted against 'root' node. !
    DO SQLS_TABLE3_KeyTest4;
    IF SQLX_KeyTest = 1 THEN
! If key exist, abort. !
        IF SQLM_TABLE3_OperRow = SQLM_TABLE3_WorkRow GOTO ENDLOOPtowComInsKeyTableKey0_4;
        IF SQLM_TABLE3_OperRow > SQLM_TABLE3_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey0_4)
    SQLM_TABLE3_GrandGrandFather = SQLM_TABLE3_GrandFather;
    SQLM_TABLE3_GrandFather = SQLM_TABLE3_Father;
    SQLM_TABLE3_Father = SQLM_TABLE3_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TABLE3_OperRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4;
    ELSE
        SQLM_TABLE3_OperRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4;
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    SQLM_TABLE3_TempRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4;
    IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4 = 0 THEN
        SQLM_TABLE3_TempRow = SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4;
        IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4 = 0 THEN
! Top of a 4-node. !
            IF SQLM_TABLE3_OperRow = SQLM_TABLE3_NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                SQLM_TABLE3_OperRow=SQLM_TABLE3_WorkRow;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4 = 0;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4  =
                    SQLM_TABLE3_NilRow;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4 =
                    SQLM_TABLE3_NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                SQLM_TABLE3_WorkRow = SQLM_TABLE3_Father;
                DO SQLS_TABLE3_KeyTest4;
                IF SQLX_KeyTest = 1 THEN
                    IF SQLM_TABLE3_OperRow > SQLM_TABLE3_WorkRow THEN
                        SQLX_KeyTest = 2;
                    ELSE
                        SQLX_KeyTest = 0;
                    FI;
                FI;
DISABLE INTERRUPT;
                SQLM_TABLE3_WorkRow = SQLM_TABLE3_OperRow;
                IF SQLX_KeyTest < 1 THEN
                    SQLM_TABLE3_Father:SQLC_TABLE3_Left4 =
                        SQLM_TABLE3_OperRow;
                ELSE
                    SQLM_TABLE3_Father:SQLC_TABLE3_Right4 =
                        SQLM_TABLE3_OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4 = 1;
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4 = 1;
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4 = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF SQLM_TABLE3_Father:SQLC_TABLE3_Color4 = 0 THEN
DISABLE INTERRUPT;
                IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left4 =
                   SQLM_TABLE3_Father
                THEN
                    IF SQLM_TABLE3_Father:SQLC_TABLE3_Right4 =
                       SQLM_TABLE3_OperRow
                    THEN
! Double rotation !
                        SQLM_TABLE3_Father:SQLC_TABLE3_Right4 =
                            SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4;
                        SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4 =
                            SQLM_TABLE3_Father;
                        SQLM_TABLE3_Father =
                            SQLM_TABLE3_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left4 =
                        SQLM_TABLE3_Father:SQLC_TABLE3_Right4;
                    SQLM_TABLE3_Father:SQLC_TABLE3_Right4 =
                        SQLM_TABLE3_GrandFather;
                ELSE
                    IF SQLM_TABLE3_Father:SQLC_TABLE3_Left4 =
                        SQLM_TABLE3_OperRow
                    THEN
! Double rotation !
                        SQLM_TABLE3_Father:SQLC_TABLE3_Left4 =
                            SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4;
                        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4 =
                            SQLM_TABLE3_Father;
                        SQLM_TABLE3_Father =
                            SQLM_TABLE3_OperRow;
                    FI;
! Single rotation or end of double rotation !
                    SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right4 =
                        SQLM_TABLE3_Father:SQLC_TABLE3_Left4;
                    SQLM_TABLE3_Father:SQLC_TABLE3_Left4 =
                        SQLM_TABLE3_GrandFather;
                FI;
! Recolor father node and its children. !
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_Father:SQLC_TABLE3_Left4;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4 = 0;
                SQLM_TABLE3_TempRow =
                    SQLM_TABLE3_Father:SQLC_TABLE3_Right4;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4 = 0;
                SQLM_TABLE3_Father:SQLC_TABLE3_Color4 = 1;
! Relink nodes !
                IF SQLM_TABLE3_GrandGrandFather:SQLC_TABLE3_Right4 =
                    SQLM_TABLE3_GrandFather
                THEN
                    SQLM_TABLE3_GrandGrandFather:SQLC_TABLE3_Right4 =
                        SQLM_TABLE3_Father;
                ELSE
                    SQLM_TABLE3_GrandGrandFather:SQLC_TABLE3_Left4 =
                        SQLM_TABLE3_Father;
                FI;
                SQLM_TABLE3_GrandFather =
                    SQLM_TABLE3_Father;
                SQLM_TABLE3_OperRow =
                    SQLM_TABLE3_GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey0_4;
! Aftermath !
ENDLOOPtowComInsKeyTableKey0_4)
! Recolor root node (should ALWAYS be BLACK (1)) !
    SQLM_TABLE3_RootRow = SQLM_TableReference:SQLM_System+2;
    SQLM_TABLE3_TempRow =
        SQLM_TABLE3_RootRow:SQLC_TABLE3_Right4;
    SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4 = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComInsKeyLab1;
    WHEN 2 DO GOTO towComInsKeyLab2;
    WHEN 3 DO GOTO towComInsKeyLab3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKey !
!------------------------------------------------!
    ENTER towComDelKey WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        SQLX_KeyNumber,
        SQLX_ReturnLabel,
        SQLX_KeyPrefix,
        SQLX_GrandFather,
        SQLX_Father,
        SQLX_Current,
        SQLX_DeleteFather,
        SQLX_Delete;
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO GOTO towComDelKeyTableKey0_2;
    WHEN 3 DO GOTO towComDelKeyTableKey0_3;
    WHEN 4 DO GOTO towComDelKeyTableKey0_4;
    OTHERWISE DO ! nothing ! ;
    ESAC;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey0_2)
! Setup pointers !
    SQLM_TABLE3_GrandFather=SQLX_GrandFather;
    SQLM_TABLE3_Father=SQLX_Father;
    SQLM_TABLE3_OperRow=SQLX_Current;
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_DeleteFather=SQLX_DeleteFather;
    SQLM_TABLE3_Delete=SQLX_Delete;
    SQLM_TABLE3_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey0_2)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TABLE3_GrandFather,
            SQLM_TABLE3_Father,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_DeleteFather,
            SQLM_TABLE3_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_TABLE3_OperRow=SQLM_TABLE3_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey0_2;
! Test key. !
    DO SQLS_TABLE3_KeyTest2;
! Move down to next node !
    SQLM_TABLE3_GrandFather=SQLM_TABLE3_Father;
    SQLM_TABLE3_Father=SQLM_TABLE3_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TABLE3_OperRow=
            SQLM_TABLE3_Father:SQLC_TABLE3_Left2;
        SQLM_TABLE3_Brother=
            SQLM_TABLE3_Father:SQLC_TABLE3_Right2;
    ELSE
        SQLM_TABLE3_OperRow=
            SQLM_TABLE3_Father:SQLC_TABLE3_Right2;
        SQLM_TABLE3_Brother=
            SQLM_TABLE3_Father:SQLC_TABLE3_Left2;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2 (*)
        SQLM_TABLE3_Father:SQLC_TABLE3_Color2 (*)
        (-) SQLM_TABLE3_Brother:SQLC_TABLE3_Color2 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_TABLE3_Father:SQLC_TABLE3_Color2=0;
        SQLM_TABLE3_Brother:SQLC_TABLE3_Color2=1;
        IF SQLM_TABLE3_Father:SQLC_TABLE3_Right2=
            SQLM_TABLE3_Brother
        THEN
            SQLM_TABLE3_Father:SQLC_TABLE3_Right2=
                SQLM_TABLE3_Brother:SQLC_TABLE3_Left2;
            SQLM_TABLE3_Brother:SQLC_TABLE3_Left2=
                SQLM_TABLE3_Father;
        ELSE
            SQLM_TABLE3_Father:SQLC_TABLE3_Left2=
                SQLM_TABLE3_Brother:SQLC_TABLE3_Right2;
            SQLM_TABLE3_Brother:SQLC_TABLE3_Right2=
                SQLM_TABLE3_Father;
        FI;
        IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left2=
            SQLM_TABLE3_Father
        THEN
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left2=
                SQLM_TABLE3_Brother;
        ELSE
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right2=
                SQLM_TABLE3_Brother;
        FI;
        SQLM_TABLE3_GrandFather=SQLM_TABLE3_Brother;
        IF SQLM_TABLE3_Father:SQLC_TABLE3_Left2=
            SQLM_TABLE3_OperRow
        THEN
            SQLM_TABLE3_Brother=
                SQLM_TABLE3_Father:SQLC_TABLE3_Right2;
        ELSE
            SQLM_TABLE3_Brother=
                SQLM_TABLE3_Father:SQLC_TABLE3_Left2;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_TABLE3_Father:SQLC_TABLE3_Left2=
        SQLM_TABLE3_OperRow
    THEN
        SQLM_TABLE3_Nephew=
            SQLM_TABLE3_Brother:SQLC_TABLE3_Left2;
    ELSE
        SQLM_TABLE3_Nephew=
            SQLM_TABLE3_Brother:SQLC_TABLE3_Right2;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2=1 THEN
     SQLM_TABLE3_TempRow=
         SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
     IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2=1 THEN
      SQLM_TABLE3_TempRow=
          SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
      IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_TABLE3_Brother:SQLC_TABLE3_Color2=1 THEN
         SQLM_TABLE3_TempRow=
             SQLM_TABLE3_Brother:SQLC_TABLE3_Right2;
         IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2=1 THEN
          SQLM_TABLE3_TempRow=
              SQLM_TABLE3_Brother:SQLC_TABLE3_Left2;
          IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2=1 THEN
            SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2=0;
            SQLM_TABLE3_Brother:SQLC_TABLE3_Color2=0;
            SQLM_TABLE3_Father:SQLC_TABLE3_Color2=1;
            GOTO L2towComDelKeyTableKey0_2;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_TABLE3_Nephew:SQLC_TABLE3_Color2=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_TABLE3_Nephew:SQLC_TABLE3_Color2=
                SQLM_TABLE3_Father:SQLC_TABLE3_Color2;
            IF SQLM_TABLE3_Father:SQLC_TABLE3_Left2=
               SQLM_TABLE3_OperRow
            THEN
                SQLM_TABLE3_Father:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Left2;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Right2;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_Father;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_Brother;
            ELSE
                SQLM_TABLE3_Father:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Right2;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Left2;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_Father;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_Brother;
            FI;
            SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2=0;
            SQLM_TABLE3_Father:SQLC_TABLE3_Color2=1;
            IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left2=
               SQLM_TABLE3_Father
            THEN
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_Nephew;
            ELSE
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_Nephew;
            FI;
            SQLM_TABLE3_GrandFather=SQLM_TABLE3_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_TABLE3_Nephew:SQLC_TABLE3_Color2=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_TABLE3_Brother:SQLC_TABLE3_Color2=
                SQLM_TABLE3_Father:SQLC_TABLE3_Color2;
            IF SQLM_TABLE3_Father:SQLC_TABLE3_Left2=
               SQLM_TABLE3_OperRow
            THEN
                SQLM_TABLE3_TempRow=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Right2;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2=1;
                SQLM_TABLE3_Father:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Left2;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_Father;
            ELSE
                SQLM_TABLE3_TempRow=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Left2;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color2=1;
                SQLM_TABLE3_Father:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Right2;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_Father;
            FI;
            SQLM_TABLE3_OperRow:SQLC_TABLE3_Color2=0;
            SQLM_TABLE3_Father:SQLC_TABLE3_Color2=1;
            IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left2=
                SQLM_TABLE3_Father
            THEN
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left2=
                    SQLM_TABLE3_Brother;
            ELSE
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right2=
                    SQLM_TABLE3_Brother;
            FI;
            SQLM_TABLE3_GrandFather=SQLM_TABLE3_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey0_2)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_TABLE3_DeleteFather=SQLM_TABLE3_GrandFather;
        SQLM_TABLE3_Delete=SQLM_TABLE3_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey0_2;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey0_2)
    IF SQLM_TABLE3_Delete /= SQLM_TABLE3_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_TABLE3_DeleteFather:SQLC_TABLE3_Left2=
           SQLM_TABLE3_Delete
        THEN
            SQLM_TABLE3_DeleteFather:SQLC_TABLE3_Left2=
                SQLM_TABLE3_Father;
        ELSE
            SQLM_TABLE3_DeleteFather:SQLC_TABLE3_Right2=
                SQLM_TABLE3_Father;
        FI;
        IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left2=
           SQLM_TABLE3_Father
        THEN
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left2=
                SQLM_TABLE3_NilRow;
        ELSE
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right2=
                SQLM_TABLE3_NilRow;
        FI;
        IF SQLM_TABLE3_Father /= SQLM_TABLE3_Delete THEN
            SQLM_TABLE3_Father:SQLC_TABLE3_Color2=
                SQLM_TABLE3_Delete:SQLC_TABLE3_Color2;
            SQLM_TABLE3_Father:SQLC_TABLE3_Right2=
                SQLM_TABLE3_Delete:SQLC_TABLE3_Right2;
            SQLM_TABLE3_Father:SQLC_TABLE3_Left2=
                SQLM_TABLE3_Delete:SQLC_TABLE3_Left2;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
        SQLM_TABLE3_OperRow=SQLM_TABLE3_Delete;
        SQLM_TABLE3_GuardRow= SQLM_TableReference:SQLM_System;
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2;
SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2 =
    SQLM_TABLE3_OperRow;
        SQLM_TABLE3_Delete:SQLC_TABLE3_Allocated=0;
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey0_3)
! Setup pointers !
    SQLM_TABLE3_GrandFather=SQLX_GrandFather;
    SQLM_TABLE3_Father=SQLX_Father;
    SQLM_TABLE3_OperRow=SQLX_Current;
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_DeleteFather=SQLX_DeleteFather;
    SQLM_TABLE3_Delete=SQLX_Delete;
    SQLM_TABLE3_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey0_3)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TABLE3_GrandFather,
            SQLM_TABLE3_Father,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_DeleteFather,
            SQLM_TABLE3_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_TABLE3_OperRow=SQLM_TABLE3_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey0_3;
! Test key. !
    DO SQLS_TABLE3_KeyTest3;
! Move down to next node !
    SQLM_TABLE3_GrandFather=SQLM_TABLE3_Father;
    SQLM_TABLE3_Father=SQLM_TABLE3_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TABLE3_OperRow=
            SQLM_TABLE3_Father:SQLC_TABLE3_Left3;
        SQLM_TABLE3_Brother=
            SQLM_TABLE3_Father:SQLC_TABLE3_Right3;
    ELSE
        SQLM_TABLE3_OperRow=
            SQLM_TABLE3_Father:SQLC_TABLE3_Right3;
        SQLM_TABLE3_Brother=
            SQLM_TABLE3_Father:SQLC_TABLE3_Left3;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3 (*)
        SQLM_TABLE3_Father:SQLC_TABLE3_Color3 (*)
        (-) SQLM_TABLE3_Brother:SQLC_TABLE3_Color3 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_TABLE3_Father:SQLC_TABLE3_Color3=0;
        SQLM_TABLE3_Brother:SQLC_TABLE3_Color3=1;
        IF SQLM_TABLE3_Father:SQLC_TABLE3_Right3=
            SQLM_TABLE3_Brother
        THEN
            SQLM_TABLE3_Father:SQLC_TABLE3_Right3=
                SQLM_TABLE3_Brother:SQLC_TABLE3_Left3;
            SQLM_TABLE3_Brother:SQLC_TABLE3_Left3=
                SQLM_TABLE3_Father;
        ELSE
            SQLM_TABLE3_Father:SQLC_TABLE3_Left3=
                SQLM_TABLE3_Brother:SQLC_TABLE3_Right3;
            SQLM_TABLE3_Brother:SQLC_TABLE3_Right3=
                SQLM_TABLE3_Father;
        FI;
        IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left3=
            SQLM_TABLE3_Father
        THEN
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left3=
                SQLM_TABLE3_Brother;
        ELSE
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right3=
                SQLM_TABLE3_Brother;
        FI;
        SQLM_TABLE3_GrandFather=SQLM_TABLE3_Brother;
        IF SQLM_TABLE3_Father:SQLC_TABLE3_Left3=
            SQLM_TABLE3_OperRow
        THEN
            SQLM_TABLE3_Brother=
                SQLM_TABLE3_Father:SQLC_TABLE3_Right3;
        ELSE
            SQLM_TABLE3_Brother=
                SQLM_TABLE3_Father:SQLC_TABLE3_Left3;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_TABLE3_Father:SQLC_TABLE3_Left3=
        SQLM_TABLE3_OperRow
    THEN
        SQLM_TABLE3_Nephew=
            SQLM_TABLE3_Brother:SQLC_TABLE3_Left3;
    ELSE
        SQLM_TABLE3_Nephew=
            SQLM_TABLE3_Brother:SQLC_TABLE3_Right3;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3=1 THEN
     SQLM_TABLE3_TempRow=
         SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3;
     IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3=1 THEN
      SQLM_TABLE3_TempRow=
          SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3;
      IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_TABLE3_Brother:SQLC_TABLE3_Color3=1 THEN
         SQLM_TABLE3_TempRow=
             SQLM_TABLE3_Brother:SQLC_TABLE3_Right3;
         IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3=1 THEN
          SQLM_TABLE3_TempRow=
              SQLM_TABLE3_Brother:SQLC_TABLE3_Left3;
          IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3=1 THEN
            SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3=0;
            SQLM_TABLE3_Brother:SQLC_TABLE3_Color3=0;
            SQLM_TABLE3_Father:SQLC_TABLE3_Color3=1;
            GOTO L2towComDelKeyTableKey0_3;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_TABLE3_Nephew:SQLC_TABLE3_Color3=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_TABLE3_Nephew:SQLC_TABLE3_Color3=
                SQLM_TABLE3_Father:SQLC_TABLE3_Color3;
            IF SQLM_TABLE3_Father:SQLC_TABLE3_Left3=
               SQLM_TABLE3_OperRow
            THEN
                SQLM_TABLE3_Father:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Left3;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Right3;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_Father;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_Brother;
            ELSE
                SQLM_TABLE3_Father:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Right3;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Left3;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_Father;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_Brother;
            FI;
            SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3=0;
            SQLM_TABLE3_Father:SQLC_TABLE3_Color3=1;
            IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left3=
               SQLM_TABLE3_Father
            THEN
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_Nephew;
            ELSE
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_Nephew;
            FI;
            SQLM_TABLE3_GrandFather=SQLM_TABLE3_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_TABLE3_Nephew:SQLC_TABLE3_Color3=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_TABLE3_Brother:SQLC_TABLE3_Color3=
                SQLM_TABLE3_Father:SQLC_TABLE3_Color3;
            IF SQLM_TABLE3_Father:SQLC_TABLE3_Left3=
               SQLM_TABLE3_OperRow
            THEN
                SQLM_TABLE3_TempRow=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Right3;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3=1;
                SQLM_TABLE3_Father:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Left3;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_Father;
            ELSE
                SQLM_TABLE3_TempRow=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Left3;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color3=1;
                SQLM_TABLE3_Father:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Right3;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_Father;
            FI;
            SQLM_TABLE3_OperRow:SQLC_TABLE3_Color3=0;
            SQLM_TABLE3_Father:SQLC_TABLE3_Color3=1;
            IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left3=
                SQLM_TABLE3_Father
            THEN
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left3=
                    SQLM_TABLE3_Brother;
            ELSE
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right3=
                    SQLM_TABLE3_Brother;
            FI;
            SQLM_TABLE3_GrandFather=SQLM_TABLE3_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey0_3)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_TABLE3_DeleteFather=SQLM_TABLE3_GrandFather;
        SQLM_TABLE3_Delete=SQLM_TABLE3_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey0_3;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey0_3)
    IF SQLM_TABLE3_Delete /= SQLM_TABLE3_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_TABLE3_DeleteFather:SQLC_TABLE3_Left3=
           SQLM_TABLE3_Delete
        THEN
            SQLM_TABLE3_DeleteFather:SQLC_TABLE3_Left3=
                SQLM_TABLE3_Father;
        ELSE
            SQLM_TABLE3_DeleteFather:SQLC_TABLE3_Right3=
                SQLM_TABLE3_Father;
        FI;
        IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left3=
           SQLM_TABLE3_Father
        THEN
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left3=
                SQLM_TABLE3_NilRow;
        ELSE
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right3=
                SQLM_TABLE3_NilRow;
        FI;
        IF SQLM_TABLE3_Father /= SQLM_TABLE3_Delete THEN
            SQLM_TABLE3_Father:SQLC_TABLE3_Color3=
                SQLM_TABLE3_Delete:SQLC_TABLE3_Color3;
            SQLM_TABLE3_Father:SQLC_TABLE3_Right3=
                SQLM_TABLE3_Delete:SQLC_TABLE3_Right3;
            SQLM_TABLE3_Father:SQLC_TABLE3_Left3=
                SQLM_TABLE3_Delete:SQLC_TABLE3_Left3;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
towComDelKeyTableKey0_4)
! Setup pointers !
    SQLM_TABLE3_GrandFather=SQLX_GrandFather;
    SQLM_TABLE3_Father=SQLX_Father;
    SQLM_TABLE3_OperRow=SQLX_Current;
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
    SQLM_TABLE3_DeleteFather=SQLX_DeleteFather;
    SQLM_TABLE3_Delete=SQLX_Delete;
    SQLM_TABLE3_NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey0_4)
! Check if scheduling is needed !
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            SQLM_TABLE3_GrandFather,
            SQLM_TABLE3_Father,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_DeleteFather,
            SQLM_TABLE3_Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF SQLM_TABLE3_OperRow=SQLM_TABLE3_NilRow
        GOTO ENDLOOPtowComDelKeyTableKey0_4;
! Test key. !
    DO SQLS_TABLE3_KeyTest4;
    IF SQLX_KeyTest = 1 THEN
        IF SQLM_TABLE3_OperRow > SQLM_TABLE3_WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
! Move down to next node !
    SQLM_TABLE3_GrandFather=SQLM_TABLE3_Father;
    SQLM_TABLE3_Father=SQLM_TABLE3_OperRow;
    IF SQLX_KeyTest > 1 THEN
        SQLM_TABLE3_OperRow=
            SQLM_TABLE3_Father:SQLC_TABLE3_Left4;
        SQLM_TABLE3_Brother=
            SQLM_TABLE3_Father:SQLC_TABLE3_Right4;
    ELSE
        SQLM_TABLE3_OperRow=
            SQLM_TABLE3_Father:SQLC_TABLE3_Right4;
        SQLM_TABLE3_Brother=
            SQLM_TABLE3_Father:SQLC_TABLE3_Left4;
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4 (*)
        SQLM_TABLE3_Father:SQLC_TABLE3_Color4 (*)
        (-) SQLM_TABLE3_Brother:SQLC_TABLE3_Color4 = 1
    THEN
DISABLE INTERRUPT;
        SQLM_TABLE3_Father:SQLC_TABLE3_Color4=0;
        SQLM_TABLE3_Brother:SQLC_TABLE3_Color4=1;
        IF SQLM_TABLE3_Father:SQLC_TABLE3_Right4=
            SQLM_TABLE3_Brother
        THEN
            SQLM_TABLE3_Father:SQLC_TABLE3_Right4=
                SQLM_TABLE3_Brother:SQLC_TABLE3_Left4;
            SQLM_TABLE3_Brother:SQLC_TABLE3_Left4=
                SQLM_TABLE3_Father;
        ELSE
            SQLM_TABLE3_Father:SQLC_TABLE3_Left4=
                SQLM_TABLE3_Brother:SQLC_TABLE3_Right4;
            SQLM_TABLE3_Brother:SQLC_TABLE3_Right4=
                SQLM_TABLE3_Father;
        FI;
        IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left4=
            SQLM_TABLE3_Father
        THEN
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left4=
                SQLM_TABLE3_Brother;
        ELSE
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right4=
                SQLM_TABLE3_Brother;
        FI;
        SQLM_TABLE3_GrandFather=SQLM_TABLE3_Brother;
        IF SQLM_TABLE3_Father:SQLC_TABLE3_Left4=
            SQLM_TABLE3_OperRow
        THEN
            SQLM_TABLE3_Brother=
                SQLM_TABLE3_Father:SQLC_TABLE3_Right4;
        ELSE
            SQLM_TABLE3_Brother=
                SQLM_TABLE3_Father:SQLC_TABLE3_Left4;
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF SQLM_TABLE3_Father:SQLC_TABLE3_Left4=
        SQLM_TABLE3_OperRow
    THEN
        SQLM_TABLE3_Nephew=
            SQLM_TABLE3_Brother:SQLC_TABLE3_Left4;
    ELSE
        SQLM_TABLE3_Nephew=
            SQLM_TABLE3_Brother:SQLC_TABLE3_Right4;
    FI;
! If current-node is top-node of a 2-node. !
    IF SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4=1 THEN
     SQLM_TABLE3_TempRow=
         SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4;
     IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4=1 THEN
      SQLM_TABLE3_TempRow=
          SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4;
      IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF SQLM_TABLE3_Brother:SQLC_TABLE3_Color4=1 THEN
         SQLM_TABLE3_TempRow=
             SQLM_TABLE3_Brother:SQLC_TABLE3_Right4;
         IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4=1 THEN
          SQLM_TABLE3_TempRow=
              SQLM_TABLE3_Brother:SQLC_TABLE3_Left4;
          IF SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4=1 THEN
            SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4=0;
            SQLM_TABLE3_Brother:SQLC_TABLE3_Color4=0;
            SQLM_TABLE3_Father:SQLC_TABLE3_Color4=1;
            GOTO L2towComDelKeyTableKey0_4;
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF SQLM_TABLE3_Nephew:SQLC_TABLE3_Color4=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            SQLM_TABLE3_Nephew:SQLC_TABLE3_Color4=
                SQLM_TABLE3_Father:SQLC_TABLE3_Color4;
            IF SQLM_TABLE3_Father:SQLC_TABLE3_Left4=
               SQLM_TABLE3_OperRow
            THEN
                SQLM_TABLE3_Father:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Left4;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Right4;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_Father;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_Brother;
            ELSE
                SQLM_TABLE3_Father:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Right4;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_Nephew:SQLC_TABLE3_Left4;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_Father;
                SQLM_TABLE3_Nephew:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_Brother;
            FI;
            SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4=0;
            SQLM_TABLE3_Father:SQLC_TABLE3_Color4=1;
            IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left4=
               SQLM_TABLE3_Father
            THEN
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_Nephew;
            ELSE
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_Nephew;
            FI;
            SQLM_TABLE3_GrandFather=SQLM_TABLE3_Nephew;
ENABLE INTERRUPT;
        ELSIF SQLM_TABLE3_Nephew:SQLC_TABLE3_Color4=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            SQLM_TABLE3_Brother:SQLC_TABLE3_Color4=
                SQLM_TABLE3_Father:SQLC_TABLE3_Color4;
            IF SQLM_TABLE3_Father:SQLC_TABLE3_Left4=
               SQLM_TABLE3_OperRow
            THEN
                SQLM_TABLE3_TempRow=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Right4;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4=1;
                SQLM_TABLE3_Father:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Left4;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_Father;
            ELSE
                SQLM_TABLE3_TempRow=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Left4;
                SQLM_TABLE3_TempRow:SQLC_TABLE3_Color4=1;
                SQLM_TABLE3_Father:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_Brother:SQLC_TABLE3_Right4;
                SQLM_TABLE3_Brother:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_Father;
            FI;
            SQLM_TABLE3_OperRow:SQLC_TABLE3_Color4=0;
            SQLM_TABLE3_Father:SQLC_TABLE3_Color4=1;
            IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left4=
                SQLM_TABLE3_Father
            THEN
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left4=
                    SQLM_TABLE3_Brother;
            ELSE
                SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right4=
                    SQLM_TABLE3_Brother;
            FI;
            SQLM_TABLE3_GrandFather=SQLM_TABLE3_Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey0_4)
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        SQLM_TABLE3_DeleteFather=SQLM_TABLE3_GrandFather;
        SQLM_TABLE3_Delete=SQLM_TABLE3_Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey0_4;
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey0_4)
    IF SQLM_TABLE3_Delete /= SQLM_TABLE3_NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF SQLM_TABLE3_DeleteFather:SQLC_TABLE3_Left4=
           SQLM_TABLE3_Delete
        THEN
            SQLM_TABLE3_DeleteFather:SQLC_TABLE3_Left4=
                SQLM_TABLE3_Father;
        ELSE
            SQLM_TABLE3_DeleteFather:SQLC_TABLE3_Right4=
                SQLM_TABLE3_Father;
        FI;
        IF SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left4=
           SQLM_TABLE3_Father
        THEN
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Left4=
                SQLM_TABLE3_NilRow;
        ELSE
            SQLM_TABLE3_GrandFather:SQLC_TABLE3_Right4=
                SQLM_TABLE3_NilRow;
        FI;
        IF SQLM_TABLE3_Father /= SQLM_TABLE3_Delete THEN
            SQLM_TABLE3_Father:SQLC_TABLE3_Color4=
                SQLM_TABLE3_Delete:SQLC_TABLE3_Color4;
            SQLM_TABLE3_Father:SQLC_TABLE3_Right4=
                SQLM_TABLE3_Delete:SQLC_TABLE3_Right4;
            SQLM_TABLE3_Father:SQLC_TABLE3_Left4=
                SQLM_TABLE3_Delete:SQLC_TABLE3_Left4;
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO towComDelKeyLab1;
    WHEN 2 DO GOTO towComDelKeyLab2;
    WHEN 3 DO GOTO towComDelKeyLab3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towPostComRow !
!------------------------------------------------!
    ENTER towPostComRow WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow;
    CASE SQLM_TableReference IS
    WHEN 0 DO GOTO towPostComRowTable0;
    OTHERWISE DO
        SEND towPostComRowR WITH
            SQLX_OtherProtected,
            0;
        EXIT;
    ESAC;
!------------------------------------------------!
!       towPostComRowTable !
!------------------------------------------------!
towPostComRowTable0)
! execute user code !
!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat39;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat39;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat39;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat39;
PROTECTEDALLOCATEDbeginStat39)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat39)
ENABLE INTERRUPT;
    IF SQLCODE = 3 + 17 <= 8 THEN
! Error: Protected region congestion, too many simultaneous users !
        SEND towPostComRowR WITH
            SQLX_OtherProtected,
            SQLCODE;
        EXIT;
    FI;
    PROTECTEDP:SQLBLOCK=SQLX_OtherBlock;
    PROTECTEDP:SQLOPERATION=SQLX_KeyOperation;
    PROTECTEDP:SQLX_SQLPROTECTED=SQLX_OtherProtected;
    PROTECTEDP:SQLX_SQLWORKROW=0;
    PROTECTEDP:SQLX_SQLOPERROW=SQLX_OperRow;
    GOTO POST1;
POSTRET)
    SQLX_OtherProtected=PROTECTEDP:SQLX_SQLPROTECTED;
!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_CURSOR1_Cursor /= 0 THEN
        SEND towClose REFERENCE SQLM_Remote(1).block WITH
            PROTECTEDP,
            SQLM_Remote(1).table,
            PROTECTEDP:SQLM_CURSOR1_Cursor;
        WAIT FOR towCloseAck IN TOWCLOSEACK40;
TOWCLOSEACK40)
        RETRIEVE towCloseAck WITH
            PROTECTEDP;
    FI;
    PROTECTEDP:SQLM_CURSOR1_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=6;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab6)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;
! send back success !
    SEND towPostComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towRollBck !
!------------------------------------------------!
    ENTER towRollBck WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow;
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
!--------------------------------------!
!       beginStat       !
!--------------------------------------!
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat41;
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat41;
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat41;
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat41;
PROTECTEDALLOCATEDbeginStat41)
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat41)
ENABLE INTERRUPT;
    IF SQLCODE = 3 + 17 <= 8 THEN
! Error: Protected region congestion, too many simultaneous users !
        SEND towRollBckR WITH
            SQLX_OtherProtected,
            SQLCODE;
        EXIT;
    FI;
    PROTECTEDP:SQLBLOCK=SQLX_OtherBlock;
    PROTECTEDP:SQLOPERATION=SQLX_KeyOperation;
    PROTECTEDP:SQLX_SQLPROTECTED=SQLX_OtherProtected;
    PROTECTEDP:SQLX_SQLTABLEREFERENCE=SQLM_TableReference;
    PROTECTEDP:SQLX_SQLOPERROW=SQLX_OperRow;
    PROTECTEDP:SQLX_SQLWORKROW=SQLX_WorkRow;
! execute user specified code !
    GOTO ROLL1;
ROLLRET)
    SQLX_OtherBlock=PROTECTEDP:SQLBLOCK;
    SQLX_KeyOperation=PROTECTEDP:SQLOPERATION;
    SQLX_OtherProtected=PROTECTEDP:SQLX_SQLPROTECTED;
    SQLM_TableReference=PROTECTEDP:SQLX_SQLTABLEREFERENCE;
    SQLX_OperRow=PROTECTEDP:SQLX_SQLOPERROW;
    SQLX_WorkRow=PROTECTEDP:SQLX_SQLWORKROW;
!--------------------------------------!
!       endStat !
!--------------------------------------!
! If there are any cursors open, close them. !
    IF PROTECTEDP:SQLM_CURSOR1_Cursor /= 0 THEN
        SEND towClose REFERENCE SQLM_Remote(1).block WITH
            PROTECTEDP,
            SQLM_Remote(1).table,
            PROTECTEDP:SQLM_CURSOR1_Cursor;
        WAIT FOR towCloseAck IN TOWCLOSEACK42;
TOWCLOSEACK42)
        RETRIEVE towCloseAck WITH
            PROTECTEDP;
    FI;
    PROTECTEDP:SQLM_CURSOR1_Cursor=0;
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=7;
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab7)
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;
! remove work rows and release locks !
    SQLM_TABLE3_GuardRow=SQLM_TableReference:SQLM_System;
    SQLM_TABLE3_NilRow=SQLM_TABLE3_GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        SQLM_TABLE3_OperRow=SQLX_WorkRow;
! remove row from insert list !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
SQLM_TABLE3_TempRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;

IF SQLM_TABLE3_TempRow /= SQLM_TABLE3_NilRow THEN
    SQLM_TABLE3_TempRow:SQLC_TABLE3_Right2 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
FI;
! insert row in free list !
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
! Put pOperRow first into free list.!
SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2;
SQLM_TABLE3_GuardRow:SQLC_TABLE3_Right2 =
    SQLM_TABLE3_OperRow;
! deallocate work row !
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated=0;
    WHEN 1 DO
        SQLM_TABLE3_OperRow=SQLX_WorkRow;
! remove row from insert list. !
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
! Remove row from insert list !
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
SQLM_TABLE3_TempRow:SQLC_TABLE3_Left2 =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
SQLM_TABLE3_TempRow =
    SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;

IF SQLM_TABLE3_TempRow /= SQLM_TABLE3_NilRow THEN
    SQLM_TABLE3_TempRow:SQLC_TABLE3_Right2 =
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
FI;
        SQLM_TABLE3_WorkRow=SQLX_WorkRow;
        SQLM_TABLE3_OperRow=SQLX_OperRow;
! deallocate work row !
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
! Deallocate a work row !
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock=0;
    WHEN 2 DO
        SQLM_TABLE3_OperRow=SQLX_OperRow;
        SQLM_TABLE3_OperRow:SQLC_TABLE3_Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
!------------------------------------------------!
!       towChaLock !
!------------------------------------------------!
    RECEIVE towChaLock WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow,
        SQLX_OldLock,
        SQLX_Lock,
        SQLX_DBnumber2;
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
    SQLM_TABLE3_WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock THEN
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock = 0 THEN
        IF SQLM_TABLE3_WorkRow:SQLC_TABLE3_DBnumber2 /=
            SQLX_DBnumber2
        THEN
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    SQLM_TABLE3_WorkRow:SQLC_TABLE3_Lock=SQLX_Lock;
! send back success !
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
!--------------------------------!
!       towGetTabNam!
!--------------------------------!
    RECEIVE towGetTabNam WITH
        SQLX_OtherProtected,
        SQLM_TableReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    OTHERWISE DO
        RETURN towGetTabNamAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetTabDat!
!--------------------------------!
    RECEIVE towGetTabDat WITH
        SQLX_OtherProtected,
        SQLM_TableReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TABLE3_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TABLE3_DBnumber TO SQLX_BaseAddress2;
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        1,
        1,
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        1,
        0,
        1,
        1,
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0,
        4;
    OTHERWISE DO
        RETURN towGetTabDatAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetFldNam!
!--------------------------------!
    RECEIVE towGetFldNam WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 1 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 2 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "column 1";
    WHEN 3 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "column 2";
    WHEN 4 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "column 3";
    WHEN 5 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "column 4";
    WHEN 6 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 7 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 8 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    WHEN 9 DO
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        "";
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetStrFld!
!--------------------------------!
    RECEIVE towGetStrFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 2 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLE3_COL1_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    WHEN 5 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TABLE3_COL4_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TABLE3_COL4_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        2,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "xxx",
        1;
    WHEN 7 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TABLE3_COL6_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TABLE3_COL6_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        4,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    WHEN 6 DO
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TABLE3_COL5_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TABLE3_COL5_Data TO
        SQLX_BaseAddress2;
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
        4,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        "",
        1;
    OTHERWISE DO
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetNumFld!
!--------------------------------!
    RECEIVE towGetNumFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 3 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    SQLX_BaseAddress1=0;
    VARIABLENUMBER FOR SQLC_TABLE3_COL2_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        1,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        0, 0,
        0,
        65535,
        1;
    WHEN 4 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TABLE3_COL3_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TABLE3_COL3_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        65535,
        1;
    WHEN 8 DO
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TABLE3_COL7_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TABLE3_COL7_Data TO
        SQLX_BaseAddress2;
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0,
        0,
        1,
        1;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetPckFld!
!--------------------------------!
    RECEIVE towGetPckFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 9 DO
!--------------------------------!
!       towGetPckFldTableColumn!
!--------------------------------!
    VARIABLENUMBER FOR SQLC_TABLE3_COL8_Null TO
        SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_TABLE3_COL8_Data TO
        SQLX_BaseAddress2;
    RETURN towGetPckFldAck WITH
        SQLX_OtherProtected,
        0,
        0,
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
        2, 0, 0, 0, 0, 0, 0, 0, 0,
        1;
    OTHERWISE DO
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetKeyFld!
!--------------------------------!
    RECEIVE towGetKeyFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLX_ComponentReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        0;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 2 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        2;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        5;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
    CASE SQLX_ComponentReference IS
    WHEN 0 DO
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        6;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetKeyDat!
!--------------------------------!
    RECEIVE towGetKeyDat WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
    CASE SQLX_KeyNumber IS
    WHEN 2 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        0,
        1;
    EXIT;
    WHEN 3 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        1,
        1;
    EXIT;
    WHEN 4 DO
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
        2,
        1;
    EXIT;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
    OTHERWISE DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetFks!
!--------------------------------!
    RECEIVE towGetFks WITH
        SQLX_OtherProtected,
        SQLM_TableReference;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
! send back success.!
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        0,
        0;
    OTHERWISE DO
        RETURN towGetFksAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetFkInf!
!--------------------------------!
    RECEIVE towGetFkInf WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
    OTHERWISE DO
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetFlt!
!--------------------------------!
    RECEIVE towGetFlt WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_FaultCode;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
    OTHERWISE DO
        RETURN towGetFltAck WITH SQLX_OtherProtected, 1;
    ESAC;
!--------------------------------!
!       towGetPreFlt!
!--------------------------------!
    RECEIVE towGetPreFlt WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_FaultCode;
        SQLX_ReturnCode=1;
    RETURN towGetPreFltAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_FaultCode;
!--------------------------------!
!       towGetSymbol!
!--------------------------------!
    RECEIVE towGetSymbol WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference,
        SQLX_SymbolValue;
    SQLX_ReturnCode=0;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
   CASE SQLX_ColumnReference IS
    WHEN 8 DO
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
    CASE SQLX_SymbolValue IS
    WHEN 0 DO
        SQLX_Symbol="FALSE";
    WHEN 1 DO
        SQLX_Symbol="TRUE";
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    OTHERWISE DO SQLX_ReturnCode=1;
    ESAC;
    RETURN towGetSymbolAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_Symbol;
!--------------------------------!
!       towGetSymVal!
!--------------------------------!
    RECEIVE towGetSymVal WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference,
        SQLX_Symbol;
    SQLX_ReturnCode=0;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 8 DO
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
    CASE SQLX_Symbol IS
    WHEN "FALSE" DO
        SQLX_SymbolValue=0;
    WHEN "TRUE" DO
        SQLX_SymbolValue=1;
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=2;
    ESAC;
    OTHERWISE DO SQLX_ReturnCode=1;
    ESAC;
    RETURN towGetSymValAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_SymbolValue;
!--------------------------------!
!       towGetPreSym!
!--------------------------------!
    RECEIVE towGetPreSym WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference,
        SQLX_SymbolValue;
    SQLX_ReturnCode=0;
    CASE SQLM_TableReference IS
    WHEN 0 DO
!--------------------------------!
!       towGetPreSymTable!
!--------------------------------!
    CASE SQLX_ColumnReference IS
    WHEN 8 DO
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
    IF SQLX_SymbolValue > 1 THEN
        SQLX_SymbolValue=1;
        SQLX_Symbol="TRUE";
    ELSIF SQLX_SymbolValue > 0 THEN
        SQLX_SymbolValue=0;
        SQLX_Symbol="FALSE";
    ELSE
        SQLX_ReturnCode=3;
    FI;
    OTHERWISE DO SQLX_ReturnCode=2;
    ESAC;
    OTHERWISE DO
        SQLX_ReturnCode=1;
    ESAC;
    RETURN towGetPreSymAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_SymbolValue,
        SQLX_Symbol;
!------------------------------------------------!
!       RESTARTPHASE1 !
!------------------------------------------------!
RESTARTPHASE1)
! Send table data to Data Dictionary !
    SEND ddhInitTable WITH
        1,
        cOwnRef,
        0,
        "TABLE3",
        0,
        0,
        0;
    EXIT;
ddhInitTableLab1)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        1,
        cOwnRef,
        0,
        "DBNUM",
        1,
        2,
        6,
        32,
        1;
    EXIT;
ddhInitFieldLab1)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        2,
        cOwnRef,
        0,
        "COL1",
        2,
        2,
        1,
        15,
        1;
    EXIT;
ddhInitFieldLab2)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        3,
        cOwnRef,
        0,
        "COL2",
        3,
        2,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab3)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        4,
        cOwnRef,
        0,
        "COL3",
        4,
        2,
        0,
        16,
        1;
    EXIT;
ddhInitFieldLab4)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        5,
        cOwnRef,
        0,
        "COL4",
        5,
        2,
        1,
        15,
        1;
    EXIT;
ddhInitFieldLab5)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        6,
        cOwnRef,
        0,
        "COL5",
        6,
        2,
        2,
        7,
        1;
    EXIT;
ddhInitFieldLab6)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        7,
        cOwnRef,
        0,
        "COL6",
        7,
        2,
        1,
        31,
        1;
    EXIT;
ddhInitFieldLab7)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        8,
        cOwnRef,
        0,
        "COL7",
        8,
        2,
        4,
        1,
        1;
    EXIT;
ddhInitFieldLab8)
! Send column data to Data Dictionary !
    SEND ddhInitField WITH
        9,
        cOwnRef,
        0,
        "COL8",
        9,
        2,
        3,
        28,
        1;
    EXIT;
ddhInitFieldLab9)
    GOTO RESTARTEND;
!------------------------------------------------!
!       RESTARTPHASE2 !
!------------------------------------------------!
!------------------------------------------------!
!       RESTARTPHASE4 !
!------------------------------------------------!
RESTARTPHASE4)
! Clear work area. !
    SQLM_TableReference=0;
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_TABLE3_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_TABLE3_WorkRow:SQLC_TABLE3_Allocated=0;
    FI;
    GOTO RESTARTEND;
!------------------------------------------------!
!       RESTARTPHASE5 !
!------------------------------------------------!
!------------------------------------------------!
!       towDdhInitTableR !
!------------------------------------------------!
    ENTER ddhInitTableR WITH SQLX_ReturnLabel;
    GOTO ddhInitTableLab1;
!------------------------------------------------!
!       towDdhInitFieldR !
!------------------------------------------------!
    ENTER ddhInitFIeldR WITH SQLX_ReturnLabel;
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO ddhInitFieldLab1;
    WHEN 2 DO GOTO ddhInitFieldLab2;
    WHEN 3 DO GOTO ddhInitFieldLab3;
    WHEN 4 DO GOTO ddhInitFieldLab4;
    WHEN 5 DO GOTO ddhInitFieldLab5;
    WHEN 6 DO GOTO ddhInitFieldLab6;
    WHEN 7 DO GOTO ddhInitFieldLab7;
    WHEN 8 DO GOTO ddhInitFieldLab8;
    WHEN 9 DO GOTO ddhInitFieldLab9;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!------------------------------------------------!
!       towDdhInitFkR !
!------------------------------------------------!
!------------------------------------------------!
!       towGetSch !
!------------------------------------------------!
    ENTER towGetSch WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLX_OperRow,
        SQLX_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLX_ReturnLabel;
    CASE SQLM_TableReference IS

    WHEN 0 DO
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
    SQLM_TABLE3_OperRow = SQLX_OperRow;
    SQLM_TABLE3_WorkRow = SQLX_WorkRow;
    SQLM_TABLE3_NilRow = SQLM_Tablereference:SQLM_System+1;
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree0_2)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_TABLE3_OperRow /= SQLM_TABLE3_NilRow THEN
        DO SQLS_TABLE3_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            SQLM_TABLE3_OperRow =
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
            GOTO LOOPtowGetSchTableKeyBTree0_2;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_TABLE3_OperRow =
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
            GOTO LOOPtowGetSchTableKeyBTree0_2;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree0_3)
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_TABLE3_OperRow /= SQLM_TABLE3_NilRow THEN
        DO SQLS_TABLE3_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            SQLM_TABLE3_OperRow =
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3;
            GOTO LOOPtowGetSchTableKeyBTree0_3;

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_TABLE3_OperRow =
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3;
            GOTO LOOPtowGetSchTableKeyBTree0_3;
        FI;
    FI;
! Return the row found !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    ELSE
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_TABLE3_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_TABLE3_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_TABLE3_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow0;
! find first allocated row, then schedule if necessary !
    IF SQLM_TABLE3_OperRow < 24000 THEN
        FOR FIRST SQLM_TABLE3_OperRow
            FROM SQLM_TABLE3_OperRow-1
            WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow0;
        GOTO FAILEDtowGetSchTableCursorRow0;
    ELSE
        FOR FIRST SQLM_TABLE3_OperRow
            FROM SQLM_TABLE3_OperRow-1
            UNTIL SQLM_TABLE3_OperRow-24000
            WHERE SQLM_TABLE3_OperRow:SQLC_TABLE3_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow0;
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow0)
    SQLM_TABLE3_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow0)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_TABLE3_OperRow,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 2 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree0_2)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_TABLE3_OperRow /= SQLM_TABLE3_NilRow THEN
        DO SQLS_TABLE3_KeyTest2;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_TABLE3_OperRow;
                FI;
            FI;
            SQLM_TABLE3_OperRow =
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_TABLE3_OperRow <
                SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2
            THEN
                SQLX_RightTurn = SQLM_TABLE3_OperRow;
                SQLM_TABLE3_OperRow =
                  SQLM_TABLE3_OperRow:SQLC_TABLE3_Right2;
            ELSE
                SQLM_TABLE3_OperRow =
                  SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
            FI;
        ELSE
            SQLM_TABLE3_OperRow =
              SQLM_TABLE3_OperRow:SQLC_TABLE3_Left2;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree0_2;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 3 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree0_3)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 16 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_TABLE3_OperRow /= SQLM_TABLE3_NilRow THEN
        DO SQLS_TABLE3_KeyTest3;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_TABLE3_OperRow;
                FI;
            FI;
            SQLM_TABLE3_OperRow =
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_TABLE3_OperRow <
                SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2
            THEN
                SQLX_RightTurn = SQLM_TABLE3_OperRow;
                SQLM_TABLE3_OperRow =
                  SQLM_TABLE3_OperRow:SQLC_TABLE3_Right3;
            ELSE
                SQLM_TABLE3_OperRow =
                  SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3;
            FI;
        ELSE
            SQLM_TABLE3_OperRow =
              SQLM_TABLE3_OperRow:SQLC_TABLE3_Left3;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree0_3;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        WHEN 4 DO
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree0_4)
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > 17 THEN
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_TABLE3_OperRow,
            SQLM_TABLE3_WorkRow
            ,SQLX_DR5
            ,SQLX_DR6
            ,SQLX_DR7
            ,SQLX_DR8
            ,SQLX_DR9
            ,SQLX_DR10
            ,SQLX_DR11
            ,SQLX_DR12
            ,SQLX_DR13
            ,SQLX_DR14
            ,SQLX_DR15
            ,SQLX_DR16
            ,SQLX_DR17
            ,SQLX_DR18
            ,SQLX_DR19
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_TABLE3_OperRow /= SQLM_TABLE3_NilRow THEN
        DO SQLS_TABLE3_KeyTest4;
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_TABLE3_OperRow;
                FI;
            FI;
            SQLM_TABLE3_OperRow =
                SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4;
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_TABLE3_OperRow <
                SQLM_TABLE3_WorkRow:SQLC_TABLE3_Left2
            THEN
                SQLX_RightTurn = SQLM_TABLE3_OperRow;
                SQLM_TABLE3_OperRow =
                  SQLM_TABLE3_OperRow:SQLC_TABLE3_Right4;
            ELSE
                SQLM_TABLE3_OperRow =
                  SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4;
            FI;
        ELSE
            SQLM_TABLE3_OperRow =
              SQLM_TABLE3_OperRow:SQLC_TABLE3_Left4;
        FI;
        GOTO LOOPtowGetSchTableCursorBTree0_4;
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_TABLE3_WorkRow
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
        OTHERWISE DO;
        ESAC;
    FI;

    WHEN 1 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab1;

    WHEN 2 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab2;

    WHEN 3 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab3;

    WHEN 4 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab4;

    WHEN 5 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab5;

    WHEN 6 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab6;

    WHEN 7 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab7;

    WHEN 8 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab8;

    WHEN 9 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab9;

    WHEN 10 DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab10;
    OTHERWISE DO;
    ESAC;
    EXIT;

!------------------------------------------------!
!       tuPlexCode !
!------------------------------------------------!
!------------------------------------------------!
!       comPlexCode !
!------------------------------------------------!
!------------------------------------------------!
!       RESTARTPHASE3 !
!------------------------------------------------!
RESTARTPHASE3)
! Ask for block and table reference for remote table !
    SEND ddhTabRef WITH
        1,
        cOwnRef,
        "TABLE2";
    EXIT;
ddhTabRefLab1)
    SQLM_Remote(0).block=SQLX_OtherBlock;
    SQLM_Remote(0).table=SQLX_TableReference;
! Ask for block and table reference for remote table !
    SEND ddhTabRef WITH
        2,
        cOwnRef,
        "TABLE1";
    EXIT;
ddhTabRefLab2)
    SQLM_Remote(1).block=SQLX_OtherBlock;
    SQLM_Remote(1).table=SQLX_TableReference;
    GOTO RESTARTEND;
!------------------------------------------------!
!       tuDdhTabRefR !
!------------------------------------------------!
    ENTER ddhTabRefR WITH
        SQLX_ReturnLabel,
        SQLX_ReturnCode,
        SQLX_OtherBlock,
        SQLX_TableReference;
    CASE SQLX_ReturnLabel IS
    WHEN 1 DO GOTO ddhTabRefLab1;
    WHEN 2 DO GOTO ddhTabRefLab2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!        recTusReAllProt !
!--------------------------------------!
    RECEIVE TusReAllProt WITH
        PROTECTEDP,
        SQLX_OtherProtected;
    PROTECTEDP:SQLM_Allocated = 1;
    RETURN TusReAllProtAck WITH
        SQLX_OtherProtected;
!--------------------------------------!
!       recTowGetR      !
!--------------------------------------!
   ENTER towGetR WITH
        PROTECTEDP,
        SQLCODE,
        SQLX_OperRow,
        SQLX_DBnumber2
        ,SQLX_DR3
        ,SQLX_DR4
        ,SQLX_DR5
        ,SQLX_DR6
        ,SQLX_DR7
        ,SQLX_DR8
        ,SQLX_DR9
        ,SQLX_DR10
        ,SQLX_DR11
        ,SQLX_DR12
        ,SQLX_DR13
        ,SQLX_DR14
        ,SQLX_DR15
        ,SQLX_DR16
        ,SQLX_DR17
        ,SQLX_DR18
        ,SQLX_DR19
        ,SQLX_DR20
        ,SQLX_DR21
        ,SQLX_DR22
        ,SQLX_DR23
        ;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO towGetLab1;
    WHEN 2 DO GOTO towGetLab2;
    WHEN 3 DO GOTO towGetLab3;
    WHEN 4 DO GOTO towGetLab4;
    WHEN 5 DO GOTO towGetLab5;
    WHEN 6 DO GOTO towGetLab6;
    WHEN 7 DO GOTO towGetLab7;
    WHEN 8 DO GOTO towGetLab8;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recTowChaVolRowR        !
!--------------------------------------!
    ENTER towChaVolRowR WITH
        PROTECTEDP,
        SQLCODE;
    GOTO towChaVolRowLab1;
    EXIT;
!--------------------------------------!
!       recTrhInsRowR   !
!--------------------------------------!
    ENTER trhInsRowR WITH
        PROTECTEDP,
        SQLCODE;
    GOTO trhInsRowLab1;
    EXIT;
!--------------------------------------!
!       recTrhLetFldR    !
!--------------------------------------!
    ENTER TrhLetFldR WITH
        PROTECTEDP,
        SQLCODE;
    GOTO trhLetFldLab1;
    EXIT;
!--------------------------------------!
!       recTrhChaRowR   !
!--------------------------------------!
    ENTER trhChaRowR WITH
        PROTECTEDP,
        SQLCODE;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO trhChaRowLab1;
    WHEN 2 DO GOTO trhChaRowLab2;
    WHEN 3 DO GOTO trhChaRowLab3;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recTrhDelRowR   !
!--------------------------------------!
    ENTER trhDelRowR WITH
        PROTECTEDP,
        SQLCODE;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO trhDelRowLab1;
    WHEN 2 DO GOTO trhDelRowLab2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recTowOpenR     !
!--------------------------------------!
    ENTER towOpenR WITH
        PROTECTEDP,
        SQLCODE,
        SQLX_OperRow;
    GOTO towOpenLab1;
    EXIT;
!--------------------------------------!
!       recTrhStaTransR !
!--------------------------------------!
    ENTER trhStaTransR WITH
        PROTECTEDP,
        SQLCODE,
        PROTECTEDP:SQLTRANSID;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO trhStaTransLab1;
    WHEN 2 DO GOTO trhStaTransLab2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recTrhVerTransR !
!--------------------------------------!
    ENTER trhVerTransR WITH
        PROTECTEDP,
        SQLCODE,
        PROTECTEDP:SQLBLOCK,
        PROTECTEDP:SQLTABLE;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO trhVerTransLab1;
    WHEN 2 DO GOTO trhVerTransLab2;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recTrhComTransR !
!--------------------------------------!
    ENTER trhComTransR WITH
        PROTECTEDP,
        SQLCODE,
        PROTECTEDP:SQLBLOCK,
        PROTECTEDP:SQLTABLE;
    GOTO trhComTransLab1;
    EXIT;
!--------------------------------------!
!       recTrhRollBckR  !
!--------------------------------------!
    ENTER trhRollBckR WITH
        PROTECTEDP,
        SQLCODE;
    CASE PROTECTEDP:SQLX_SQLRETURN IS
    WHEN 1 DO GOTO trhRollBckLab1;
    WHEN 2 DO GOTO trhRollBckLab2;
    WHEN 3 DO GOTO trhRollBckLab3;
    WHEN 4 DO GOTO trhRollBckLab4;
    WHEN 5 DO GOTO trhRollBckLab5;
    WHEN 6 DO GOTO trhRollBckLab6;
    WHEN 7 DO GOTO trhRollBckLab7;
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
!--------------------------------------!
!       recContinueB !
!--------------------------------------!
    ENTER CONTINUEB WITH
        PROTECTEDP,
        SQLX_ReturnLabel;
    GOTO continueBLab1;
    EXIT;
!--------------------------------------!
!       recContinueC !
!--------------------------------------!
!END SQL!
END PROGRAM;
!BEGIN SQL COMMON 0!
!------------------------------------------------!
!       towAsaCode !
!------------------------------------------------!
!------------------------------------------------!
!       comAsaCode !
!------------------------------------------------!
!------------------------------------------------!
!       sPack !
!------------------------------------------------!

PROGRAM SQLS_TABLE3_Pack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_TABLE3_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_1)
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_1;
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,9
        ADDR    EXIT_1!
LHC CR/W0-9; JGT WR1,EXIT_1;
LHC CR/W0-0; JER WR1,L0_1;!        ADDR    L0_1!
LHC CR/W0-1; JER WR1,L1_1;!        ADDR    L1_1!
LHC CR/W0-2; JER WR1,L2_1;!        ADDR    L2_1!
LHC CR/W0-3; JER WR1,L3_1;!        ADDR    L3_1!
LHC CR/W0-4; JER WR1,L4_1;!        ADDR    L4_1!
LHC CR/W0-5; JER WR1,L5_1;!        ADDR    L5_1!
LHC CR/W0-6; JER WR1,L6_1;!        ADDR    L6_1!
LHC CR/W0-7; JER WR1,L7_1;!        ADDR    L7_1!
LHC CR/W0-8; JER WR1,L8_1;!        ADDR    L8_1!
LHC CR/W0-9; JER WR1,L9_1;!        ADDR    L9_1!

L0_1)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_1;

L1_1)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_TABLE3_DBnumber;
        WS      SQLX_TempData-WR2;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        RSII    SQLX_DR3-WR1,IR,DR4,DR23;
        ACC     SQLX_DR3-1;
        JLN LOOP_1;

L2_1)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLE3_COL1_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-8;
        JLN     LOOP_1;

L3_1)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLE3_COL2_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_1;

L4_1)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLE3_COL3_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_TABLE3_COL3_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_1;

L5_1)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLE3_COL4_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_TABLE3_COL4_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-8;
        JLN     LOOP_1;

L6_1)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLE3_COL5_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_TABLE3_COL5_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-4;
        JLN     LOOP_1;

L7_1)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLE3_COL6_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_TABLE3_COL6_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    AWCD    SQLX_DR3-16;
        JLN     LOOP_1;

L8_1)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLE3_COL7_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLC_TABLE3_COL7_Data;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_1;

L9_1)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
    LBNBA   WR1-SQLC_TABLE3_COL8_Null;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    LBNBA   WR1-SQLX_TempData;
    RSS     WR2-SQLC_TABLE3_COL8_Data/W0;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TABLE3_COL8_Data/W1;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TABLE3_COL8_Data/W2;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TABLE3_COL8_Data/W3;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TABLE3_COL8_Data/W4;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TABLE3_COL8_Data/W5;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TABLE3_COL8_Data/W6;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_TABLE3_COL8_Data/W7;
    WS      SQLX_TempData-WR2;
    RSII    SQLX_DR3-WR1,IR,DR4,DR23;
    ACC     SQLX_DR3-1;
        JLN     LOOP_1;
EXIT_1)
        SCC     SQLX_DR3-10;                         !adress of DR4!
        MFR     SQLX_DR4-DR4;
        MFR     SQLX_DR5-DR5;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;
!------------------------------------------------!
!       sUnpack !
!------------------------------------------------!

PROGRAM SQLS_TABLE3_UnPack; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_TABLE3_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_2)
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_2;
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,9
        ADDR    EXIT_2!
LHC CR/W0-9; JGT WR1,EXIT_2;
LHC CR/W0-0; JER WR1,EXIT_2;!        ADDR    EXIT_2!
LHC CR/W0-1; JER WR1,EXIT_2;!        ADDR    EXIT_2!
LHC CR/W0-2; JER WR1,L2_2;!        ADDR L2_2!
LHC CR/W0-3; JER WR1,L3_2;!        ADDR L3_2!
LHC CR/W0-4; JER WR1,L4_2;!        ADDR L4_2!
LHC CR/W0-5; JER WR1,L5_2;!        ADDR L5_2!
LHC CR/W0-6; JER WR1,L6_2;!        ADDR L6_2!
LHC CR/W0-7; JER WR1,L7_2;!        ADDR L7_2!
LHC CR/W0-8; JER WR1,L8_2;!        ADDR L8_2!
LHC CR/W0-9; JER WR1,L9_2;!        ADDR L9_2!

L2_2)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack column data.!
        LBNBA   WR1-SQLC_TABLE3_COL1_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-8;
        JLN     LOOP_2;

L3_2)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE3_2;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLE3_COL2_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_2;
UPDATE3_2)
! read column data into register WR3.!
        RS      WR3-SQLC_TABLE3_COL2_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_TABLE3_COL2_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
! read column data into register WR4.!
        RS      WR4-SQLC_TABLE3_COL2_Data;
! should we add the values together?!
        JEC     WR2,1,ADD3_2;
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_TABLE3_COL2_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_2;
ADD3_2)
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_TABLE3_COL2_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_2;

L4_2)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TABLE3_COL3_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_TABLE3_COL3_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_2;

L5_2)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TABLE3_COL4_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_TABLE3_COL4_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-8;
        JLN     LOOP_2;

L6_2)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TABLE3_COL5_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_TABLE3_COL5_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-4;
        JLN     LOOP_2;

L7_2)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TABLE3_COL6_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_TABLE3_COL6_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        AWCD    WR0-16;
        JLN     LOOP_2;

L8_2)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TABLE3_COL7_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
! unpack column data.!
        LBNBA   WR1-SQLC_TABLE3_COL7_Data;
        WSII    WR1-WR0,IR,DR6,DR19;
        ACC     WR0-1;
        JLN     LOOP_2;

L9_2)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
! unpack null indicator.!
        LBNBA   WR1-SQLC_TABLE3_COL8_Null;
        WSII    WR1-WR0,IR,DR6,DR19;
! increase pointer where to get packed data.!
        ACC     WR0-1;
    LBNBA   WR1-SQLX_TempData;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TABLE3_COL8_Data/W0-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TABLE3_COL8_Data/W1-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TABLE3_COL8_Data/W2-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TABLE3_COL8_Data/W3-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TABLE3_COL8_Data/W4-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TABLE3_COL8_Data/W5-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TABLE3_COL8_Data/W6-WR5;
    ACC     WR0-1;
    WSII    WR1-WR0,IR,DR6,DR19;
    RS      WR5-SQLX_TempData;
    WSS     SQLC_TABLE3_COL8_Data/W7-WR5;
    ACC     WR0-1;
        JLN     LOOP_2;

EXIT_2)
END PROGRAM;
!------------------------------------------------!
!       sPackKey !
!------------------------------------------------!

PROGRAM SQLS_TABLE3_packKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_TABLE3_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
!        JTR     SQLX_KeyNumber,4!
LHC CR/W0-4;
JGT SQLX_KeyNumber,EXIT_3;!        ADDR    EXIT_3!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_3;!        ADDR    L0_3!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_3;!        ADDR    EXIT_3!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_3;!        ADDR    L2_3!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_3;!        ADDR    L3_3!
LHC CR/W0-4; JER SQLX_KeyNumber,L4_3;!        ADDR    L4_3!

L0_3)
        MFR     SQLX_DR23-SQLM_TABLE3_OperRow;
        JLN     EXIT_3;

L2_3)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-8;
        LBNBA   WR1-SQLC_TABLE3_COL1_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_3;

L3_3)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-8;
        LBNBA   WR1-SQLC_TABLE3_COL4_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_TABLE3_COL4_Null;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_3;

L4_3)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
        SCC     SQLX_DR3-4;
        LBNBA   WR1-SQLC_TABLE3_COL5_Data;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_TABLE3_COL5_Null;
        RSII    SQLX_DR3-WR1,IR,DR6,DR23;
        JLN     EXIT_3;

EXIT_3)
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
        MFR     SQLX_DR6-DR6;
        MFR     SQLX_DR7-DR7;
        MFR     SQLX_DR8-DR8;
        MFR     SQLX_DR9-DR9;
        MFR     SQLX_DR10-DR10;
        MFR     SQLX_DR11-DR11;
        MFR     SQLX_DR12-DR12;
        MFR     SQLX_DR13-DR13;
        MFR     SQLX_DR14-DR14;
        MFR     SQLX_DR15-DR15;
        MFR     SQLX_DR16-DR16;
        MFR     SQLX_DR17-DR17;
        MFR     SQLX_DR18-DR18;
        MFR     SQLX_DR19-DR19;
        MFR     SQLX_DR20-DR20;
        MFR     SQLX_DR21-DR21;
        MFR     SQLX_DR22-DR22;
        MFR     SQLX_DR23-DR23;
END PROGRAM;

!------------------------------------------------!
!       sUnPackKey !
!------------------------------------------------!

PROGRAM SQLS_TABLE3_UnPackKey; ASA210C;
        MFR     DR6-SQLX_DR6;
        MFR     DR7-SQLX_DR7;
        MFR     DR8-SQLX_DR8;
        MFR     DR9-SQLX_DR9;
        MFR     DR10-SQLX_DR10;
        MFR     DR11-SQLX_DR11;
        MFR     DR12-SQLX_DR12;
        MFR     DR13-SQLX_DR13;
        MFR     DR14-SQLX_DR14;
        MFR     DR15-SQLX_DR15;
        MFR     DR16-SQLX_DR16;
        MFR     DR17-SQLX_DR17;
        MFR     DR18-SQLX_DR18;
        MFR     DR19-SQLX_DR19;
        MFR     DR20-SQLX_DR20;
        MFR     DR21-SQLX_DR21;
        MFR     DR22-SQLX_DR22;
        MFR     DR23-SQLX_DR23;
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_TABLE3_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
! jump to key unpack code.!
!        JTR     SQLX_KeyNumber,4!
LHC CR/W0-4;
JGT SQLX_KeyNumber,EXIT_4;!        ADDR    EXIT_4!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_4;!        ADDR    L0_4!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_4;!        ADDR    L1_4!
LHC CR/W0-2; JER SQLX_KeyNumber,L2_4;!        ADDR    L2_4!
LHC CR/W0-3; JER SQLX_KeyNumber,L3_4;!        ADDR    L3_4!
LHC CR/W0-4; JER SQLX_KeyNumber,L4_4;!        ADDR    L4_4!

L0_4)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
        MFR     SQLM_TABLE3_OperRow-SQLX_DR23;
        JLN     EXIT_4;

L1_4)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
        MFR     SQLM_TABLE3_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
        JLN     EXIT_4;

L2_4)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-8;
        LBNBA   WR1-SQLC_TABLE3_COL1_Data;
        LCC     WR3-8;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_4;

L3_4)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-8;
        LBNBA   WR1-SQLC_TABLE3_COL4_Data;
        LCC     WR3-8;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_TABLE3_COL4_Null;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_4;

L4_4)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
        SCC     WR0-4;
        LBNBA   WR1-SQLC_TABLE3_COL5_Data;
        LCC     WR3-4;
        WSII    WR1-WR0,WR3,DR6,DR23;
        SCC     WR0-1;
        LBNBA   WR1-SQLC_TABLE3_COL5_Null;
        LCC     WR3-1;
        WSII    WR1-WR0,WR3,DR6,DR23;
        JLN     EXIT_4;

EXIT_4)
END PROGRAM;
!------------------------------------------------!
!       sKeyTestN !
!------------------------------------------------!

PROGRAM SQLS_TABLE3_KeyTest2; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_5;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! Check which string variable is less using the new assembler
  instruction CS. !
        MFR     WR1-SQLM_TABLE3_OperRow;
        MFR     WR2-SQLM_TABLE3_WorkRow;
        CS      SQLC_TABLE3_COL1_Data,WR1,
                SQLC_TABLE3_COL1_Data,WR2;
        MFR     SQLX_KeyTest-CR;
        JUC     CR,1,EXIT_5;

EQUAL_5)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
EXIT_5)
END PROGRAM;

PROGRAM SQLS_TABLE3_KeyTest3; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_6;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! If the component have a null indicator check the values. A column
  which is null (1) is always lower than a row which is not null (0). !
        MFR     PR0-SQLM_TABLE3_OperRow;
        RS      WR1-SQLC_TABLE3_COL4_Null;
        MFR     PR0-SQLM_TABLE3_WorkRow;
        RS      CR-SQLC_TABLE3_COL4_Null;
        JLT     WR1,GREATER_6;
        JGT     WR1,LESS_6;
        JEC     WR1,1,L5_6;
! Check which string variable is less using the new assembler
  instruction CS. !
        MFR     WR1-SQLM_TABLE3_OperRow;
        MFR     WR2-SQLM_TABLE3_WorkRow;
        CS      SQLC_TABLE3_COL4_Data,WR1,
                SQLC_TABLE3_COL4_Data,WR2;
        MFR     SQLX_KeyTest-CR;
        JUC     CR,1,EXIT_6;
L5_6)

EQUAL_6)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_6;

LESS_6)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_6;

GREATER_6)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_6)
END PROGRAM;

PROGRAM SQLS_TABLE3_KeyTest4; ASA210C;
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_7;
! Test next component !
        SCC     SQLX_KeySuffix-1;
! If the component have a null indicator check the values. A column
  which is null (1) is always lower than a row which is not null (0). !
        MFR     PR0-SQLM_TABLE3_OperRow;
        RS      WR1-SQLC_TABLE3_COL5_Null;
        MFR     PR0-SQLM_TABLE3_WorkRow;
        RS      CR-SQLC_TABLE3_COL5_Null;
        JLT     WR1,GREATER_7;
        JGT     WR1,LESS_7;
        JEC     WR1,1,L6_7;
! Check which string variable is less using the new assembler
  instruction CS. !
        MFR     WR1-SQLM_TABLE3_OperRow;
        MFR     WR2-SQLM_TABLE3_WorkRow;
        CS      SQLC_TABLE3_COL5_Data,WR1,
                SQLC_TABLE3_COL5_Data,WR2;
        MFR     SQLX_KeyTest-CR;
        JUC     CR,1,EXIT_7;
L6_7)

EQUAL_7)
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
        JLN     EXIT_7;

LESS_7)
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_7;

GREATER_7)
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
EXIT_7)
END PROGRAM;
!------------------------------------------------!
!       genSigSurv !
!------------------------------------------------!

!------------------------------------------------!
!       tuAsaCode !
!------------------------------------------------!
!------------------------------------------------!
!       comAsaCode !
!------------------------------------------------!
!------------------------------------------------!
!       sPackX !
!------------------------------------------------!

PROGRAM SQLS_Pack1; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-SQLM_1,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack2; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-SQLM_1,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack3; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-36 * 7,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack4; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-SQLM_1,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack5; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-SQLM_1,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack6; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-4;
    RSI     DR8-SQLM_2,WR0,4;
    MFR     SQLX_DR8-DR8;
    MFR     SQLX_DR9-DR9;
    MFR     SQLX_DR10-DR10;
    MFR     SQLX_DR11-DR11;
END PROGRAM;

PROGRAM SQLS_Pack7; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-4;
    RSI     DR7-SQLM_1,WR0,4;
    MFR     SQLX_DR7-DR7;
    MFR     SQLX_DR8-DR8;
    MFR     SQLX_DR9-DR9;
    MFR     SQLX_DR10-DR10;
END PROGRAM;

PROGRAM SQLS_Pack8; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-35432,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack9; ASA210C;
    LCC     IR-0;
    LCC     WR0-4;
    RSI     DR9-C,WR0,4;
    MFR     SQLX_DR9-DR9;
    MFR     SQLX_DR10-DR10;
    MFR     SQLX_DR11-DR11;
    MFR     SQLX_DR12-DR12;
END PROGRAM;

PROGRAM SQLS_Pack10; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-1,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack11; ASA210C;
    LCC     IR-0;
    LCC     WR0-4;
    RSI     DR9-3,WR0,4;
    MFR     SQLX_DR9-DR9;
    MFR     SQLX_DR10-DR10;
    MFR     SQLX_DR11-DR11;
    MFR     SQLX_DR12-DR12;
END PROGRAM;

PROGRAM SQLS_Pack12; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-C,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack13; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-SQLM_1,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack14; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-SQLM_1,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;

PROGRAM SQLS_Pack15; ASA210C;
    MFR     PR0-PROTECTEDP;
    LCC     IR-0;
    LCC     WR0-8;
    RSI     DR16-SQLM_1,WR0,8;
    MFR     SQLX_DR16-DR16;
    MFR     SQLX_DR17-DR17;
    MFR     SQLX_DR18-DR18;
    MFR     SQLX_DR19-DR19;
    MFR     SQLX_DR20-DR20;
    MFR     SQLX_DR21-DR21;
    MFR     SQLX_DR22-DR22;
    MFR     SQLX_DR23-DR23;
END PROGRAM;
!------------------------------------------------!
!       sUnPackX !
!------------------------------------------------!

PROGRAM SQLS_UnPack1; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    MFR     DR4-SQLX_DR4;
    MFR     DR5-SQLX_DR5;
    MFR     DR6-SQLX_DR6;
    MFR     DR7-SQLX_DR7;
    MFR     DR8-SQLX_DR8;
    MFR     DR9-SQLX_DR9;
    MFR     DR10-SQLX_DR10;
    MFR     DR11-SQLX_DR11;
    WSI     A-DR4,WR0,8;
END PROGRAM;

PROGRAM SQLS_UnPack2; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    MFR     DR4-SQLX_DR4;
    MFR     DR5-SQLX_DR5;
    MFR     DR6-SQLX_DR6;
    MFR     DR7-SQLX_DR7;
    MFR     DR8-SQLX_DR8;
    MFR     DR9-SQLX_DR9;
    MFR     DR10-SQLX_DR10;
    MFR     DR11-SQLX_DR11;
    WSI     C1-DR4,WR0,8;
END PROGRAM;

PROGRAM SQLS_UnPack3; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    MFR     DR4-SQLX_DR4;
    MFR     DR5-SQLX_DR5;
    MFR     DR6-SQLX_DR6;
    MFR     DR7-SQLX_DR7;
    MFR     DR8-SQLX_DR8;
    MFR     DR9-SQLX_DR9;
    MFR     DR10-SQLX_DR10;
    MFR     DR11-SQLX_DR11;
    WSI     C1-DR4,WR0,8;
END PROGRAM;

PROGRAM SQLS_UnPack4; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    MFR     DR4-SQLX_DR4;
    MFR     DR5-SQLX_DR5;
    MFR     DR6-SQLX_DR6;
    MFR     DR7-SQLX_DR7;
    MFR     DR8-SQLX_DR8;
    MFR     DR9-SQLX_DR9;
    MFR     DR10-SQLX_DR10;
    MFR     DR11-SQLX_DR11;
    WSI     C1-DR4,WR0,8;
END PROGRAM;

PROGRAM SQLS_UnPack5; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    MFR     DR4-SQLX_DR4;
    MFR     DR5-SQLX_DR5;
    MFR     DR6-SQLX_DR6;
    MFR     DR7-SQLX_DR7;
    MFR     DR8-SQLX_DR8;
    MFR     DR9-SQLX_DR9;
    MFR     DR10-SQLX_DR10;
    MFR     DR11-SQLX_DR11;
    WSI     A-DR4,WR0,8;
END PROGRAM;

PROGRAM SQLS_UnPack6; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    MFR     DR4-SQLX_DR4;
    MFR     DR5-SQLX_DR5;
    MFR     DR6-SQLX_DR6;
    MFR     DR7-SQLX_DR7;
    MFR     DR8-SQLX_DR8;
    MFR     DR9-SQLX_DR9;
    MFR     DR10-SQLX_DR10;
    MFR     DR11-SQLX_DR11;
    WSI     A-DR4,WR0,8;
END PROGRAM;

PROGRAM SQLS_UnPack7; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    MFR     DR4-SQLX_DR4;
    MFR     DR5-SQLX_DR5;
    MFR     DR6-SQLX_DR6;
    MFR     DR7-SQLX_DR7;
    MFR     DR8-SQLX_DR8;
    MFR     DR9-SQLX_DR9;
    MFR     DR10-SQLX_DR10;
    MFR     DR11-SQLX_DR11;
    WSI     A-DR4,WR0,8;
END PROGRAM;

PROGRAM SQLS_UnPack8; ASA210C;
    LCC     IR-0;
    LCC     WR0-8;
    MFR     DR4-SQLX_DR4;
    MFR     DR5-SQLX_DR5;
    MFR     DR6-SQLX_DR6;
    MFR     DR7-SQLX_DR7;
    MFR     DR8-SQLX_DR8;
    MFR     DR9-SQLX_DR9;
    MFR     DR10-SQLX_DR10;
    MFR     DR11-SQLX_DR11;
    WSI     A-DR4,WR0,8;
END PROGRAM;
!------------------------------------------------!
!       sCmpStringX !
!------------------------------------------------!
!------------------------------------------------!
!       genSigSurv !
!------------------------------------------------!
!END SQL!


END DOCUMENT;
