%%SET extendedAsaCode(1)
%%SET LOGPATCH(1)
%%SET DRNPATCH(1)
%%SET DRN2PATCH(1)
%%--------------------------------------------------------------------------------
%%IF(LOGPATCH(1))
%%MESSAGE("Disable logging")
%%ENDIF
%%IF(DRNPATCH(1))
%%MESSAGE("Fixes bug in register allocation")
%%ENDIF
%%IF(DRN2PATCH(1))
%%MESSAGE("Fixes bug in WSII")
%%ENDIF
%%--------------------------------------------------------------------------------
%%--> COMMON
%%---> Declarations
%%----> comDeclProtection
-------------------------------------------------------------------------------
- comDeclProtection
-
- Parameters: None
-
- IMP variables used:
-       curNames
-       tables
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components:
-       comDeclTempVars
-       userProtection
-------------------------------------------------------------------------------
%%BEGIN(comDeclProtection)
!------------------------------------------------!
!       comDeclProtection !
!------------------------------------------------!
RECORD PROTECTION;
! This variable indicates if the row is allocated or not. !
    VARIABLE    SQLM_Allocated          1   DS CLEAR;
! Return label reference !
    VARIABLE    SQLX_SQLRETURN          16  DS;
%%IF(curNames(?))
! Cursor references !
%%LOOP(i, curNames)
    VARIABLE    SQLM_%%(i)_Cursor          !R! 16 DS CLEAR;
%%ENDLOOP(i)
%%ENDIF
! The block reference to the table user in the current transaction. !
    VARIABLE    SQLBLOCK            16  DS;
! The table reference of a table issuing a local status code. !
    VARIABLE    SQLTABLE            16  DS;
%%IF(tables[0] > 0)
! This variable could be set by the user in user defined code. !
    VARIABLE    SQLLOCALCODE        8  DS;
! The current operation which should be PREPARED, POSTCOMMITED or ROLLBACKED:
$ 0 = insert, 1 = update, 2 = delete !
    VARIABLE    SQLOPERATION        2  DS;
! The current operating row while user defined code are executed. !
    VARIABLE    SQLX_SQLOPERROW         16  DS;
! The current working row while user defined code are executed. !
    VARIABLE    SQLX_SQLWORKROW         16  DS CLEAR;
! The current transaction identity while user defined code are executed. !
    VARIABLE    SQLX_SQLPROTECTED       16  DS;
! The current table reference while userdefined code are executed. !
    VARIABLE    SQLX_SQLTABLEREFERENCE  16  DS;
%%ENDIF
! Set by unPackX (table user) if there is no null indicator variable for
$ a column which is null. !
    VARIABLE    SQLX_SQLCODE            16  DS;
! This variable holds the current transaction identity. !
    VARIABLE    SQLTRANSID              16  DS CLEAR;
! User defined protected variable. !
%%INCLUDE(userProtection)
%%IF(tableUser(?))
! Used to protect pointers from time gaps in table user statements. !
    VARIABLE    SQLM_P(4)               !R! 16  DS;
%%ENDIF
! Variables generated by the preprocessor. !
%%INCLUDE(comDeclTempVars)
END RECORD;
! Pointer to protected !
    POINTER     PROTECTEDP   (PROTECTION);
! The size of the protected area. !
    VARIABLE    SQLM_ProtectedAllocated 16  DS RELOAD;
! The last allocated row in the protected area. !
    VARIABLE    SQLM_ProtectedLast      16  DS CLEAR;
! The number of allocated rows in the protected area. !
    VARIABLE    SQLM_ProtectedUsed      16  DS CLEAR;
! Used to lock the protected area for size alteration. !
    VARIABLE    SQLM_ProtectedLock       1  DS CLEAR;

%%END(comDeclProtection)
%%----> comDeclSqlCode
-------------------------------------------------------------------------------
- comDeclSqlCode
-
- Parameters: None
-
- IMP variables used: None
-
- IMP variables defined: None
-
- Temporary IMP variables: None
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(comDeclSqlCode)
!------------------------------------------------!
!       comDeclSqlCode !
!------------------------------------------------!
! This variable is used to check the result of a SQL statement. !
    VARIABLE    SQLCODE         16 DS;
    STRUCTURE   SQLCODE =
                1   VALUE       8,
                1   SUBCODE     8;
%%END(comDeclSqlCode)
%%----> comDeclPlexTemp
-------------------------------------------------------------------------------
- comDeclPlexTemp
-
- Parameters: None
-
- IMP variables used:
-       tables
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(comDeclPlexTemp)
!------------------------------------------------!
!       comDeclPlexTemp !
!------------------------------------------------!
! The data base number !
    VARIABLE    SQLX_DBnumber1      16;
    VARIABLE    SQLX_DBnumber2      16;
! The reference to the current operating row. !
    VARIABLE    SQLX_OperRow        16;
! The return label when a schedule or look up was performed !
    VARIABLE    SQLX_ReturnLabel    16;
! Temporary row reference !
    VARIABLE    SQLX_TempRow        16;
! The result of a key test operation !
    VARIABLE    SQLX_KeyTest        16;
! Reference to this block. Used mainly when scheduling. !
    VARIABLE    cOwnRef      16 DS;
! The file number when the user has not defined a size alteration event !
    VARIABLE    SQLX_FileNumber     16;
! The new table size when the user has not defined a size alteration event !
    VARIABLE    SQLX_NewIndNum      16;
! The restart phase when the user has not defined restart code !
    VARIABLE    SQLX_RestartPhase   16;
! The signal key in a restart phase when no user defined code is present !
    VARIABLE    SQLX_SignalKey      16;
! The size alteration event number when no user defined code is present !
    VARIABLE    SQLX_SizeEvent      16;
! The reference of the calling block. !
    VARIABLE    SQLX_OtherBlock     16;
! A pointer to the PROTECTED area or the transaction id !
    VARIABLE    SQLX_OtherProtected 16;
! The stored reference of the calling block. !
    VARIABLE    CSQLX_OtherBlock     16 DS;
! A stored pointer to the PROTECTED area or the transaction id !
    VARIABLE    CSQLX_OtherProtected 16 DS;
! The return code !
    VARIABLE    SQLX_ReturnCode     16;
! Signal data for use in the assembler functions. !
%%LOOP(i <= 24)
    VARIABLE    SQLX_DR%%(i - 1)     16;
%%ENDLOOP(i)
%%IF(remTables[0] > 0)
! A remote table reference !
    VARIABLE    SQLX_TableReference 16;
%%ENDIF
%%IF(tables[0] > 0)
! The base address of a variable !
    VARIABLE    SQLX_BaseAddress1   16;
    VARIABLE    SQLX_BaseAddress2   16;
! Column reference. !
    VARIABLE    SQLX_ColumnReference    16;
! This index variable is used to temporary store information about
$ columns to pack or unpack (see sPack, sUnPack). !
    VARIABLE    SQLX_Columns(32)    16 DS;
! Key component reference. !
    VARIABLE    SQLX_ComponentReference 16;
! Used when scheduling key insertion/deletion !
    VARIABLE    SQLX_Father              16;
    VARIABLE    SQLX_GrandFather              16;
    VARIABLE    SQLX_GrandGrandFather             16;
! The fault code sought !
    VARIABLE    SQLX_FaultCode      16;
! The key operation. !
    VARIABLE    SQLX_KeyOperation   16;
! The number of key components which is used in key comparisons !
    VARIABLE    SQLX_KeyPrefix      16;
! The number of untested key components in the key prefix !
    VARIABLE    SQLX_KeySuffix      16;
! The key number. !
    VARIABLE    SQLX_KeyNumber        16;
! The new lock of a row !
    VARIABLE    SQLX_Lock           16;
! The old (expected) lock of a row !
    VARIABLE    SQLX_OldLock        16;
! The last right turn in a btree in a search operation !
    VARIABLE    SQLX_RightTurn      16;
! This variable is used to determine when a schedule is necessary !
    VARIABLE    SQLX_Schedule       16;
! The symbol name and value !
    STRING VARIABLE SQLX_Symbol 7 DS;
    VARIABLE    SQLX_SymbolValue    16;
! Delete key variables !
    VARIABLE    SQLX_Delete              16;
    VARIABLE    SQLX_DeleteFather             16;
! Temporary data !
    VARIABLE    SQLX_TempData       16 DS;
! Reference to the current work row. !
    VARIABLE    SQLX_WorkRow        16;
! Reference to the current row !
    VARIABLE    SQLX_Current              16;
! The local error code after user defined code is executed !
    VARIABLE     SQLX_Code           16;
%%ENDIF
%%END(comDeclPlexTemp)
%%----> comDeclTempVars
-------------------------------------------------------------------------------
- comDeclTempVars
-
- Declare the temporary variables generated by the expression handling and
- signal handling in the preprocessor.
-
- Parameters: None
-
- IMP variables used:
-       tempSizes
-       tempUseI
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(comDeclTempVars)
!------------------------------------------------!
!       comDeclTempVars !
!------------------------------------------------!
%%LOOP(i <= tempSizes[0])
%%IF(tempUse%%(i)("STR") OR tempUse%%(i)("NSTR"))
    STRING VARIABLE SQLM_%%(i) %%(tempSizes[i]) DS;
%%ELSE
    VARIABLE SQLM_%%(i) %%(tempSizes[i]) DS;
%%ENDIF
%%IF(tempUse%%(i)("DBNO"))
    STRUCTURE SQLM_%%(i) =
        1 PART1 16,
        1 PART2 16;
%%ENDIF
%%IF(tempUse%%(i)("PN12") OR tempUse%%(i)("PN28"))
    STRUCTURE SQLM_%%(i) =
        1 LENGTH 16,
        1 W1 16,
        1 W2 16,
%%IF(tempUse%%(i)("PN12"))
        1 W3 16;
%%ELSE
        1 W3 16,
        1 W4 16,
        1 W5 16,
        1 W6 16,
        1 W7 16;
%%ENDIF
%%ENDIF
%%ENDLOOP(i)
%%END(comDeclTempVars)
%%---> Common Macros
%%----> version
-------------------------------------------------------------------------------
- version
-
- 1.0	Initial version  
        91-08-16 SoftLab
- 1.01  towInsRowTableRow: WorkRow cannot be assigned values before it
                           is defined.
        towResPart: SQLX_OtherBlock and SQLX_OtherProtected have to be
                    stored as there is combined-signal-sending before
                    towResPartR in several restart phases.
        91-08-16 TX/ZBE ELB             
- 1.02  scanPredicate: Fixed to handle tests on rownumber columns correctly.
        91-08-21 SoftLab/Tom
- 1.03  SAEIncrease,SAEDecrease: Insert list head in guard row initiated at
        size alteration for tables
        with primary key = btree OR alternate keys exist.
        91-08-28 TX/ZBE ELB 
- 1.04  towInsRowTableRow: WorkRow = OperRow assignment moved to before
                           possible insertion in insert list.
        91-09-09 TX/ZBE ELB
- 1.05  towVerRowTable : Missing work row assignment before table checks 
        (scan predicates).
        New code component recTusReAllProt. used by the transaction handler to 
        reallocate a protection individual (at restart) that holds info on a 
        verified transaction.
        910913 tx/zbe/timp.
- 1.06  recTusReAllProt: Adding signal names to 'sentSigs' and
        'recSigs' to be able to generate signal survey.
        New code component genSigSurv to generate signal survey for
        the generated block. Included from towAsaCode and tuAsaCode,
        but protected by a flag so that it is executed only once.
        scanPredicate: a new parameter added to tell if the scan
        predicate is generated as a table check or a fetch scan
        predicate. In the former case it is ok for a column to be
        null, in the latter case it is an error, thus the parameter is
        used to select the correct label to jump to for null testing.
        91-09-13 SoftLab/Tom
-------------------------------------------------------------------------------
%%BEGIN(version)
!------------------------------------------------!
! Versions used for PLEX-SQL expansion:          !
! CCL: 1.06                                      !
%%IF(pzVersion(?))
! PZ : %%(pzVersion)                                     !
%%ELSE
! PZ : unknown                                   !
%%ENDIF
!------------------------------------------------!
%%END(version)
%%----> copyPackNum
-------------------------------------------------------------------------------
- copyPackNum
-
- Parameters:
-       v1: Receiving variable
-       v2: Sending variable
-       v3: Column size
-
- IMP variables used: None
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       w
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(copyPackNum)
!------------------------------------------------!
!       copyPackNum !
!------------------------------------------------!
%%SET v1("%%(copyPackNum[1])")
%%SET v2("%%(copyPackNum[2])")
%%SET v3(%%(copyPackNum[3]))
%%IF(v3 = 12)%%SET v3(3)%%ELSE%%SET v3(7)%%ENDIF
    %%(v1).LENGTH =
        %%(v2).LENGTH;
%%LOOP(w <= v3)
    %%(v1).W%%(w) =
        %%(v2).W%%(w);
%%ENDLOOP(w)
%%END(copyPackNum)
%%----> genSigSurv
-------------------------------------------------------------------------------
- genSigSurv
-
- Parameters: None
-
- IMP variables used: None
-
- IMP variables defined: None
-
- Temporary IMP variables: None
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(genSigSurv)
!------------------------------------------------!
!       genSigSurv !
!------------------------------------------------!
%%IF(NOT genSigSurv(?))
%%SET genSigSurv()
%%PROCESS("tools/dbsSigSurv.imp", "dbsSigSurv.ssurv")
%%ENDIF
%%END(genSigSurv)
%%---> Top Level Macros
%%----> comDeclarations
-------------------------------------------------------------------------------
- comDeclarations
-
- Parameters: None
-
- IMP variables used:
-       comDeclarations
-
- IMP variables defined:
-       tableOwnerCode
-       tableUserCode
-       contfsDelayTime
-       statNo
-       indMax
-       comDeclarations
-       didNos
-
- Temporary IMP variables: None
-
- Included code components:
-       comDeclPlexTemp
-       comDeclSqlCode
-       comDeclProtection
-------------------------------------------------------------------------------
%%BEGIN(comDeclarations)
!------------------------------------------------!
!       comDeclarations !
!------------------------------------------------!
%%IF(NOT comDeclarations(?))
%%SET comDeclarations()
%%SET indMax(65535)
%%SET tableUserCode(162)
%%SET tableOwnerCode(135)
%%SET statNo(0)
%%SET sentSigs()
%%SET recSigs()
%%SET didNos()
%%SET contfsDelayTime("100 MS")
%%INCLUDE(comDeclProtection)
%%INCLUDE(comDeclSqlCode)
%%INCLUDE(comDeclPlexTemp)
%%ENDIF
%%END(comDeclarations)
%%----> comPlexCode
-------------------------------------------------------------------------------
- comPlexCode
-
- Parameters: None
-
- IMP variables used:
-       comPlexCode
-
- IMP variables defined:
-       comPlexCode
-
- Temporary IMP variables: None
-
- Included code components: None
-       comSetFsSae
-       comContFsSae
-       comGiveFsSae
-       towResPart
-------------------------------------------------------------------------------
%%BEGIN(comPlexCode)
!------------------------------------------------!
!       comPlexCode !
!------------------------------------------------!
%%IF(NOT comPlexCode(?))
%%SET comPlexCode()
%%----------------------------------------
%%-- Start and restart code
%%----------------------------------------
%%INCLUDE(towResPart)
%%----------------------------------------
%%-- Size Alteration Event handling code
%%----------------------------------------
%%INCLUDE(comGiveFsSae)
%%INCLUDE(comContFsSae)
%%INCLUDE(comSetFsSae)
%%----------------------------------------
%%-- End of code
%%----------------------------------------
%%ENDIF
%%END(comPlexCode)
%%----> comAsaCode
-------------------------------------------------------------------------------
- comAsaCode
-
- Parameters: None
-
- IMP variables used:
-       comAsaCode
-
- IMP variables defined:
-       comAsaCode
-
- Temporary IMP variables: None
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(comAsaCode)
!------------------------------------------------!
!       comAsaCode !
!------------------------------------------------!
%%IF(NOT comAsaCode(?))
%%SET comAsaCode()
%%IF(extendedAsaCode(?))
%%SET sib("")
%%SET sie(";")
%%ELSE
%%SET sib("!")
%%SET sie("!")
%%ENDIF
%%ENDIF
%%END(comAsaCode)
%%----> comData
-------------------------------------------------------------------------------
- comData
-
- Parameters: None
-
- IMP variables used:
-       comData
-
- IMP variables defined:
-       comData
-
- Temporary IMP variables: None
-
- Included code components:
-       version
-------------------------------------------------------------------------------
%%BEGIN(comData)
!------------------------------------------------!
!       comData !
!------------------------------------------------!
%%IF(NOT comData(?))
%%SET comData()
%%INCLUDE(version)
! Initialize Protected Region !
    SIZE OF PROTECTION=%%(protInitSize);
    SQLM_ProtectedAllocated=%%(protInitSize);
    SQLM_ProtectedLast=%%(protInitSize);
%%ENDIF
%%END(comData)
%%---> Handle: System start
%%----> comSttor
-------------------------------------------------------------------------------
- comSttor
-
- Parameters:
-   If user traps STTOR:
-       1: Name of restart case variable
-       2: Name of restart phase variable
-       3: Name of restart type variable
-       4: Not used, always 1
-       5: Not used, always 1
-       6: Name of restart rank variable
-       7: Name of signal key variable
-   If user does not trap STTOR: Empty list
-
- IMP variables used:
-       tableUserCode
-       tableUser
-       tableOwnerCode
-       tableOwner
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       sttorPhase
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(comSttor)
!------------------------------------------------!
!       comSttor !
!------------------------------------------------!
%%IF(comSttor[0] = 0)
! Receive STTOR !
%%SET recSigs(,STTOR)
    ENTER STTOR WITH
        +,
        SQLX_RestartPhase,
        +,
        +,
        +,
        +,
        SQLX_SignalKey;
%%SET sttorPhase(SQLX_RestartPhase)
%%ELSE
%%SET sttorPhase(%%(comSttor[2]))
%%ENDIF
! Enter restart phase 1 !
    IF %%(sttorPhase) = 1 THEN
! Load the block reference of the table owning/using block !
        LOADREF SQLX_TempRow;
        cOwnRef = SQLX_TempRow;
        TRANSFORM BLOCKREF IN TEMP SQLX_TempRow TO BLOCKNUMBER IN TEMP SQLX_TempRow;
! Inform the system that the block contains a table owner and/or table user. !
%%SET sentSigs(,STOREFUCODE)
        SEND STOREFUCODE WITH
            +,
            SQLX_TempRow,
%%IF(tableOwner(?) AND tableUser(?))
            2,
%%ELSE
            1,
%%ENDIF
%%IF(tableOwner(?))
            %%(tableOwnerCode),
%%ENDIF
%%IF(tableUser(?))
            %%(tableUserCode),
%%ENDIF
        WAIT FOR STOREFUCODEACK IN RESTART;
%%SET recSigs(,STOREFUCODEACK)
RESTART)RETRIEVE STOREFUCODEACK;
    FI;
%%IF(comSttor[0] = 0)
! No other restart phases are interesting !
%%SET sentSigs(,STTORRY)
    SEND STTORRY WITH
        SQLX_SignalKey,
        2,
        2,
        255;
    EXIT;
%%ENDIF
%%END(comSttor)
%%----> towResPart
-------------------------------------------------------------------------------
- towResPart
-
- Parameters: None
-
- IMP variables used:
-       tables
-       remTables
-       fkTabInds
-
- IMP variables defined: None
-
- Temporary IMP variables: None
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(towResPart)
!------------------------------------------------!
!       towResPart !
!------------------------------------------------!
%%SET recSigs(,TOWRESPART)
    ENTER towResPart WITH
        SQLX_OtherBlock,        ! Other users block number !
        SQLX_OtherProtected,    ! Other users protected pointer !
        SQLX_RestartPhase;      ! Our internal restart phase !
   ! Store block ref and pointer !
    CSQLX_OtherBlock = SQLX_OtherBlock;
    CSQLX_OtherProtected = SQLX_OtherProtected;
! Select code to execute the specified restart code !
    CASE SQLX_RestartPhase IS
%%IF(tables[0] > 0)
    WHEN 1 DO GOTO RESTARTPHASE1;
%%IF(fkTabInds[0] > 0)
    WHEN 2 DO GOTO RESTARTPHASE2;
%%ENDIF
%%ENDIF
%%IF(remTables[0] > 0)
    WHEN 3 DO GOTO RESTARTPHASE3;
%%ENDIF
%%IF(tables[0] > 0)
    WHEN 4 DO GOTO RESTARTPHASE4;
%%ENDIF
%%IF(didNos[0] > 0)
    WHEN 5 DO GOTO RESTARTPHASE5;
%%ENDIF
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Return execution to Data Dictionary or Transaction Handler !
RESTARTEND)
%%SET sentSigs(,TOWRESPARTR)
    SEND towResPartR REFERENCE CSQLX_OtherBlock WITH
        CSQLX_OtherProtected,    ! Other users protected pointer !
        0;                  ! Return code !
    EXIT;
%%END(towResPart)
%%---> Handle: Size Alteration Event
%%----> GIVEFS
%%-----> comGiveFs
-------------------------------------------------------------------------------
- comGiveFs
-
- Parameters:
-   If user traps GIVEFS:
-       1: Name of size event variable
-       2: Name of file pointer variable
-   If user does not trap GIVEFS: Empty list
-
- IMP variables used:
-       tabSaes
-       workSaes
-       tables
-       protSae
-       giveFsEvent
-
- IMP variables defined:
-       giveFsEvent
-
- Temporary IMP variables:
-       areas
-       i
-       j
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(comGiveFs)
%%IF(protSae(?) OR tables[0]>0)
!------------------------------------------------!
!       comGiveFs !
!------------------------------------------------!
%%IF(comGiveFs[0] = 0)
%%SET recSigs(,GIVEFS)
    ENTER GIVEFS WITH
        SQLX_SizeEvent,
        +;
%%SET giveFsEvent(SQLX_SizeEvent)
%%ELSE
%%SET giveFsEvent(%%(comGiveFs[1]))
%%ENDIF
    CASE %%(giveFsEvent) IS
%%IF(protSae(?))
    WHEN %%(protSae) DO GOTO SAE%%(protSae)L1;
%%ENDIF
%%IF(tables[0] > 0)
%%SET areas(tab, work)
%%LOOP(i, areas)
%%IF(%%(i)Saes(?))
%%LOOP(j, %%(i)Saes)
%%IF(j # "")
    WHEN %%(j) DO GOTO SAE%%(j)L1;
%%ENDIF
%%ENDLOOP(j)
%%ENDIF
%%ENDLOOP(i)
%%ENDIF
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%IF(comGiveFs[0] = 0)
! No appropriate Size Alteration Event was found. !
%%SET sentSigs(,GIVEFSEND)
    SEND GIVEFSEND WITH #100;
    EXIT;
%%ENDIF
%%ENDIF
%%END(comGiveFs)
%%-----> comGiveFsSae
-------------------------------------------------------------------------------
- comGiveFsSae
-
- Parameters: None
-
- IMP variables used:
-       protSae
-       protDivConst
-       protMaxSize
-       protRelDiv
-       protDivDir
-       tabSaes
-       tabDivConsts
-       tabMaxSizes
-       tabRelDivs
-       tabDivDirs
-       workSaes
-       workDivConsts
-       workMaxSizes
-       workRelDivs
-       workDivDirs
-       tables
-       tabNos
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       areas
-       i
-       j
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(comGiveFsSae)
!------------------------------------------------!
!       comGiveFsSae !
!------------------------------------------------!
%%IF(protSae(?))
SAE%%(protSae)L1)
    FILENUMBER FOR SQLM_Allocated TO SQLX_FileNumber;
%%SET sentSigs(,GIVEFSEND)
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        %%(protDivDir),
        %%(protRelDiv),
        0,
        SQLM_ProtectedAllocated,
        %%(protDivConst);
    EXIT;
%%ENDIF
%%IF(tables[0] > 0)
%%SET areas(tab, work)
%%LOOP(i, areas)
%%IF(%%(i)Saes(?))
%%LOOP(j <= %%(i)Saes[0])
%%IF(%%(i)Saes[j] # "")
SAE%%(%%(i)Saes[j])L1)
    SQLM_TableReference = %%(tabNos[j]);
    FILENUMBER FOR SQLC_%%(tables[j])_Allocated TO SQLX_FileNumber;
%%SET sentSigs(,GIVEFSEND)
    SEND GIVEFSEND WITH
        1,
        SQLX_FileNumber,
        1,
        5,
        1,
%%IF(i(tab))
        %%(%%(i)MaxSizes[j])+SQLM_TableReference:SQLM_WorkAllocated+3,
        SQLM_TableReference:SQLM_TableUsed,
        SQLM_TableReference:SQLM_WorkAllocated+3;
%%ELSE
        SQLM_TableReference:SQLM_TableAllocated+%%(%%(i)MaxSizes[j])+3,
        SQLM_TableReference:SQLM_WorkUsed,
        SQLM_TableReference:SQLM_TableAllocated+3;
%%ENDIF
    EXIT;
%%ENDIF
%%ENDLOOP(j)
%%ENDIF
%%ENDLOOP(i)
%%ENDIF
%%END(comGiveFsSae)
%%----> CONTFS
%%-----> comContFs
-------------------------------------------------------------------------------
- comContFs
-
- Parameters:
-   If user traps CONTFS:
-       1: Name of size event variable
-       2: Name of file pointer variable
-       3: Name of new number of individuals variable
-   If user does not trap CONTFS: Empty list
-
- IMP variables used:
-       tabSaes
-       workSaes
-       tables
-       protSae
-       contFsEvent
-
- IMP variables defined:
-       contFsSize
-       contFsEvent
-
- Temporary IMP variables:
-       areas
-       i
-       j
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(comContFs)
%%IF(protSae(?) OR tables[0]>0)
!------------------------------------------------!
!       comContFs !
!------------------------------------------------!
%%IF(comContFs[0] = 0)
%%SET recSigs(,CONTFS)
    ENTER CONTFS WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum;
%%SET contFsEvent(SQLX_SizeEvent)
%%SET contFsSize(SQLX_NewIndNum)
%%ELSE
%%SET contFsEvent(%%(comContFs[1]))
%%SET contFsSize(%%(comContFs[3]))
%%ENDIF
! Select Size Alteration Event !
    CASE %%(contFsEvent) IS
%%IF(protSae(?))
    WHEN %%(protSae) DO GOTO SAE%%(protSae)L2;
%%ENDIF
%%IF(tables[0] > 0)
%%SET areas(tab, work)
%%LOOP(i, areas)
%%IF(%%(i)Saes(?))
%%LOOP(j, %%(i)Saes)
%%IF(j # "")
    WHEN %%(j) DO GOTO SAE%%(j)L2;
%%ENDIF
%%ENDLOOP(j)
%%ENDIF
%%ENDLOOP(i)
%%ENDIF
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%IF(comContFs[0] = 0)
! The size alteration event was of no interest !
%%SET sentSigs(,CONTFSEND)
    SEND CONTFSEND WITH 1;
    EXIT;
%%ENDIF
%%ENDIF
%%END(comContFs)
%%-----> comContFsSae
-------------------------------------------------------------------------------
- comContFsSae
-
- Parameters: None
-
- IMP variables used:
-       contfsDelayTime
-       contFsSize
-       contFsEvent
-       workSaes
-       bTreesI
-       tables
-       tabNos
-       workMaxSizes
-       workMinSizes
-       tabSaes
-       cNext
-       cPrev
-       tabMaxSizes
-       tabMinSizes
-       protSae
-       protMaxSize ???
-       protInitSize
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       c
-       i
-       j
-       p
-       s
-       tNo
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(comContFsSae)
!------------------------------------------------!
!       comContFsSae !
!------------------------------------------------!
%%------> sSAEDecrease
%%LOOP(i <= tables[0])
%%SET tNo(%%(tabNos[i]))
%%SET c(SQLC_%%(tables[i])_)
%%SET p(SQLM_%%(tables[i])_)
%%SET s(SQLS_%%(tables[i])_)

BEGIN %%(s)SAEDecrease;
    %%(p)GuardRow=SQLM_TableReference:SQLM_System;
    %%(p)NilRow=SQLM_TableReference:SQLM_System+1;
    %%(p)RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    %%(p)OperRow=
        %%(p)GuardRow-%%(p)WorkRow;
%%LOOP(j, bTrees%%(tNo))
    %%(p)OperRow:%%(c)Color%%(j)=
        %%(p)GuardRow:%%(c)Color%%(j);    
%%ENDLOOP(j)
%%IF(bTrees%%(tNo)(2) OR aks%%(tNo)[0] > 0)
    IF %%(p)GuardRow:%%(%%(c)Next) =
        %%(p)NilRow
    THEN
        %%(p)OperRow:%%(%%(c)Next)=
            %%(p)NilRow-%%(p)WorkRow;
    ELSE
        %%(p)OperRow:%%(%%(c)Next)=
            %%(p)GuardRow:%%(%%(c)Next);
    FI;
    IF %%(p)GuardRow:%%(%%(c)Prev) =
        %%(p)NilRow
    THEN
        %%(p)OperRow:%%(%%(c)Prev)=
              %%(p)NilRow-%%(p)WorkRow;
    ELSE
        %%(p)OperRow:%%(%%(c)Prev)=
            %%(p)GuardRow:%%(%%(c)Prev);
    FI;
%%ENDIF
    %%(p)OperRow:%%(c)Allocated=1;
! Move Nil Row !
    %%(p)OperRow=
        %%(p)NilRow-%%(p)WorkRow;
%%LOOP(j, bTrees%%(tNo))
    %%(p)OperRow:%%(c)Color%%(j)=
        %%(p)NilRow:%%(c)Color%%(j);
    %%(p)OperRow:%%(c)Right%%(j)=
        %%(p)GuardRow-%%(p)WorkRow;
    %%(p)OperRow:%%(c)Left%%(j) =
        %%(p)GuardRow-%%(p)WorkRow;
%%ENDLOOP(j)
    %%(p)OperRow:%%(c)Allocated=1;
! Move Root Row !
    %%(p)OperRow=
        %%(p)RootRow-%%(p)WorkRow;
%%LOOP(j, bTrees%%(tNo))
    %%(p)OperRow:%%(c)Color%%(j)=
        %%(p)RootRow:%%(c)Color%%(j);    
    IF %%(p)RootRow:%%(c)Right%%(j) =
        %%(p)NilRow
    THEN
        %%(p)OperRow:%%(c)Right%%(j)=
            %%(p)NilRow-%%(p)WorkRow;    
    ELSE
        %%(p)OperRow:%%(c)Right%%(j)=
            %%(p)RootRow:%%(c)Right%%(j);    
    FI;
    IF %%(p)RootRow:%%(c)Left%%(j) =
        %%(p)NilRow
    THEN
        %%(p)OperRow:%%(c)Left%%(j)=
            %%(p)NilRow-%%(p)WorkRow;    
    ELSE
        %%(p)OperRow:%%(c)Left%%(j)=
            %%(p)RootRow:%%(c)Left%%(j);    
    FI;
%%ENDLOOP(j)
    %%(p)OperRow:%%(c)Allocated=1;
END %%(s)SAEDecrease;
%%ENDLOOP(i)
%%------> Protected
%%IF(protSae(?))
SAE%%(protSae)L2)
! Check if the new size is within legal bounds, if not report failure !
    IF %%(contFsSize) < %%(protInitSize) GOTO FAILURE%%(protSae);
! Check if the new size is less than the last allocated row, if so
$ report failure !
    FOR FIRST PROTECTEDP
        FROM SQLM_ProtectedAllocated-1
        WHERE PROTECTEDP:SQLM_Allocated=1
        DO IF %%(contFsSize) =< PROTECTEDP GOTO FAILURE%%(protSae);
! Everything seems fine !
    SQLM_ProtectedLock=1;
%%SET sentSigs(,CONTFSEND)
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE%%(protSae))
! Report failure !
%%SET sentSigs(,CONTFSEND)
    SEND CONTFSEND WITH 1;
    EXIT;
%%ENDIF
%%------> Table Areas
%%IF(tables[0] > 0)
%%IF(tabSaes(?))
%%LOOP(i <= tabSaes[0])
%%IF(tabSaes[i] # "")
%%SET c(SQLC_%%(tables[i])_)
%%SET p(SQLM_%%(tables[i])_)
%%SET s(SQLS_%%(tables[i])_)
SAE%%(tabSaes[i])L2)
    SQLM_TableReference=%%(tabNos[i]);
    IF %%(contFsSize) < SQLM_TableReference:SQLM_WorkAllocated+3
        GOTO FAILURE1%%(tabSaes[i]);
    %%(contFsSize)=%%(contFsSize)-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF %%(contFsSize) < %%(tabMinSizes[i]) GOTO FAILURE1%%(tabSaes[i]);
    IF %%(contFsSize) > %%(tabMaxSizes[i]) GOTO FAILURE1%%(tabSaes[i]);
! Check if the new size is less than the last allocated row, if so
$ report failure !
    IF %%(contFsSize) < SQLM_TableReference:SQLM_TableLast
        GOTO FAILURE1%%(tabSaes[i]);
! Check if there are work rows allocated, if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0 GOTO FAILURE2%%(tabSaes[i]);
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF %%(contFsSize) < SQLM_TableReference:SQLM_TableAllocated THEN
%%IF(bTrees%%(tabNos[i])(2))
! Remove rows from free list !
        %%(p)NilRow=SQLM_TableReference:SQLM_System+1;
        %%(p)GuardRow=SQLM_TableReference:SQLM_System;
        %%(p)WorkRow=%%(p)GuardRow;
        %%(p)OperRow=
            %%(p)GuardRow:%%(%%(c)Prev);
LOOP%%(tabSaes[i]))
        IF %%(p)OperRow = %%(p)NilRow
            GOTO EXIT%%(tabSaes[i]);
        IF %%(p)OperRow >= %%(contFsSize) THEN
            IF %%(p)WorkRow = %%(p)GuardRow THEN
                %%(p)WorkRow:%%(%%(c)Prev)=
                    %%(p)OperRow:%%(%%(c)Next);
            ELSE
                %%(p)WorkRow:%%(%%(c)Next)=
                    %%(p)OperRow:%%(%%(c)Next);
            FI;
            %%(p)OperRow=
                %%(p)OperRow:%%(%%(c)Next);
        ELSE
            %%(p)WorkRow=%%(p)OperRow;
            %%(p)OperRow=
                %%(p)OperRow:%%(%%(c)Next);
        FI;
        GOTO LOOP%%(tabSaes[i]);
EXIT%%(tabSaes[i]))
%%ENDIF
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        %%(p)WorkRow=
            SQLM_TableReference:SQLM_TableAllocated-%%(contFsSize);
! Move the system rows and remap NIL pointers !
        DO %%(s)SAEDecrease;
%%IF(bTrees%%(tabNos[i])[0] > 0)
! Remap NIL pointers !
        %%(p)WorkRow=
            %%(p)NilRow-%%(p)WorkRow;
        IF %%(contFsSize)>0 THEN
%%LOOP(j, bTrees%%(tabNos[i]))
            FOR ALL %%(p)OperRow
                FROM %%(contFsSize)-1
                WHERE %%(p)OperRow:%%(c)Right%%(j)=
                    %%(p)NilRow
                DO %%(p)OperRow:%%(c)Right%%(j)=
                    %%(p)WorkRow;
            FOR ALL %%(p)OperRow
                FROM %%(contFsSize)-1
                WHERE %%(p)OperRow:%%(c)Left%%(j)=
                    %%(p)NilRow
                DO %%(p)OperRow:%%(c)Left%%(j)=
                    %%(p)WorkRow;
%%ENDLOOP(j)
        FI;
%%ENDIF
    FI;
! Everything seems fine !
%%SET sentSigs(,CONTFSEND)
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE1%%(tabSaes[i]))
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
%%SET sentSigs(,CONTFSEND)
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE2%%(tabSaes[i]))
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
%%SET sentSigs(,CONTFS)
    SEND CONTFS REFERENCE cOwnRef WITH
        %%(contFsEvent),
        +,
        %%(contFsSize)+SQLM_TableReference:SQLM_WorkAllocated+3,
        DELAY %%(contfsDelayTime);
    EXIT;
%%ENDIF
%%ENDLOOP(i)
%%ENDIF
%%------> Work Areas
%%IF(workSaes(?))
%%LOOP(i <= workSaes[0])
%%IF(workSaes[i] # "")
%%SET c(SQLC_%%(tables[i])_)
%%SET p(SQLM_%%(tables[i])_)
%%SET s(SQLS_%%(tables[i])_)
SAE%%(workSaes[i])L2)
    SQLM_TableReference=%%(tabNos[i]);
    IF %%(contFsSize) < SQLM_TableReference:SQLM_TableAllocated+3
        GOTO FAILURE1%%(tabSaes[i]);
    %%(contFsSize)=%%(contFsSize)-
        (SQLM_TableReference:SQLM_TableAllocated+3);
! Check if the new size is within legal bounds, if not report failure !
    IF %%(contFsSize) < %%(workMinSizes[i]) GOTO FAILURE1%%(workSaes[i]);
    IF %%(contFsSize) > %%(workMaxSizes[i]) GOTO FAILURE1%%(workSaes[i]);
! Check if there are work rows allocated in the area which will be
$ removed , if so delay the CONTFS !
    IF SQLM_TableReference:SQLM_WorkUsed /= 0
        GOTO FAILURE2%%(workSaes[i]);
! Lock the work area until SETFS is executed. !
    SQLM_TableReference:SQLM_WorkLock=1;
    IF %%(contFsSize) < SQLM_TableReference:SQLM_WorkAllocated THEN
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        %%(p)WorkRow=
            SQLM_TableReference:SQLM_WorkAllocated-%%(contFsSize);
! Move the system rows and remap NIL pointers !
        DO %%(s)SAEDecrease;
%%IF(bTrees%%(tabNos[i])[0] > 0)
! Remap NIL pointers !
        %%(p)WorkRow=
            %%(p)NilRow-%%(p)WorkRow;
        IF SQLM_TableReference:SQLM_TableAllocated>0 THEN
%%LOOP(j, bTrees%%(tabNos[i]))
            FOR ALL %%(p)OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE %%(p)OperRow:%%(c)Right%%(j)=
                    %%(p)NilRow
                DO %%(p)OperRow:%%(c)Right%%(j)=
                    %%(p)WorkRow;
            FOR ALL %%(p)OperRow
                FROM SQLM_TableReference:SQLM_TableAllocated-1
                WHERE %%(p)OperRow:%%(c)Left%%(j)=
                    %%(p)NilRow
                DO %%(p)OperRow:%%(c)Left%%(j)=
                    %%(p)WorkRow;
%%ENDLOOP(j)
        FI;
%%ENDIF
    FI;
! Everything seems fine !
%%SET sentSigs(,CONTFSEND)
    SEND CONTFSEND WITH 0;
    EXIT;
FAILURE1%%(workSaes[i]))
! Unlock work area and report failure !
    SQLM_TableReference:SQLM_WorkLock=0;
%%SET sentSigs(,CONTFSEND)
    SEND CONTFSEND WITH 1;
    EXIT;
FAILURE2%%(workSaes[i]))
! Lock work area and delay CONTFS !
    SQLM_TableReference:SQLM_WorkLock=1;
%%SET sentSigs(,CONTFS)
    SEND CONTFS REFERENCE cOwnRef WITH
        %%(contFsEvent),
        +,
        %%(contFsSize)+SQLM_TableReference:SQLM_TableAllocated+3,
        DELAY %%(contfsDelayTime);
    EXIT;
%%ENDIF
%%ENDLOOP(i)
%%ENDIF
%%ENDIF
%%------> End
%%END(comContFsSae)
%%----> SETFS
%%-----> comSetFs
-------------------------------------------------------------------------------
- comSetFs
-
- Parameters:
-   If user traps SETFS:
-       1: Name of size event variable
-       2: Name of file pointer variable
-       3: Name of new number of individuals variable
-   If user does not trap SETFS: Empty list
-
- IMP variables used:
-       tabSaes
-       workSaes
-       tables
-       protSae
-       setFsEvent
-
- IMP variables defined:
-       setFsSize
-       setFsEvent
-
- Temporary IMP variables:
-       areas
-       i
-       j
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(comSetFs)
%%IF(protSae(?) OR tables[0]>0)
!------------------------------------------------!
!       comSetFs !
!------------------------------------------------!
%%IF(comSetFs[0] = 0)
%%SET recSigs(,SETFS)
    ENTER SETFS WITH
        SQLX_SizeEvent,
        +,
        SQLX_NewIndNum;
%%SET setFsEvent(SQLX_SizeEvent)
%%SET setFsSize(SQLX_NewIndNum)
%%ELSE
%%SET setFsEvent(%%(comSetFs[1]))
%%SET setFsSize(%%(comSetFs[3]))
%%ENDIF
! Select Size Alteration Event !
    CASE %%(setFsEvent) IS
%%IF(protSae(?))
    WHEN %%(protSae) DO GOTO SAE%%(protSae)L3;
%%ENDIF
%%IF(tables[0] > 0)
%%SET areas(tab, work)
%%LOOP(i, areas)
%%IF(%%(i)Saes(?))
%%LOOP(j, %%(i)Saes)
%%IF(j # "")
    WHEN %%(j) DO GOTO SAE%%(j)L3;
%%ENDIF
%%ENDLOOP(j)
%%ENDIF
%%ENDLOOP(i)
%%ENDIF
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%IF(comSetFs[0] = 0)
! Ignore non-interesting size alteration events !
%%SET sentSigs(,SETFSEND)
    SEND SETFSEND;
    EXIT;
%%ENDIF
%%ENDIF
%%END(comSetFs)
%%-----> comSetFsSae
-------------------------------------------------------------------------------
- comSetFsSae
-
- Parameters: None
-
- IMP variables used:
-       bTreesI
-       tabNos
-       setFsSize
-       workSaes
-       tables
-       cNext
-       cPrev
-       tabSaes
-       curNames
-       protSae
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       c
-       i
-       j
-       p
-       s
-       tNo
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(comSetFsSae)
!------------------------------------------------!
!       comSetFsSae !
!------------------------------------------------!
%%------> sSAEIncrease, sSAEClear
%%LOOP(i <= tables[0])
%%SET tNo(%%(tabNos[i]))
%%SET c(SQLC_%%(tables[i])_)
%%SET p(SQLM_%%(tables[i])_)
%%SET s(SQLS_%%(tables[i])_)

BEGIN %%(s)SAEIncrease;
    %%(p)GuardRow=SQLM_TableReference:SQLM_System;
    %%(p)NilRow=SQLM_TableReference:SQLM_System+1;
    %%(p)RootRow=SQLM_TableReference:SQLM_System+2;
! Move Guard Row !
    %%(p)OperRow=
        %%(p)GuardRow+%%(p)WorkRow;
%%LOOP(j, bTrees%%(tNo))
    %%(p)OperRow:%%(c)Color%%(j)=
        %%(p)GuardRow:%%(c)Color%%(j);    
%%ENDLOOP(j)
%%IF(bTrees%%(tNo)(2) OR aks%%(tNo)[0] > 0)
    IF %%(p)GuardRow:%%(%%(c)Next)=
        %%(p)NilRow
    THEN
        %%(p)OperRow:%%(%%(c)Next)=
            %%(p)NilRow+%%(p)WorkRow;
    ELSE
        %%(p)OperRow:%%(%%(c)Next)=
            %%(p)GuardRow:%%(%%(c)Next);
    FI;
    IF %%(p)GuardRow:%%(%%(c)Prev)=
        %%(p)NilRow
    THEN
        %%(p)OperRow:%%(%%(c)Prev)=
            %%(p)NilRow+%%(p)WorkRow;
    ELSE
        %%(p)OperRow:%%(%%(c)Prev)=
            %%(p)GuardRow:%%(%%(c)Prev);
    FI;
%%ENDIF
    %%(p)OperRow:%%(c)Allocated=1;
! Move Nil Row !
    %%(p)OperRow=
        %%(p)NilRow+%%(p)WorkRow;
%%LOOP(j, bTrees%%(tNo))
    %%(p)OperRow:%%(c)Color%%(j)=
        %%(p)NilRow:%%(c)Color%%(j);    
    %%(p)OperRow:%%(c)Right%%(j)=
        %%(p)GuardRow+%%(p)WorkRow;
    %%(p)OperRow:%%(c)Left%%(j) =
        %%(p)GuardRow+%%(p)WorkRow;
%%ENDLOOP(j)
    %%(p)OperRow:%%(c)Allocated=1;
! Move Root Row !
    %%(p)OperRow=
        %%(p)RootRow+%%(p)WorkRow;
%%LOOP(j, bTrees%%(tNo))
    %%(p)OperRow:%%(c)Color%%(j)=
        %%(p)RootRow:%%(c)Color%%(j);    
    IF %%(p)RootRow:%%(c)Right%%(j) =
        %%(p)NilRow
    THEN
        %%(p)OperRow:%%(c)Right%%(j)=
            %%(p)NilRow+%%(p)WorkRow;    
    ELSE
        %%(p)OperRow:%%(c)Right%%(j)=
            %%(p)RootRow:%%(c)Right%%(j);    
    FI;
    IF %%(p)RootRow:%%(c)Left%%(j) =
        %%(p)NilRow
    THEN
        %%(p)OperRow:%%(c)Left%%(j)=
            %%(p)NilRow+%%(p)WorkRow;    
    ELSE
        %%(p)OperRow:%%(c)Left%%(j)=
            %%(p)RootRow:%%(c)Left%%(j);    
    FI;
%%ENDLOOP(j)
    %%(p)OperRow:%%(c)Allocated=1;
! Clear allocate bits in new area !
    FOR ALL %%(p)OperRow
        FROM SQLM_TableReference:SQLM_System+
            %%(p)WorkRow-1
        UNTIL SQLM_TableReference:SQLM_System
%%IF(bTrees%%(tNo)[0] > 0)
        DO %%(s)SAEClear;
%%ELSE
        DO %%(p)OperRow:%%(c)Allocated=0;
%%ENDIF
%%IF(bTrees%%(tNo)[0] > 0)
! Remap NIL pointers !
    %%(p)WorkRow=
        %%(p)WorkRow+%%(p)NilRow;
    IF SQLM_TableReference:SQLM_TableAllocated > 0 THEN
%%LOOP(j, bTrees%%(tNo))
        FOR ALL %%(p)OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE %%(p)OperRow:%%(c)Right%%(j)=
                %%(p)NilRow
            DO %%(p)OperRow:%%(c)Right%%(j)=
                %%(p)WorkRow;
        FOR ALL %%(p)OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated-1
            WHERE %%(p)OperRow:%%(c)Left%%(j)=
                %%(p)NilRow
            DO %%(p)OperRow:%%(c)Left%%(j)=
                %%(p)WorkRow;
%%ENDLOOP(j)
    FI;
%%ENDIF
END %%(s)SAEIncrease;
%%IF(bTrees%%(tNo)[0] > 0)

BEGIN %%(s)SAEClear;
! Clear allocate bit. !
    %%(p)OperRow:%%(c)Allocated=0;
! Clear btree pointers. !
%%LOOP(j, bTrees%%(tNo))
    %%(p)OperRow:%%(c)Left%%(j)=0;
    %%(p)OperRow:%%(c)Right%%(j)=0;
%%ENDLOOP(j)
END %%(s)SAEClear;
%%ENDIF
%%ENDLOOP(i)
%%------> Protected
%%IF(protSae(?))
SAE%%(protSae)L3)
! Init cursor pointers !
%%IF(curNames(?))
%%IF(curNames[0] > 0)
    ON PROTECTEDP FROM SQLM_ProtectedAllocated UPTO %%(setFsSize) DO
%%LOOP(i, curNames)
        PROTECTEDP:SQLM_%%(i)_Cursor=0;
%%ENDLOOP(i)
    NO;
%%ENDIF
%%ENDIF
! Set new size !
    SQLM_ProtectedAllocated=%%(setFsSize);
    SQLM_ProtectedLock=0;
! The size alteration is performed. !
%%SET sentSigs(,SETFSEND)
    SEND SETFSEND;
    EXIT;
%%ENDIF
%%------> Table Areas
%%IF(tables[0] > 0)
%%IF(tabSaes(?))
%%LOOP(i <= tabSaes[0])
%%IF(tabSaes[i] # "")
%%SET c(SQLC_%%(tables[i])_)
%%SET p(SQLM_%%(tables[i])_)
%%SET s(SQLS_%%(tables[i])_)
SAE%%(tabSaes[i])L3)
    SQLM_TableReference=%%(tabNos[i]);
    %%(setFsSize)=%%(setFsSize)-
        (SQLM_TableReference:SQLM_WorkAllocated+3);
    IF %%(setFsSize) > SQLM_TableReference:SQLM_TableAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        %%(p)WorkRow=
            %%(setFsSize)-SQLM_TableReference:SQLM_TableAllocated;
! Move the system rows and remap NIL pointers !
        DO %%(s)SAEIncrease;
%%IF(bTrees%%(tabNos[i])(2))
! Link in new rows into the free list (first in list) !
        ON %%(p)OperRow
            FROM SQLM_TableReference:SQLM_TableAllocated
            UPTO %%(setFsSize)-2
            DO %%(p)OperRow:%%(%%(c)Next)=
                %%(p)OperRow+1;
        NO;
        %%(p)OperRow=%%(setFsSize)-1;
        %%(p)GuardRow=SQLM_TableReference:SQLM_WorkAllocated+%%(setFsSize);
        %%(p)OperRow:%%(%%(c)Next)=
            %%(p)GuardRow:%%(%%(c)Prev);
        %%(p)GuardRow:%%(%%(c)Prev)=
            SQLM_TableReference:SQLM_TableAllocated;
%%ENDIF
    FI;
! Change table allocated variable and system row pointer !
    SQLM_TableReference:SQLM_TableAllocated=%%(setFsSize);
    SQLM_TableReference:SQLM_System=%%(setFsSize)+
        SQLM_TableReference:SQLM_WorkAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
%%SET sentSigs(,SETFSEND)
    SEND SETFSEND;
    EXIT;
%%ENDIF
%%ENDLOOP(i)
%%ENDIF
%%------> Work Areas
%%IF(workSaes(?))
%%LOOP(i <= workSaes[0])
%%IF(workSaes[i] # "")
%%SET c(SQLC_%%(tables[i])_)
%%SET p(SQLM_%%(tables[i])_)
%%SET s(SQLS_%%(tables[i])_)
SAE%%(workSaes[i])L3)
    SQLM_TableReference=%%(tabNos[i]);
    %%(setFsSize)=%%(setFsSize)-
        (SQLM_TableReference:SQLM_TableAllocated+3);
    IF %%(setFsSize) > SQLM_TableReference:SQLM_WorkAllocated THEN
! The size is increased. !
! Set pWorkRow to contain the distance between the old system rows and
$ the new ones. !
        %%(p)WorkRow=
            %%(setFsSize)-SQLM_TableReference:SQLM_WorkAllocated;
! Move the system rows and remap NIL pointers !
        DO %%(s)SAEIncrease;
    FI;
! Change table variable !
    SQLM_TableReference:SQLM_WorkAllocated=%%(setFsSize);
    SQLM_TableReference:SQLM_System=%%(setFsSize)+
        SQLM_TableReference:SQLM_TableAllocated;
! Release work area lock and reply !
    SQLM_TableReference:SQLM_WorkLock=0;
%%SET sentSigs(,SETFSEND)
    SEND SETFSEND;
    EXIT;
%%ENDIF
%%ENDLOOP(i)
%%ENDIF
%%ENDIF
%%------> End
%%END(comSetFsSae)
%%--> TABLE OWNER
%%---> Declarations
%%----> towTables
-------------------------------------------------------------------------------
- towTables
-
- Parameters: None
-
- IMP variables used:
-       bTreesI
-       indMax
-       aksI
-       tables
-       colsI
-       symValsI_J
-       symLitsI_J
-       symColsI
-       colSizesI
-       packNumColsI
-       colPropsI
-       colTypesI
-       colNullI
-       tabNos
-
- IMP variables defined:
-       cLastRow
-       cNext
-       cPrev
-       didNos
-       didPosI
-       didColsI
-
- Temporary IMP variables:
-       c
-       col
-       i
-       j
-       k
-       p
-       size
-       tab
-       tabNo
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(towTables)
!------------------------------------------------!
!       towTables !
!------------------------------------------------!
%%LOOP(i <= tables[0])
%%SET tabNo(%%(tabNos[i]))
%%SET c(SQLC_%%(tables[i])_)
%%SET p(SQLM_%%(tables[i])_)
%%SET tab(SQLT_%%(tables[i])_)
RECORD %%(tab)Table;
! This variable indicates if the row is allocated or not. !
    VARIABLE    %%(c)Allocated      1   DS RELOAD;
! This variable indicates if the row is locked or not. !
    VARIABLE    %%(c)Lock           2   DS CLEAR;
! The current data base number. !
    VARIABLE    %%(c)DBnumber       32  DS CLEAR;
! The column null indicators and the columns !
%%LOOP(j <= cols%%(tabNo)[0])
%%SET col(%%(c)%%(cols%%(tabNo)[j])_)
%%IF(colNull%%(tabNo)[j] = 1)
    VARIABLE %%(col)Null 1 DS %%(colProps%%(tabNo)[j]);
%%ENDIF
%%IF(colTypes%%(tabNo)[j] = "STRING" OR colTypes%%(tabNo)[j] = "NUMSTRING")
    STRING VARIABLE %%(col)Data %%(colSizes%%(tabNo)[j]) DS %%(colProps%%(tabNo)[j]);
%%ELSIF(colTypes%%(tabNo)[j] = "BITS" OR colTypes%%(tabNo)[j] = "SYMBOL")
    VARIABLE %%(col)Data %%(colSizes%%(tabNo)[j]) DS %%(colProps%%(tabNo)[j]);
%%ELSIF(colTypes%%(tabNo)[j] = "PACKED NUMSTRING")
%%IF(colSizes%%(tabNo)[j] = 12)
    VARIABLE %%(col)Data 64 DS %%(colProps%%(tabNo)[j]);
%%ELSE
    VARIABLE %%(col)Data 128 DS %%(colProps%%(tabNo)[j]);
%%ENDIF
%%ENDIF
%%IF(colDidNo%%(tabNo)_%%(j)(?))
%%IF(NOT didNos(%%(colDidNo%%(tabNo)_%%(j))))
%%SET didNos(, %%(colDidNo%%(tabNo)_%%(j)))
%%ENDIF
%%SET didPos%%(colDidNo%%(tabNo)_%%(j))(, %%(colDidPos%%(tabNo)_%%(j)))
%%SET didCols%%(colDidNo%%(tabNo)_%%(j))(, %%(col)Data)
%%ENDIF

%%ENDLOOP(j)

%%SET size(%%(bTrees%%(tabNo)[0]))
%%IF(size > 0)
! This variable holds color information about nodes. !
%%IF(size <= 2)%%SET size(2)
%%ELSIF(size <= 4)%%SET size(4)
%%ELSIF(size <= 8)%%SET size(8)
%%ELSIF(size <= 16)%%SET size(16)
%%ELSIF(size <= 32)%%SET size(32)
%%ELSIF(size <= 64)%%SET size(64)
%%ELSE%%SET size(128)%%ENDIF
    VARIABLE    %%(c)Color         %%(size)   DS RELOAD;
%%LOOP(j, bTrees%%(tabNo))
! This variable holds a pointer to the left subtree. !
    VARIABLE    %%(c)Left%%(j)         !R! 16 DS RELOAD;
! This variable holds a pointer to the right subtree. !
    VARIABLE    %%(c)Right%%(j)        !R! 16 DS RELOAD;
%%ENDLOOP(j)
%%ELSE
! This variable is used to hold a row reference in a cursor lookup. !
    VARIABLE    %%(c)LastRow       !R! 16 DS;
%%ENDIF
END RECORD;

! Structure of the data base number. !
STRUCTURE   %%(c)DBnumber =
    1       %%(c)DBnumber1      16,
    1       %%(c)DBnumber2      16;

! Structure of the packed numstring columns. !
%%LOOP(j, packNumCols%%(tabNo))
STRUCTURE %%(c)%%(cols%%(tabNo)[j])_Data =
    1 LENGTH 16,
    1 W1 16,
    1 W2 16,
%%IF(colSizes%%(tabNo)[j] = 12)
    1 W3 16;
%%ELSE
    1 W3 16,
    1 W4 16,
    1 W5 16,
    1 W6 16,
    1 W7 16;
%%ENDIF
%%ENDLOOP(j)

%%IF(bTrees%%(tabNo)[0] > 0)
! This variable indicates the current color of the node !
STRUCTURE %%(c)Color =
    1 %%(c)Color%%(bTrees%%(tabNo)[1]) 1
%%LOOP(j <= bTrees%%(tabNo)[0] - 1)
    , 1 %%(c)Color%%(bTrees%%(tabNo)[j + 1]) 1
%%ENDLOOP(j)
    ;
%%ENDIF

! The symbol values. !
%%LOOP(j, symCols%%(tabNo))
%%LOOP(k <= symVals%%(tabNo)_%%(j)[0])
NSYMB %%(tables[i])%%(cols%%(tabNo)[j])%%(symVals%%(tabNo)_%%(j)[k]) = %%(symLits%%(tabNo)_%%(j)[k]);
%%ENDLOOP(k)
%%ENDLOOP(j)
%%--
%%-- This variable holds the last row found when using a cursor access
%%-- (FETCH operation).
%%--
%%IF(bTrees%%(tabNo)[0] > 0)
%%SET %%(c)LastRow(%%(c)Left%%(bTrees%%(tabNo)[1]))
%%ELSE
%%SET %%(c)LastRow(%%(c)LastRow)
%%ENDIF
%%IF(bTrees%%(tabNo)(2) OR aks%%(tabNo)[0] > 0)
%%--
%%-- This variable is used to point to the next item in an insert or free
%%-- list. If there are no more items following, cNext is set to %%(p)NilRow.
%%--
%%-- In the GUARD row of the system rows cNext is used to point out the
%%-- beginning of the insert list.
%%--
%%-- NOTE: if the row is a member of a binary tree this variable is used to
%%-- point to the LEFT subtree. Thus a row can not, and must not, be a member
%%-- of a list and a tree at the same time.
%%--
%%SET %%(c)Next(%%(c)Left%%(bTrees%%(tabNo)[1]))
%%--
%%-- This variable is used to point to the previous item in an insert list.
%%-- The first item in the list points to the GUARD row. This variable is
%%-- not used in the free list.
%%--
%%-- NOTE: if the row is a member of a binary tree this variable is used to
%%-- point to the RIGHT subtree. Thus a row can not, and must not, be a
%%-- member of a list and a tree at the same time.
%%--
%%SET  %%(c)Prev(%%(c)Right%%(bTrees%%(tabNo)[1]))
%%ENDIF

! Pointers !
    POINTER %%(p)OperRow (%%(tab)Table);
    POINTER %%(p)WorkRow (%%(tab)Table);
    POINTER %%(p)GuardRow (%%(tab)Table);
    POINTER %%(p)NilRow (%%(tab)Table);
    POINTER %%(p)RootRow (%%(tab)Table);
    POINTER %%(p)TempRow (%%(tab)Table);
    POINTER %%(p)GrandGrandFather (%%(tab)Table);
    POINTER %%(p)GrandFather (%%(tab)Table);
    POINTER %%(p)Father (%%(tab)Table);
    POINTER %%(p)Brother (%%(tab)Table);
    POINTER %%(p)Nephew (%%(tab)Table);
    POINTER %%(p)Delete (%%(tab)Table);
    POINTER %%(p)DeleteFather (%%(tab)Table);
%%ENDLOOP(i)
%%END(towTables)
%%----> towTabInfo
-------------------------------------------------------------------------------
- towTabInfo
-
- Parameters: None
-
- IMP variables used: None
-
- IMP variables defined: None
-
- Temporary IMP variables: None
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(towTabInfo)
!------------------------------------------------!
!       towTabInfo !
!------------------------------------------------!
RECORD SQLT_TableInfo;
! The location of the first system row. !
    VARIABLE    SQLM_System    !R! 16 DS RELOAD;
! The number of rows in the table area, allocated or not. !
    VARIABLE    SQLM_TableAllocated !R! 16 DS RELOAD;
! The location of the last row which is allocated in the table area. !
    VARIABLE    SQLM_TableLast !R! 16 DS RELOAD;
! The number of allocated rows in the table area. !
    VARIABLE    SQLM_TableUsed !R! 16 DS RELOAD;
! The number of rows in the work area, allocated or not. !
    VARIABLE    SQLM_WorkAllocated  !R! 16 DS RELOAD;
! The location of the last row which is allocated in the work area. !
    VARIABLE    SQLM_WorkLast !R! 16 DS RELOAD;
! The number of allocated rows in the work area. !
    VARIABLE    SQLM_WorkUsed !R! 16 DS RELOAD;
! This variable locks the work area of a table. !
    VARIABLE    SQLM_WorkLock   1   DS CLEAR;
END RECORD;
! This variable holds the current table number. !
    POINTER     SQLM_TableReference (SQLT_TableInfo);
%%END(towTabInfo)
%%---> Handle: towVerRow
%%----> towVerRow
-------------------------------------------------------------------------------
- towVerRow
-
- Parameters: None
-
- IMP variables used:
-       akTabInds
-       checkTabInds
-       prepTabInds
-       tables
-       tabNos
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       t
-       ti
-
- Included code components:
-       towVerRowTable
-------------------------------------------------------------------------------
%%BEGIN(towVerRow)
!------------------------------------------------!
!       towVerRow !
!------------------------------------------------!
%%SET recSigs(,TOWVERROW)
    ENTER towVerRow WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow;
%%SET ti()
%%LOOP(t <= tabNos[0])
%%IF(akTabInds(%%(t)) OR checkTabInds(%%(t)) OR prepTabInds(%%(t)))
%%SET ti(, %%(t))
%%ENDIF
%%ENDLOOP(t)
%%IF(ti[0] > 0)
    CASE SQLM_TableReference IS
%%LOOP(t, ti)
    WHEN %%(tabNos[t]) DO GOTO towVerRowTable%%(tabNos[t]);
%%ENDLOOP(t)
    OTHERWISE DO
%%ENDIF
%%SET sentSigs(,TOWVERROWR)
        SEND towVerRowR WITH
            SQLX_OtherProtected,
            0;
        EXIT;
%%IF(ti[0] > 0)
    ESAC;
%%ENDIF
%%LOOP(t, ti)
%%INCLUDE(towVerRowTable(%%(t)))
%%ENDLOOP(t)
%%IF(akTabInds[0] > 0)
ERRORtowVerRowTable)
! Send back uniqness error !
%%SET sentSigs(,TOWVERROWR)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Uniqueness constraint failure !
        3 + 3 <= 8;
    EXIT;
%%ENDIF
%%END(towVerRow)
%%----> towVerRowTable
-------------------------------------------------------------------------------
- towVerRowTable
-
- Parameters:
-       1: Table index
-
- IMP variables used:
-       tables
-       tabNos
        prepLabelI
-       prepReturnI
-       tabChecks
-       towGetSchLab
-       bTreeColsI_J
-       aksI
-       towVerSchLab
-       schLimit
-       schConstI_J
-       schVer
-       indMax
-       cNext
-
- IMP variables defined:
-       towGetSchLab
-       towVerSchLab
-
- Temporary IMP variables:
-       ak
-       limit
-       p
-       p1
-       s
-       tNo
-
- Included code components:
-       beginStat
-       endStat
-       scanPredicate
-------------------------------------------------------------------------------
%%BEGIN(towVerRowTable)
!------------------------------------------------!
!       towVerRowTable !
!------------------------------------------------!
%%SET p1(%%(towVerRowTable[1]))
%%SET tNo(%%(tabNos[p1]))
%%SET c(SQLC_%%(tables[p1])_)
%%SET p(SQLM_%%(tables[p1])_)
%%SET s(SQLS_%%(tables[p1])_)
towVerRowTable%%(tNo))
%%IF(prepLabel%%(tNo)(?))
! execute user defined code !
%%INCLUDE(beginStat)
! Error: Protected region congestion, too many simultaneous users !
    IF SQLCODE = 3 + 17 <= 8 THEN
%%SET sentSigs(,TOWVERROWR)
        SEND towVerRowR WITH
            SQLX_OtherProtected,
            SQLCODE;
        EXIT;
    FI;
    PROTECTEDP:SQLLOCALCODE=0;
    PROTECTEDP:SQLBLOCK=SQLX_OtherBlock;
    PROTECTEDP:SQLOPERATION=SQLX_KeyOperation;
    PROTECTEDP:SQLX_SQLPROTECTED=SQLX_OtherProtected;
    PROTECTEDP:SQLX_SQLTABLEREFERENCE=SQLM_TableReference;
    PROTECTEDP:SQLX_SQLOPERROW=SQLX_OperRow;
    PROTECTEDP:SQLX_SQLWORKROW=SQLX_WorkRow;
%%IF(prepReturn%%(tNo)(?))
    GOTO %%(prepLabel%%(tNo));
%%(prepReturn%%(tNo)))
%%ELSE
    DO %%(prepLabel%%(tNo));
%%ENDIF
    SQLX_OtherBlock=PROTECTEDP:SQLBLOCK;
    SQLX_KeyOperation=PROTECTEDP:SQLOPERATION;
    SQLX_OtherProtected=PROTECTEDP:SQLX_SQLPROTECTED;
    SQLM_TableReference=PROTECTEDP:SQLX_SQLTABLEREFERENCE;
    SQLX_OperRow=PROTECTEDP:SQLX_SQLOPERROW;
    SQLX_WorkRow=PROTECTEDP:SQLX_SQLWORKROW;
    SQLX_Code=PROTECTEDP:SQLLOCALCODE;
%%INCLUDE(endStat)
    IF SQLX_Code /= 0 THEN
%%SET sentSigs(,TOWVERROWR)
        SEND towVerRowR WITH
            SQLX_OtherProtected,
! Table local status code: !
            4 + SQLX_Code <= 8;
        EXIT;
    FI;
%%ENDIF
%%IF(tabChecks[p1] > 0 OR aks%%(tNo)[0] > 0)
    IF SQLX_KeyOperation = 2 GOTO CONTINUE1towVerRowTable%%(tNo);
%%ENDIF
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow=SQLX_WorkRow;
    FI;
! insert or update key code !
%%IF(aks%%(tNo)[0] > 0)
! check alternate keys in insert list !
    %%(p)WorkRow=SQLX_WorkRow;
    %%(p)OperRow=SQLM_TableReference:SQLM_System;
    %%(p)NilRow=%%(p)OperRow+1;
    SQLX_Schedule=0;
LOOP1towVerRowTable%%(tNo))
    %%(p)OperRow=%%(p)OperRow:%%(%%(c)Next);
    IF %%(p)OperRow = %%(p)NilRow GOTO END1towVerRowTable%%(tNo);
    IF %%(p)OperRow = SQLX_OperRow GOTO LOOP1towVerRowTable%%(tNo);
    IF %%(p)OperRow = SQLX_WorkRow GOTO LOOP1towVerRowTable%%(tNo);
    SQLX_KeyNumber=2;
LOOP2towVerRowTable%%(tNo))
    SQLX_KeyNumber=SQLX_KeyNumber+1;
%%SET towVerSchLab(%%(towVerSchLab + 1))
towVerSchLab%%(towVerSchLab))
    CASE SQLX_KeyNumber IS
%%LOOP(ak, aks%%(tNo))
%%SET limit(%%(schLimit / (schConst%%(tNo)_%%(ak) + schVer)))
    WHEN %%(ak) DO
        SQLX_Schedule=SQLX_Schedule+1;
        IF SQLX_Schedule > %%(limit) THEN
%%SET sentSigs(,TOWVERSCH)
            SEND towVerSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLX_OtherBlock,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                %%(p)OperRow,
                SQLX_KeyNumber,
                %%(towVerSchLab);
            EXIT;
        FI;
        SQLX_KeyPrefix=%%(bTreeCols%%(tNo)_%%(ak)[0]);
        DO %%(s)KeyTest%%(ak);
%%ENDLOOP(ak)
    WHEN %%(aks%%(tNo)[aks%%(tNo)[0]] + 1) DO GOTO LOOP1towVerRowTable%%(tNo);
    OTHERWISE DO ! nothing ! ;
    ESAC;
    IF SQLX_KeyTest = 1 GOTO ERRORtowVerRowTable;
    GOTO LOOP2towVerRowTable%%(tNo);
END1towVerRowTable%%(tNo))
! check IF alternate key IS in btree !
%%LOOP(ak, aks%%(tNo))
    %%(p)OperRow=SQLX_OperRow;
    %%(p)WorkRow=SQLX_WorkRow;
    IF SQLX_KeyOperation=1 THEN
        SQLX_KeyPrefix=%%(bTreeCols%%(tNo)_%%(ak)[0]);
        DO %%(s)KeyTest%%(ak);
! used later in commit !
        %%(p)WorkRow:%%(c)Color%%(ak)=SQLX_KeyTest;
        IF SQLX_KeyTest=1 GOTO CONTINUE2towVerRowTable%%(tNo)_%%(ak);
    FI;
    %%(p)RootRow=SQLM_TableReference:SQLM_System+2;
%%SET sentSigs(,TOWGETSCH)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        %%(ak),
        %%(p)RootRow:%%(c)Right%%(ak),
        SQLX_WorkRow,
        SQLX_KeyOperation, ! use DR5 !
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        %%(bTreeCols%%(tNo)_%%(ak)[0]),
        SQLX_OperRow,
%%SET towGetSchLab(%%(towGetSchLab + 1))
        %%(towGetSchLab);
    EXIT;
towGetSchLab%%(towGetSchLab))
    SQLX_KeyOperation = SQLX_DR5;
    %%(p)OperRow=SQLX_OperRow;
    SQLX_OperRow=SQLX_RightTurn;
    IF %%(p)OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowVerRowTable;
CONTINUE2towVerRowTable%%(tNo)_%%(ak))
%%ENDLOOP(ak)
%%ENDIF
%%IF(tabChecks[p1] > 0)
! Check columns !
    %%(p)OperRow=SQLX_WorkRow;
%%LOOP(i <= tabChecks[p1])
%%INCLUDE(scanPredicate(%%(tNo), %%(tables[p1]), %%(tNo)_%%(i), "CONTINUE1towVerRowTable%%(tNo)", "FAILUREtowVerRowTable%%(tNo)", "C"))
%%ENDLOOP(i)
FAILUREtowVerRowTable%%(tNo))
%%SET sentSigs(,TOWVERROWR)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
! Error: Table check failure, transaction rolled back !
        3 + 5 <= 8;
    EXIT;
%%ENDIF
%%IF(tabChecks[p1] > 0 OR aks%%(tNo)[0] > 0)
CONTINUE1towVerRowTable%%(tNo))
%%ENDIF
%%SET sentSigs(,TOWVERROWR)
    SEND towVerRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
%%END(towVerRowTable)
%%---> Handle: towVerSch
%%----> towVerSch
-------------------------------------------------------------------------------
- towVerSch
-
- Parameters: None
-
- IMP variables used:
-       towVerSchLab
-       tabNos
-       tables
-       akTabInds
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       l
-       p
-       t
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(towVerSch)
!------------------------------------------------!
!       towVerSch !
!------------------------------------------------!
%%IF(towVerSchLab > 0)
%%SET recSigs(,TOWVERSCH)
    ENTER towVerSch WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
%%IF(akTabInds[0] > 1)
        SQLX_OperRow,
        SQLX_WorkRow,
%%ELSE
%%SET p(SQLM_%%(tables[akTabInds])_)
        %%(p)OperRow,
        %%(p)WorkRow,
%%ENDIF
        SQLX_TempRow,
        SQLX_KeyNumber,
        SQLX_ReturnLabel;
    SQLX_Schedule=0;
%%IF(akTabInds[0] > 1)
    CASE SQLM_TableReference IS
%%LOOP(t, akTabInds)
%%SET p(SQLM_%%(tables[t])_)
    WHEN %%(tabNos[t]) DO
        %%(p)WorkRow=SQLX_WorkRow;
        %%(p)OperRow=SQLX_TempRow;
        %%(p)NilRow=SQLM_TableReference:SQLM_System+1;
%%ENDLOOP(t)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ELSE
%%SET p(SQLM_%%(tables[akTabInds])_)
    %%(p)NilRow=SQLM_TableReference:SQLM_System+1;
%%ENDIF
%%IF(towVerSchLab > 1)
    CASE SQLX_ReturnLabel IS
%%LOOP(l <= towVerSchLab)
    WHEN %%(l) DO GOTO towVerSchLab%%(l);
%%ENDLOOP(l)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ELSE
    GOTO towVerSchLab1;
%%ENDIF
%%ENDIF
%%END(towVerSch)
%%---> Handle: towComRow
%%----> towComRow
-------------------------------------------------------------------------------
- towComRow
-
- Parameters: None
-
- IMP variables used: None
-       tables
-       tabNos
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       t
-
- Included code components: None
-       towComRowTable
-------------------------------------------------------------------------------
%%BEGIN(towComRow)
!------------------------------------------------!
!       towComRow !
!------------------------------------------------!
%%SET recSigs(,TOWCOMROW)
    ENTER towComRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2;
%%IF(tables[0] > 1)
    CASE SQLM_TableReference IS
%%LOOP(t, tabNos)
    WHEN %%(t) DO GOTO towComRowTable%%(t);
%%ENDLOOP(t)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ENDIF
%%LOOP(t <= tables[0])
%%INCLUDE(towComRowTable(%%(t)))
%%ENDLOOP(t)
%%END(towComRow)
%%----> towComRowTable
-------------------------------------------------------------------------------
- towComRowTable
-
- Parameters:
-       1: Table index
-
- IMP variables used:
-       towComSchLab
-       scanMax
-       bTreesI
-       colNullI
-       tables
-       colsI
-       normColsI
-       towComInsKeyLab
-       bTreeColsI_J
-       towComDelKeyLab
-
- IMP variables defined:
-       towComSchLab
-       towComInsKeyLab
-       towComDelKeyLab
-
- Temporary IMP variables:
-       bt
-       c
-       col
-       i
-       last
-       p
-       p1
-       tNo
-
- Included code components:
-       putIntoFreeList
-       deAllocateWorkRow
-------------------------------------------------------------------------------
%%BEGIN(towComRowTable)
!------------------------------------------------!
!       towComRowTable !
!------------------------------------------------!
%%SET p1(%%(towComRowTable[1]))
%%SET tNo(%%(tabNos[p1]))
%%SET c(SQLC_%%(tables[p1])_)
%%SET p(SQLM_%%(tables[p1])_)
%%IF(tables[0] > 1)
towComRowTable%%(tNo))
%%ENDIF
%%IF(bTrees%%(tNo)[0] > 0)
    %%(p)OperRow=SQLX_OperRow;
    %%(p)WorkRow=SQLX_WorkRow;
%%SET last(%%(bTrees%%(tNo)[0] + 1))
%%LOOP(bt <= last - 1)
! test if we need to update key (only update) !
%%SET towComSchLab(%%(towComSchLab + 1))
%%SET btNo(%%(bTrees%%(tNo)[last - bt]))
%%IF(btNo = 2 OR aks%%(tNo)(%%(btNo)))
    IF SQLX_KeyOperation /= 1 GOTO towComSchLab%%(towComSchLab);
    %%(p)WorkRow=SQLX_WorkRow;
    IF %%(p)WorkRow:%%(c)Color%%(btNo)=1
        GOTO LABEL2towComRowTable%%(tNo)_%%(btNo);
%%ENDIF
! wait until no one is locking the tree !
towComSchLab%%(towComSchLab))
    %%(p)RootRow=SQLM_TableReference:SQLM_System+2;
    %%(p)NilRow=%%(p)RootRow-1;
    IF %%(p)RootRow:%%(c)Left%%(btNo)=%%(p)NilRow THEN
%%SET sentSigs(,TOWCOMSCH)
        SEND towComSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            %%(towComSchLab);
        EXIT;
    FI;
    %%(p)RootRow:%%(c)Left%%(btNo)=%%(p)NilRow;
! remove old key in tree (only for update and delete) !
%%SET towComDelKeyLab(%%(towComDelKeyLab + 1))
    IF SQLX_KeyOperation=0 GOTO towComDelKeyLab%%(towComDelKeyLab);
    %%(p)RootRow=SQLM_TableReference:SQLM_System+2;
%%SET sentSigs(,TOWCOMDELKEY)
    SEND towComDelKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        %%(btNo),
        %%(towComDelKeyLab),
        %%(bTreeCols%%(tNo)_%%(btNo)[0]),
        +,
        %%(p)RootRow,
        %%(p)RootRow:%%(c)Right%%(btNo),
        +,
        SQLM_TableReference:SQLM_System+1;
    EXIT;
towComDelKeyLab%%(towComDelKeyLab))
! copy the key into the row (only for update) !
    IF SQLX_KeyOperation /= 1 GOTO LABEL1towComRowTable%%(tNo)_%%(btNo);
    %%(p)OperRow=SQLX_OperRow;
    %%(p)WorkRow=SQLX_WorkRow;
%%LOOP(i, bTreeCols%%(tNo)_%%(btNo))
%%SET col(SQLC_%%(tables[p1])_%%(cols%%(tNo)[i])_)
%%IF(colNull%%(tNo)[i] = 1)
    %%(p)OperRow:%%(col)Null=
        %%(p)WorkRow:%%(col)Null;
%%ENDIF
%%IF(colTypes%%(tNo)[i] # "PACKED NUMSTRING")
    %%(p)OperRow:%%(col)Data=
        %%(p)WorkRow:%%(col)Data;
%%ELSE
%%INCLUDE(copyPackNum("%%(p)OperRow:%%(col)Data", "%%(p)WorkRow:%%(col)Data", %%(colSizes%%(tNo)[i])))
%%ENDIF
%%ENDLOOP(i)
LABEL1towComRowTable%%(tNo)_%%(btNo))
! insert new key (only for insert and update) !
%%SET towComInsKeyLab(%%(towComInsKeyLab + 1))
    IF SQLX_KeyOperation = 2 GOTO towComInsKeyLab%%(towComInsKeyLab);
%%SET sentSigs(,TOWCOMINSKEY)
    SEND towComInsKey REFERENCE cOwnRef WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        %%(btNo),
        %%(towComInsKeyLab),
        %%(bTreeCols%%(tNo)_%%(btNo)[0]),
        +,
        +,
        +,
        SQLM_TableReference:SQLM_System+2; ! pRootRow !
    EXIT;
towComInsKeyLab%%(towComInsKeyLab))
    %%(p)RootRow=SQLM_TableReference:SQLM_System+2;
    %%(p)RootRow:%%(c)Left%%(btNo)=0;
%%IF(btNo = 2 OR aks%%(tNo)(%%(btNo)))
LABEL2towComRowTable%%(tNo)_%%(btNo))
%%ENDIF
%%ENDLOOP(bt)
%%ENDIF
    %%(p)OperRow=SQLX_OperRow;
    %%(p)WorkRow=SQLX_WorkRow;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
! update the data base number of the row. !
        %%(p)OperRow:%%(c)DBnumber1 = SQLX_DBnumber1;
        %%(p)OperRow:%%(c)DBnumber2 = SQLX_DBnumber2;
! The number of used rows are increased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed+1;
    WHEN 1 DO
%%IF(bTrees%%(tNo)(2) OR aks%%(tNo)[0] > 0)
        %%(p)OperRow=SQLX_WorkRow;
        %%(p)NilRow=SQLM_TableReference:SQLM_System+1;
%%INCLUDE(deleteFromInsertList(%%(p1)))
        %%(p)OperRow=SQLX_WorkRow;
%%ENDIF
%%LOOP(i, normCols%%(tNo))
%%IF(i # 1)
%%SET col(SQLC_%%(tables[p1])_%%(cols%%(tNo)[i])_)
%%IF(colNull%%(tNo)[i] = 1)
        %%(p)OperRow:%%(col)Null=
            %%(p)WorkRow:%%(col)Null;
%%ENDIF
%%IF(colTypes%%(tNo)[i] # "PACKED NUMSTRING")
        %%(p)OperRow:%%(col)Data=
            %%(p)WorkRow:%%(col)Data;
%%ELSE
%%INCLUDE(copyPackNum("%%(p)OperRow:%%(col)Data", "%%(p)WorkRow:%%(col)Data", %%(colSizes%%(tNo)[i])))
%%ENDIF
%%ENDIF
%%ENDLOOP(i)
! deallocate work row !
%%INCLUDE(deAllocateWorkRow(%%(tables[p1])))
! update the data base number of the row. !
        %%(p)OperRow:%%(c)DBnumber1 = SQLX_DBnumber1;
        %%(p)OperRow:%%(c)DBnumber2 = SQLX_DBnumber2;
    WHEN 2 DO
! deallocate row !
        %%(p)OperRow:%%(c)Allocated=0;
        %%(p)OperRow:%%(c)Lock=0;
! The number of used rows are decreased by one !
        SQLM_TableReference:SQLM_TableUsed=
            SQLM_TableReference:SQLM_TableUsed-1;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! Find SQLM_TableLast !
    IF SQLX_KeyOperation /= 2 GOTO CONTINUEtowComRowTable%%(tNo);
%%SET towComSchLab(%%(towComSchLab + 1))
towComSchLab%%(towComSchLab))
    IF %%(p)OperRow = SQLM_TableReference:SQLM_TableLast THEN
! If the last row is released find a new last row. !
        %%(p)WorkRow=SQLM_TableReference:SQLM_TableLast+1;
        IF %%(p)WorkRow > %%(scanMax) THEN
            FOR FIRST %%(p)WorkRow
                FROM %%(p)WorkRow-1
                UNTIL %%(p)WorkRow-%%(scanMax)
                WHERE %%(p)WorkRow:%%(c)Allocated = 1
                GOTO FOUNDtowComRowTable%%(tNo);
%%SET sentSigs(,TOWCOMSCH)
            SEND towComSch REFERENCE cOwnRef WITH
                SQLX_OtherProtected,
                SQLM_TableReference,
                SQLX_KeyOperation,
                SQLX_OperRow,
                SQLX_WorkRow,
                SQLX_DBnumber1,
                SQLX_DBnumber2,
                %%(towComSchLab);
            EXIT;
        ELSE
            FOR FIRST %%(p)WorkRow
                FROM %%(p)WorkRow-1
                WHERE %%(p)WorkRow:%%(c)Allocated = 1
                GOTO FOUNDtowComRowTable%%(tNo);
            %%(p)WorkRow=0;
        FI;
FOUNDtowComRowTable%%(tNo))
        SQLM_TableReference:SQLM_TableLast=%%(p)WorkRow;
    FI;
CONTINUEtowComRowTable%%(tNo))
! send back success !
%%SET sentSigs(,TOWCOMROWR)
    SEND towComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
%%END(towComRowTable)
%%---> Handle: towComSch
%%----> towComSch
-------------------------------------------------------------------------------
- towComSch
-
- Parameters: None
-
- IMP variables used:
-       towComSchLab
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       l
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(towComSch)
!------------------------------------------------!
!       towComSch !
!------------------------------------------------!
%%IF(towComSchLab > 0)
%%SET recSigs(,TOWCOMSCH)
    ENTER towComSch WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        SQLX_ReturnLabel;
%%IF(towComSchLab = 1)
    GOTO towComSchLab1;
%%ELSE
    CASE SQLX_ReturnLabel IS
%%LOOP(l <= towComSchLab)
    WHEN %%(l) DO GOTO towComSchLab%%(l);
%%ENDLOOP(l)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ENDIF
%%ENDIF
%%END(towComSch)
%%---> Handle: towComInsKey
%%----> towComInsKey
-------------------------------------------------------------------------------
- towComInsKey
-
- Parameters: None
-
- IMP variables used:
-       btTabInds
-       tabNos
-       towComInsKeyLab
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       t
-
- Included code components: None
-       towComInsKeyTable
-------------------------------------------------------------------------------
%%BEGIN(towComInsKey)
!------------------------------------------------!
!       towComInsKey !
!------------------------------------------------!
%%IF(towComInsKeyLab > 0)
%%SET recSigs(,TOWCOMINSKEY)
    ENTER towComInsKey WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        SQLX_KeyNumber,
        SQLX_ReturnLabel,
        SQLX_KeyPrefix,
        SQLX_GrandGrandFather,
        SQLX_GrandFather,
        SQLX_Father,
        SQLX_Current;
%%IF(btTabInds[0] > 1)
    CASE SQLM_TableReference IS
%%LOOP(t, btTabInds)
    WHEN %%(tabNos[t]) DO
%%INCLUDE(towComInsKeyTable(%%(t)))
%%ENDLOOP(t)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ELSE
%%INCLUDE(towComInsKeyTable(%%(btTabInds[1])))
%%ENDIF
%%ENDIF
%%END(towComInsKey)
%%----> towComInsKeyTable
-------------------------------------------------------------------------------
- towComInsKeyTable
-
- Parameters:
-       1: Table index
-
- IMP variables used: None
-       bTreesI
-       tabNos
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       bt
-       p1
-       tNo
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(towComInsKeyTable)
!------------------------------------------------!
!       towComInsKeyTable !
!------------------------------------------------!
%%SET p1(%%(towComInsKeyTable[1]))
%%SET tNo(%%(tabNos[p1]))
%%IF(bTrees%%(tNo)[0] > 1)
    CASE SQLX_KeyNumber IS
%%LOOP(bt, bTrees%%(tNo))
    WHEN %%(bt) DO GOTO towComInsKeyTableKey%%(tNo)_%%(bt);
%%ENDLOOP(bt)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
%%LOOP(bt, bTrees%%(tNo))
%%INCLUDE(towComInsKeyTableKey(%%(p1), %%(bt)))
%%ENDLOOP(bt)
%%END(towComInsKeyTable)
%%----> towComInsKeyTableKey
-------------------------------------------------------------------------------
- towComInsKeyTableKey
-
- Parameters:
-       1: Table index
-       2: B-tree number
-
- IMP variables used:
-       tables
-       tabNos
-       towComInsKeyLab
-       aksI
-       bTreesI
-       schLimit
-       schConstI_J
-       schInsKey
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       btNo
-       c
-       l
-       limit
-       p
-       q1
-       s
-       tabNo
-
- Included code components:
-       deleteFromInsertList
-------------------------------------------------------------------------------
%%BEGIN(towComInsKeyTableKey)
!------------------------------------------------!
!       towComInsKeyTableKey !
!------------------------------------------------!
%%SET q1(%%(towComInsKeyTableKey[1]))
%%SET tabNo(%%(tabNos[q1]))
%%SET btNo(%%(towComInsKeyTableKey[2]))
%%SET c(SQLC_%%(tables[q1])_)
%%SET p(SQLM_%%(tables[q1])_)
%%SET s(SQLS_%%(tables[q1])_)
%%IF(bTrees%%(tabNo)[0] > 1)
towComInsKeyTableKey%%(tabNo)_%%(btNo))
%%ENDIF
! Setup pointers and clear loop counter. !
    %%(p)NilRow = SQLM_TableReference:SQLM_System+1;
    %%(p)GrandGrandFather=SQLX_GrandGrandFather;
    %%(p)GrandFather=SQLX_GrandFather;
    %%(p)Father=SQLX_Father;
    %%(p)OperRow=SQLX_Current;
    %%(p)WorkRow=SQLX_OperRow;
    SQLX_Schedule=0;
    IF %%(p)OperRow = %%(p)NilRow+1 THEN
        SQLX_KeyTest=0;
        GOTO ENTERtowComInsKeyTableKey%%(tabNo)_%%(btNo);
    FI;
LOOPtowComInsKeyTableKey%%(tabNo)_%%(btNo))
! Check if scheduling is necessary, if so schedule. !
%%SET limit(%%(schLimit / (schConst%%(tabNo)_%%(btNo) + schInsKey)))
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > %%(limit) THEN
%%SET sentSigs(,TOWCOMINSKEY)
        SEND towComInsKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            %%(p)GrandGrandFather,
            %%(p)GrandFather,
            %%(p)Father,
            %%(p)OperRow;
        EXIT;
    FI;
! If the root node is nil, abort. !
    IF %%(p)OperRow = %%(p)NilRow
        GOTO ENDLOOPtowComInsKeyTableKey%%(tabNo)_%%(btNo);
! Test key to be inserted against 'root' node. !
    DO %%(s)KeyTest%%(btNo);
%%IF(btNo # 2 AND NOT aks%%(tabNo)(%%(btNo)))
    IF SQLX_KeyTest = 1 THEN
! If key exist, abort. !
        IF %%(p)OperRow = %%(p)WorkRow GOTO ENDLOOPtowComInsKeyTableKey%%(tabNo)_%%(btNo);
        IF %%(p)OperRow > %%(p)WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
%%ELSE
! If key exist, abort. !
    IF SQLX_KeyTest = 1 GOTO ENDLOOPtowComInsKeyTableKey%%(tabNo)_%%(btNo);
%%ENDIF
! Walk left or right determined upon the keytest (above). !
ENTERtowComInsKeyTableKey%%(tabNo)_%%(btNo))
    %%(p)GrandGrandFather = %%(p)GrandFather;
    %%(p)GrandFather = %%(p)Father;
    %%(p)Father = %%(p)OperRow;
    IF SQLX_KeyTest > 1 THEN
        %%(p)OperRow = %%(p)OperRow:%%(c)Left%%(btNo);
    ELSE
        %%(p)OperRow = %%(p)OperRow:%%(c)Right%%(btNo);
    FI;
! Reorganize the tree if needed. Check if we are atop a 4-node. If so
  this node has to be split into a 2+2 node to allow further
  propagations of single nodes upwards in the tree. !
    %%(p)TempRow = %%(p)OperRow:%%(c)Left%%(btNo);
    IF %%(p)TempRow:%%(c)Color%%(btNo) = 0 THEN
        %%(p)TempRow = %%(p)OperRow:%%(c)Right%%(btNo);
        IF %%(p)TempRow:%%(c)Color%%(btNo) = 0 THEN
! Top of a 4-node. !
            IF %%(p)OperRow = %%(p)NilRow THEN
! If both children to 'root' row are RED (0) and the 'root' row is NIL
  then insert the work row. !
DISABLE INTERRUPT;
                %%(p)OperRow=%%(p)WorkRow;
%%IF(btNo = 2 OR NOT bTrees%%(tabNo)(2) AND btNo = 3 AND aks%%(tabNo)(3))
! remove row from insert list !
%%INCLUDE(deleteFromInsertList(%%(q1)))
%%ENDIF
                %%(p)OperRow:%%(c)Color%%(btNo) = 0;
                %%(p)OperRow:%%(c)Left%%(btNo)  =
                    %%(p)NilRow;
                %%(p)OperRow:%%(c)Right%%(btNo) =
                    %%(p)NilRow;
ENABLE INTERRUPT;
! Make father node of work row point to the work row !
                %%(p)WorkRow = %%(p)Father;
                DO %%(s)KeyTest%%(btNo);
%%IF(btNo # 2 AND NOT aks%%(tabNo)(%%(btNo)))
                IF SQLX_KeyTest = 1 THEN
                    IF %%(p)OperRow > %%(p)WorkRow THEN
                        SQLX_KeyTest = 2;
                    ELSE
                        SQLX_KeyTest = 0;
                    FI;
                FI;
%%ENDIF
DISABLE INTERRUPT;
                %%(p)WorkRow = %%(p)OperRow;
                IF SQLX_KeyTest < 1 THEN
                    %%(p)Father:%%(c)Left%%(btNo) =
                        %%(p)OperRow;
                ELSE
                    %%(p)Father:%%(c)Right%%(btNo) =
                        %%(p)OperRow;
                FI;
ENABLE INTERRUPT;
            ELSE
! If both children to 'root' row are RED (0) and the 'root' node is NOT
  NIL then performe a color flip (splitting a 4-node into 2 2-nodes and
  propogating one node up in the tree: 2-4-node to a 3-2+2-node, 3-4
  node to a 4-2+2-node). !
                %%(p)TempRow =
                    %%(p)OperRow:%%(c)Left%%(btNo);
                %%(p)TempRow:%%(c)Color%%(btNo) = 1;
                %%(p)TempRow =
                    %%(p)OperRow:%%(c)Right%%(btNo);
                %%(p)TempRow:%%(c)Color%%(btNo) = 1;
                %%(p)OperRow:%%(c)Color%%(btNo) = 0;
            FI;
! If father is RED (0) then a balance must be performed (this is a
  3-4-node split into a 4-2+2-node) !
            IF %%(p)Father:%%(c)Color%%(btNo) = 0 THEN
DISABLE INTERRUPT;
                IF %%(p)GrandFather:%%(c)Left%%(btNo) =
                   %%(p)Father
                THEN
                    IF %%(p)Father:%%(c)Right%%(btNo) =
                       %%(p)OperRow
                    THEN
! Double rotation !
                        %%(p)Father:%%(c)Right%%(btNo) =
                            %%(p)OperRow:%%(c)Left%%(btNo);
                        %%(p)OperRow:%%(c)Left%%(btNo) =
                            %%(p)Father;
                        %%(p)Father =
                            %%(p)OperRow;
                    FI;
! Single rotation or end of double rotation !
                    %%(p)GrandFather:%%(c)Left%%(btNo) =
                        %%(p)Father:%%(c)Right%%(btNo);
                    %%(p)Father:%%(c)Right%%(btNo) =
                        %%(p)GrandFather;
                ELSE
                    IF %%(p)Father:%%(c)Left%%(btNo) =
                        %%(p)OperRow
                    THEN
! Double rotation !
                        %%(p)Father:%%(c)Left%%(btNo) =
                            %%(p)OperRow:%%(c)Right%%(btNo);
                        %%(p)OperRow:%%(c)Right%%(btNo) =
                            %%(p)Father;
                        %%(p)Father =
                            %%(p)OperRow;
                    FI;
! Single rotation or end of double rotation !
                    %%(p)GrandFather:%%(c)Right%%(btNo) =
                        %%(p)Father:%%(c)Left%%(btNo);
                    %%(p)Father:%%(c)Left%%(btNo) =
                        %%(p)GrandFather;
                FI;
! Recolor father node and its children. !
                %%(p)TempRow =
                    %%(p)Father:%%(c)Left%%(btNo);
                %%(p)TempRow:%%(c)Color%%(btNo) = 0;
                %%(p)TempRow =
                    %%(p)Father:%%(c)Right%%(btNo);
                %%(p)TempRow:%%(c)Color%%(btNo) = 0;
                %%(p)Father:%%(c)Color%%(btNo) = 1;
! Relink nodes !
                IF %%(p)GrandGrandFather:%%(c)Right%%(btNo) =
                    %%(p)GrandFather
                THEN
                    %%(p)GrandGrandFather:%%(c)Right%%(btNo) =
                        %%(p)Father;
                ELSE
                    %%(p)GrandGrandFather:%%(c)Left%%(btNo) =
                        %%(p)Father;
                FI;
                %%(p)GrandFather =
                    %%(p)Father;
                %%(p)OperRow =
                    %%(p)GrandFather;
ENABLE INTERRUPT;
            FI;
        FI;
    FI;
    GOTO LOOPtowComInsKeyTableKey%%(tabNo)_%%(btNo);
! Aftermath !
ENDLOOPtowComInsKeyTableKey%%(tabNo)_%%(btNo))
! Recolor root node (should ALWAYS be BLACK (1)) !
    %%(p)RootRow = SQLM_TableReference:SQLM_System+2;
    %%(p)TempRow =
        %%(p)RootRow:%%(c)Right%%(btNo);
    %%(p)TempRow:%%(c)Color%%(btNo) = 1;
! jump back !
    CASE SQLX_ReturnLabel IS
%%LOOP(l <= towComInsKeyLab)
    WHEN %%(l) DO GOTO towComInsKeyLab%%(l);
%%ENDLOOP(l)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%END(towComInsKeyTableKey)
%%---> Handle: towComDelKey
%%----> towComDelKey
-------------------------------------------------------------------------------
- towComDelKey
-
- Parameters: None
-
- IMP variables used: None
-       btTabInds
-       tabNos
-       towComDelKeyLab
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       t
-
- Included code components: None
-       towComDelKeyTable
-------------------------------------------------------------------------------
%%BEGIN(towComDelKey)
!------------------------------------------------!
!       towComDelKey !
!------------------------------------------------!
%%IF(towComDelKeyLab > 0)
%%SET recSigs(,TOWCOMDELKEY)
    ENTER towComDelKey WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow,
        SQLX_DBnumber1,
        SQLX_DBnumber2,
        SQLX_KeyNumber,
        SQLX_ReturnLabel,
        SQLX_KeyPrefix,
        SQLX_GrandFather,
        SQLX_Father,
        SQLX_Current,
        SQLX_DeleteFather,
        SQLX_Delete;
%%IF(btTabInds[0] > 1)
    CASE SQLM_TableReference IS
%%LOOP(t, btTabInds)
    WHEN %%(tabNos[t]) DO
%%INCLUDE(towComDelKeyTable(%%(t)))
%%ENDLOOP(t)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ELSE
%%INCLUDE(towComDelKeyTable(%%(btTabInds[1])))
%%ENDIF
%%ENDIF
%%END(towComDelKey)
%%----> towComDelKeyTable
-------------------------------------------------------------------------------
- towComDelKeyTable
-
- Parameters:
-       1: Table index
-
- IMP variables used:
-       bTreesI
-       tabNos
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       bt
-       p1
-       tNo
-
- Included code components:
-       towComDelKeyTableKey
-------------------------------------------------------------------------------
%%BEGIN(towComDelKeyTable)
!------------------------------------------------!
!       towComDelKeyTable !
!------------------------------------------------!
%%SET p1(%%(towComDelKeyTable[1]))
%%SET tNo(%%(tabNos[p1]))
%%IF(bTrees%%(tNo)[0] > 1)
    CASE SQLX_KeyNumber IS
%%LOOP(bt, bTrees%%(tNo))
    WHEN %%(bt) DO GOTO towComDelKeyTableKey%%(tNo)_%%(bt);
%%ENDLOOP(bt)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
%%LOOP(bt, bTrees%%(tNo))
%%INCLUDE(towComDelKeyTableKey(%%(p1), %%(bt)))
%%ENDLOOP(bt)
%%END(towComDelKeyTable)
%%----> towComDelKeyTableKey
-------------------------------------------------------------------------------
- towComDelKeyTableKey
-
- Parameters:
-       1: Table index
-       2: B-tree number
-
- IMP variables used:
-       tables
-       tabNos
-       towComDelKeyLab
-       aksI
-       schLimit
-       schConstI_J
-       schDelKey
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       btNo
-       c
-       l
-       limit
-       p
-       q1
-       s
-       tabNo
-
- Included code components:
-       putIntoFreeList
-------------------------------------------------------------------------------
%%BEGIN(towComDelKeyTableKey)
!------------------------------------------------!
!       towComDelKeyTableKey !
!------------------------------------------------!
%%SET q1(%%(towComDelKeyTableKey[1]))
%%SET tabNo(%%(tabNos[q1]))
%%SET btNo(%%(towComDelKeyTableKey[2]))
%%SET c(SQLC_%%(tables[q1])_)
%%SET p(SQLM_%%(tables[q1])_)
%%SET s(SQLS_%%(tables[q1])_)
%%IF(bTrees%%(tNo)[0] > 1)
towComDelKeyTableKey%%(tabNo)_%%(btNo))
%%ENDIF
! Setup pointers !
    %%(p)GrandFather=SQLX_GrandFather;
    %%(p)Father=SQLX_Father;
    %%(p)OperRow=SQLX_Current;
    %%(p)WorkRow=SQLX_WorkRow;
    %%(p)DeleteFather=SQLX_DeleteFather;
    %%(p)Delete=SQLX_Delete;
    %%(p)NilRow=SQLM_TableReference:SQLM_System+1;
    SQLX_Schedule=0;
LOOPtowComDelKeyTableKey%%(tabNo)_%%(btNo))
! Check if scheduling is needed !
%%SET limit(%%(schLimit / (schConst%%(tabNo)_%%(btNo) + schDelKey)))
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > %%(limit) THEN
%%SET sentSigs(,TOWCOMDELKEY)
        SEND towComDelKey REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyOperation,
            SQLX_OperRow,
            SQLX_WorkRow,
            SQLX_DBnumber1,
            SQLX_DBnumber2,
            SQLX_KeyNumber,
            SQLX_ReturnLabel,
            SQLX_KeyPrefix,
            %%(p)GrandFather,
            %%(p)Father,
            %%(p)OperRow,
            %%(p)DeleteFather,
            %%(p)Delete;
        EXIT;
    FI;
! If current row is NIL, if so abort. !
    IF %%(p)OperRow=%%(p)NilRow
        GOTO ENDLOOPtowComDelKeyTableKey%%(tabNo)_%%(btNo);
! Test key. !
    DO %%(s)KeyTest%%(btNo);
%%IF(btNo # 2 AND NOT aks%%(tabNo)(%%(btNo)))
    IF SQLX_KeyTest = 1 THEN
        IF %%(p)OperRow > %%(p)WorkRow THEN
            SQLX_KeyTest = 2;
        ELSE
            SQLX_KeyTest = 0;
        FI;
    FI;
%%ENDIF
! Move down to next node !
    %%(p)GrandFather=%%(p)Father;
    %%(p)Father=%%(p)OperRow;
    IF SQLX_KeyTest > 1 THEN
        %%(p)OperRow=
            %%(p)Father:%%(c)Left%%(btNo);
        %%(p)Brother=
            %%(p)Father:%%(c)Right%%(btNo);
    ELSE
        %%(p)OperRow=
            %%(p)Father:%%(c)Right%%(btNo);
        %%(p)Brother=
            %%(p)Father:%%(c)Left%%(btNo);
    FI;
! If father-node is the top-node of a 3-node rotate the 3-node so that
  current-node is a RED (0) node. If the current-node allready is a RED (0)
  node, no ratation is taken place. !
    IF %%(p)OperRow:%%(c)Color%%(btNo) (*)
        %%(p)Father:%%(c)Color%%(btNo) (*)
        (-) %%(p)Brother:%%(c)Color%%(btNo) = 1
    THEN
DISABLE INTERRUPT;
        %%(p)Father:%%(c)Color%%(btNo)=0;
        %%(p)Brother:%%(c)Color%%(btNo)=1;
        IF %%(p)Father:%%(c)Right%%(btNo)=
            %%(p)Brother
        THEN
            %%(p)Father:%%(c)Right%%(btNo)=
                %%(p)Brother:%%(c)Left%%(btNo);
            %%(p)Brother:%%(c)Left%%(btNo)=
                %%(p)Father;
        ELSE
            %%(p)Father:%%(c)Left%%(btNo)=
                %%(p)Brother:%%(c)Right%%(btNo);
            %%(p)Brother:%%(c)Right%%(btNo)=
                %%(p)Father;
        FI;
        IF %%(p)GrandFather:%%(c)Left%%(btNo)=
            %%(p)Father
        THEN
            %%(p)GrandFather:%%(c)Left%%(btNo)=
                %%(p)Brother;
        ELSE
            %%(p)GrandFather:%%(c)Right%%(btNo)=
                %%(p)Brother;
        FI;
        %%(p)GrandFather=%%(p)Brother;
        IF %%(p)Father:%%(c)Left%%(btNo)=
            %%(p)OperRow
        THEN
            %%(p)Brother=
                %%(p)Father:%%(c)Right%%(btNo);
        ELSE
            %%(p)Brother=
                %%(p)Father:%%(c)Left%%(btNo);
        FI;
ENABLE INTERRUPT;
    FI;
! Set the brother-child-node to the child 'nearest' the current-node in
  value. !
    IF %%(p)Father:%%(c)Left%%(btNo)=
        %%(p)OperRow
    THEN
        %%(p)Nephew=
            %%(p)Brother:%%(c)Left%%(btNo);
    ELSE
        %%(p)Nephew=
            %%(p)Brother:%%(c)Right%%(btNo);
    FI;
! If current-node is top-node of a 2-node. !
    IF %%(p)OperRow:%%(c)Color%%(btNo)=1 THEN
     %%(p)TempRow=
         %%(p)OperRow:%%(c)Right%%(btNo);
     IF %%(p)TempRow:%%(c)Color%%(btNo)=1 THEN
      %%(p)TempRow=
          %%(p)OperRow:%%(c)Left%%(btNo);
      IF %%(p)TempRow:%%(c)Color%%(btNo)=1 THEN
! And brother-node is top-node of a 2-node. If so color flip these two
$ 2-nodes into a 4-node removing one node from the node containing the
$ father-node.
$   2-2+2-node  =>  4-node
$   3-2+2-node  =>  2-4-node
$   4-2+2-node  =>  3-4-node !
        IF %%(p)Brother:%%(c)Color%%(btNo)=1 THEN
         %%(p)TempRow=
             %%(p)Brother:%%(c)Right%%(btNo);
         IF %%(p)TempRow:%%(c)Color%%(btNo)=1 THEN
          %%(p)TempRow=
              %%(p)Brother:%%(c)Left%%(btNo);
          IF %%(p)TempRow:%%(c)Color%%(btNo)=1 THEN
            %%(p)OperRow:%%(c)Color%%(btNo)=0;
            %%(p)Brother:%%(c)Color%%(btNo)=0;
            %%(p)Father:%%(c)Color%%(btNo)=1;
            GOTO L2towComDelKeyTableKey%%(tabNo)_%%(btNo);
        FI;FI;FI;
! Or if the brother-node is top-node of a 3-node. Note that current-node is
$ a2-node. !
        IF %%(p)Nephew:%%(c)Color%%(btNo)=0 THEN
! Double rotate father-node, brother-node and the brother-child-node.
$   3-2+3-node  =>  3-3+3-node
$   4-2+3-node  =>  4-3+3-node
$ The resulting 3+3-nodes may be 4-nodes depending on which type of node the
$ child of the brother node was. !
DISABLE INTERRUPT;
            %%(p)Nephew:%%(c)Color%%(btNo)=
                %%(p)Father:%%(c)Color%%(btNo);
            IF %%(p)Father:%%(c)Left%%(btNo)=
               %%(p)OperRow
            THEN
                %%(p)Father:%%(c)Right%%(btNo)=
                    %%(p)Nephew:%%(c)Left%%(btNo);
                %%(p)Brother:%%(c)Left%%(btNo)=
                    %%(p)Nephew:%%(c)Right%%(btNo);
                %%(p)Nephew:%%(c)Left%%(btNo)=
                    %%(p)Father;
                %%(p)Nephew:%%(c)Right%%(btNo)=
                    %%(p)Brother;
            ELSE
                %%(p)Father:%%(c)Left%%(btNo)=
                    %%(p)Nephew:%%(c)Right%%(btNo);
                %%(p)Brother:%%(c)Right%%(btNo)=
                    %%(p)Nephew:%%(c)Left%%(btNo);
                %%(p)Nephew:%%(c)Right%%(btNo)=
                    %%(p)Father;
                %%(p)Nephew:%%(c)Left%%(btNo)=
                    %%(p)Brother;
            FI;
            %%(p)OperRow:%%(c)Color%%(btNo)=0;
            %%(p)Father:%%(c)Color%%(btNo)=1;
            IF %%(p)GrandFather:%%(c)Left%%(btNo)=
               %%(p)Father
            THEN
                %%(p)GrandFather:%%(c)Left%%(btNo)=
                    %%(p)Nephew;
            ELSE
                %%(p)GrandFather:%%(c)Right%%(btNo)=
                    %%(p)Nephew;
            FI;
            %%(p)GrandFather=%%(p)Nephew;
ENABLE INTERRUPT;
        ELSIF %%(p)Nephew:%%(c)Color%%(btNo)=1 THEN
DISABLE INTERRUPT;
! Single rotate father-node and brother-node.
$   3-2+3-node  =>  3-4-node
$   3-2+4-node  =>  3-4+2-node
$   4-2+3-node  =>  4-4-node
$   4-2+4-node  =>  4-4+2-node
$ Note that the current-node is part of the 4-node and father-node is the
$ top-node of the 4-node after the rotation. !
            %%(p)Brother:%%(c)Color%%(btNo)=
                %%(p)Father:%%(c)Color%%(btNo);
            IF %%(p)Father:%%(c)Left%%(btNo)=
               %%(p)OperRow
            THEN
                %%(p)TempRow=
                    %%(p)Brother:%%(c)Right%%(btNo);
                %%(p)TempRow:%%(c)Color%%(btNo)=1;
                %%(p)Father:%%(c)Right%%(btNo)=
                    %%(p)Brother:%%(c)Left%%(btNo);
                %%(p)Brother:%%(c)Left%%(btNo)=
                    %%(p)Father;
            ELSE
                %%(p)TempRow=
                    %%(p)Brother:%%(c)Left%%(btNo);
                %%(p)TempRow:%%(c)Color%%(btNo)=1;
                %%(p)Father:%%(c)Left%%(btNo)=
                    %%(p)Brother:%%(c)Right%%(btNo);
                %%(p)Brother:%%(c)Right%%(btNo)=
                    %%(p)Father;
            FI;
            %%(p)OperRow:%%(c)Color%%(btNo)=0;
            %%(p)Father:%%(c)Color%%(btNo)=1;
            IF %%(p)GrandFather:%%(c)Left%%(btNo)=
                %%(p)Father
            THEN
                %%(p)GrandFather:%%(c)Left%%(btNo)=
                    %%(p)Brother;
            ELSE
                %%(p)GrandFather:%%(c)Right%%(btNo)=
                    %%(p)Brother;
            FI;
            %%(p)GrandFather=%%(p)Brother;
ENABLE INTERRUPT;
        FI;
    FI;FI;FI;
L2towComDelKeyTableKey%%(tabNo)_%%(btNo))
! If the father-node was the node which we wanted, remember that node and
  its father. !
    IF SQLX_KeyTest=1 THEN
        %%(p)DeleteFather=%%(p)GrandFather;
        %%(p)Delete=%%(p)Father;
    FI;
    GOTO LOOPtowComDelKeyTableKey%%(tabNo)_%%(btNo);
! Whole tree traversed !
ENDLOOPtowComDelKeyTableKey%%(tabNo)_%%(btNo))
    IF %%(p)Delete /= %%(p)NilRow THEN
! A node was found to be deleted, then link in the father of the
  current-(NIL)-node instead of the node found in PT (which is the node to
  be deleted). !
DISABLE INTERRUPT;
        IF %%(p)DeleteFather:%%(c)Left%%(btNo)=
           %%(p)Delete
        THEN
            %%(p)DeleteFather:%%(c)Left%%(btNo)=
                %%(p)Father;
        ELSE
            %%(p)DeleteFather:%%(c)Right%%(btNo)=
                %%(p)Father;
        FI;
        IF %%(p)GrandFather:%%(c)Left%%(btNo)=
           %%(p)Father
        THEN
            %%(p)GrandFather:%%(c)Left%%(btNo)=
                %%(p)NilRow;
        ELSE
            %%(p)GrandFather:%%(c)Right%%(btNo)=
                %%(p)NilRow;
        FI;
        IF %%(p)Father /= %%(p)Delete THEN
            %%(p)Father:%%(c)Color%%(btNo)=
                %%(p)Delete:%%(c)Color%%(btNo);
            %%(p)Father:%%(c)Right%%(btNo)=
                %%(p)Delete:%%(c)Right%%(btNo);
            %%(p)Father:%%(c)Left%%(btNo)=
                %%(p)Delete:%%(c)Left%%(btNo);
        FI;
ENABLE INTERRUPT;
! Link in the deleted row in the free list IF the key was primary key. !
%%IF(btNo = 2)
        %%(p)OperRow=%%(p)Delete;
        %%(p)GuardRow= SQLM_TableReference:SQLM_System;
%%INCLUDE(putIntoFreeList(%%(q1)))
        %%(p)Delete:%%(c)Allocated=0;
%%ENDIF
    FI;
! jump back !
    CASE SQLX_ReturnLabel IS
%%LOOP(l <= towComDelKeyLab)
    WHEN %%(l) DO GOTO towComDelKeyLab%%(l);
%%ENDLOOP(l)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%END(towComDelKeyTableKey)
%%---> Handle: towPostComRow
%%----> towPostComRow
-------------------------------------------------------------------------------
- towPostComRow
-
- Parameters: None
-
- IMP variables used:
-       tabNos
-       commTabInds
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       t
-
- Included code components:
-       towPostComRowTable
-------------------------------------------------------------------------------
%%BEGIN(towPostComRow)
!------------------------------------------------!
!       towPostComRow !
!------------------------------------------------!
%%SET recSigs(,TOWPOSTCOMROW)
    ENTER towPostComRow WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow;
%%IF(commTabInds[0] > 0)
    CASE SQLM_TableReference IS
%%LOOP(t, commTabInds)
    WHEN %%(tabNos[t]) DO GOTO towPostComRowTable%%(tabNos[t]);
%%ENDLOOP(t)
    OTHERWISE DO
%%ENDIF
%%SET sentSigs(,TOWPOSTCOMROWR)
        SEND towPostComRowR WITH
            SQLX_OtherProtected,
            0;
        EXIT;
%%IF(commTabInds[0] > 0)
    ESAC;
%%LOOP(t, commTabInds)
%%INCLUDE(towPostComRowTable(%%(tabNos[t])))
%%ENDLOOP(t)
%%ENDIF
%%END(towPostComRow)
%%----> towPostComRowTable
-------------------------------------------------------------------------------
- towPostComRowTable
-
- Parameters:
-       1: Table number (not index!)
-
- IMP variables used:
-       commLabelI
-       commReturnI
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       tNo
-
- Included code components:
-       beginStat
-       endStat
-------------------------------------------------------------------------------
%%BEGIN(towPostComRowTable)
!------------------------------------------------!
!       towPostComRowTable !
!------------------------------------------------!
%%SET tNo(%%(towPostComRowTable[1]))
towPostComRowTable%%(tNo))
! execute user code !
%%INCLUDE(beginStat)
    IF SQLCODE = 3 + 17 <= 8 THEN
! Error: Protected region congestion, too many simultaneous users !
%%SET sentSigs(,TOWPOSTCOMROWR)
        SEND towPostComRowR WITH
            SQLX_OtherProtected,
            SQLCODE;
        EXIT;
    FI;
    PROTECTEDP:SQLBLOCK=SQLX_OtherBlock;
    PROTECTEDP:SQLOPERATION=SQLX_KeyOperation;
    PROTECTEDP:SQLX_SQLPROTECTED=SQLX_OtherProtected;
    PROTECTEDP:SQLX_SQLWORKROW=0;
    PROTECTEDP:SQLX_SQLOPERROW=SQLX_OperRow;
%%IF(commReturn%%(tNo)(?))
    GOTO %%(commLabel%%(tNo));
%%(commReturn%%(tNo)))
%%ELSE
    DO %%(commLabel%%(tNo));
%%ENDIF
    SQLX_OtherProtected=PROTECTEDP:SQLX_SQLPROTECTED;
%%INCLUDE(endStat)
! send back success !
%%SET sentSigs(,TOWPOSTCOMROWR)
    SEND towPostComRowR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
%%END(towPostComRowTable)
%%---> Handle: towRollBck
%%----> towRollBck
-------------------------------------------------------------------------------
- towRollBck
-
- Parameters: None
-
- IMP variables used:
-       tables
-       tabNos
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       t
-
- Included code components:
-       towRollBckTable
-------------------------------------------------------------------------------
%%BEGIN(towRollBck)
!------------------------------------------------!
!       towRollBck !
!------------------------------------------------!
%%SET recSigs(,TOWROLLBCK)
    ENTER towRollBck WITH
        SQLX_OtherProtected,
        SQLX_OtherBlock,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_OperRow,
        SQLX_WorkRow;
%%IF(tables[0] > 1)
    CASE SQLM_TableReference IS
%%LOOP(t, tabNos)
    WHEN %%(t) DO GOTO towRollBckTable%%(t);
%%ENDLOOP(t)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ENDIF
%%LOOP(t <= tables[0])
%%INCLUDE(towRollBckTable(%%(t)))
%%ENDLOOP(t)
%%END(towRollBck)
%%----> towRollBckTable
-------------------------------------------------------------------------------
- towRollBckTable
-
- Parameters:
-       1: Table index
-
- IMP variables used:
-       tables
-       tabNos
-       aksI
-       bTreesI
-       rollLabelI
-       rollReturnI
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       c
-       p
-       p1
-       tNo
-
- Included code components:
-       deAllocateWorkRow
-       deleteFromInsertList
-       putIntoFreeList
-       beginStat
-       endStat
-------------------------------------------------------------------------------
%%BEGIN(towRollBckTable)
!------------------------------------------------!
!       towRollBckTable !
!------------------------------------------------!
%%SET p1(%%(towRollBckTable[1]))
%%SET tNo(%%(tabNos[p1]))
%%SET c(SQLC_%%(tables[p1])_)
%%SET p(SQLM_%%(tables[p1])_)
%%IF(tables[0] > 1)
towRollBckTable%%(tNo))
%%ENDIF
%%IF(rollLabel%%(tNo)(?))
%%INCLUDE(beginStat)
    IF SQLCODE = 3 + 17 <= 8 THEN
! Error: Protected region congestion, too many simultaneous users !
%%SET sentSigs(,TOWROLLBCKR)
        SEND towRollBckR WITH
            SQLX_OtherProtected,
            SQLCODE;
        EXIT;
    FI;
    PROTECTEDP:SQLBLOCK=SQLX_OtherBlock;
    PROTECTEDP:SQLOPERATION=SQLX_KeyOperation;
    PROTECTEDP:SQLX_SQLPROTECTED=SQLX_OtherProtected;
    PROTECTEDP:SQLX_SQLTABLEREFERENCE=SQLM_TableReference;
    PROTECTEDP:SQLX_SQLOPERROW=SQLX_OperRow;
    PROTECTEDP:SQLX_SQLWORKROW=SQLX_WorkRow;
! execute user specified code !
%%IF(rollReturn%%(tNo)(?))
    GOTO %%(rollLabel%%(tNo));
%%(rollReturn%%(tNo)))
%%ELSE
    DO %%(rollLabel%%(tNo));
%%ENDIF
    SQLX_OtherBlock=PROTECTEDP:SQLBLOCK;
    SQLX_KeyOperation=PROTECTEDP:SQLOPERATION;
    SQLX_OtherProtected=PROTECTEDP:SQLX_SQLPROTECTED;
    SQLM_TableReference=PROTECTEDP:SQLX_SQLTABLEREFERENCE;
    SQLX_OperRow=PROTECTEDP:SQLX_SQLOPERROW;
    SQLX_WorkRow=PROTECTEDP:SQLX_SQLWORKROW;
%%INCLUDE(endStat)
%%ENDIF
! remove work rows and release locks !
    %%(p)GuardRow=SQLM_TableReference:SQLM_System;
    %%(p)NilRow=%%(p)GuardRow+1;
    CASE SQLX_KeyOperation IS
    WHEN 0 DO
        %%(p)OperRow=SQLX_WorkRow;
%%IF(bTrees%%(tNo)(2) OR aks%%(tNo)[0] > 0)
! remove row from insert list !
%%INCLUDE(deleteFromInsertList(%%(p1)))
%%ENDIF
%%IF(bTrees%%(tNo)(2))
! insert row in free list !
%%INCLUDE(putIntoFreeList(%%(p1)))
%%ENDIF
! deallocate work row !
        %%(p)OperRow:%%(c)Allocated=0;
    WHEN 1 DO
%%IF(aks%%(tNo)[0] > 0)
        %%(p)OperRow=SQLX_WorkRow;
! remove row from insert list. !
%%INCLUDE(deleteFromInsertList(%%(p1)))
%%ENDIF
        %%(p)WorkRow=SQLX_WorkRow;
        %%(p)OperRow=SQLX_OperRow;
! deallocate work row !
%%INCLUDE(deAllocateWorkRow(%%(tables[p1])))
        %%(p)OperRow:%%(c)Lock=0;
    WHEN 2 DO
        %%(p)OperRow=SQLX_OperRow;
        %%(p)OperRow:%%(c)Lock=0;
    OTHERWISE DO ! nothing ! ;
    ESAC;
! send back success !
%%SET sentSigs(,TOWROLLBCKR)
    SEND towRollBckR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
%%END(towRollBckTable)
%%---> Handle: towChaLock
%%----> towChaLock
-------------------------------------------------------------------------------
- towChaLock
-
- Parameters: None
-
- IMP variables used:
-       tables
-       tabNos
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       t
-
- Included code components:
-       towChaLockTable
-------------------------------------------------------------------------------
%%BEGIN(towChaLock)
!------------------------------------------------!
!       towChaLock !
!------------------------------------------------!
%%SET recSigs(,TOWCHALOCK)
    RECEIVE towChaLock WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow,
        SQLX_OldLock,
        SQLX_Lock,
        SQLX_DBnumber2;
%%IF(tables[0] > 1)
    CASE SQLM_TableReference IS
%%LOOP(t <= tables[0])
    WHEN %%(tabNos[t]) DO
%%INCLUDE(towChaLockTable(%%(t)))
%%ENDLOOP(t)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ELSE
%%INCLUDE(towChaLockTable(1))
%%ENDIF
%%END(towChaLock)
%%----> towChaLockTable
-------------------------------------------------------------------------------
- towChaLockTable
-
- Parameters:
-       1: Table index
-
- IMP variables used:
-       tables
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       c
-       p
-
- Included code components:
-------------------------------------------------------------------------------
%%BEGIN(towChaLockTable)
!------------------------------------------------!
!       towChaLockTable !
!------------------------------------------------!
%%SET c(SQLC_%%(tables[towChaLockTable[1]])_)
%%SET p(SQLM_%%(tables[towChaLockTable[1]])_)
    %%(p)WorkRow=SQLX_WorkRow;
! check if old lock is not as expected, if so report failure !
    IF SQLX_OldLock /= %%(p)WorkRow:%%(c)Lock THEN
%%SET sentSigs(,TOWCHALOCKACK)
        RETURN towChaLockAck WITH
            SQLX_OtherProtected,
! System internal status code: Current lock specification mismatch !
            255 + 5 <= 8;
    FI;
! check if no lock and has not the expected DB number, if so report failure !
    IF %%(p)WorkRow:%%(c)Lock = 0 THEN
        IF %%(p)WorkRow:%%(c)DBnumber2 /=
            SQLX_DBnumber2
        THEN
%%SET sentSigs(,TOWCHALOCKACK)
            RETURN towChaLockAck WITH
                SQLX_OtherProtected,
! Search failure: Row updated while accessing !
                2 + 4 <= 8;
        FI;
    FI;
! change lock !
    %%(p)WorkRow:%%(c)Lock=SQLX_Lock;
! send back success !
%%SET sentSigs(,TOWCHALOCKACK)
    RETURN towChaLockAck WITH
        SQLX_OtherProtected,
        0;
%%END(towChaLockTable)
%%---> Top Level Macros
%%----> towDeclarations
-------------------------------------------------------------------------------
- towDeclarations
-
- Parameters: None
-
- IMP variables used:
-       commLabelI
-       prepLabelI
-       tabChecks
-       bTreesI
-       fksI
-       aksI
-       colNonVolI
-       symColsI
-       tables
-       tabNos
-
- IMP variables defined:
-       tableOwner
-       maxTabNo
-       symTabInds
-       volTabInds
-       akTabInds
-       fkTabInds
-       fkNullDefTabInds
-       fksNullDefI
-       btTabInds
-       checkTabInds
-       codeTabInds
-       prepTabInds
-       commTabInds
-       towGetSchLab
-       towInsSchLab
-       towVerSchLab
-       towComSchLab
-       towComDelKeyLab
-       towComInsKeyLab
-       ddhInitTableLab
-       ddhInitFieldLab
-       ddhInitFkLab
-       allocateWorkRowLab
-       scanMax
-       schLimit
-       schGetKey
-       schGetCur
-       schIns
-       schVer
-       schInsKey
-       schDelKey
-
- Temporary IMP variables:
-       i
-       j
-       tNo
-
- Included code components:
-       towTabInfo
-       towTables
-       towSymbols
-       comDeclarations
-------------------------------------------------------------------------------
%%BEGIN(towDeclarations)
!------------------------------------------------!
!       towDeclarations !
!------------------------------------------------!
%%SET tableOwner()
%%SET maxTabNo(0)
%%SET symTabInds()
%%SET volTabInds()
%%SET akTabInds()
%%SET fkTabInds()
%%SET fkNullDefTabInds()
%%SET btTabInds()
%%SET checkTabInds()
%%SET codeTabInds()
%%SET prepTabInds()
%%SET commTabInds()
%%LOOP(i <= tabNos[0])
%%SET tNo(%%(tabNos[i]))
%%IF(tNo > maxTabNo)%%SET maxTabNo(%%(tNo))%%ENDIF
%%IF(symCols%%(tNo)[0] > 0)%%SET symTabInds(, %%(i))%%ENDIF
%%IF(colNonVol%%(tNo)(0))%%SET volTabInds(, %%(i))%%ENDIF
%%IF(aks%%(tNo)[0] > 0)%%SET akTabInds(, %%(i))%%ENDIF
%%IF(fks%%(tNo)[0] > 0)
%%SET fkTabInds(, %%(i))
%%LOOP(j, fks%%(tNo))
%%IF(fkAct%%(tNo)_%%(j) = "SET NULL" OR fkAct%%(tNo)_%%(j) = "SET DEFAULT")
%%IF(NOT fkNullDefTabInds(%%(i)))%%SET fkNullDefTabInds(, %%(i))%%ENDIF
%%SET fksNullDef%%(tNo)(, %%(j))
%%ENDIF
%%ENDLOOP(j)
%%ENDIF
%%IF(bTrees%%(tNo)[0] > 0)%%SET btTabInds(, %%(i))%%ENDIF
%%IF(tabChecks[i] > 0)%%SET checkTabInds(, %%(i))%%ENDIF
%%IF(locCodes%%(tNo)(?))%%SET codeTabInds(, %%(i))%%ENDIF
%%IF(prepLabel%%(tNo)(?))%%SET prepTabInds(, %%(i))%%ENDIF
%%IF(commLabel%%(tNo)(?))%%SET commTabInds(, %%(i))%%ENDIF
%%ENDLOOP(i)
%%SET towGetSchLab(%%(maxTabNo))

%%SET towInsSchLab(0)
%%SET towVerSchLab(0)
%%SET towComSchLab(0)
%%SET towComDelKeyLab(0)
%%SET towComInsKeyLab(0)
%%SET ddhInitTableLab(0)
%%SET ddhInitFieldLab(0)
%%SET ddhInitFkLab(0)
%%SET allocateWorkRowLab(0)

%%SET scanMax(24000)
%%SET schLimit(2000)
%%SET schGetKey(100)
%%SET schGetCur(100)
%%SET schIns(100)
%%SET schVer(100)
%%SET schInsKey(100)
%%SET schDelKey(100)

%%INCLUDE(comDeclarations)
%%INCLUDE(towSymbols)
%%INCLUDE(towTables)
%%INCLUDE(towTabInfo)

%%END(towDeclarations)
%%----> towPlexCode
-------------------------------------------------------------------------------
- towPlexCode
-
- Parameters: None
-
- IMP variables used: None
-
- IMP variables defined: None
-
- Temporary IMP variables: None
-
- Included code components:
-       comPlexCode
-       towGetRow
-       towGetSch
-       towGetFld
-       towGetKey
-       towOpen
-       towClose
-       towChaVolRow
-       towInsRow
-       towInsSch
-       towChaRow
-       towDelRow
-       towLetFld
-       towLetFldFK
-       towVerRow
-       towVerSch
-       towComRow
-       towComSch
-       towComInsKey
-       towComDelKey
-       towPostComRow
-       towRollBck
-       towChaLock
-       towGetTabNam
-       towGetTabDat
-       towGetFldNam
-       towGetStrFld
-       towGetNumFld
-       towGetPckFld
-       towGetKeyFld
-       towGetKeyDat
-       towGetFks
-       towGetFkInf
-       towGetFlt
-       towGetPreFlt
-       towGetSymbol
-       towGetSymVal
-       towGetPreSym
-       RESTARTPHASE1
-       RESTARTPHASE2
-       RESTARTPHASE4
-       RESTARTPHASE5
-       towDdhInitTableR
-       towDdhInitFieldR
-       towDdhInitFkR
-------------------------------------------------------------------------------
%%BEGIN(towPlexCode)
!------------------------------------------------!
!       towPlexCode !
!------------------------------------------------!
%%----------------------------------------
%%-- Common code
%%----------------------------------------
%%INCLUDE(comPlexCode)
%%----------------------------------------
%%-- Data manipulation code
%%----------------------------------------
%%INCLUDE(towGetRow)
%%INCLUDE(towGetFld)
%%INCLUDE(towGetKey)
%%INCLUDE(towOpen)
%%INCLUDE(towClose)
%%INCLUDE(towChaVolRow)
%%INCLUDE(towInsRow)
%%INCLUDE(towInsSch)
%%INCLUDE(towChaRow)
%%INCLUDE(towDelRow)
%%INCLUDE(towLetFld)
%%INCLUDE(towLetFldFK)
%%----------------------------------------
%%-- Transaction handling code
%%----------------------------------------
%%INCLUDE(towVerRow)
%%INCLUDE(towVerSch)
%%INCLUDE(towComRow)
%%INCLUDE(towComSch)
%%INCLUDE(towComInsKey)
%%INCLUDE(towComDelKey)
%%INCLUDE(towPostComRow)
%%INCLUDE(towRollBck)
%%INCLUDE(towChaLock)
%%----------------------------------------
%%-- Data dictionary support code
%%----------------------------------------
%%INCLUDE(towGetTabNam)
%%INCLUDE(towGetTabDat)
%%INCLUDE(towGetFldNam)
%%INCLUDE(towGetStrFld)
%%INCLUDE(towGetNumFld)
%%INCLUDE(towGetPckFld)
%%INCLUDE(towGetKeyFld)
%%INCLUDE(towGetKeyDat)
%%INCLUDE(towGetFks)
%%INCLUDE(towGetFkInf)
%%INCLUDE(towGetFlt)
%%INCLUDE(towGetPreFlt)
%%INCLUDE(towGetSymbol)
%%INCLUDE(towGetSymVal)
%%INCLUDE(towGetPreSym)
%%----------------------------------------
%%-- Start and restart support code
%%----------------------------------------
%%INCLUDE(RESTARTPHASE1)
%%INCLUDE(RESTARTPHASE2)
%%INCLUDE(RESTARTPHASE4)
%%INCLUDE(RESTARTPHASE5)
%%INCLUDE(towDdhInitTableR)
%%INCLUDE(towDdhInitFieldR)
%%INCLUDE(towDdhInitFkR)
%%----------------------------------------
%%-- Key lookup code
%%----------------------------------------
%%INCLUDE(towGetSch)
%%----------------------------------------
%%-- End of code
%%----------------------------------------
%%END(towPlexCode)
%%----> towAsaCode
-------------------------------------------------------------------------------
- towAsaCode
-
- Parameters: None
-
- IMP variables used: None
-
- IMP variables defined: None
-
- Temporary IMP variables: None
-
- Included code components:
-       comAsaCode
-       sPack
-       sUnpack
-       sPackKey
-       sUnPackKey
-       sKeyTestN
-------------------------------------------------------------------------------
%%BEGIN(towAsaCode)
!------------------------------------------------!
!       towAsaCode !
!------------------------------------------------!
%%SET sCount(0)
%%INCLUDE(comAsaCode)
%%INCLUDE(sPack)
%%INCLUDE(sUnpack)
%%INCLUDE(sPackKey)
%%INCLUDE(sUnPackKey)
%%INCLUDE(sKeyTestN)
%%----------------------------------------
%%-- Generate signal survey
%%----------------------------------------
%%INCLUDE(genSigSurv)
%%END(towAsaCode)
%%----> towData
-------------------------------------------------------------------------------
- towData
-
- Parameters: None
-   If user has declared a data sector:
-       1: Set to "USER"
-   If user has not declared a data sector: Empty list
-
- IMP variables used:
-       tables
-       tabNos
-       bTreesI
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       c
-       i
-       j
-       p
-
- Included code components:
-       comData
-------------------------------------------------------------------------------
%%BEGIN(towData)
!------------------------------------------------!
!       towData !
!------------------------------------------------!
%%IF(towData[0] = 0 AND NOT tuData(?))
DATA;
%%ENDIF
%%INCLUDE(comData)
! Set size of table information area. !
    SIZE OF SQLT_TableInfo = %%(maxTabNo + 1);
! Initialize Table !
%%LOOP(i <= tables[0])
%%SET c(SQLC_%%(tables[i])_)
%%SET p(SQLM_%%(tables[i])_)
! Set initialize size of table. !
    SIZE OF SQLT_%%(tables[i])_Table = 3;
! Initilize table information table !
    SET SQLM_TableAllocated=0 FOR SQLM_Tablereference = %%(tabNos[i]);
    SET SQLM_TableUsed=0 FOR SQLM_Tablereference = %%(tabNos[i]);
    SET SQLM_TableLast=0 FOR SQLM_Tablereference = %%(tabNos[i]);
    SET SQLM_WorkAllocated =0 FOR SQLM_Tablereference = %%(tabNos[i]);
    SET SQLM_WorkUsed =0 FOR SQLM_Tablereference = %%(tabNos[i]);
    SET SQLM_WorkLast =0 FOR SQLM_Tablereference = %%(tabNos[i]);
    SET SQLM_System   =0 FOR SQLM_Tablereference = %%(tabNos[i]);
! Allocate the system rows !
    SET %%(c)Allocated  = 1 FOR %%(p)GuardRow   = 0;
    SET %%(c)Allocated  = 1 FOR %%(p)NilRow     = 1;
    SET %%(c)Allocated  = 1 FOR %%(p)RootRow    = 2;
! Initialize all system rows. !
%%LOOP(j, bTrees%%(tabNos[i]))
! Initialize root row (mSystem+2) !
    SET %%(c)Color%%(j)     = 1 FOR %%(p)RootRow    = 2;
    SET %%(c)Left%%(j)      = 0 FOR %%(p)RootRow    = 2;
    SET %%(c)Right%%(j)     = 1 FOR %%(p)RootRow    = 2;
! Initialize nil row (mSystem+1) !
    SET %%(c)Color%%(j)     = 1 FOR %%(p)NilRow     = 1;
    SET %%(c)Left%%(j)      = 0 FOR %%(p)NilRow     = 1;
    SET %%(c)Right%%(j)     = 0 FOR %%(p)NilRow     = 1;
! Initialize guard row (mSystem) !
    SET %%(c)Color%%(j)     = 0 FOR %%(p)GuardRow   = 0;
%%ENDLOOP(j)
%%IF(bTrees%%(tabNos[i])(2) OR aks%%(tabNos[i])[0] > 0)
    SET %%(%%(c)Next)       = 1 FOR %%(p)GuardRow   = 0;
%%ENDIF
%%IF(bTrees%%(tabNos[i])(2))
    SET %%(%%(c)Prev)       = 1 FOR %%(p)GuardRow   = 0;
%%ENDIF
%%ENDLOOP(i)
%%IF(towData[0] = 0 AND (NOT tableUser(?) OR tuData(?)))
END DATA;
%%ENDIF
%%END(towData)
%%---> Handle: System start
%%----> RESTARTPHASE1
-------------------------------------------------------------------------------
- RESTARTPHASE1
-
- Parameters: None
-
- IMP variables used:
-       tables
-       tabNos
-       ddhInitFieldLab
-       colNonVolI
-       colSizesI
-       colTypesI
-       colVisI
-       colsI
-       ddhInitTableLab
-       multiNoI
-       tabWAuths
-       tabRAuths
-
- IMP variables defined:
-       ddhInitTableLab
-       ddhInitFieldLab
-
- Temporary IMP variables:
-       i
-       j
-       tabNo
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(RESTARTPHASE1)
!------------------------------------------------!
!       RESTARTPHASE1 !
!------------------------------------------------!
%%IF(tables[0] > 0)
RESTARTPHASE1)
%%LOOP(i <= tables[0])
%%SET tabNo(%%(tabNos[i]))
! Send table data to Data Dictionary !
%%SET sentSigs(,DDHINITTABLE)
    SEND ddhInitTable WITH
%%SET ddhInitTableLab(%%(ddhInitTableLab + 1))
        %%(ddhInitTableLab),
        cOwnRef,
        %%(tabNo),
        "%%(tables[i])",
        %%(tabRAuths[i]),
        %%(tabWAuths[i]),
%%IF(multiNo%%(tabNo)(?))
        1;
%%ELSE
        0;
%%ENDIF
    EXIT;
ddhInitTableLab%%(ddhInitTableLab))
%%LOOP(j <= cols%%(tabNo)[0])
! Send column data to Data Dictionary !
%%SET sentSigs(,DDHINITFIELD)
    SEND ddhInitField WITH
%%SET ddhInitFieldLab(%%(ddhInitFieldLab + 1))
        %%(ddhInitFieldLab),
        cOwnRef,
        %%(tabNo),
        "%%(cols%%(tabNo)[j])",
        %%(j),
%%IF(colVis%%(tabNo)[j] = "INVISIBLE")
        0,
%%ELSIF(colVis%%(tabNo)[j] = "READONLY")
        1,
%%ELSE
        2,
%%ENDIF
%%IF(colTypes%%(tabNo)[j] = "BITS")
        0,
%%ELSIF(colTypes%%(tabNo)[j] = "STRING")
        1,
%%ELSIF(colTypes%%(tabNo)[j] = "NUMSTRING")
        2,
%%ELSIF(colTypes%%(tabNo)[j] = "PACKED NUMSTRING")
        3,
%%ELSIF(colTypes%%(tabNo)[j] = "SYMBOL")
        4,
%%ELSIF(colTypes%%(tabNo)[j] = "ROWNUMBER")
        5,
%%ELSIF(colTypes%%(tabNo)[j] = "DBNUMBER")
        6,
%%ENDIF
        %%(colSizes%%(tabNo)[j]),
        %%(colNonVol%%(tabNo)[j]);
    EXIT;
ddhInitFieldLab%%(ddhInitFieldLab))
%%ENDLOOP(j)
%%ENDLOOP(i)
    GOTO RESTARTEND;
%%ENDIF
%%END(RESTARTPHASE1)
%%----> RESTARTPHASE2
-------------------------------------------------------------------------------
- RESTARTPHASE2
-
- Parameters: None
-
- IMP variables used:
-       ddhInitFkLab
-       fkActI_J
-       fkTabI_J
-       fksI
-       tabNos
-       fkTabInds
-
- IMP variables defined:
-       ddhInitFkLab
-
- Temporary IMP variables:
-       i
-       j
-       tabNo
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(RESTARTPHASE2)
!------------------------------------------------!
!       RESTARTPHASE2 !
!------------------------------------------------!
%%IF(fkTabInds[0] > 0)
RESTARTPHASE2)
%%LOOP(i, fkTabInds)
%%SET tabNo(%%(tabNos[i]))
%%LOOP(j, fks%%(tabNo))
! Send FK data to Data Dictionary !
%%SET sentSigs(,DDHINITFK)
    SEND ddhInitFk WITH
%%SET ddhInitFkLab(%%(ddhInitFkLab + 1))
        %%(ddhInitFkLab),
        cOwnRef,
        %%(tabNo),
        %%(j),
        "%%(fkTab%%(tabNo)_%%(j))",
%%IF(fkAct%%(tabNo)_%%(j) = "RESTRICT")
        0;
%%ELSIF(fkAct%%(tabNo)_%%(j) = "CASCADE")
        1;
%%ELSIF(fkAct%%(tabNo)_%%(j) = "SET NULL")
        2;
%%ELSIF(fkAct%%(tabNo)_%%(j) = "SET DEFAULT")
        3;
%%ENDIF
    EXIT;
ddhInitFkLab%%(ddhInitFkLab))
%%ENDLOOP(j)
%%ENDLOOP(i)
    GOTO RESTARTEND;
%%ENDIF
%%END(RESTARTPHASE2)
%%----> RESTARTPHASE4
-------------------------------------------------------------------------------
- RESTARTPHASE4
-
- Parameters: None
-
- IMP variables used:
-       tables
-       tabNos
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(RESTARTPHASE4)
!------------------------------------------------!
!       RESTARTPHASE4 !
!------------------------------------------------!
%%IF(tables[0] > 0)
RESTARTPHASE4)
%%LOOP(i <= tables[0])
! Clear work area. !
    SQLM_TableReference=%%(tabNos[i]);
    IF SQLM_TableReference:SQLM_WorkAllocated > 0 THEN    
        FOR ALL SQLM_%%(tables[i])_WorkRow
            FROM SQLM_TableReference:SQLM_System-1
            UNTIL SQLM_TableReference:SQLM_TableAllocated
            DO SQLM_%%(tables[i])_WorkRow:SQLC_%%(tables[i])_Allocated=0;
    FI;
%%ENDLOOP(i)
    GOTO RESTARTEND;
%%ENDIF
%%END(RESTARTPHASE4)
%%----> RESTARTPHASE5
-------------------------------------------------------------------------------
- RESTARTPHASE5
-
- Parameters: None
-
- IMP variables used:
-       didNos
-       didPosI
-       didColsI
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(RESTARTPHASE5)
!------------------------------------------------!
!       RESTARTPHASE5 !
!------------------------------------------------!
%%IF(didNos[0] > 0)
RESTARTPHASE5)
! Send Data Interface Description information for selected columns !
%%LOOP(i, didNos)
%%SET l1(%%(((didPos%%(i)[0] - 1) / 10) + 1))
%%LOOP(j <= l1)
%%SET l2(%%(didPos%%(i)[0] - ((j - 1) * 10)))
%%IF(l2 > 10)%%SET l2(10)%%ENDIF
%%LOOP(k <= l2)
    VARIABLENUMBER FOR %%(didCols%%(i)[k + ((j - 1) * 10)]) TO SQLX_DR%%(k);
%%ENDLOOP(k)
%%SET sentSigs(,DIDINFO)
    SEND DIDINFO WITH
        %%(i),
        cOwnRef,
        %%(l2),
%%LOOP(k <= l2)
        SQLX_DR%%(k),
        %%(didPos%%(i)[k + ((j - 1) * 10)]),
%%ENDLOOP(k)
    WAIT FOR DIDINFOACK IN didInfoAck%%(i)_%%(j);
%%SET recSigs(,DIDINFOACK)
didInfoAck%%(i)_%%(j))RETRIEVE DIDINFOACK;
%%ENDLOOP(j)
%%ENDLOOP(i)
    GOTO RESTARTEND;
%%ENDIF
%%END(RESTARTPHASE5)
%%----> towDdhInitTableR
-------------------------------------------------------------------------------
- towDdhInitTableR
-
- Parameters: None
-
- IMP variables used:
-       ddhInitTableLab
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(towDdhInitTableR)
!------------------------------------------------!
!       towDdhInitTableR !
!------------------------------------------------!
%%IF(ddhInitTableLab > 0)
%%SET recSigs(,DDHINITTABLER)
    ENTER ddhInitTableR WITH SQLX_ReturnLabel;
%%IF(ddhInitTableLab = 1)
    GOTO ddhInitTableLab1;
%%ELSE
    CASE SQLX_ReturnLabel IS
%%LOOP(i <= ddhInitTableLab)
    WHEN %%(i) DO GOTO ddhInitTableLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ENDIF
%%ENDIF
%%END(towDdhInitTableR)
%%----> towDdhInitFieldR
-------------------------------------------------------------------------------
- towDdhInitFieldR
-
- Parameters: None
-
- IMP variables used:
-       ddhInitFieldLab
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(towDdhInitFieldR)
!------------------------------------------------!
!       towDdhInitFieldR !
!------------------------------------------------!
%%IF(ddhInitFieldLab > 0)
%%SET recSigs(,DDHINITFIELDR)
    ENTER ddhInitFIeldR WITH SQLX_ReturnLabel;
%%IF(ddhInitFieldLab = 1)
    GOTO ddhInitFieldLab1;
%%ELSE
    CASE SQLX_ReturnLabel IS
%%LOOP(i <= ddhInitFieldLab)
    WHEN %%(i) DO GOTO ddhInitFieldLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ENDIF
%%ENDIF
%%END(towDdhInitFieldR)
%%----> towDdhInitFkR
-------------------------------------------------------------------------------
- towDdhInitFkR
-
- Parameters: None
-
- IMP variables used:
-       ddhInitFkLab
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(towDdhInitFkR)
!------------------------------------------------!
!       towDdhInitFkR !
!------------------------------------------------!
%%IF(ddhInitFkLab > 0)
%%SET recSigs(,DDHINITFKR)
    ENTER ddhInitFkR WITH SQLX_ReturnLabel;
%%IF(ddhInitFkLab = 1)
    GOTO ddhInitFkLab1;
%%ELSE
    CASE SQLX_ReturnLabel IS
%%LOOP(i <= ddhInitFkLab)
    WHEN %%(i) DO GOTO ddhInitFkLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ENDIF
%%ENDIF
%%END(towDdhInitFkR)
%%--> TABLE USER
%%---> Declarations
%%----> tuDeclRemTab
-------------------------------------------------------------------------------
- tuDeclRemTab
-
- Parameters: None
-
- IMP variables used:
-       remTables
-       remTabNos
-       colsI
-       symColsI
-       symValsI_J
-       symLitsI_J
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-       j
-       k
-       size
-       tabNo
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(tuDeclRemTab)
!------------------------------------------------!
!       tuDeclRemTab !
!------------------------------------------------!
%%IF(remTables[0] > 0)
%%SET size(%%(remTables[0]))
%%IF(size = 1)
%%ELSIF(size <= 2)%%SET size(2)
%%ELSIF(size <= 4)%%SET size(4)
%%ELSIF(size <= 8)%%SET size(8)
%%ELSIF(size <= 16)%%SET size(16)
%%ELSIF(size <= 32)%%SET size(32)
%%ELSIF(size <= 64)%%SET size(64)
%%ELSIF(size <= 128)%%SET size(128)
%%ELSE%%SET size(256)%%ENDIF
    VARIABLE SQLM_Remote(%%(size)) 32 DS RELOAD;
    STRUCTURE SQLM_Remote =
! This variable holds the block reference of a remote single table. !
        1 block 16,
! This variable holds the table reference of a remote single table. !
        1 table 16;
! The symbol values for all remote tables. !
%%LOOP(i <= remTables[0])
%%SET tabNo(%%(remTabNos[i]))
%%LOOP(j, symCols%%(tabNo))
%%LOOP(k <= symVals%%(tabNo)_%%(j)[0])
NSYMB %%(remTables[i])%%(cols%%(tabNo)[j])%%(symVals%%(tabNo)_%%(j)[k]) = %%(symLits%%(tabNo)_%%(j)[k]);
%%ENDLOOP(k)
%%ENDLOOP(j)
%%ENDLOOP(i)
%%ENDIF
%%END(tuDeclRemTab)
%%---> Common Assembler Blocks
%%----> sPackX
-------------------------------------------------------------------------------
- sPackX
-
- Parameters: None
-
- IMP variables used:
-       sPackXVars
-       sPackXRegs
-       sPackXPtrs
-       sPackXLens
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(sPackX)
!------------------------------------------------!
!       sPackX !
!------------------------------------------------!
%%LOOP(i <= sPackXVars[0])

PROGRAM SQLS_Pack%%(i); ASA210C;
%%IF(sPackXPtrs[i] # "")
    MFR     PR0-%%(sPackXPtrs[i]);
%%ENDIF
    LCC     IR-0;
%%IF(sPackXLens[i] > 15)
    LHC     WR0/W0-%%(sPackXLens[i]);
%%ELSE
    LCC     WR0-%%(sPackXLens[i]);
%%ENDIF
    RSI     DR%%(sPackXRegs[i])-%%(sPackXVars[i]),WR0,%%(sPackXLens[i]);
%%IF(DRNPATCH(1))
%%LOOP(j <= sPackXLens[i])
    MFR     SQLX_DR%%(sPackXRegs[i]+j-1)-DR%%(sPackXRegs[i]+j-1);
%%ENDLOOP(j)
%%ENDIF
END PROGRAM;
%%ENDLOOP(i)
%%END(sPackX)
%%----> sUnPackX
-------------------------------------------------------------------------------
- sUnPackX
-
- Parameters: None
-
- IMP variables used:
-       sUnPackXVars
-       sUnPackXRegs
-       sUnPackXPtrs
-       sUnPackXLens
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(sUnPackX)
!------------------------------------------------!
!       sUnPackX !
!------------------------------------------------!
%%LOOP(i <= sUnPackXVars[0])

PROGRAM SQLS_UnPack%%(i); ASA210C;
%%IF(sUnPackXPtrs[i] # "")
    MFR     PR0-%%(sUnPackXPtrs[i]);
%%ENDIF
    LCC     IR-0;
%%IF(sUnPackXLens[i] > 15)
    LHC     WR0/W0-%%(sUnPackXLens[i]);
%%ELSE
    LCC     WR0-%%(sUnPackXLens[i]);
%%ENDIF
%%IF(DRNPATCH(1))
%%LOOP(j <= %%(sUnPackXLens[i]))
    MFR     DR%%(sUnPackXRegs[i]+j-1)-SQLX_DR%%(sUnPackXRegs[i]+j-1);
%%ENDLOOP(j)
%%ENDIF
    WSI     %%(sUnPackXVars[i])-DR%%(sUnPackXRegs[i]),WR0,%%(sUnPackXLens[i]);
END PROGRAM;
%%ENDLOOP(i)
%%END(sUnPackX)
%%----> sCmpStringX
-------------------------------------------------------------------------------
- sCmpStringX
-
- Parameters: None
-
- IMP variables used:
-       sCmpStringXPtrs1
-       sCmpStringXPtrs2
-       sCmpStringXVars1
-       sCmpStringXVars2
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(sCmpStringX)
!------------------------------------------------!
!       sCmpStringX !
!------------------------------------------------!
%%LOOP(i <= sCmpStringXVars1[0])

PROGRAM SQLS_CmpString%%(i); ASA210C;
%%IF(sCmpStringXPtrs1[i] # "")
    MFR     WR0-%%(sCmpStringXPtrs1[i]);
%%ENDIF
%%IF(sCmpStringXPtrs2[i] # "")
    MFR     WR1-%%(sCmpStringXPtrs2[i]);
%%ENDIF
    %%(sib)CS      %%(sCmpStringXVars1[i]),WR0,%%(sCmpStringXVars2[i]),WR1%%(sie)
    MFR     SQLX_KeyTest-CR;
END PROGRAM;
%%ENDLOOP(i)
%%END(sCmpStringX)
%%---> Common Macros
%%----> unPackX
-------------------------------------------------------------------------------
- unPackX
-
- Parameters:
-       1: Signal number
-
- IMP variables used:
-       tabNo
-       sigColsI
-       sigVarsI
-       sigPtrsI
-       sigNullsI
-       sigNullPtrsI
-       colTypesI
-       colLenI
-       colSizesI
-       colNullI
-
- IMP variables defined:
-       sUnPackXPtrs
-       sUnPackXVars
-       sUnPackXRegs
-       sUnPackXLens
-
- Temporary IMP variables:
-       col
-       drn
-       j
-       ptr
-       sig
-       t
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(unPackX)
!------------------------------------------------!
!       unPackX !
!------------------------------------------------!
%%SET sig(%%(unPackX[1]))
%%SET drn(4)
%%LOOP(j <= sigCols%%(sig)[0])
%%SET col(%%(sigCols%%(sig)[j]))
%%IF(sigPtrs%%(sig)[j] # "")%%SET ptr("%%(sigPtrs%%(sig)[j]):")%%ELSE%%SET ptr()%%ENDIF
%%IF(col = 0)
%%SET t("BITS")
%%ELSE
%%SET t(%%(colTypes%%(tabNo)[col]))
%%IF(colNull%%(tabNo)[col] = 1)
%%IF(sigNulls%%(sig)[j] = "")
    IF SQLX_DR%%(drn) = 1 THEN
        PROTECTEDP:SQLX_SQLCODE = 1 + 1 <= 8;
    FI;
%%ELSE
%%IF(sigNullPtrs%%(sig)[j] # "")
    %%(sigNullPtrs%%(sig)[j]):%%(sigNulls%%(sig)[j]) = SQLX_DR%%(drn);
%%ELSE
    %%(sigNulls%%(sig)[j]) = SQLX_DR%%(drn);
%%ENDIF
%%ENDIF
%%SET drn(%%(drn + 1))
%%ENDIF
%%ENDIF
%%IF(t = "BITS" OR t = "SYMBOL")
    %%(ptr)%%(sigVars%%(sig)[j]) = SQLX_DR%%(drn);
%%ELSIF(t = "DBNUMBER")
    %%(ptr)%%(sigVars%%(sig)[j]).PART1 = SQLX_DR%%(drn);
    %%(ptr)%%(sigVars%%(sig)[j]).PART2 = SQLX_DR%%(drn + 1);
%%ELSIF(t = "PACKED NUMSTRING")
    %%(ptr)%%(sigVars%%(sig)[j]).LENGTH = SQLX_DR%%(drn);
    %%(ptr)%%(sigVars%%(sig)[j]).W1 = SQLX_DR%%(drn + 1);
    %%(ptr)%%(sigVars%%(sig)[j]).W2 = SQLX_DR%%(drn + 2);
    %%(ptr)%%(sigVars%%(sig)[j]).W3 = SQLX_DR%%(drn + 3);
%%IF(colSizes%%(tabNo)[col] = 28)
    %%(ptr)%%(sigVars%%(sig)[j]).W4 = SQLX_DR%%(drn + 4);
    %%(ptr)%%(sigVars%%(sig)[j]).W5 = SQLX_DR%%(drn + 5);
    %%(ptr)%%(sigVars%%(sig)[j]).W6 = SQLX_DR%%(drn + 6);
    %%(ptr)%%(sigVars%%(sig)[j]).W7 = SQLX_DR%%(drn + 7);
%%ENDIF
%%ELSE
%%SET sUnPackXPtrs(, "%%(sigPtrs%%(sig)[j])")
%%SET sUnPackXVars(, "%%(sigVars%%(sig)[j])")
%%SET sUnPackXRegs(, %%(drn))
%%SET sUnPackXLens(, %%(colLen%%(tabNo)[col]))
    DO SQLS_UnPack%%(sUnPackXVars[0]);  ! UnPack signal registers into string !
%%ENDIF
%%IF(col = 0)
%%SET drn(%%(drn + 1))
%%ELSE
%%SET drn(%%(drn + colLen%%(tabNo)[col]))
%%ENDIF
%%ENDLOOP(j)
%%END(unPackX)
%%----> packX
-------------------------------------------------------------------------------
- packX
-
- Parameters:
-       1: Signal number
-       2: "I" if insert statement, "U" if update statement
-
- IMP variables used:
-       colLenI
-       tabNo
-       sigExprsI
-       sigPtrsI
-       colSizesI
-       colTypesI
-       sigNullsI
-       sigNullPtrsI
-       colNullI
-       sigColsI
-       sigColOpsI
-
- IMP variables defined:
-       drs
-       sPackXPtrs
-       sPackXVars
-       sPackXRegs
-       sPackXLens
-
- Temporary IMP variables:
-       col
-       drn
-       j
-       op
-       ptr
-       sig
-       statType
-       t
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(packX)
!------------------------------------------------!
!       packX !
!------------------------------------------------!
%%SET sig(%%(packX[1]))
%%SET statType(%%(packX[2]))
%%SET drn(5)
    SQLX_DR%%(drn) = %%(sigCols%%(sig)[0]);
%%SET drn(%%(drn + 1))
%%SET t(%%(sigCols%%(sig)[0]))
%%LOOP(j <= t)
%%SET op(%%(sigCols%%(sig)[t + 1 - j]))
%%IF(statType = "U")
%%IF(sigColOps%%(sig)[t + 1 - j] = "+")%%SET op(%%(op + 16384))
%%ELSIF(sigColOps%%(sig)[t + 1 - j] = "-")%%SET op(%%(op + 32768))
%%ENDIF
%%ENDIF
    SQLX_DR%%(drn) = %%(op);
%%SET drn(%%(drn + 1))
%%ENDLOOP(j)
%%LOOP(j <= t)
%%SET col(%%(sigCols%%(sig)[j]))
%%IF(colNull%%(tabNo)[col] = 1)
%%IF(sigExprs%%(sig)[j] = "NULL")
    SQLX_DR%%(drn) = 1;
%%ELSIF(sigNulls%%(sig)[j] # "")
%%IF(sigNullPtrs%%(sig)[j] # "")
    SQLX_DR%%(drn) = %%(sigNullPtrs%%(sig)[j]):%%(sigNulls%%(sig)[j]);
%%ELSE
    SQLX_DR%%(drn) = %%(sigNulls%%(sig)[j]);
%%ENDIF
%%ELSE
    SQLX_DR%%(drn) = 0;
%%ENDIF
%%SET drn(%%(drn + 1))
%%ENDIF
%%IF(sigExprs%%(sig)[j] # "NULL")
%%SET t(%%(colTypes%%(tabNo)[col]))
%%IF(sigPtrs%%(sig)[j] # "")%%SET ptr("%%(sigPtrs%%(sig)[j]):")%%ELSE%%SET ptr()%%ENDIF
%%IF(t = "BITS" OR t = "SYMBOL")
    SQLX_DR%%(drn) = %%(ptr)%%(sigExprs%%(sig)[j]);
%%ELSIF(t = "PACKED NUMSTRING")
    SQLX_DR%%(drn) = %%(ptr)%%(sigExprs%%(sig)[j]).LENGTH;
    SQLX_DR%%(drn + 1) = %%(ptr)%%(sigExprs%%(sig)[j]).W1;
    SQLX_DR%%(drn + 2) = %%(ptr)%%(sigExprs%%(sig)[j]).W2;
    SQLX_DR%%(drn + 3) = %%(ptr)%%(sigExprs%%(sig)[j]).W3;
%%IF(colSizes%%(tabNo)[col] = 28)
    SQLX_DR%%(drn + 4) = %%(ptr)%%(sigExprs%%(sig)[j]).W4;
    SQLX_DR%%(drn + 5) = %%(ptr)%%(sigExprs%%(sig)[j]).W5;
    SQLX_DR%%(drn + 6) = %%(ptr)%%(sigExprs%%(sig)[j]).W6;
    SQLX_DR%%(drn + 7) = %%(ptr)%%(sigExprs%%(sig)[j]).W7;
%%ENDIF
%%ELSE
%%SET sPackXPtrs(, "%%(sigPtrs%%(sig)[j])")
%%SET sPackXVars(, "%%(sigExprs%%(sig)[j])")
%%SET sPackXRegs(, %%(drn))
%%SET sPackXLens(, %%(colLen%%(tabNo)[col]))
    DO SQLS_Pack%%(sPackXVars[0]);  ! pack string into signal registers !
%%ENDIF
%%ENDIF
%%SET drn(%%(drn + colLen%%(tabNo)[col]))
%%ENDLOOP(j)
%%LOOP(j <= drn - 5)
%%SET drs(, %%(j + 4))
%%ENDLOOP(j)
%%END(packX)
%%----> packKeyX
-------------------------------------------------------------------------------
- packKeyX
-
- Parameters:
-       1: Key type (1 for cursor access)
-
- IMP variables used:
-       tabNo
-       keyExprs
-       keyOp
-       keyPrefix
-       keyNo
-       curNames
-       curNo
-       colNullI
-       colLenI
-       keyPtrs
-       colSizesI
-       colTypesI
-       bTreeColsI
-       bTreesI
-
- IMP variables defined:
-       drs
-       sPackXPtrs
-       sPackXVars
-       sPackXRegs
-       sPackXLens
-
- Temporary IMP variables:
-       col
-       drn
-       j
-       ptr
-       t
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(packKeyX)
!------------------------------------------------!
!       packKeyX !
!------------------------------------------------!
%%IF(bTrees%%(tabNo)(%%(packKeyX[1])))
%%SET drn(24)
%%LOOP(j <= keyExprs[0])
%%SET col(%%(bTreeCols%%(tabNo)_%%(keyNo)[j]))
%%SET drn(%%(drn - colLen%%(tabNo)[col]))
%%IF(keyExprs[j] # "NULL")
%%SET t(%%(colTypes%%(tabNo)[col]))
%%IF(keyPtrs[j] # "")%%SET ptr("%%(keyPtrs[j]):")%%ELSE%%SET ptr()%%ENDIF
%%IF(t = "BITS" OR t = "SYMBOL")
    SQLX_DR%%(drn) = %%(ptr)%%(keyExprs[j]);
%%ELSIF(t = "DBNUMBER")
    SQLX_DR%%(drn) = %%(ptr)%%(keyExprs[j]).PART1;
    SQLX_DR%%(drn + 1) = %%(ptr)%%(keyExprs[j]).PART2;
%%ELSIF(t = "PACKED NUMSTRING")
    SQLX_DR%%(drn) = %%(ptr)%%(keyExprs[j]).LENGTH;
    SQLX_DR%%(drn + 1) = %%(ptr)%%(keyExprs[j]).W1;
    SQLX_DR%%(drn + 2) = %%(ptr)%%(keyExprs[j]).W2;
    SQLX_DR%%(drn + 3) = %%(ptr)%%(keyExprs[j]).W3;
%%IF(colSizes%%(tabNo)[col] = 28)
    SQLX_DR%%(drn + 4) = %%(ptr)%%(keyExprs[j]).W4;
    SQLX_DR%%(drn + 5) = %%(ptr)%%(keyExprs[j]).W5;
    SQLX_DR%%(drn + 6) = %%(ptr)%%(keyExprs[j]).W6;
    SQLX_DR%%(drn + 7) = %%(ptr)%%(keyExprs[j]).W7;
%%ENDIF
%%ELSE
%%SET sPackXPtrs(, "%%(keyPtrs[j])")
%%SET sPackXVars(, "%%(keyExprs[j])")
%%SET sPackXRegs(, %%(drn))
%%SET sPackXLens(, %%(colLen%%(tabNo)[col]))
    DO SQLS_Pack%%(sPackXVars[0]);  ! pack string into signal registers !
%%ENDIF
%%ENDIF
%%IF(colNull%%(tabNo)[col] = 1)
%%SET drn(%%(drn - 1))
%%IF(keyExprs[j] = "NULL")
    SQLX_DR%%(drn) = 1;
%%ELSE
    SQLX_DR%%(drn) = 0;
%%ENDIF
%%ENDIF
%%ENDLOOP(j)
%%LOOP(j <= 24 - drn)
%%SET drs(, %%(24 - j))
%%ENDLOOP(j)
%%ELSIF(packKeyX[1] = 1)
    SQLX_DR23 = PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor;
    SQLX_DR22 = %%(keyNo);
    SQLX_DR21 = %%(keyPrefix);
    SQLX_DR20 = %%(keyOp);
%%SET drs(, 20, 21, 22, 23)
%%ELSE
    SQLX_DR23 = %%(keyExprs);
%%SET drs(, 23)
%%ENDIF
%%END(packKeyX)
%%----> packRequestX
-------------------------------------------------------------------------------
- packRequestX
-
- Parameters:
-       1: Signal number
-
- IMP variables used:
-       sigColsI
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       drn
-       j
-       sig
-       t
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(packRequestX)
!------------------------------------------------!
!       packRequestX !
!------------------------------------------------!
%%SET sig(%%(packRequestX[1]))
%%SET t(%%(sigCols%%(sig)[0]))
%%SET drn(5)
%%SET drs(, 5)
    SQLX_DR%%(drn) = %%(t);
%%LOOP(j <= t)
%%SET drn(%%(drn + 1))
%%SET drs(, %%(drn))
    SQLX_DR%%(drn) = %%(sigCols%%(sig)[t + 1 - j]);
%%ENDLOOP(j)
%%END(packRequestX)
%%----> getData
-------------------------------------------------------------------------------
- getData
-
- Parameters: None
-
- IMP variables used:
-       vars
-       tabName
-       colsI
-       tabNo
-       cols
-       colSizesI
-       nulls
-       nullPtrs
-       colNullI
-       colTypesI
-       ptrs
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       j
-       ptr
-       t
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(getData)
!------------------------------------------------!
!       getData !
!------------------------------------------------!
%%LOOP(j <= cols[0])
%%IF(ptrs[j] # "")%%SET ptr("%%(ptrs[j]):")%%ELSE%%SET ptr()%%ENDIF
%%IF(cols[j] = 0)
    %%(ptr)%%(vars[j]) = SQLM_%%(tabName)_OperRow;
%%ELSE
%%SET t(%%(colTypes%%(tabNo)[cols[j]]))
%%IF(colNull%%(tabNo)[cols[j]] = 1)
%%IF(nulls[j] = "")
    IF SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Null = 1 THEN
        SQLCODE = 1 + 1 <= 8;
    FI;
%%ELSE
%%IF(nullPtrs[j] # "")
    %%(nullPtrs[j]):%%(nulls[j]) = SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Null;
%%ELSE
    %%(nulls[j]) = SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Null;
%%ENDIF
%%ENDIF
%%ENDIF
%%IF(t = "BITS" OR t = "SYMBOL" OR t = "STRING" OR t = "NUMSTRING")
    %%(ptr)%%(vars[j]) = SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Data;
%%ELSIF(t = "DBNUMBER")
    %%(ptr)%%(vars[j]).PART1 = SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Data.PART1;
    %%(ptr)%%(vars[j]).PART2 = SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Data.PART2;
%%ELSIF(t = "PACKED NUMSTRING")
%%INCLUDE(copyPackNum("%%(ptr)%%(vars[j])", "SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Data", %%(colSizes%%(tabNo)[cols[j]])))
%%ENDIF
%%ENDIF
%%ENDLOOP(j)
%%END(getData)
%%----> putData
-------------------------------------------------------------------------------
- putData
-
- Parameters: None
-
- IMP variables used:
-       tabNo
-       tabName
-       cols
-       exprs
-       ptrs
-       nulls
-       nullPtrs
-       colsI
-       colTypesI
-       colNullI
-       colSizesI
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       j
-       ptr
-       t
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(putData)
!------------------------------------------------!
!       putData !
!------------------------------------------------!
%%LOOP(j <= cols[0])
%%IF(colNull%%(tabNo)[cols[j]] = 1)
%%IF(exprs[j] = "NULL")
    SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Null = 1;
%%ELSIF(nulls[j] # "")
%%IF(nullPtrs[j] # "")
    SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Null =
        %%(nullPtrs[j]):%%(nulls[j]);
%%ELSE
    SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Null =
        %%(nulls[j]);
%%ENDIF
%%ELSE
    SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Null = 0;
%%ENDIF
%%ENDIF
%%IF(exprs[j] # "NULL")
%%SET t(%%(colTypes%%(tabNo)[cols[j]]))
%%IF(ptrs[j] # "")%%SET ptr("%%(ptrs[j]):")%%ELSE%%SET ptr()%%ENDIF
%%IF(t = "BITS" OR t = "SYMBOL" OR t = "STRING" OR t = "NUMSTRING")
    SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Data =
        %%(ptr)%%(exprs[j]);
%%ELSIF(t = "PACKED NUMSTRING")
%%INCLUDE(copyPackNum("SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(cols%%(tabNo)[cols[j]])_Data", "%%(ptr)%%(exprs[j])", %%(colSizes%%(tabNo)[cols[j]])))
%%ENDIF
%%ENDIF
%%ENDLOOP(j)
%%END(putData)
%%----> scanPredicate
-------------------------------------------------------------------------------
- scanPredicate
-
- Parameters:
-       1: Table number
-       2: Table name
-       3: Scan predicate number
-       4: Success label
-       5: Failure label
-       6: "C" if table check, "P" fetch scan predicate
-
- IMP variables used:
-       scanPredJ
-       scanColsJ
-       scanNullsJ
-       scanNullPtrsJ
-       colsI
-       colNullI
-       colTypesI
-       colSizesI
-
- IMP variables defined:
-       sCmpStringXPtrs1
-       sCmpStringXPtrs2
-       sCmpStringXVars1
-       sCmpStringXVars2
-
- Temporary IMP variables:
-       k
-       lab
-       left
-       op
-       pred
-       right
-       scanTabNo
-       scanTabName
-       predType
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(scanPredicate)
!------------------------------------------------!
!       scanPredicate !
!------------------------------------------------!
%%SET scanTabNo(%%(scanPredicate[1]))
%%SET scanTabName(%%(scanPredicate[2]))
%%SET pred(%%(scanPredicate[3]))
%%SET predType(%%(scanPredicate[6]))
%%IF(scanPred%%(pred)[1] # "")
SQLL_%%(scanPred%%(pred)[1]))
%%ENDIF
%%IF(scanPred%%(pred)[5] # "NULL")
%%IF(predType = "P")%%SET lab("%%(scanPred%%(pred)[11])")
%%ELSE%%SET lab("%%(scanPred%%(pred)[9])")%%ENDIF
%%IF(lab = "True")%%SET lab("%%(scanPredicate[4])")
%%ELSIF(lab = "False")%%SET lab("%%(scanPredicate[5])")
%%ELSE%%SET lab("SQLL_%%(lab)")%%ENDIF
%%IF(scanNulls%%(pred)[0] = 0)
%%LOOP(k, scanCols%%(pred))
%%IF(k # 0 AND colNull%%(scanTabNo)[k] = 1)
    IF SQLM_%%(scanTabName)_OperRow:
            SQLC_%%(scanTabName)_%%(cols%%(scanTabNo)[k])_Null = 1
        GOTO %%(lab);
%%ENDIF
%%ENDLOOP(k)
%%ELSE
%%LOOP(k <= scanNulls%%(pred)[0])
%%IF(scanNullPtrs%%(pred)[k] # "")
    IF %%(scanNullPtrs%%(pred)[k]):%%(scanNulls%%(pred)[k]) = 1
        GOTO %%(lab);
%%ELSE
    IF %%(scanNulls%%(pred)[k]) = 1 GOTO %%(lab);
%%ENDIF
%%ENDLOOP(k)
%%ENDIF
%%ENDIF
%%SET left("%%(scanPred%%(pred)[4])")
%%IF(left # "")%%SET left("%%(left):")%%ENDIF
%%SET right("%%(scanPred%%(pred)[7])")
%%IF(right # "")%%SET right("%%(right):")%%ENDIF
%%IF(scanPred%%(pred)[3] # "")
    %%(left)%%(scanPred%%(pred)[2]) = %%(scanPred%%(pred)[3]);
%%ENDIF
%%IF(scanPred%%(pred)[6] # "")
    %%(right)%%(scanPred%%(pred)[5]) = %%(scanPred%%(pred)[6]);
%%ENDIF
%%IF(scanCols%%(pred)[0] = 0)
%%SET predType("BITS")
%%ELSE
%%IF(scanCols%%(pred)[1] = 0)
%%SET predType("BITS")
%%ELSE
%%SET predType(%%(colTypes%%(scanTabNo)[scanCols%%(pred)[1]]))
%%ENDIF
%%ENDIF
%%SET op("%%(scanPred%%(pred)[8])")
%%SET lab("%%(scanPred%%(pred)[9])")
%%IF(lab = "True")%%SET lab("%%(scanPredicate[4])")
%%ELSIF(lab = "False")%%SET lab("%%(scanPredicate[5])")
%%ELSE%%SET lab("SQLL_%%(lab)")%%ENDIF
%%IF(scanPred%%(pred)[5] = "NULL")
    IF %%(left)%%(scanPred%%(pred)[2]) %%(op) 1
        GOTO %%(lab);
%%ELSIF(predType = "BITS" OR predType = "SYMBOL" OR ((predType = "STRING" OR predType = "NUMSTRING") AND (op = "=" OR op = "/=")))
    IF %%(left)%%(scanPred%%(pred)[2]) %%(op) %%(right)%%(scanPred%%(pred)[5])
        GOTO %%(lab);
%%ELSIF(predType = "PACKED NUMSTRING")
    IF %%(left)%%(scanPred%%(pred)[2]).LENGTH %%(op) %%(right)%%(scanPred%%(pred)[5]).LENGTH
        GOTO %%(lab);
    IF %%(left)%%(scanPred%%(pred)[2]).W1 %%(op) %%(right)%%(scanPred%%(pred)[5]).W1
        GOTO %%(lab);
    IF %%(left)%%(scanPred%%(pred)[2]).W2 %%(op) %%(right)%%(scanPred%%(pred)[5]).W2
        GOTO %%(lab);
    IF %%(left)%%(scanPred%%(pred)[2]).W3 %%(op) %%(right)%%(scanPred%%(pred)[5]).W3
        GOTO %%(lab);
%%IF(colSizes%%(scanTabNo)[scanCols%%(pred)[1]] = 28)
    IF %%(left)%%(scanPred%%(pred)[2]).W4 %%(op) %%(right)%%(scanPred%%(pred)[5]).W4
        GOTO %%(lab);
    IF %%(left)%%(scanPred%%(pred)[2]).W5 %%(op) %%(right)%%(scanPred%%(pred)[5]).W5
        GOTO %%(lab);
    IF %%(left)%%(scanPred%%(pred)[2]).W6 %%(op) %%(right)%%(scanPred%%(pred)[5]).W6
        GOTO %%(lab);
    IF %%(left)%%(scanPred%%(pred)[2]).W7 %%(op) %%(right)%%(scanPred%%(pred)[5]).W7
        GOTO %%(lab);
%%ENDIF
%%ELSIF(predType = "STRING" OR predType = "NUMSTRING")
%%SET sCmpStringXPtrs1(, "%%(scanPred%%(pred)[4])")
%%SET sCmpStringXPtrs2(, "%%(scanPred%%(pred)[7])")
%%SET sCmpStringXVars1(, "%%(scanPred%%(pred)[2])")
%%SET sCmpStringXVars2(, "%%(scanPred%%(pred)[5])")
    DO SQLS_CmpString%%(sCmpStringXVars1[0]);
    IF SQLX_KeyTest %%(op) 1 GOTO %%(lab);
%%ENDIF
%%SET lab("%%(scanPred%%(pred)[10])")
%%IF(lab # "")
%%IF(lab = "True")%%SET lab("%%(scanPredicate[4])")
%%ELSIF(lab = "False")%%SET lab("%%(scanPredicate[5])")
%%ELSE%%SET lab("SQLL_%%(lab)")%%ENDIF
    GOTO %%(lab);
%%ENDIF
%%END(scanPredicate)
%%----> saveSigPtrs
-------------------------------------------------------------------------------
- saveSigPtrs
-
- Parameters:
-       1: "G" if select or fetch statement, "P" if insert or update statement
-
- IMP variables used:
-       sigCount
-       sigPtrsI
-       sigAssPtrsI
-
- IMP variables defined:
-       sigPtr_I
-
- Temporary IMP variables:
-       i
-       j
-       p1
-       sc
-       sig
-       sigPtrs
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(saveSigPtrs)
!------------------------------------------------!
!       saveSigPtrs !
!------------------------------------------------!
%%SET p1(%%(saveSigPtrs[1]))
%%IF(p1 = "P")%%SET sc(%%(sigCount))%%ELSE%%SET sc(%%(sigCount + 1))%%ENDIF
%%SET sigPtrs()
%%LOOP(i <= sc)
%%IF(p1 = "P")%%SET sig(%%(i))%%ELSE%%SET sig(%%(i - 1))%%ENDIF
%%LOOP(j, sigPtrs%%(sig))
%%IF(j # "" AND j # "PROTECTEDP" AND NOT sigPtrs(%%(j)))%%SET sigPtrs(, %%(j))%%ENDIF
%%ENDLOOP(j)
%%IF(p1 = "P")
%%LOOP(j, sigAssPtrs%%(sig))
%%IF(j # "" AND j # "PROTECTEDP" AND NOT sigPtrs(%%(j)))%%SET sigPtrs(, %%(j))%%ENDIF
%%ENDLOOP(j)
%%ENDIF
%%ENDLOOP(i)
%%IF(sigPtrs[0] > 0)
! Protect pointers from time gap. !
%%LOOP(i <= sigPtrs[0])
    PROTECTEDP:SQLM_P(%%(i - 1)) = %%(sigPtrs[i]);
%%SET sigPtr_%%(sigPtrs[i])(%%(i - 1))
%%ENDLOOP(i)
%%ENDIF
%%END(saveSigPtrs)
%%----> restoreSigPtrs
-------------------------------------------------------------------------------
- restoreSigPtrs
-
- Parameters:
-       1: Signal number
-       2: "G" if select or fetch statement, "P" if insert or update statement
-
- IMP variables used:
-       sigPtrsI
-       sigAssPtrsI
-       sigPtr_I
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       j
-       p1
-       p2
-       sigPtrs
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(restoreSigPtrs)
!------------------------------------------------!
!       restoreSigPtrs !
!------------------------------------------------!
%%SET p1(%%(restoreSigPtrs[1]))
%%SET p2(%%(restoreSigPtrs[2]))
%%SET sigPtrs()
%%LOOP(j, sigPtrs%%(p1))
%%IF(j # "" AND j # "PROTECTEDP" AND NOT sigPtrs(%%(j)))
    %%(j) = PROTECTEDP:SQLM_P(%%(sigPtr_%%(j)));
%%SET sigPtrs(, %%(j))
%%ENDIF
%%ENDLOOP(j)
%%IF(p2 = "P")
%%LOOP(j, sigAssPtrs%%(p1))
%%IF(j # "" AND j # "PROTECTEDP" AND NOT sigPtrs(%%(j)))
    %%(j) = PROTECTEDP:SQLM_P(%%(sigPtr_%%(j)));
%%SET sigPtrs(, %%(j))
%%ENDIF
%%ENDLOOP(j)
%%ENDIF
%%END(restoreSigPtrs)
%%---> Top Level Macros
%%----> tuDeclarations
-------------------------------------------------------------------------------
- tuDeclarations
-
- Parameters: None
-
- IMP variables used: None
-
- IMP variables defined:
-       tableUser
-       ddhTabRefLab
-       sPackXVars
-       sUnPackXVars
-       sCmpStringXVars1
-       towGetLab
-       towChaVolRowLab
-       trhChaRowLab
-       trhInsRowLab
-       trhLetFldLab
-       trhDelRowLab
-       towOpenLab
-       trhStaTransLab
-       trhVerTransLab
-       trhComTransLab
-       trhRollBckLab
-       continueBLab
-       continueCLab
-
- Temporary IMP variables: None
-
- Included code components:
-       comDeclarations
-       tuDeclRemTab
-------------------------------------------------------------------------------
%%BEGIN(tuDeclarations)
!------------------------------------------------!
!       tuDeclarations !
!------------------------------------------------!
%%SET tableUser()
%%INCLUDE(comDeclarations)
%%INCLUDE(tuDeclRemTab)

%%SET ddhTabRefLab(0)
%%SET sPackXVars()
%%SET sUnPackXVars()
%%SET sCmpStringXVars1()

%%SET towGetLab(0)
%%SET towChaVolRowLab(0)
%%SET trhChaRowLab(0)
%%SET trhInsRowLab(0)
%%SET trhLetFldLab(0)
%%SET trhDelRowLab(0)
%%SET towOpenLab(0)
%%SET towCloseLab(0)
%%SET trhStaTransLab(0)
%%SET trhVerTransLab(0)
%%SET trhComTransLab(0)
%%SET trhRollBckLab(0)
%%SET continueBLab(0)
%%SET continueCLab(0)
%%END(tuDeclarations)
%%----> tuPlexCode
-------------------------------------------------------------------------------
- tuPlexCode
-
- Parameters: None
-
- IMP variables used: None
-
- IMP variables defined: None
-
- Temporary IMP variables: None
-
- Included code components:
-       comPlexCode
-       RESTARTPHASE3
-       tuDdhTabRefR
-       recTowGetR
-       recTowChaVolRowR
-       recTrhInsRowR
-       recTrhLetFldR
-       recTrhChaRowR
-       recTrhDelRowR
-       recTowOpenR
-       recTrhStaTransR
-       recTrhVerTransR
-       recTrhComTransR
-       recTrhRollBckR
-       recContinueB
-       recContinueC
-       recTrhGetDBnoR
-       recTusReAllProt
-------------------------------------------------------------------------------
%%BEGIN(tuPlexCode)
!------------------------------------------------!
!       tuPlexCode !
!------------------------------------------------!
%%----------------------------------------
%%-- Common code
%%----------------------------------------
%%INCLUDE(comPlexCode)
%%----------------------------------------
%%-- Start and restart support code
%%----------------------------------------
%%INCLUDE(RESTARTPHASE3)
%%INCLUDE(tuDdhTabRefR)
%%INCLUDE(recTusReAllProt)
%%----------------------------------------
%%-- Receive return signals
%%----------------------------------------
%%INCLUDE(recTowGetR)
%%INCLUDE(recTowChaVolRowR)
%%INCLUDE(recTrhInsRowR)
%%INCLUDE(recTrhLetFldR)
%%INCLUDE(recTrhChaRowR)
%%INCLUDE(recTrhDelRowR)
%%INCLUDE(recTowOpenR)
%%INCLUDE(recTrhStaTransR)
%%INCLUDE(recTrhVerTransR)
%%INCLUDE(recTrhComTransR)
%%INCLUDE(recTrhRollBckR)
%%INCLUDE(recContinueB)
%%INCLUDE(recContinueC)
%%----------------------------------------
%%-- End of code
%%----------------------------------------
%%END(tuPlexCode)
%%----> tuAsaCode
-------------------------------------------------------------------------------
- tuAsaCode
-
- Parameters: None
-
- IMP variables used: None
-
- IMP variables defined: None
-
- Temporary IMP variables: None
-
- Included code components:
-       comAsaCode
-       sPackX
-       sUnPackX
-       sCmpStringX
-------------------------------------------------------------------------------
%%BEGIN(tuAsaCode)
!------------------------------------------------!
!       tuAsaCode !
!------------------------------------------------!
%%INCLUDE(comAsaCode)
%%INCLUDE(sPackX)
%%INCLUDE(sUnPackX)
%%INCLUDE(sCmpStringX)
%%----------------------------------------
%%-- Generate signal survey
%%----------------------------------------
%%INCLUDE(genSigSurv)
%%END(tuAsaCode)
%%----> tuData
-------------------------------------------------------------------------------
- tuData
-
- Parameters:
-   If user has declared a data sector:
-       1: Set to "USER"
-   If user has not declared a data sector: Empty list
-
- IMP variables used: None
-
- IMP variables defined: None
-
- Temporary IMP variables: None
-
- Included code components:
-       comData
-------------------------------------------------------------------------------
%%BEGIN(tuData)
!------------------------------------------------!
!       tuData !
!------------------------------------------------!
%%IF(tuData[0] = 0 AND NOT towData(?))
DATA;
%%ENDIF
%%INCLUDE(comData)
%%IF(tuData[0] = 0 AND (NOT tableOwner(?) OR towData(?)))
END DATA;
%%ENDIF
%%END(tuData)
%%---> Handle: System start
%%----> RESTARTPHASE3
-------------------------------------------------------------------------------
- RESTARTPHASE3
-
- Parameters: None
-
- IMP variables used: None
-       remTables
-       remTabNos
-       ddhTabRefLab
-       multiNoI
-
- IMP variables defined:
-       ddhTabRefLab
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(RESTARTPHASE3)
%%IF(remTables[0] > 0)
!------------------------------------------------!
!       RESTARTPHASE3 !
!------------------------------------------------!
RESTARTPHASE3)
%%LOOP(i <= remTables[0])
%%IF(NOT multiNo%%(remTabNos[i])(?))
! Ask for block and table reference for remote table !
%%SET sentSigs(,DDHTABREF)
    SEND ddhTabRef WITH
%%SET ddhTabRefLab(%%(ddhTabRefLab + 1))
        %%(ddhTabRefLab),
        cOwnRef,
        "%%(remTables[i])";
    EXIT;
ddhTabRefLab%%(ddhTabRefLab))
    SQLM_Remote(%%(remTabNos[i] - remTabNos[1])).block=SQLX_OtherBlock;
    SQLM_Remote(%%(remTabNos[i] - remTabNos[1])).table=SQLX_TableReference;
%%ENDIF
%%ENDLOOP(i)
    GOTO RESTARTEND;
%%ENDIF
%%END(RESTARTPHASE3)
%%----> tuDdhTabRefR
-------------------------------------------------------------------------------
- tuDdhTabRefR
-
- Parameters: None
-
- IMP variables used:
-       ddhTabRefLab
-
- IMP variables defined: None
-
- Temporary IMP variables:
-       i
-
- Included code components: None
-------------------------------------------------------------------------------
%%BEGIN(tuDdhTabRefR)
!------------------------------------------------!
!       tuDdhTabRefR !
!------------------------------------------------!
%%IF(ddhTabRefLab > 0)
%%SET recSigs(,DDHTABREFR)
    ENTER ddhTabRefR WITH
        SQLX_ReturnLabel,
        SQLX_ReturnCode,
        SQLX_OtherBlock,
        SQLX_TableReference;
%%IF(ddhTabRefLab = 1)
    GOTO ddhTabRefLab1;
%%ELSE
    CASE SQLX_ReturnLabel IS
%%LOOP(i <= ddhTabRefLab)
    WHEN %%(i) DO GOTO ddhTabRefLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ENDIF
%%ENDIF
%%END(tuDdhTabRefR)
--------------------------------------------------------------------------
-  5 COMMON ASSEMBLER BLOCKS
--------------------------------------------------------------------------


----------------------------------------------------------------------------
- Code component sPack, chapter 5.1

- This function packs the data stored in the row pointed to by pOperRow
- into the data registers DR5 to DR23.

- Parameters:
-       None

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).
-
- IMP variables defined:
-       None

- Temporary IMP variables:
-       i
-       j

- Included code components:
-       sPackColumn
-       sPackColumnDBnum
-       sPackColumnRownum
----------------------------------------------------------------------------
%%BEGIN(sPack)
!------------------------------------------------!
!       sPack !
!------------------------------------------------!
%%LOOP(i <= tables[0])

PROGRAM SQLS_%%(tables[i])_Pack; ASA210C;
%%IF(DRNPATCH(1))
%%LOOP(j <= 14)
        MFR     DR%%(j+5)-SQLX_DR%%(j+5);
%%ENDLOOP(j)
%%ENDIF
%%SET sCount(%%(sCount + 1))
! Set pointer register to row where to get data.!
       MFR     PR0-SQLM_%%(tables[i])_OperRow;
! read column which columns to pack into SQLX_Columns.!
       LCC     IR-0;
       WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! use WR0 as a counter of number of columns to pack.!
       MFR     WR0-SQLX_DR5;
! store the index of first register to pack data into.!
       LCC     SQLX_DR3-10;                  !adress of DR4!
LOOP_%%(sCount))
! if no more columns to pack exit this function and returtn the
  number of data registers containing packed data in SQLX_DR3.!
       JEC     WR0,0,EXIT_%%(sCount);
       SCC     WR0-1;
! get which column to pack and jump to that specific code.!
        MFR     IR-WR0;
        RS      WR1-SQLX_Columns;
        LCC     IR-0;
!        JTR     WR1,%%(cols%%(tabNos[i])[0])
        ADDR    EXIT_%%(sCount)!
LHC CR/W0-%%(cols%%(tabNos[i])[0]); JGT WR1,EXIT_%%(sCount);
LHC CR/W0-0; JER WR1,L0_%%(sCount);!        ADDR    L0_%%(sCount)!
LHC CR/W0-1; JER WR1,L1_%%(sCount);!        ADDR    L1_%%(sCount)!
%%LOOP(j <= cols%%(tabNos[i])[0]-1)
LHC CR/W0-%%(j+1); JER WR1,L%%(j+1)_%%(sCount);!        ADDR    L%%(j+1)_%%(sCount)!
%%ENDLOOP(j)

L0_%%(sCount))
%%INCLUDE(sPackColumnRownum)
        JLN LOOP_%%(sCount);

L1_%%(sCount))
%%INCLUDE(sPackColumnDBnum(%%(i)))
        JLN LOOP_%%(sCount);
%%LOOP(j <= cols%%(tabNos[i])[0]-1)

L%%(j+1)_%%(sCount))
%%INCLUDE(sPackColumn(%%(i),%%(j + 1)))
        JLN     LOOP_%%(sCount);
%%ENDLOOP(j)
EXIT_%%(sCount))
        SCC     SQLX_DR3-10;                         !adress of DR4!
%%IF(DRNPATCH(1))
%%LOOP(j <= 20)
        MFR     SQLX_DR%%(j+3)-DR%%(j+3);
%%ENDLOOP(j)
%%ENDIF
END PROGRAM;
%%ENDLOOP(i)
%%END(sPack)
---------------------------------------------------------------------------





---------------------------------------------------------------------------
- Code component sPackColumnRownum, chapter 5.1.2

- Parameters:
-       None

- IMP variables used:
-       None

- IMP variables defined:
-       None

- Temporary IMP variables:
-       None

- Included code components:
-       None
----------------------------------------------------------------------------
%%BEGIN(sPackColumnRownum)
!------------------------------------------------!
!       sPackColumnRownum !
!------------------------------------------------!
        WS      SQLX_TempData-PR0;
        LBNBA   WR1-SQLX_TempData;
        %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
        ACC     SQLX_DR3-1;
%%END(sPackColumnRownum)
--------------------------------------------------------------------------






--------------------------------------------------------------------------
- Code component sPackColumnDBnum, chapter 5.1.3

- Parameters:
-       p1:             Table index.

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       None

- Included code components:
-       None
----------------------------------------------------------------------------
%%BEGIN(sPackColumnDBnum)
!------------------------------------------------!
!       sPackColumnDBnum !
!------------------------------------------------!
%%SET p1(%%(sPackColumnDBnum[1]))
        LBNBA   WR1-SQLX_TempData;
        RSE     WR2-SQLC_%%(tables[p1])_DBnumber;
        WS      SQLX_TempData-WR2;
        %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
        ACC     SQLX_DR3-1;
        WS      SQLX_TempData-WR3;
        %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
        ACC     SQLX_DR3-1;
%%END(sPackColumnDBnum)
---------------------------------------------------------------------------




----------------------------------------------------------------------------
- Code component sPackColumn, chapter 5.1.4

- Parameters:
-       p1:             Table index
-       p2:             column number

-IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.
-       colLenI[J]      Length in words (16 bits) of column J in table I.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       p3

- Included code components:
-       None
----------------------------------------------------------------------------
%%BEGIN(sPackColumn)
!------------------------------------------------!
!       sPackColumn !
!------------------------------------------------!
%%SET p1(%%(sPackColumn[1]))
%%SET p2(%%(sPackColumn[2]))
%%SET p3(%%(tabNos[p1]))
%%IF(colNull%%(p3)[p2]=1)
    LBNBA   WR1-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Null;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    ACC     SQLX_DR3-1;
%%ENDIF
%%IF(colTypes%%(p3)[p2] = "PACKED NUMSTRING")
    LBNBA   WR1-SQLX_TempData;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W0;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W1;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W2;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W3;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    ACC     SQLX_DR3-1;
%%IF(colSizes%%(p3)[p2] = 28)
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W4;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W5;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W6;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    ACC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W7;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    ACC     SQLX_DR3-1;
%%ENDIF
%%ELSE
    LBNBA   WR1-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
%%IF(colLen%%(p3)[p2] <= 15)
    ACC     SQLX_DR3-%%(colLen%%(p3)[p2]);
%%ELSE
    AWCD    SQLX_DR3-%%(colLen%%(p3)[p2]);
%%ENDIF
%%ENDIF
%%END(sPackColumn)
----------------------------------------------------------------------------








----------------------------------------------------------------------------
- Code component sUnpack, chapter 5.2.1

- This function unpacks the data stored in data registers DR6 to DR19
- into the row pointed to by pWorkRow.

-IMP variables used:
-       tables          All table names in the block.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).

- IMP variables defined:
-       None

- Temporary IMP variables:
-       i
-       j

- Included code components:
-       sUnpackcolumn
---------------------------------------------------------------------------
%%BEGIN(sUnpack)
!------------------------------------------------!
!       sUnpack !
!------------------------------------------------!
%%LOOP(i <= tables[0])

PROGRAM SQLS_%%(tables[i])_UnPack; ASA210C;
%%IF(DRNPATCH(1))
%%LOOP(j <= 14)
        MFR     DR%%(j+5)-SQLX_DR%%(j+5);
%%ENDLOOP(j)
%%ENDIF
%%SET sCount(%%(sCount + 1))
%%IF(cols%%(tabNos[i])[0] > 1)
! set PR0 to point to the row where to put packed data. This register
  must not be changed until all data is unpacked.!
        MFR     PR0-SQLM_%%(tables[i])_WorkRow;
! store column numbers in SQLX_Columns.!
        LCC     IR-0;
        WSI     SQLX_Columns-DR6,SQLX_DR5,14;
! set WR0 to point to the first packed data register.!
        LCC     WR0-12;                                 !adress of DR6!
        AR      WR0-SQLX_DR5;
LOOP_%%(sCount))
! if no more column to unpack exit.!
        JEC     SQLX_DR5,0,EXIT_%%(sCount);
! subtract number of columns to unpack with 1.!
        SCC     SQLX_DR5-1;
! store which column to be unpacked in WR1 and operation of value in WR2.!
        MFR     IR-SQLX_DR5;
        RS      WR2-SQLX_Columns;
        MFR     WR1-WR2;
        SHR     WR2,14;
        NWC     WR1-#3FFF;
! set IR to zero (unpack all column) and jump to the right routine to
  unpack the column as indicated in WR1.!
        LCC     IR-0;
!        JTR     WR1,%%(cols%%(tabNos[i])[0])
        ADDR    EXIT_%%(sCount)!
LHC CR/W0-%%(cols%%(tabNos[i])[0]); JGT WR1,EXIT_%%(sCount);
LHC CR/W0-0; JER WR1,EXIT_%%(sCount);!        ADDR    EXIT_%%(sCount)!
LHC CR/W0-1; JER WR1,EXIT_%%(sCount);!        ADDR    EXIT_%%(sCount)!
%%LOOP(j <= cols%%(tabNos[i])[0]-1)
LHC CR/W0-%%(j+1); JER WR1,L%%(j+1)_%%(sCount);!        ADDR L%%(j+1)_%%(sCount)!
%%ENDLOOP(j)
%%LOOP(j <= cols%%(tabNos[i])[0]-1)

L%%(j+1)_%%(sCount))
%%INCLUDE(sUnpackcolumn(%%(i),%%(j + 1)))
%%ENDLOOP(j)

EXIT_%%(sCount))
%%ENDIF
END PROGRAM;
%%ENDLOOP(i)
%%END(sUnpack)
----------------------------------------------------------------------------








----------------------------------------------------------------------------
- Code component sUnpackcolumn, chapter 5.2.2

- Parameters:
-       p1:             Table index
-       p2:             column number


-IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.
-       colLenI[J]      Length in words (16 bits) of column J in table I.
-       colTypesI[J]    Column type for column J in table I. One of: "BITS",
                        "STRING", "NUMSTRING", "PACKED NUMSTRING", "SYMBOL",
                        "DBNUMBER".

- IMP variables defined:
-       p3:             table name

- Temporary IMP variables:
-       None

- Included code components:
-       None
----------------------------------------------------------------------------
%%BEGIN(sUnpackcolumn)
!------------------------------------------------!
!       sUnpackcolumn !
!------------------------------------------------!
%%SET p1(%%(sUnpackcolumn[1]))
%%SET p2(%%(sUnpackcolumn[2]))
%%SET p3(%%(tabNos[p1]))
%%IF(colTypes%%(p3)[p2] = "BITS" AND colNull%%(p3)[p2] = 0)
! check if column should just be overwritten.!
        JUC     WR2,0,UPDATE%%(p2)_%%(sCount);
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data;
        %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
        ACC     WR0-1;
        JLN     LOOP_%%(sCount);
UPDATE%%(p2)_%%(sCount))
! read column data into register WR3.!
        RS      WR3-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data;
! overwrite previous value in column.!
        LBNBA   WR1-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data;
        %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
! read column data into register WR4.!
        RS      WR4-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data;
! should we add the values together?!
        JEC     WR2,1,ADD%%(p2)_%%(sCount);
! subtract the new value from the previous column value.!
        SR      WR3-WR4;
! store the subtracted value in column !
        WS      SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_%%(sCount);
ADD%%(p2)_%%(sCount))
! add the new value to the previous column value.!
        AR      WR3-WR4;
! store the subtracted value in column.!
        WS      SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data-WR3;
        ACC     WR0-1;
        JLN     LOOP_%%(sCount);
%%ELSE
%%IF(colNull%%(p3)[p2]=1)
! unpack null indicator.!
        LBNBA   WR1-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Null;
        %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
! increase pointer where to get packed data.!
        ACC     WR0-1;
%%ENDIF
%%IF(colTypes%%(p3)[p2] = "PACKED NUMSTRING")
    LBNBA   WR1-SQLX_TempData;
    %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
    RS      WR5-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W0-WR5;
    ACC     WR0-1;
    %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
    RS      WR5-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W1-WR5;
    ACC     WR0-1;
    %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
    RS      WR5-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W2-WR5;
    ACC     WR0-1;
    %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
    RS      WR5-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W3-WR5;
    ACC     WR0-1;
%%IF(colSizes%%(p3)[p2] = 28)
    %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
    RS      WR5-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W4-WR5;
    ACC     WR0-1;
    %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
    RS      WR5-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W5-WR5;
    ACC     WR0-1;
    %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
    RS      WR5-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W6-WR5;
    ACC     WR0-1;
    %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
    RS      WR5-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data/W7-WR5;
    ACC     WR0-1;
%%ENDIF
%%ELSE
! unpack column data.!
        LBNBA   WR1-SQLC_%%(tables[p1])_%%(cols%%(p3)[p2])_Data;
        %%(sib)WSII    WR1-WR0,IR,DR6,DR19%%(sie)
%%IF(colLen%%(p3)[p2] <= 15)
        ACC     WR0-%%(colLen%%(p3)[p2]);
%%ELSE
        AWCD    WR0-%%(colLen%%(p3)[p2]);
%%ENDIF
%%ENDIF
        JLN     LOOP_%%(sCount);
%%ENDIF
%%END(sUnpackcolumn)
---------------------------------------------------------------------------






---------------------------------------------------------------------------
-Code component sPackKey, chapter 5.3.1

-This function pacs a key into the data stored in registers DR6 to DR23.
-Only keys which uses btree access must be specified.


-IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       i
-       j

- Included code components:
-       sPackKeyKey
-------------------------------------------------------------------------------
%%BEGIN(sPackKey)
!------------------------------------------------!
!       sPackKey !
!------------------------------------------------!
%%LOOP(i <= tables[0])

PROGRAM SQLS_%%(tables[i])_packKey; ASA210C;
%%IF(DRNPATCH(1))
%%LOOP(j <= 18)
        MFR     DR%%(j+5)-SQLX_DR%%(j+5);
%%ENDLOOP(j)
%%ENDIF
%%SET sCount(%%(sCount + 1))
! set PR0 to point to the row where to put packed data. This register
  must not be changed until data is unpacked.!
        MFR     PR0-SQLM_%%(tables[i])_OperRow;
! jump to code for key type.!
        LCC     IR-0;
        LHC     SQLX_DR3/W0-30;                     !adress of DR23 + 1!
%%IF(bTrees%%(tabNos[i])(2))
!        JTR     SQLX_KeyNumber,%%(bTrees%%(tabNos[i])[0]+1)!
LHC CR/W0-%%(bTrees%%(tabNos[i])[0]+1);
%%ELSE
!        JTR     SQLX_KeyNumber,%%(bTrees%%(tabNos[i])[0]+2)!
LHC CR/W0-%%(bTrees%%(tabNos[i])[0]+2);
%%ENDIF
JGT SQLX_KeyNumber,EXIT_%%(sCount);!        ADDR    EXIT_%%(sCount)!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_%%(sCount);!        ADDR    L0_%%(sCount)!
LHC CR/W0-1; JER SQLX_KeyNumber,EXIT_%%(sCount);!        ADDR    EXIT_%%(sCount)!
%%IF(NOT bTrees%%(tabNos[i])(2))
LHC CR/W0-2; JER SQLX_KeyNumber,L0_%%(sCount);!        ADDR    L0_%%(sCount)!
%%ENDIF
%%LOOP(j, bTrees%%(tabNos[i]))
LHC CR/W0-%%(j); JER SQLX_KeyNumber,L%%(j)_%%(sCount);!        ADDR    L%%(j)_%%(sCount)!
%%ENDLOOP(j)

L0_%%(sCount))
        MFR     SQLX_DR23-SQLM_%%(tables[i])_OperRow;
        JLN     EXIT_%%(sCount);
%%LOOP(j, bTrees%%(tabNos[i]))

L%%(j)_%%(sCount))
%%INCLUDE(sPackKeyKey(%%(i),%%(j)))
        JLN     EXIT_%%(sCount);
%%ENDLOOP(j)

EXIT_%%(sCount))
! calculate the number of data registers which contain packed data.!
        MFR     WR0-SQLX_DR3;
        LHC     SQLX_DR3/W0-30;                      !adress of DR23 + 1!
        SR      SQLX_DR3-WR0;
%%IF(DRNPATCH(1))
%%LOOP(j <= 18)
        MFR     SQLX_DR%%(j+5)-DR%%(j+5);
%%ENDLOOP(j)
%%ENDIF
END PROGRAM;
%%ENDLOOP(i)

%%END(sPackKey)
------------------------------------------------------------------------





------------------------------------------------------------------------
- Code component sPackKeyKey, chapter 5.3.2

- Parameters
-       p1:             Table index
-       p2:             Key number.

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.
-       bTreeColsI_J    Column numbers for all columns in table I btree J.
-       colLenI[J]      Length in words (16 bits) of column J in table I.
-       colSizesI[J]    Column size for column J in table I. Set to 0 if not
                        applicable.
-       colTypesI[J]    Column type for column J in table I. One of: "BITS",
                        "STRING", "NUMSTRING", "PACKED NUMSTRING", "SYMBOL",
                        "DBNUMBER".

- IMP variables defined:
-       None

- Temporary IMP variables:
-       k
-       p3

- Included code components:
-       None
----------------------------------------------------------------------------
%%BEGIN(sPackKeyKey)
!------------------------------------------------!
!       sPackKeyKey !
!------------------------------------------------!
%%SET p1(%%(sPackKeyKey[1]))
%%SET p2(%%(sPackKeyKey[2]))
%%SET p3(%%(tabNos[p1]))
%%LOOP(k, bTreeCols%%(p3)_%%(p2))
%%IF(colTypes%%(p3)[k] = "PACKED NUMSTRING")
    LBNBA   WR1-SQLX_TempData;
    SCC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W0;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    SCC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W1;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    SCC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W2;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    SCC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W3;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
%%IF(colSizes%%(p3)[k] = 28)
    SCC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W4;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    SCC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W5;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    SCC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W6;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
    SCC     SQLX_DR3-1;
    RSS     WR2-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W7;
    WS      SQLX_TempData-WR2;
    %%(sib)RSII    SQLX_DR3-WR1,IR,DR4,DR23%%(sie)
%%ENDIF
%%ELSE
%%IF(colLen%%(p3)[k] <= 15)
        SCC     SQLX_DR3-%%(colLen%%(p3)[k]);
%%ELSE
        SWCD    SQLX_DR3-%%(colLen%%(p3)[k]);
%%ENDIF
        LBNBA   WR1-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data;
        %%(sib)RSII    SQLX_DR3-WR1,IR,DR6,DR23%%(sie)
%%ENDIF
%%IF(colNull%%(p3)[k] = 1)
        SCC     SQLX_DR3-1;
        LBNBA   WR1-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Null;
        %%(sib)RSII    SQLX_DR3-WR1,IR,DR6,DR23%%(sie)
%%ENDIF
%%ENDLOOP(k)
%%END(sPackKeyKey)
----------------------------------------------------------------------------



-----------------------------------------------------------------------------
- Code component sUnPackKey, chapter 5.4.1

- IMP variables used:
-       tables          All table names in the block.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       i
-       j

- Included code components:
-       sUnPackKeyRow
-       sUnPackKeyCursor
-       sUnPackKeyBTree
-----------------------------------------------------------------------------
%%BEGIN(sUnPackKey)
!------------------------------------------------!
!       sUnPackKey !
!------------------------------------------------!
%%LOOP(i <= tables[0])

PROGRAM SQLS_%%(tables[i])_UnPackKey; ASA210C;
%%IF(DRNPATCH(1))
%%LOOP(j <= 18)
        MFR     DR%%(j+5)-SQLX_DR%%(j+5);
%%ENDLOOP(j)
%%ENDIF
%%SET sCount(%%(sCount + 1))
%%IF(bTrees%%(tabNos[i])[0] > 0)
! set pointer register to pWorkRow.!
        MFR     PR0-SQLM_%%(tables[i])_WorkRow;
        LCC     IR-0;
! set WR0 to point to the first register to get  key.!
        LHC     WR0/W0-30;                      !adress of DR23 + 1!
%%ENDIF
! jump to key unpack code.!
%%IF(bTrees%%(tabNos[i])(2))
!        JTR     SQLX_KeyNumber,%%(bTrees%%(tabNos[i])[0]+1)!
LHC CR/W0-%%(bTrees%%(tabNos[i])[0]+1);
%%ELSE
!        JTR     SQLX_KeyNumber,%%(bTrees%%(tabNos[i])[0]+2)!
LHC CR/W0-%%(bTrees%%(tabNos[i])[0]+2);
%%ENDIF
JGT SQLX_KeyNumber,EXIT_%%(sCount);!        ADDR    EXIT_%%(sCount)!
LHC CR/W0-0; JER SQLX_KeyNumber,L0_%%(sCount);!        ADDR    L0_%%(sCount)!
LHC CR/W0-1; JER SQLX_KeyNumber,L1_%%(sCount);!        ADDR    L1_%%(sCount)!
%%IF(NOT bTrees%%(tabNos[i])(2))
LHC CR/W0-2; JER SQLX_KeyNumber,L0_%%(sCount);!        ADDR    L0_%%(sCount)!
%%ENDIF
%%LOOP(j, bTrees%%(tabNos[i]))
LHC CR/W0-%%(j); JER SQLX_KeyNumber,L%%(j)_%%(sCount);!        ADDR    L%%(j)_%%(sCount)!
%%ENDLOOP(j)

L0_%%(sCount))
%%INCLUDE(sUnPackKeyRow(%%(i)))
        JLN     EXIT_%%(sCount);

L1_%%(sCount))
%%INCLUDE(sUnPackKeyCursor(%%(i)))
        JLN     EXIT_%%(sCount);
%%LOOP(j, bTrees%%(tabNos[i]))

L%%(j)_%%(sCount))
%%INCLUDE(sUnPackKeyBTree(%%(i),%%(j)))
        JLN     EXIT_%%(sCount);
%%ENDLOOP(j)

EXIT_%%(sCount))
END PROGRAM;
%%ENDLOOP(i)
%%END(sUnPackKey)
-----------------------------------------------------------------------------







----------------------------------------------------------------------------
- Code component sUnPackKeyBTree, chapter 5.4.2.1

- Parameters:
-       p1:             Table index
-       p2:             Key number

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.
-       bTreeColsI_J    Column numbers for all columns in table I btree J.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       p3

- Included code components:
-----------------------------------------------------------------------------
%%BEGIN(sUnPackKeyBTree)
!------------------------------------------------!
!       sUnPackKeyBTree !
!------------------------------------------------!
%%SET p1(%%(sUnPackKeyBTree[1]))
%%SET p2(%%(sUnPackKeyBTree[2]))
%%SET p3(%%(tabNos[p1]))
%%LOOP(k, bTreeCols%%(p3)_%%(p2))
%%IF(colTypes%%(p3)[k] = "PACKED NUMSTRING")
    LBNBA   WR1-SQLX_TempData;
    SCC     WR0-1;
%%IF(DRN2PATCH(1))
    LCC     WR3-1;
    %%(sib)WSII    WR1-WR0,WR3,DR6,DR23%%(sie)
%%ELSE
    %%(sib)WSII    WR1-WR0,IR,DR6,DR23%%(sie)
%%ENDIF
    RS      WR2-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W0-WR2;
    SCC     WR0-1;
%%IF(DRN2PATCH(1))
    %%(sib)WSII    WR1-WR0,WR3,DR6,DR23%%(sie)
%%ELSE
    %%(sib)WSII    WR1-WR0,IR,DR6,DR23%%(sie)
%%ENDIF
    RS      WR2-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W1-WR2;
    SCC     WR0-1;
%%IF(DRN2PATCH(1))
    %%(sib)WSII    WR1-WR0,WR3,DR6,DR23%%(sie)
%%ELSE
    %%(sib)WSII    WR1-WR0,IR,DR6,DR23%%(sie)
%%ENDIF
    RS      WR2-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W2-WR2;
    SCC     WR0-1;
%%IF(DRN2PATCH(1))
    %%(sib)WSII    WR1-WR0,WR3,DR6,DR23%%(sie)
%%ELSE
    %%(sib)WSII    WR1-WR0,IR,DR6,DR23%%(sie)
%%ENDIF
    RS      WR2-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W3-WR2;
%%IF(colSizes%%(p3)[k] = 28)
    SCC     WR0-1;
%%IF(DRN2PATCH(1))
    %%(sib)WSII    WR1-WR0,WR3,DR6,DR23%%(sie)
%%ELSE
    %%(sib)WSII    WR1-WR0,IR,DR6,DR23%%(sie)
%%ENDIF
    RS      WR2-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W4-WR2;
    SCC     WR0-1;
%%IF(DRN2PATCH(1))
    %%(sib)WSII    WR1-WR0,WR3,DR6,DR23%%(sie)
%%ELSE
    %%(sib)WSII    WR1-WR0,IR,DR6,DR23%%(sie)
%%ENDIF
    RS      WR2-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W5-WR2;
    SCC     WR0-1;
%%IF(DRN2PATCH(1))
    %%(sib)WSII    WR1-WR0,WR3,DR6,DR23%%(sie)
%%ELSE
    %%(sib)WSII    WR1-WR0,IR,DR6,DR23%%(sie)
%%ENDIF
    RS      WR2-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W6-WR2;
    SCC     WR0-1;
%%IF(DRN2PATCH(1))
    %%(sib)WSII    WR1-WR0,WR3,DR6,DR23%%(sie)
%%ELSE
    %%(sib)WSII    WR1-WR0,IR,DR6,DR23%%(sie)
%%ENDIF
    RS      WR2-SQLX_TempData;
    WSS     SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data/W7-WR2;
%%ENDIF
%%ELSE
%%IF(colLen%%(p3)[k] <= 15)
        SCC     WR0-%%(colLen%%(p3)[k]);
%%ELSE
        SWCD    WR0-%%(colLen%%(p3)[k]);
%%ENDIF
        LBNBA   WR1-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data;
%%IF(DRN2PATCH(1))
%%IF(colLen%%(p3)[k] <= 15)
        LCC     WR3-%%(colLen%%(p3)[k]);
%%ELSE
        LHC     WR3/W0-%%(colLen%%(p3)[k]);
%%ENDIF
        %%(sib)WSII    WR1-WR0,WR3,DR6,DR23%%(sie)
%%ELSE
        %%(sib)WSII    WR1-WR0,IR,DR6,DR23%%(sie)
%%ENDIF
%%ENDIF
%%IF(colNull%%(p3)[k]=1)
        SCC     WR0-1;
        LBNBA   WR1-SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Null;
%%IF(DRN2PATCH(1))
        LCC     WR3-1;
        %%(sib)WSII    WR1-WR0,WR3,DR6,DR23%%(sie)
%%ELSE
        %%(sib)WSII    WR1-WR0,IR,DR6,DR23%%(sie)
%%ENDIF
%%ENDIF
%%ENDLOOP(k)
%%END(sUnPackKeyBTree)
------------------------------------------------------------------------------


------------------------------------------------------------------------------
- Code component sUnPackKeyRow, chapter 5.4.2.2

- Parameters:
-       p1:             Table index.

- Included code components:
-       None
-----------------------------------------------------------------------------
%%BEGIN(sUnPackKeyRow)
!------------------------------------------------!
!       sUnPackKeyRow !
!------------------------------------------------!
%%SET p1(%%(sUnPackKeyRow[1]))
        MFR     SQLM_%%(tables[p1])_OperRow-SQLX_DR23;
%%END(sUnPackKeyRow)
------------------------------------------------------------------------------


-----------------------------------------------------------------------------
- Code component sUnPackKeyCursor, chapter 5.4.2.3

- Parameters:
-       p1:             Table index.

- Included code components:
-       None
----------------------------------------------------------------------------
%%BEGIN(sUnPackKeyCursor)
!------------------------------------------------!
!       sUnPackKeyCursor !
!------------------------------------------------!
%%SET p1(%%(sUnPackKeyCursor[1]))
        MFR     SQLM_%%(tables[p1])_WorkRow-SQLX_DR23;
        MFR     SQLX_KeyNumber-SQLX_DR22;
        MFR     SQLX_KeyPrefix-SQLX_DR21;
        MFR     SQLX_KeyOperation-SQLX_DR20;
%%END(sUnPackKeyCursor)
------------------------------------------------------------------------------





-----------------------------------------------------------------------------
- Code component sKeyTestN, chapter 5.5

- Test the key in two rows as pointed out by pOperRow and pWorkRow

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.
-       bTreeColsI_J    Column numbers for all columns in table I btree J.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.
-       bitsColsI       The column number for all bits columns in table I. Set
-                       to empty list if there are no symbol columns.
-       symColsI

- IMP variables defined:
-       None

- Temporary IMP variables:
-       p3
-       i
-       j
-       k
-       postAmble

- Included code components:
-       None
----------------------------------------------------------------------------
%%BEGIN(sKeyTestN)
!------------------------------------------------!
!       sKeyTestN !
!------------------------------------------------!
%%LOOP(i <= tables[0])
%%SET p3(%%(tabNos[i]))
%%LOOP(j, bTrees%%(p3))

PROGRAM SQLS_%%(tables[i])_KeyTest%%(j); ASA210C;
%%SET sCount(%%(sCount + 1))
! Initialize xKeySuffix to xKeyPreffix !
        MFR     SQLX_KeySuffix-SQLX_KeyPrefix;
%%SET postAmble(0)
%%LOOP(k, bTreeCols%%(p3)_%%(j))
! If there are no more components to test abort the test (EQUAL) !
        JEC     SQLX_KeySuffix,0,EQUAL_%%(sCount);
! Test next component !
        SCC     SQLX_KeySuffix-1;
%%IF(colNull%%(p3)[k]=1)
%%SET postAmble(1)
! If the component have a null indicator check the values. A column
  which is null (1) is always lower than a row which is not null (0). !
        MFR     PR0-SQLM_%%(tables[i])_OperRow;
        RS      WR1-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Null;
        MFR     PR0-SQLM_%%(tables[i])_WorkRow;
        RS      CR-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Null;
        JLT     WR1,GREATER_%%(sCount);
        JGT     WR1,LESS_%%(sCount);
        JEC     WR1,1,L%%(k)_%%(sCount);
%%ENDIF
%%IF(bitsCols%%(p3)(%%(k)) OR symCols%%(p3)(%%(k)))
%%SET postAmble(1)
! Check which field variabel value is less. !
        MFR     PR0-SQLM_%%(tables[i])_OperRow;
        RS      WR1-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data;
        MFR     PR0-SQLM_%%(tables[i])_WorkRow;
        RS      CR-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data;
        JLT     WR1,LESS_%%(sCount);
        JGT     WR1,GREATER_%%(sCount);
%%ELSIF(packNumCols%%(p3)(%%(k)))
%%SET postAmble(1)
    MFR     PR0-SQLM_%%(tables[i])_OperRow;
    RSS     WR1-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W0;
    MFR     PR0-SQLM_%%(tables[i])_WorkRow;
    RSS     CR-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W0;
    JLT     WR1,LESS_%%(sCount);
    JGT     WR1,GREATER_%%(sCount);
    MFR     PR0-SQLM_%%(tables[i])_OperRow;
    RSS     WR1-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W1;
    MFR     PR0-SQLM_%%(tables[i])_WorkRow;
    RSS     CR-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W1;
    JLT     WR1,LESS_%%(sCount);
    JGT     WR1,GREATER_%%(sCount);
    MFR     PR0-SQLM_%%(tables[i])_OperRow;
    RSS     WR1-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W2;
    MFR     PR0-SQLM_%%(tables[i])_WorkRow;
    RSS     CR-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W2;
    JLT     WR1,LESS_%%(sCount);
    JGT     WR1,GREATER_%%(sCount);
    MFR     PR0-SQLM_%%(tables[i])_OperRow;
    RSS     WR1-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W3;
    MFR     PR0-SQLM_%%(tables[i])_WorkRow;
    RSS     CR-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W3;
    JLT     WR1,LESS_%%(sCount);
    JGT     WR1,GREATER_%%(sCount);
%%IF(colSizes%%(p3)[k] = 28)
    MFR     PR0-SQLM_%%(tables[i])_OperRow;
    RSS     WR1-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W4;
    MFR     PR0-SQLM_%%(tables[i])_WorkRow;
    RSS     CR-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W4;
    JLT     WR1,LESS_%%(sCount);
    JGT     WR1,GREATER_%%(sCount);
    MFR     PR0-SQLM_%%(tables[i])_OperRow;
    RSS     WR1-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W5;
    MFR     PR0-SQLM_%%(tables[i])_WorkRow;
    RSS     CR-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W5;
    JLT     WR1,LESS_%%(sCount);
    JGT     WR1,GREATER_%%(sCount);
    MFR     PR0-SQLM_%%(tables[i])_OperRow;
    RSS     WR1-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W6;
    MFR     PR0-SQLM_%%(tables[i])_WorkRow;
    RSS     CR-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W6;
    JLT     WR1,LESS_%%(sCount);
    JGT     WR1,GREATER_%%(sCount);
    MFR     PR0-SQLM_%%(tables[i])_OperRow;
    RSS     WR1-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W7;
    MFR     PR0-SQLM_%%(tables[i])_WorkRow;
    RSS     CR-SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data/W7;
    JLT     WR1,LESS_%%(sCount);
    JGT     WR1,GREATER_%%(sCount);
%%ENDIF
%%ELSE
! Check which string variable is less using the new assembler
  instruction CS. !
        MFR     WR1-SQLM_%%(tables[i])_OperRow;
        MFR     WR2-SQLM_%%(tables[i])_WorkRow;
        %%(sib)CS      SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data,WR1,
                SQLC_%%(tables[i])_%%(cols%%(p3)[k])_Data,WR2%%(sie)
        MFR     SQLX_KeyTest-CR;
        JUC     CR,1,EXIT_%%(sCount);
%%ENDIF
%%IF(colNull%%(p3)[k]=1)
L%%(k)_%%(sCount))
%%ENDIF
%%ENDLOOP(k)

EQUAL_%%(sCount))
! The two keys are identical upto the key prefix !
        LCC     SQLX_KeyTest-1;
%%IF(postAmble(1))
        JLN     EXIT_%%(sCount);

LESS_%%(sCount))
! The key in pOperRow is less than the key in pWorkRow !
        LCC     SQLX_KeyTest-0;
        JLN     EXIT_%%(sCount);

GREATER_%%(sCount))
! The key in pOperRow is greater than the key in pWorkRow !
        LCC     SQLX_KeyTest-2;
%%ENDIF
EXIT_%%(sCount))
END PROGRAM;
%%ENDLOOP(j)
%%ENDLOOP(i)
%%END(sKeyTestN)
---------------------------------------------------------------------------





----------------------------------------------------------------------------
-  6 COMMON MACROS
----------------------------------------------------------------------------

----------------------------------------------------------------------------
- Code component putIntoFreeList, Chapter 6.1

- Parameters:
-       q1:             Table index

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       None

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(putIntoFreeList)
!------------------------------------------------!
!       putIntoFreeList !
!------------------------------------------------!
%%SET q1(%%(putIntoFreeList[1]))
! Put pOperRow first into free list.!
SQLM_%%(tables[q1])_OperRow:%%(SQLC_%%(tables[q1])_Next) =
    SQLM_%%(tables[q1])_GuardRow:%%(SQLC_%%(tables[q1])_Prev);
SQLM_%%(tables[q1])_GuardRow:%%(SQLC_%%(tables[q1])_Prev) =
    SQLM_%%(tables[q1])_OperRow;
%%END(putIntoFreeList)
---------------------------------------------------------------------------








---------------------------------------------------------------------------
- Code component getFromFreeList, Chapter 6.2

- Parameters:
-       q1:             Table index

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       None

- Included code components:
---------------------------------------------------------------------------
%%BEGIN(getFromFreeList)
!------------------------------------------------!
!       getFromFreeList !
!------------------------------------------------!
%%SET q1(%%(getFromFreeList[1]))
! Get first row from free list !
SQLM_%%(tables[q1])_WorkRow =
    SQLM_%%(tables[q1])_GuardRow:%%(SQLC_%%(tables[q1])_Prev);
IF SQLM_%%(tables[q1])_WorkRow /= SQLM_%%(tables[q1])_NilRow THEN
    SQLM_%%(tables[q1])_GuardRow:%%(SQLC_%%(tables[q1])_Prev) =
        SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_Next);
FI;
%%END(getFromFreeList)
--------------------------------------------------------------------------






---------------------------------------------------------------------------
- Code component insertIntoInsertList, Chapter 6.3

- Parameters:
-       q1:             Table index

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       None

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(insertIntoInsertList)
!------------------------------------------------!
!       insertIntoInsertList !
!------------------------------------------------!
%%SET q1(%%(insertIntoInsertList[1]))
! insert row in insertlist.!
SQLM_%%(tables[q1])_TempRow =
    SQLM_%%(tables[q1])_GuardRow:%%(SQLC_%%(tables[q1])_Next);
IF SQLM_%%(tables[q1])_TempRow /= SQLM_%%(tables[q1])_NilRow THEN
    SQLM_%%(tables[q1])_TempRow:%%(SQLC_%%(tables[q1])_Prev) =
        SQLM_%%(tables[q1])_WorkRow;
FI;
SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_Next) =
    SQLM_%%(tables[q1])_TempRow;
SQLM_%%(tables[q1])_GuardRow:%%(SQLC_%%(tables[q1])_Next) =
    SQLM_%%(tables[q1])_WorkRow;
SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_Prev) =
    SQLM_%%(tables[q1])_GuardRow;
%%END(insertIntoInsertList)
--------------------------------------------------------------------------






---------------------------------------------------------------------------
- Code component deleteFromInsertList, Chapter 6.4

- Parameters:
-       q1:             Table index

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       None

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(deleteFromInsertList)
!------------------------------------------------!
!       deleteFromInsertList !
!------------------------------------------------!
%%SET q1(%%(deleteFromInsertList[1]))
! Remove row from insert list !
SQLM_%%(tables[q1])_TempRow =
    SQLM_%%(tables[q1])_OperRow:%%(SQLC_%%(tables[q1])_Prev);
SQLM_%%(tables[q1])_TempRow:%%(SQLC_%%(tables[q1])_Next) =
    SQLM_%%(tables[q1])_OperRow:%%(SQLC_%%(tables[q1])_Next);
SQLM_%%(tables[q1])_TempRow =
    SQLM_%%(tables[q1])_OperRow:%%(SQLC_%%(tables[q1])_Next);

IF SQLM_%%(tables[q1])_TempRow /= SQLM_%%(tables[q1])_NilRow THEN
    SQLM_%%(tables[q1])_TempRow:%%(SQLC_%%(tables[q1])_Prev) =
        SQLM_%%(tables[q1])_OperRow:%%(SQLC_%%(tables[q1])_Prev);
FI;
%%END(deleteFromInsertList)
---------------------------------------------------------------------------



---------------------------------------------------------------------------
- Code component allocateWorkRow, Chapter 6.5

- Parameters:
-       r1:             Table name
-       r2:             WORKLOCK label
-       r3:             WORKFULL label

- IMP variables used:
-       None

- IMP variables defined:
-       None

- Temporary IMP variables:
-       None

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(allocateWorkRow)
!------------------------------------------------!
!       allocateWorkRow !
!------------------------------------------------!
%%SET r1(%%(allocateWorkRow[1]))
%%SET r2(%%(allocateWorkRow[2]))
%%SET r3(%%(allocateWorkRow[3]))
!
$ Check if work area is locked, if so jump to WORKLOCK.
!
    IF SQLM_TableReference:SQLM_WorkLock = 1
        GOTO %%(r2);
!
$ Check if work area is full, if so jump to WORKFULL
!
    IF SQLM_TableReference:SQLM_WorkAllocated =
        SQLM_TableReference:SQLM_WorkUsed
        GOTO %%(r3);
    FOR FIRST SQLM_%%(r1)_WorkRow
        FROM SQLM_TableReference:SQLM_WorkLast-1
        UNTIL SQLM_TableReference:SQLM_TableAllocated
        WHERE SQLM_%%(r1)_WorkRow:SQLC_%%(r1)_Allocated = 0
%%SET allocateWorkRowLab(%%(allocateWorkRowLab + 1))
        GOTO WORKALLOCATEallocateWorkRow%%(allocateWorkRowLab);
    FOR FIRST SQLM_%%(r1)_WorkRow
        FROM SQLM_TableReference:SQLM_System-1
        UNTIL SQLM_TableReference:SQLM_WorkLast
        WHERE SQLM_%%(r1)_WorkRow:SQLC_%%(r1)_Allocated = 0
        GOTO WORKALLOCATEallocateWorkRow%%(allocateWorkRowLab);
!
$ We should never get here
!
    GOTO %%(r3);
WORKALLOCATEallocateWorkRow%%(allocateWorkRowLab))
    IF SQLM_%%(r1)_WorkRow = SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_TableReference:SQLM_WorkLast=SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_TableReference:SQLM_WorkLast=SQLM_%%(r1)_WorkRow;
    FI;
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed+1;
    SQLM_%%(r1)_WorkRow:SQLC_%%(r1)_Allocated=1;
%%END(allocateWorkRow)
---------------------------------------------------------------------------



---------------------------------------------------------------------------
- Code component deAllocateWorkRow, Chapter 6.6

- Parameters:
-       r1:             Table name

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       None

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(deAllocateWorkRow)
!------------------------------------------------!
!       deAllocateWorkRow !
!------------------------------------------------!
%%SET r1(%%(deAllocateWorkRow[1]))
! Deallocate a work row !
    SQLM_%%(r1)_WorkRow:SQLC_%%(r1)_Allocated=0;
! Update SQLM_WorkUsed !
    SQLM_TableReference:SQLM_WorkUsed=SQLM_TableReference:SQLM_WorkUsed-1;
%%END(deAllocateWorkRow)
---------------------------------------------------------------------------






-----------------------------------------------------------------------------
- 7. HANDLE: TOWGETROW
----------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towGetRow, chapter 7.1

- Receive the towGetRow signal and then execute the code which is specific
- for each table.

-IMP variables used::
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       dr
-       i

- Included code components:
-       towGetRowTable
----------------------------------------------------------------------------
%%BEGIN(towGetRow)
!------------------------------------------------!
!       towGetRow !
!------------------------------------------------!
%%SET recSigs(,TOWGETROW)
    ENTER towGetRow WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +
%%LOOP(dr <= 19)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ;
%%IF(tables[0] > 1)
    CASE SQLM_TableReference IS
%%LOOP(i, tabNos)
    WHEN %%(i) DO GOTO towGetRow%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ENDIF
%%LOOP(i <=  tables[0])
%%INCLUDE(towGetRowTable(%%(i)))
%%ENDLOOP(i)
%%END(towGetRow)
----------------------------------------------------------------------------






----------------------------------------------------------------------------
- Code component towGetRowTable, chapter 7.2

- Parameters:
-       p1:             Table index.

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.
-       aksI            Key numbers for all AK in table I, may be empty.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       p3
-       l

- Included code components:
-       towGetRowTableKeyRow
-       towGetRowTableKeyBTree
-       towGetRowTableCursorRow
-       towGetRowTableCursorBTree
----------------------------------------------------------------------------
%%BEGIN(towGetRowTable)
!------------------------------------------------!
!       towGetRowTable !
!------------------------------------------------!
%%SET p1(%%(towGetRowTable[1]))
%%SET p3(%%(tabNos[p1]))
%%IF(tables[0] > 1)
towGetRow%%(p3))
%%ENDIF
    CASE SQLX_KeyNumber IS
    WHEN 0 DO GOTO towGetRow%%(p3)_0;

    WHEN 1 DO
! retrieve cursor data pWorkRow, xKeyNumber, xKeyPrefix, xKeyOperation) !
        DO SQLS_%%(tables[p1])_UnpackKey;
        CASE SQLX_KeyNumber IS
        WHEN 0 DO GOTO towGetRowCursor%%(p3)_0;
%%LOOP(l, bTrees%%(p3))
        WHEN %%(l) DO GOTO towGetRowCursor%%(p3)_%%(l);
%%ENDLOOP(l)
        OTHERWISE DO ! nothing ! ;
        ESAC;

%%IF(NOT bTrees%%(p3)(2))
    WHEN 2 DO GOTO towGetRow%%(p3)_0;
%%ELSE
    WHEN 2 DO GOTO towGetRow%%(p3)_2;
%%ENDIF
%%LOOP(l, aks%%(p3))
    WHEN %%(l) DO GOTO towGetRow%%(p3)_%%(l);
%%ENDLOOP(l)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;

%%INCLUDE(towGetRowTableKeyRow(%%(p1)))
%%IF(bTrees%%(p3)(2))
%%INCLUDE(towGetRowTableKeyBTree(%%(p1), 2))
%%ENDIF
%%LOOP(l, aks%%(p3))
%%INCLUDE(towGetRowTableKeyBTree(%%(p1), %%(l)))
%%ENDLOOP(l)

%%INCLUDE(towGetRowTableCursorRow(%%(p1)))
%%LOOP(l, bTrees%%(p3))
%%INCLUDE(towGetRowTableCursorBTree(%%(p1),%%(l)))
%%ENDLOOP(l)
%%END(towGetRowTable)
--------------------------------------------------------------------------











----------------------------------------------------------------------------
- Code component towGetRowTableKeyBTree, chapter 7.3.1

- Parameters:
-       q1:             Table index
-       q2:             Key number.

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreeColsI_J    Column numbers for all columns in table I btree J.

- IMP variables defined:
-       towGetSchLab

- Temporary IMP variables:
-       q3
-       dr

- Included code components:
-       None
----------------------------------------------------------------------------
%%BEGIN(towGetRowTableKeyBTree)
!------------------------------------------------!
!       towGetRowTableKeyBTree !
!------------------------------------------------!
%%SET q1(%%(towGetRowTableKeyBTree[1]))
%%SET q2(%%(towGetRowTableKeyBTree[2]))
%%SET q3(%%(tabNos[q1]))
towGetRow%%(q3)_%%(q2))
! Allocate a workrow.!
%%INCLUDE(allocateWorkRow(%%(tables[q1]),WORKLOCKtowGetRowTableKeyBTree%%(q3)_%%(q2),WORKFULLtowGetRowTableKeyBTree%%(q3)_%%(q2)))
!store packed key in work row!
    DO SQLS_%%(tables[q1])_UnPackKey;
!find an operating row.!
    SQLM_%%(tables[q1])_RootRow = SQLM_TableReference:SQLM_System + 2;
%%SET sentSigs(,TOWGETSCH)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_%%(tables[q1])_RootRow:SQLC_%%(tables[q1])_Right%%(q2),
        SQLM_%%(tables[q1])_WorkRow
%%LOOP(dr <= 15)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ,
        3,
        %%(bTreeCols%%(q3)_%%(q2)[0]),
        +,
%%SET towGetSchLab(%%(towGetSchLab + 1))
        %%(towGetSchLab);
    EXIT;
towGetSchLab%%(towGetSchLab))
    SQLM_%%(tables[q1])_WorkRow=SQLX_WorkRow;
    SQLM_%%(tables[q1])_OperRow=SQLX_Operrow;
! deallocate work row.!
%%INCLUDE(deAllocateWorkRow(%%(tables[q1])))
! check if row is found, if not report failure!
    IF SQLM_%%(tables[q1])_OperRow = SQLM_TableReference:SQLM_System+1 THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found (SELECT, UPDATE, DELETE, FETCH) !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in return signal.!
    DO SQLS_%%(tables[q1])_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Lock > 1 THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_%%(tables[q1])_OperRow,
            SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2
%%LOOP(dr <= 21)
            ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
        ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
%%SET sentSigs(,TOWGETR)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_%%(tables[q1])_OperRow,
        SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2
%%LOOP(dr <= 21)
        ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
        ;
    EXIT;

! Work area is locked !
WORKLOCKtowGetRowTableKeyBTree%%(q3)_%%(q2))
%%SET sentSigs(,TOWGETR)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowGetRowTableKeyBTree%%(q3)_%%(q2))
%%SET sentSigs(,TOWGETR)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
%%END(towGetRowTableKeyBTree)
----------------------------------------------------------------------------








---------------------------------------------------------------------------
- Code component towGetRowTableKeyRow, chapter 7.3.2

- Parameters:
-       q1:             Table index.

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       q3
-       dr

- Included code components:
-       None
--------------------------------------------------------------------------
%%BEGIN(towGetRowTableKeyRow)
!------------------------------------------------!
!       towGetRowTableKeyRow !
!------------------------------------------------!
%%SET q1(%%(towGetRowTableKeyRow[1]))
%%SET q3(%%(tabNos[q1]))
towGetRow%%(q3)_0)
! get row number.!
    DO SQLS_%%(tables[q1])_UnPackKey;
! check if row is not found, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Allocated = 0 THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_%%(tables[q1])_Pack;
! check if row is read locked, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Lock > 1 THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_%%(tables[q1])_OperRow,
            SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2
%%LOOP(dr <= 21)
            ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
%%SET sentSigs(,TOWGETR)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_%%(tables[q1])_OperRow,
        SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2
%%LOOP(dr <= 21)
        ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
        ;
    EXIT;
%%END(towGetRowTableKeyRow)
----------------------------------------------------------------------------








---------------------------------------------------------------------------
- Code component towGetRowTableCursorBTree, chapter 7.4.1

- Parameters:
-       q1:             Table index
-       q2:             Key number.

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).
-       bTreeColsI_J    Column numbers for all columns in table I btree J.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.

- IMP variables defined:
-       towGetSchLab

- Temporary IMP variables:
-       q3
-       dr
-       l2

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(towGetRowTableCursorBTree)
!------------------------------------------------!
!       towGetRowTableCursorBTree !
!------------------------------------------------!
%%SET q1(%%(towGetRowTableCursorBTree[1]))
%%SET q2(%%(towGetRowTableCursorBTree[2]))
%%SET q3(%%(tabNos[q1]))
towGetRowCursor%%(q3)_%%(q2))
! find an operating row.!
    IF SQLX_KeyPrefix=0 THEN
        SQLX_KeyPrefix = %%(bTreeCols%%(q3)_%%(q2)[0]);
    FI;
    SQLM_%%(tables[q1])_RootRow = SQLM_TableReference:SQLM_System+2;
%%SET sentSigs(,TOWGETSCH)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_%%(tables[q1])_RootRow:SQLC_%%(tables[q1])_Right%%(q2),
        SQLM_%%(tables[q1])_WorkRow
%%LOOP(dr <= 15)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLM_TableReference:SQLM_System+1,
%%SET towGetSchLab(%%(towGetSchLab + 1))
        %%(towGetSchLab);
    EXIT;
towGetSchLab%%(towGetSchLab))
    SQLM_%%(tables[q1])_WorkRow = SQLX_WorkRow;
    SQLM_%%(tables[q1])_OperRow = SQLX_Operrow;
! check if row is not found, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Lock = 2;
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor !
    CASE SQLX_KeyPrefix IS
%%LOOP(l2 <= bTreeCols%%(q3)_%%(q2)[0])
%%SET colNo(%%(bTreeCols%%(q3)_%%(q2)[l2]))
    WHEN %%(l2) DO
%%IF(colNull%%(q3)[colNo] = 1)
        SQLM_%%(tables[q1])_WorkRow:
            SQLC_%%(tables[q1])_%%(cols%%(q3)[colNo])_Null=
                SQLM_%%(tables[q1])_OperRow:
                    SQLC_%%(tables[q1])_%%(cols%%(q3)[colNo])_Null;
%%ENDIF
%%IF(colTypes%%(q3)[colNo] # "PACKED NUMSTRING")
        SQLM_%%(tables[q1])_WorkRow:
            SQLC_%%(tables[q1])_%%(cols%%(q3)[colNo])_Data=
                SQLM_%%(tables[q1])_OperRow:
                    SQLC_%%(tables[q1])_%%(cols%%(q3)[colNo])_Data;
%%ELSE
%%INCLUDE(copyPackNum("SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_%%(cols%%(q3)[colNo])_Data", "SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_%%(cols%%(q3)[colNo])_Data", %%(colSizes%%(q3)[colNo])))
%%ENDIF
%%ENDLOOP(l2)
    OTHERWISE DO;
    ESAC;
    SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_LastRow) =
        SQLM_%%(tables[q1])_OperRow;
    SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_DBnumber2 =
        SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2;
! pack data in signal.!
    DO SQLS_%%(tables[q1])_Pack;
! check if row is not read locked, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Lock > 1 THEN
        SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Lock=2;
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_%%(tables[q1])_OperRow,
            SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2
%%LOOP(dr <= 21)
            ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Lock = 0;
%%SET sentSigs(,TOWGETR)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_%%(tables[q1])_OperRow,
        SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2
%%LOOP(dr <= 21)
        ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
        ;
    EXIT;
%%END(towGetRowTableCursorBTree)
----------------------------------------------------------------------------









----------------------------------------------------------------------------
- Code component towGetRowTableCursorRow, chapter 7.4.2

- Parameters:
-       q1:             Table index

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       towGetSchLab

- Temporary IMP variables:
-       q3
-       dr

- Included code components:
-       None
----------------------------------------------------------------------------
%%BEGIN(towGetRowTableCursorRow)
!------------------------------------------------!
!       towGetRowTableCursorRow !
!------------------------------------------------!
%%SET q1(%%(towGetRowTableCursorRow[1]))
%%SET q3(%%(tabNos[q1]))
towGetRowCursor%%(q3)_0)
! find an operating row.!
    IF SQLX_KeyOperation = 0 THEN
        SQLX_OperRow = SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_LastRow);
        SQLX_WorkRow = SQLM_%%(tables[q1])_WorkRow;
    ELSIF SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_LastRow) = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
        SQLX_WorkRow = SQLM_%%(tables[q1])_WorkRow;
    ELSE
%%SET sentSigs(,TOWGETSCH)
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_Tablereference,
            SQLX_KeyNumber,
            SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_LastRow),
            SQLM_%%(tables[q1])_WorkRow
%%LOOP(dr <= 15)
            ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
            ,
            SQLX_KeyOperation,
            +,
            +,
%%SET towGetSchLab(%%(towGetSchLab + 1))
            %%(towGetSchLab);
        EXIT;
    FI;
towGetSchLab%%(towGetSchLab))
    SQLM_%%(tables[q1])_WorkRow = SQLX_WorkRow;
    SQLM_%%(tables[q1])_OperRow = SQLX_OperRow;
! check if row is not found, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
        SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Lock = 2;
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Allocated = 0 THEN
        SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Lock = 2;
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! update cursor.!
    IF SQLX_KeyOperation = 0 THEN
        SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_LastRow) =
            SQLM_TableReference:SQLM_System;
    ELSE
        SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_LastRow) =
            SQLM_%%(tables[q1])_OperRow;
    FI;
    SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_DBnumber2 =
        SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2;
! pack data in signal.!
    DO SQLS_%%(tables[q1])_Pack;
! check if row is  read locked, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Lock > 1 THEN
        SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Lock = 2;
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLM_%%(tables[q1])_OperRow,
            SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2
%%LOOP(dr <= 21)
            ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
            ;
        EXIT;
    FI;
! send back row number, dbnumber and requested data.!
    SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Lock = 0;
%%SET sentSigs(,TOWGETR)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_%%(tables[q1])_OperRow,
        SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2
%%LOOP(dr <= 21)
        ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
        ;
    EXIT;
%%END(towGetRowTableCursorRow)
----------------------------------------------------------------------------




------------------------------------------------------------------------------
- 8. HANDLE TOWGETSCH
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
- Code component towGetSch, chapter 8.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       maxTabNo        The table number of the "last" table in 'table'.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       dr

- Included code components:
-       towGetSchTable
----------------------------------------------------------------------------
%%BEGIN(towGetSch)
!------------------------------------------------!
!       towGetSch !
!------------------------------------------------!
%%SET recSigs(,TOWGETSCH)
    ENTER towGetSch WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLX_OperRow,
        SQLX_WorkRow
%%LOOP(dr <= 15)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLX_ReturnLabel;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])

    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetSchTable(%%(i)))
%%ENDLOOP(i)
%%LOOP(i <= towGetSchLab - maxTabNo)

    WHEN %%(i + maxTabNo) DO
        SQLM_TableReference=SQLX_ReturnLabel;
        GOTO towGetSchLab%%(i + maxTabNo);
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
    EXIT;
%%END(towGetSch)
---------------------------------------------------------------------------









---------------------------------------------------------------------------
- Code component towGetSchTable, chapter 8.2

- Parameters:
-       p1:             Table index.

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.-
-       aksI            Key numbers for all AK in table I, may be empty.

- IMP variables defined:
-       none

- Temporary IMP variables:
-       l
-       p3

- Included code components:
-       towGetSchTableKeyBTree
-       towGetSchTableCursorRow
-       towGetSchTableCursorBTree
-------------------------------------------------------------------------
%%BEGIN(towGetSchTable)
!------------------------------------------------!
!       towGetSchTable !
!------------------------------------------------!
%%SET p1(%%(towGetSchTable[1]))
%%SET p3(%%(tabNos[p1]))
    SQLM_%%(tables[p1])_OperRow = SQLX_OperRow;
    SQLM_%%(tables[p1])_WorkRow = SQLX_WorkRow;
    SQLM_%%(tables[p1])_NilRow = SQLM_Tablereference:SQLM_System+1;
%%IF (bTrees%%(p3)(2) OR aks%%(p3)[0] > 0)
    IF SQLX_KeyOperation = 3 THEN
        CASE SQLX_KeyNumber IS
%%IF (bTrees%%(p3)(2))
        WHEN 2 DO
%%INCLUDE(towGetSchTableKeyBTree(%%(p1), 2))
%%ENDIF
%%LOOP(l, aks%%(p3))
        WHEN %%(l) DO
%%INCLUDE(towGetSchTableKeyBTree(%%(p1),%%(l)))
%%ENDLOOP(l)
        OTHERWISE DO;
        ESAC;
    ELSE
%%ENDIF
        CASE SQLX_KeyNumber IS
        WHEN 0 DO
%%INCLUDE(towGetSchTableCursorRow(%%(p1)))
%%LOOP(l, bTrees%%(p3))
        WHEN %%(l) DO
%%INCLUDE(towGetSchTableCursorBTree(%%(p1),%%(l)))
%%ENDLOOP(l)
        OTHERWISE DO;
        ESAC;
%%IF (bTrees%%(p3)(2) OR aks%%(p3)[0] > 0)
    FI;
%%ENDIF
%%END(towGetSchTable)
---------------------------------------------------------------------------









------------------------------------------------------------------------
- Code component towGetSchTableKeyBTree, chapter 8.3.1

- Parameters:
-       q1:             Table index
-       q2:             Key number

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       limit
-       q3

- Included code components:
-       None
--------------------------------------------------------------------------
%%BEGIN(towGetSchTableKeyBTree)
!------------------------------------------------!
!       towGetSchTableKeyBTree !
!------------------------------------------------!
%%SET q1(%%(towGetSchTableKeyBTree[1]))
%%SET q2(%%(towGetSchTableKeyBTree[2]))
%%SET q3(%%(tabNos[q1]))
%%SET limit(%%(schLimit / (schConst%%(q3)_%%(q2) + schGetKey)))
    SQLX_Schedule = 0;
LOOPtowGetSchTableKeyBTree%%(q3)_%%(q2))
! Check if scheduling is necessary !
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > %%(limit) THEN
%%SET sentSigs(,TOWGETSCH)
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_%%(tables[q1])_OperRow,
            SQLM_%%(tables[q1])_WorkRow
%%LOOP(dr <= 15)
            ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search. !
    IF SQLM_%%(tables[q1])_OperRow /= SQLM_%%(tables[q1])_NilRow THEN
        DO SQLS_%%(tables[q1])_KeyTest%%(q2);
        IF SQLX_KeyTest < 1 THEN
            SQLM_%%(tables[q1])_OperRow =
                SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Right%%(q2);
            GOTO LOOPtowGetSchTableKeyBTree%%(q3)_%%(q2);

        ELSIF SQLX_KeyTest > 1 THEN
            SQLM_%%(tables[q1])_OperRow =
                SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Left%%(q2);
            GOTO LOOPtowGetSchTableKeyBTree%%(q3)_%%(q2);
        FI;
    FI;
! Return the row found !
%%SET sentSigs(,TOWGETSCH)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_%%(tables[q1])_OperRow,
        SQLM_%%(tables[q1])_WorkRow
%%LOOP(dr <= 15)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
%%END(towGetSchTableKeyBTree)
-----------------------------------------------------------------------------







----------------------------------------------------------------------------
- Code component towGetSchTableCursorBTree, chapter 8.4.1

- Parameters:
-       q1:             Table index
-       q2:             key number.

-IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Tempoary IMP variables:
-       q3
-       limit
-       dr

- Included code components:
-       None
----------------------------------------------------------------------------
%%BEGIN(towGetSchTableCursorBTree)
!------------------------------------------------!
!       towGetSchTableCursorBTree !
!------------------------------------------------!
%%SET q1(%%(towGetSchTableCursorBTree[1]))
%%SET q2(%%(towGetSchTableCursorBTree[2]))
%%SET q3(%%(tabNos[q1]))
%%SET limit(%%(schLimit / (schConst%%(q3)_%%(q2) + schGetCur)))
    SQLX_Schedule=0;
LOOPtowGetSchTableCursorBTree%%(q3)_%%(q2))
    SQLX_Schedule=SQLX_Schedule+1;
    IF SQLX_Schedule > %%(limit) THEN
%%SET sentSigs(,TOWGETSCH)
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_%%(tables[q1])_OperRow,
            SQLM_%%(tables[q1])_WorkRow
%%LOOP(dr <= 15)
            ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! Determine which row is nearest to the row asked for and then redo.
  If pOperRow is pNilRow abort the search.  If a right turn is
  performed and the key operation is not 0 (THIS) and all components
  in the key prefix were tested, or row numbers are compared, then
  remember that node. !
    IF SQLM_%%(tables[q1])_OperRow /= SQLM_%%(tables[q1])_NilRow THEN
        DO SQLS_%%(tables[q1])_KeyTest%%(q2);
        IF SQLX_KeyTest < 1 THEN
            IF SQLX_KeyOperation /= 0 THEN
                IF SQLX_KeySuffix = 0 THEN
                        SQLX_RightTurn = SQLM_%%(tables[q1])_OperRow;
                FI;
            FI;
            SQLM_%%(tables[q1])_OperRow =
                SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Right%%(q2);
        ELSIF SQLX_KeyTest = 1 THEN
            IF SQLM_%%(tables[q1])_OperRow <
                SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_LastRow)
            THEN
                SQLX_RightTurn = SQLM_%%(tables[q1])_OperRow;
                SQLM_%%(tables[q1])_OperRow =
                  SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Right%%(q2);
            ELSE
                SQLM_%%(tables[q1])_OperRow =
                  SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Left%%(q2);
            FI;
        ELSE
            SQLM_%%(tables[q1])_OperRow =
              SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Left%%(q2);
        FI;
        GOTO LOOPtowGetSchTableCursorBTree%%(q3)_%%(q2);
    FI;
! Return the the last node which was remembered (see prevoius
  comment). !
%%SET sentSigs(,TOWGETSCH)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLX_RightTurn,
        SQLM_%%(tables[q1])_WorkRow
%%LOOP(dr <= 15)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
%%END(towGetSchTableCursorBTree)
---------------------------------------------------------------------------






----------------------------------------------------------------------------
- Code component towGetSchTableCursorRow, chapter 8.4.2

- Parameters
-       q1:             Table index

-IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       q3
-       dr

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(towGetSchTableCursorRow)
!------------------------------------------------!
!       towGetSchTableCursorRow !
!------------------------------------------------!
%%SET q1(%%(towGetSchTableCursorRow[1]))
%%SET q3(%%(tabNos[q1]))
! if root row is outside last allocated row, select last allocated row !
    IF SQLM_%%(tables[q1])_OperRow > SQLM_TableReference:SQLM_TableLast THEN
        SQLM_%%(tables[q1])_OperRow = SQLM_TableReference:SQLM_TableLast;
    FI;
    IF SQLM_%%(tables[q1])_OperRow = 0 GOTO FAILEDtowGetSchTableCursorRow%%(q3);
! find first allocated row, then schedule if necessary !
    IF SQLM_%%(tables[q1])_OperRow < %%(scanMax) THEN
        FOR FIRST SQLM_%%(tables[q1])_OperRow
            FROM SQLM_%%(tables[q1])_OperRow-1
            WHERE SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Allocated = 1
            GOTO FOUNDtowGetSchTableCursorRow%%(q3);
        GOTO FAILEDtowGetSchTableCursorRow%%(q3);
    ELSE
        FOR FIRST SQLM_%%(tables[q1])_OperRow
            FROM SQLM_%%(tables[q1])_OperRow-1
            UNTIL SQLM_%%(tables[q1])_OperRow-%%(scanMax)
            WHERE SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Allocated = 1
            DO GOTO FOUNDtowGetSchTableCursorRow%%(q3);
%%SET sentSigs(,TOWGETSCH)
        SEND towGetSch REFERENCE cOwnRef WITH
            SQLX_OtherBlock,
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            SQLM_%%(tables[q1])_OperRow,
            SQLM_%%(tables[q1])_WorkRow
%%LOOP(dr <= 15)
            ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
            ,
            SQLX_KeyOperation,
            SQLX_KeyPrefix,
            SQLX_RightTurn,
            SQLX_ReturnLabel;
        EXIT;
    FI;
! failure, set pOperRow to nil !
FAILEDtowGetSchTableCursorRow%%(q3))
    SQLM_%%(tables[q1])_OperRow = SQLM_TableReference:SQLM_System+1;
! Return row found !
FOUNDtowGetSchTableCursorRow%%(q3))
%%SET sentSigs(,TOWGETSCH)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLX_ReturnLabel,
        SQLX_KeyNumber,
        SQLM_%%(tables[q1])_OperRow,
        SQLM_%%(tables[q1])_WorkRow
%%LOOP(dr <= 15)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ,
        SQLX_KeyOperation,
        SQLX_KeyPrefix,
        SQLX_RightTurn,
        SQLM_TableReference;
    EXIT;
%%END(towGetSchTableCursorRow)
---------------------------------------------------------------------------





---------------------------------------------------------------------------
-       9. HANDLE TOWGETFLD
---------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towGetFld, Chapter 9.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       i

- Included code components:
-       towGetFldTable
---------------------------------------------------------------------------
%%BEGIN(towGetFld)
!------------------------------------------------!
!       towGetFld !
!------------------------------------------------!
%%SET recSigs(,TOWGETFLD)
    ENTER towGetFld WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_OperRow,
        SQLX_DBnumber2,
        +
%%LOOP(dr <= 19)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ;
%%IF(tables[0]=1)
%%INCLUDE(towGetFldTable(1))
%%ELSE
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetFldTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
    EXIT;
%%ENDIF
%%END(towGetFld)
---------------------------------------------------------------------------













---------------------------------------------------------------------------
- Code component towGetFldTable, chapter 9.2

- Parameters:
-       p1:             Table index.

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       dr

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(towGetFldTable)
!------------------------------------------------!
!       towGetFldTable !
!------------------------------------------------!
%%SET p1(%%(towGetFldTable[1]))
! set operating row.!
    SQLM_%%(tables[p1])_OperRow = SQLX_OperRow;
! check if row is outside table area, if so report failure.!
    IF SQLM_%%(tables[p1])_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if so report failure.!
    IF SQLM_%%(tables[p1])_OperRow:SQLC_%%(tables[p1])_Allocated = 0 THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is not as expected, if so report failure.!
    IF SQLM_%%(tables[p1])_OperRow:SQLC_%%(tables[p1])_DBnumber2 /=
        SQLX_DBnumber2
    THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_%%(tables[p1])_Pack;
! check if read lock, if so report failure.!
    IF SQLM_%%(tables[p1])_OperRow:SQLC_%%(tables[p1])_Lock > 1 THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
%%LOOP(dr <= 21)
            ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
            ;
        EXIT;
    FI;
! Send back row number, DB number and requested data !
%%SET sentSigs(,TOWGETR)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
%%LOOP(dr <= 21)
        ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr);
    EXIT;
%%END(towGetFldTable)
---------------------------------------------------------------------------






---------------------------------------------------------------------------
-       10. HANDLE: TOWGETKEY
----------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towGetKey, Chapter 10.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       i

- Included code components:
-       towGetKeyTable
---------------------------------------------------------------------------
%%BEGIN(towGetKey)
!------------------------------------------------!
!       towGetKey !
!------------------------------------------------!
%%SET recSigs(,TOWGETKEY)
    ENTER towGetKey WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_OperRow,
        SQLX_DBnumber2,
        SQLX_KeyNumber;
%%IF(tables[0]=1)
%%INCLUDE(towGetKeyTable(1))
%%ELSE
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetKeyTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
    EXIT;
%%ENDIF
%%END(towGetKey)
---------------------------------------------------------------------------




---------------------------------------------------------------------------
- Code component towGetKeyTable, chapter 10.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       dr

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(towGetKeyTable)
!------------------------------------------------!
!       towGetKeyTable !
!------------------------------------------------!
%%SET p1(%%(towGetKeyTable[1]))
! set operating row.!
    SQLM_%%(tables[p1])_OperRow = SQLX_OperRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_%%(tables[p1])_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_%%(tables[p1])_OperRow:SQLC_%%(tables[p1])_Allocated = 0 THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is as expected, if not rerport failure.!
    IF SQLM_%%(tables[p1])_OperRow:SQLC_%%(tables[p1])_DBnumber2 /=
        SQLX_DBnumber2
    THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! pack data in signal.!
    DO SQLS_%%(tables[p1])_PackKey;
! check if not read lock, if not report failure.!
    IF SQLM_%%(tables[p1])_OperRow:SQLC_%%(tables[p1])_Lock > 1 THEN
%%SET sentSigs(,TOWGETR)
        SEND towGetR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row locked for exclusive access !
            2+3 <= 8,
            SQLX_OperRow,
            SQLX_DBnumber2
%%LOOP(dr <= 21)
            ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
            ;
        EXIT;
    FI;
! send back row number, DB number and requested data.!
%%SET sentSigs(,TOWGETR)
    SEND towGetR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLX_OperRow,
        SQLX_DBnumber2
%%LOOP(dr <= 21)
        ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
        ;
    EXIT;
%%END(towGetKeyTable)
--------------------------------------------------------------------------




---------------------------------------------------------------------------
-       11. HANDLE: TOWOPEN
---------------------------------------------------------------------------

--------------------------------------------------------------------------
- Code component towOpen, Chapter 11.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       dr
-       i

- Included code components:
-       towOpenTable
--------------------------------------------------------------------------
%%BEGIN(towOpen)
!------------------------------------------------!
!       towOpen !
!------------------------------------------------!
%%SET recSigs(,TOWOPEN)
    ENTER towOpen WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyOperation,
        SQLX_KeyNumber,
        +,
        +
%%LOOP(dr <= 18)
        ,SQLX_DR%%(dr+5)
%%ENDLOOP(dr)
        ;
%%IF(tables[0]=1)
%%INCLUDE(towOpenTable(1))
%%ELSE
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towOpenTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
    EXIT;
%%ENDIF
%%END(towOpen)
----------------------------------------------------------------------------



---------------------------------------------------------------------------
- Code component towOpenTable, chapter 11.2

- A work row is allocated, if the key does not use row access, to store
- the key to be selected.

- Parameters:
-       p1              Table number.

- IMP variables used:
-       tables          All table names in the block.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       q3
-       dr

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(towOpenTable)
!------------------------------------------------!
!       towOpenTable !
!------------------------------------------------!
%%SET p1(%%(towOpenTable[1]))
%%SET p3(%%(tabNos[p1]))
! allocate a work row.!
%%INCLUDE(allocateWorkRow(%%(tables[p1]), WORKLOCKtowOpenTable%%(p3),WORKFULLtowOpenTable%%(p3)))
    SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_Lock=2;
! unpack key into work row.!
    DO SQLS_%%(tables[p1])_UnPackKey;
    CASE SQLX_KeyNumber IS
%%IF(NOT bTrees%%(p3)(2))
    WHEN 0,2 DO
%%ELSE
    WHEN 0 DO
%%ENDIF
! get which row to search from.!
        IF SQLX_KeyOperation = 2 THEN
            SQLM_%%(tables[p1])_OperRow = SQLM_%%(tables[p1])_OperRow+1;
        FI;
        SQLM_%%(tables[p1])_WorkRow:%%(SQLC_%%(tables[p1])_LastRow) =
            SQLM_%%(tables[p1])_OperRow;
    OTHERWISE DO
! set last row depending upon key operation.!
        IF SQLX_KeyOperation = 1 THEN
            SQLM_%%(tables[p1])_WorkRow:%%(SQLC_%%(tables[p1])_LastRow) = 0;
        ELSE
            SQLM_%%(tables[p1])_WorkRow:%%(SQLC_%%(tables[p1])_LastRow) =
                %%(indMax);
        FI;
    ESAC;
! send back success.!
%%SET sentSigs(,TOWOPENR)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0,
        SQLM_%%(tables[p1])_WorkRow;
    EXIT;

! Work area is locked !
WORKLOCKtowOpenTable%%(p3))
%%SET sentSigs(,TOWOPENR)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3+18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowOpenTable%%(p3))
%%SET sentSigs(,TOWOPENR)
    SEND towOpenR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
%%END(towOpenTable)
-------------------------------------------------------------------------







---------------------------------------------------------------------------
-       12. HANDLE: TOWCLOSE
--------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towClose, Chapter 12.1


- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       dr
-       i

- Included code components:
-       towCloseTable
-------------------------------------------------------------------------
%%BEGIN(towClose)
!------------------------------------------------!
!       towClose !
!------------------------------------------------!
%%SET recSigs(,TOWCLOSE)
    RECEIVE towClose WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow;
%%IF(tables[0]=1)
%%INCLUDE(towCloseTable(1))
%%ELSE
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towCloseTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
    EXIT;
%%ENDIF
%%END(towClose)
---------------------------------------------------------------------------










---------------------------------------------------------------------------
- Code component towCloseTable, chapter 12.2

- Parameters:
-       p1:             Table index

- Included code components:
-       deAllocateWorkRow
---------------------------------------------------------------------------
%%BEGIN(towCloseTable)
!------------------------------------------------!
!       towCloseTable !
!------------------------------------------------!
%%SET p1(%%(towCloseTable[1]))
    SQLM_%%(tables[p1])_WorkRow = SQLX_WorkRow;
! deallocate cursor.!
%%INCLUDE(deAllocateWorkRow(%%(tables[p1])))
! send back success.!
%%SET sentSigs(,TOWCLOSEACK)
    RETURN towCloseAck WITH
        SQLX_OtherProtected,
        0;
    EXIT;
%%END(towCloseTable)
--------------------------------------------------------------------------






---------------------------------------------------------------------------
-       13. HANDLE: TOWCHAVOLROW
---------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towChaVolRow, Chapter 13.1

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       dr
-       i

- Included code components:
-       towChaVolRowtable
---------------------------------------------------------------------------
%%BEGIN(towChaVolRow)
!------------------------------------------------!
!       towChaVolRow !
!------------------------------------------------!
%%IF(volTabInds[0] > 0)
%%SET recSigs(,TOWCHAVOLROW)
    ENTER towChaVolRow WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow,
        +,
        +
%%LOOP(dr <= 19)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ;
%%IF(volTabInds[0] = 1)
%%INCLUDE(towChaVolRowTable(%%(volTabInds[1])))
%%ELSE
    CASE SQLM_TableReference IS
%%LOOP(i, volTabInds)
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towChaVolRowTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
    EXIT;
%%ENDIF
%%ENDIF
%%END(towChaVolRow)
---------------------------------------------------------------------------


-------------------------------------------------------------------------
- Code component towChaVolRowTable, Chapter 13.2

Parameters:
-       p1:             Table number

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       None

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(towChaVolRowTable)
!------------------------------------------------!
!       towChaVolRowTable !
!------------------------------------------------!
%%SET p1(%%(towChaVolRowTable[1]))
! set working row.!
    SQLM_%%(tables[p1])_WorkRow = SQLX_WorkRow;
! check if row is outside tablearea, if so report failure.!
    IF SQLM_%%(tables[p1])_WorkRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
%%SET sentSigs(,TOWCHAVOLROWR)
        SEND towChaVolRowR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is allocated, if not report failure.!
    IF SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_Allocated = 0 THEN
%%SET sentSigs(,TOWCHAVOLROWR)
        SEND towChaVolRowR REFERENCE SQLX_OtherBlock WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! Unpack data into working row.!
    DO SQLS_%%(tables[p1])_UnPack;
! send back success.!
%%SET sentSigs(,TOWCHAVOLROWR)
    SEND towChaVolRowR REFERENCE SQLX_OtherBlock WITH
        SQLX_OtherProtected,
        0;
    EXIT;
%%END(towChaVolRowTable)
-------------------------------------------------------------------------






--------------------------------------------------------------------------
-       14. HANDLE: TOWINSROW
---------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towInsRow, Chapter 14.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos
-       bTrees

- IMP variables defined:
-       None

- Temporary IMP variables:
-       i
-       dr

- Included code components:
-       towInsRowTableBTree
-       towInsRowTableRow
---------------------------------------------------------------------------
%%BEGIN(towInsRow)
!------------------------------------------------!
!       towInsRow !
!------------------------------------------------!
%%SET recSigs(,TOWINSROW)
    ENTER towInsRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +,
        +
%%LOOP(dr <= 19)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ;
%%IF(tables[0] > 1)
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%IF(bTrees%%(tabNos[i])(2))
        GOTO towInsRowTableBTree%%(tabNos[i]);
%%ELSE
        GOTO towInsRowTableRow%%(tabNos[i]);
%%ENDIF
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
    EXIT;
%%ENDIF
%%LOOP(i <= tables[0])
%%IF(bTrees%%(tabNos[i])(2))
%%INCLUDE(towInsRowTableBTree(%%(i)))
%%ELSE
%%INCLUDE(towInsRowTableRow(%%(i)))
%%ENDIF
%%ENDLOOP(i)
%%END(towInsRow)
----------------------------------------------------------------------------







--------------------------------------------------------------------------
- Code component towInsRowTableBTree, chapter 14.2.1

- Parameters:
-       p1:             Table index.

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreeColsI_J    Column numbers for all columns in table I btree J.
-       defColsI        Column numbers for all columns in table I that has
                        default values explicitly or implicitly.
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.
-       defValI_J       Default value for column J in table I. All values should-                       be givenas IMP strings.

- IMP variables defined:
-       towInsSchlab

- Temporary IMP variables:
-       p3
-       dr
-       j

- Included code components:
-       deletfromInsertlist
-       putIntoFreeList
---------------------------------------------------------------------------
%%BEGIN(towInsRowTableBTree)
!------------------------------------------------!
!       towInsRowTableBTree !
!------------------------------------------------!
%%SET p1(%%(towInsRowTableBTree[1]))
%%SET p3(%%(tabNos[p1]))
%%IF(tables[0] > 1)
towInsRowTableBTree%%(p3))
%%ENDIF
    SQLM_%%(tables[p1])_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_%%(tables[p1])_NilRow = SQLM_%%(tables[p1])_GuardRow + 1;
! get free row.!
%%INCLUDE(getFromFreeList(%%(p1)))
    IF SQLM_%%(tables[p1])_WorkRow = SQLM_%%(tables[p1])_NilRow THEN
%%SET sentSigs(,TOWINSROWR)
        SEND towInsRowR WITH
            SQLX_OtherProtected,
!  Error: Table full !
            3+9 <= 8;
        EXIT;
    FI;
! allocate row and unpack primary key.!
    SQLM_%%(tables[p1])_Workrow:SQLC_%%(tables[p1])_Allocated = 1;
    DO SQLS_%%(tables[p1])_UnpackKey;
! insert row in insert list (double linked).!
%%INCLUDE(insertIntoInsertList(%%(p1)))
! check if primary key is in insert list, if so jump to error.!
    SQLM_%%(tables[p1])_OperRow = SQLM_%%(tables[p1])_GuardRow;
    SQLX_Schedule = 0;
    SQLX_KeyPrefix = %%(bTreeCols%%(p3)_2[0]);
%%SET towInsSchLab(%%(towInsSchLab + 1))
towInsSchLab%%(towInsSchLab))
%%SET limit(%%(schLimit / (schConst%%(p3)_2 + schIns)))
    SQLX_Schedule = SQLX_Schedule+1;
    IF SQLX_Schedule > %%(limit) THEN
%%SET sentSigs(,TOWINSSCH)
        SEND towInsSch REFERENCE cOwnRef WITH
            SQLX_OtherProtected,
            SQLM_TableReference,
            SQLX_KeyNumber,
            %%(towInsSchLab),
            SQLM_%%(tables[p1])_WorkRow,
            SQLM_%%(tables[p1])_OperRow
%%LOOP(dr <= 15)
            ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
            ,
            +,
            +,
            +,
            SQLX_KeyPrefix;
        EXIT;
    FI;
    SQLM_%%(tables[p1])_OperRow =
        SQLM_%%(tables[p1])_OperRow:%%(SQLC_%%(tables[p1])_Next);
    IF SQLM_%%(tables[p1])_OperRow /= SQLM_%%(tables[p1])_NilRow THEN
        IF SQLM_%%(tables[p1])_OperRow /= SQLM_%%(tables[p1])_WorkRow THEN
            DO SQLS_%%(tables[p1])_KeyTest2;
            IF SQLX_KeyTest = 1 GOTO ERRORtowInsRowTableBTree%%(p3);
        FI;
        GOTO towInsSchLab%%(towInsSchLab);
    FI;
! check if primary key IS in tree, if so jump to error.!
    SQLM_%%(tables[p1])_RootRow = SQLM_TableReference:SQLM_System+2;
%%SET sentSigs(,TOWGETSCH)
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_%%(tables[p1])_RootRow:SQLC_%%(tables[p1])_Right2,
        SQLM_%%(tables[p1])_WorkRow
%%LOOP(dr <= 15)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ,
        3,
        %%(bTreeCols%%(p3)_2[0]),
        +,
%%SET towGetSchLab(%%(towGetSchLab + 1))
        %%(towGetSchLab);
    EXIT;
towGetSchLab%%(towGetSchLab))
    SQLM_%%(tables[p1])_WorkRow=SQLX_WorkRow;
    SQLM_%%(tables[p1])_OperRow=SQLX_Operrow;
    IF SQLM_%%(tables[p1])_OperRow /= SQLM_TableReference:SQLM_System+1
        GOTO ERRORtowInsRowTableBTree%%(p3);
! set default values and unpack data from D7 to D21.!
%%LOOP(j, defCols%%(p3))
%%IF(colNull%%(p3)[j] = 1)
%%IF(defVal%%(p3)_%%(j) = "NULL")
    SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_%%(cols%%(p3)[j])_Null = 1;
%%ELSE
    SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_%%(cols%%(p3)[j])_Null = 0;
%%ENDIF
%%ENDIF
%%IF(defVal%%(p3)_%%(j) # "NULL")
    SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_%%(cols%%(p3)[j])_Data = %%(defVal%%(p3)_%%(j));
%%ENDIF
%%ENDLOOP(j)
    DO SQLS_%%(tables[p1])_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_%%(tables[p1])_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_%%(tables[p1])_WorkRow;
    FI;
%%SET sentSigs(,TOWINSROWR)
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_%%(tables[p1])_WorkRow;
    EXIT;
ERRORtowInsRowTableBTree%%(p3))
    SQLM_%%(tables[p1])_OperRow = SQLM_%%(tables[p1])_WorkRow;
    SQLM_%%(tables[p1])_GuardRow = SQLM_TableReference:SQLM_System;
! remove row from insert list.!
%%INCLUDE(deleteFromInsertList(%%(p1)))
! insert row in free list.!
%%INCLUDE(putIntoFreeList(%%(p1)))
! deallocate row.!
    SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_Allocated = 0;
! send failure.!
%%SET sentSigs(,TOWINSROWR)
    SEND towInsRowR WITH
        SQLX_OtherProtected,
! Search failure: Row already exists !
        2+5 <= 8;
    EXIT;
%%END(towInsRowTableBTree)
-----------------------------------------------------------------------












--------------------------------------------------------------------------
- Code component towInsRowTableRow, chapter 14.2.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tables          All table names in the block.
-       defColsI        Column numbers for all columns in table I that has
                        default values explicitly or implicitly.
-       aksI            Key numbers for all AK in table I, may be empty.
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.
-       defValI_J       Default value for column J in table I. All values should-                       be givenas IMP strings.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       p3
-       j

- Included code components:
-iInsertIntoInsertList
--------------------------------------------------------------------------
%%BEGIN(towInsRowTableRow)
!------------------------------------------------!
!       towInsRowTableRow !
!------------------------------------------------!
%%SET p1(%%(towInsRowTableRow[1]))
%%SET p3(%%(tabNos[p1]))
%%IF(tables[0] > 1)
towInsRowTableRow%%(p3))
%%ENDIF
! unpack key (set pOperRow).!
    DO SQLS_%%(tables[p1])_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_%%(tables[p1])_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
%%SET sentSigs(,TOWINSROWR)
        SEND towInsRowR WITH
            SQLX_OtherProtected,
! Search failure: Rownumber outside defined table area !
            2+6 <= 8;
        EXIT;
    FI;
! check is row is allocated, if so report failure.!
    IF SQLM_%%(tables[p1])_OperRow:SQLC_%%(tables[p1])_Allocated = 1 THEN
%%SET sentSigs(,TOWINSROWR)
        SEND towInsRowR WITH
            SQLX_OtherProtected,
! Search failure: Row already exists !
            2+5 <= 8;
        EXIT;
    FI;
! allocate and lock row.!
    SQLM_%%(tables[p1])_OperRow:SQLC_%%(tables[p1])_Allocated = 1;
    SQLM_%%(tables[p1])_OperRow:SQLC_%%(tables[p1])_Lock = 1;
! assign work row !
    SQLM_%%(tables[p1])_WorkRow=SQLM_%%(tables[p1])_OperRow;
%%IF(aks%%(p3)[0] > 0)
    SQLM_%%(tables[p1])_GuardRow = SQLM_Tablereference:SQLM_System;
    SQLM_%%(tables[p1])_NilRow = SQLM_%%(tables[p1])_GuardRow + 1;
! insert row in insert list (dubbel linked).!
%%INCLUDE(insertIntoInsertList(%%(p1)))
%%ENDIF
! set default values and unpack data from D7 to D21.!
%%LOOP(j, defCols%%(p3))
%%IF(colNull%%(p3)[j] = 1)
%%IF(defVal%%(p3)_%%(j) = "NULL")
    SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_%%(cols%%(p3)[j])_Null = 1;
%%ELSE
    SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_%%(cols%%(p3)[j])_Null = 0;
%%ENDIF
%%ENDIF
%%IF(defVal%%(p3)_%%(j) # "NULL")
    SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_%%(cols%%(p3)[j])_Data = %%(defVal%%(p3)_%%(j));
%%ENDIF
%%ENDLOOP(j)
    DO SQLS_%%(tables[p1])_UnPack;
! send success.!
    IF SQLM_TableReference:SQLM_TableLast < SQLM_%%(tables[p1])_WorkRow THEN
        SQLM_TableReference:SQLM_TableLast = SQLM_%%(tables[p1])_WorkRow;
    FI;
%%SET sentSigs(,TOWINSROWR)
    SEND towInsRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_%%(tables[p1])_OperRow;
    EXIT;
%%END(towInsRowTableRow)
---------------------------------------------------------------------------



---------------------------------------------------------------------------
-       15. HANDLE: TOWINSSCH
---------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towInsSch, Chapter 15.1

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       i
-       dr

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(towInsSch)
%%IF(towInsSchLab > 0)
!------------------------------------------------!
!       towInsSch !
!------------------------------------------------!
%%SET recSigs(,TOWINSSCH)
    ENTER towInsSch WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLX_ReturnLabel,
%%IF(tables[0]=1)
        SQLM_%%(tables[1])_WorkRow,
        SQLM_%%(tables[1])_OperRow
%%ELSE
        SQLX_WorkRow,
        SQLX_OperRow
%%ENDIF
%%LOOP(dr <= 15)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr),
        +,
        +,
        +,
        SQLX_KeyPrefix;
    SQLX_Schedule = 0;
%%IF(tables[0] > 1)
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
        SQLM_%%(tables[i])_WorkRow = SQLX_WorkRow;
        SQLM_%%(tables[i])_OperRow = SQLX_OperRow;
        SQLM_%%(tables[i])_NilRow=SQLM_TableReference:SQLM_System+1;
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
%%ELSE
    SQLM_%%(tables[1])_NilRow=SQLM_TableReference:SQLM_System+1;
%%ENDIF
%%IF(towInsSchLab = 1)
    GOTO towInsSchLab1;
%%ELSE
    CASE SQLX_ReturnLabel IS
%%LOOP(i <= towInsSchLab)
    WHEN %%(i) DO GOTO towInsSchLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ;
    ESAC;
    EXIT;
%%ENDIF
%%ENDIF
%%END(towInsSch)
--------------------------------------------------------------------------





--------------------------------------------------------------------------
-       16. HANDLE: TOWCHAROW
-------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towChaRow, Chapter 16.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos

- IMP variables defined:
-       None

- Temporary IMP variables:
-       i
-       dr

- Included code components:
-       towChaRowTable
---------------------------------------------------------------------------
%%BEGIN(towChaRow)
!------------------------------------------------!
!       towChaRow !
!------------------------------------------------!
%%SET recSigs(,TOWCHAROW)
    ENTER towChaRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +,
        +
%%LOOP(dr <= 19)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ;
%%IF(tables[0] > 1)
    CASE SQLM_TableReference IS
%%LOOP(i, tabNos)
    WHEN %%(i) DO GOTO towChaRowTable%%(i);
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
    EXIT;
%%ENDIF
%%LOOP(i <= tables[0])
%%INCLUDE(towChaRowTable(%%(i)))
%%ENDLOOP(i)
%%END(towChaRow)
---------------------------------------------------------------------------



---------------------------------------------------------------------------
- Code component towChaRowTable, Chapter 16.2

- Parameters:
-       p1:             Table index.

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       p3

- Included code components:
-       towChaRowTableKeyRow
-       towChaRowTableKeyCursor
-       towChaRowTableKeyBTree
-       towChaRowTableKeyContinue
----------------------------------------------------------------------------
%%BEGIN(towChaRowTable)
!------------------------------------------------!
!       towChaRowTable !
!------------------------------------------------!
%%SET p1(%%(towChaRowTable[1]))
%%SET p3(%%(tabNos[p1]))
%%IF(tables[0] > 1)
towChaRowTable%%(p3))
%%ENDIF
    CASE SQLX_KeyNumber IS
%%IF(NOT bTrees%%(p3)(2))
    WHEN 0,2 DO GOTO towChaRowTableKeyRow%%(p3);
    WHEN 1 DO GOTO towChaRowTableKeyCursor%%(p3);
%%ELSE
    WHEN 0 DO GOTO towChaRowTableKeyRow%%(p3);
    WHEN 1 DO GOTO towChaRowTableKeyCursor%%(p3);
    WHEN 2 DO GOTO towChaRowTableKeyBTree%%(p3);
%%ENDIF
    OTHERWISE DO;
    ESAC;
%%INCLUDE(towChaRowTableKeyRow(%%(p1)))
%%INCLUDE(towChaRowTableKeyCursor(%%(p1)))
%%IF(bTrees%%(p3)(2))
%%INCLUDE(towChaRowTableKeyBTree(%%(p1), 2))
%%ENDIF
%%INCLUDE(towChaRowTableKeyContinue(%%(p1)))
%%END(towChaRowTable)
--------------------------------------------------------------------------




---------------------------------------------------------------------------
- Code component towChaRowTableKeyBTree, Chapter 16.3.1

- Parameters:
-       q1:             Table index
-       q2:             Key number.

- IMP variables used:
-       tables          All table names in the block.
-       bTreeColsI_J    Column numbers for all columns in table I btree J.

- IMP variables defined:
-       towGetschlab

- Temporary IMP variables:
-       q3
-       dr

- Included code components:
---------------------------------------------------------------------------
%%BEGIN(towChaRowTableKeyBTree)
!------------------------------------------------!
!       towChaRowTableKeyBTree !
!------------------------------------------------!
%%SET q1(%%(towChaRowTableKeyBTree[1]))
%%SET q2(%%(towChaRowTableKeyBTree[2]))
%%SET q3(%%(tabNos[p1]))
towChaRowTableKeyBTree%%(q3))
! allocate work row.!
%%INCLUDE(allocateWorkRow(%%(tables[q1]),WORKLOCKtowChaRowTableKeyBTree%%(q3),WORKFULLtowChaRowTableKeyBTree%%(q3)))
! unpack key into the work row.!
    DO SQLS_%%(tables[q1])_UnPackKey;
! find an operating row.!
    SQLM_%%(tables[q1])_RootRow = SQLM_TableReference:SQLM_System+2;
%%SET sentSigs(,TOWGETSCH)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_%%(tables[q1])_RootRow:SQLC_%%(tables[q1])_Right%%(q2),
        SQLM_%%(tables[q1])_WorkRow
%%LOOP(dr <= 15)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ,
        3,
        %%(bTreeCols%%(q3)_%%(q2)[0]),
        +,
%%SET towGetSchLab(%%(towGetSchLab + 1))
        %%(towGetSchLab);
    EXIT;
towGetSchLab%%(towGetSchLab))
    SQLM_%%(tables[q1])_WorkRow=SQLX_WorkRow;
    SQLM_%%(tables[q1])_OperRow=SQLX_Operrow;
! check if row is not allocated, if so deallocate work row and report failure.!
    IF SQLM_%%(tables[q1])_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Allocated = 0;
%%SET sentSigs(,TOWCHAROWR)
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Lock > 0 THEN
        SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Allocated = 0;
%%SET sentSigs(,TOWCHAROWR)
        SEND towChaRowR WITH
            SQLX_OtherProtected,
            2+2 <= 8,
! Search failure: Row locked for update or delete !
            SQLM_%%(tables[q1])_OperRow;
        EXIT;
    FI;
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Color%%(q2) = 1;
    GOTO towChaRowTableKeyContinue%%(q3);
%%END(towChaRowTableKeyBTree)
---------------------------------------------------------------------------



---------------------------------------------------------------------------
- Code component towChaRowTableKeyRow, Chapter 16.3.2

- Parameters:
-       q1:             Table index

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       q3

- Included code components:
-       allocateworkrow
--------------------------------------------------------------------------
%%BEGIN(towChaRowTableKeyRow)
!------------------------------------------------!
!       towChaRowTableKeyRow !
!------------------------------------------------!
%%SET q1(%%(towChaRowTableKeyRow[1]))
%%SET q3(%%(tabNos[q1]))
towChaRowTableKeyRow%%(q3))
! unpack key (set pOperRow).!
    DO SQLS_%%(tables[q1])_UnPackKey;
! check if row is outside table area, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
%%SET sentSigs(,TOWCHAROWR)
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Allocated = 0 THEN
%%SET sentSigs(,TOWCHAROWR)
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Lock > 0 THEN
%%SET sentSigs(,TOWCHAROWR)
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_%%(tables[q1])_OperRow;
        EXIT;
    FI;
! allocate work row.!
%%INCLUDE(allocateWorkRow(%%(tables[q1]),WORKLOCKtowChaRowTableKeyBTree%%(q3),WORKFULLtowChaRowTableKeyBTree%%(q3)))
    GOTO towChaRowTableKeyContinue%%(q3);
%%END(towChaRowTableKeyRow)
---------------------------------------------------------------------------






---------------------------------------------------------------------------
- Code component towChaRowTableKeyCursor, Chapter 16.3.3

- Parameters:
-       q1:             Table index

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       q3

- Included code components:
-       allocateworkRow
---------------------------------------------------------------------------
%%BEGIN(towChaRowTableKeyCursor)
!------------------------------------------------!
!       towChaRowTableKeyCursor !
!------------------------------------------------!
%%SET q1(%%(towChaRowTableKeyCursor[1]))
%%SET q3(%%(tabNos[q1]))
towChaRowTableKeyCursor%%(q3))
! unpack cursor data and set operating row to last row found in cursor.!
    DO SQLS_%%(tables[q1])_UnPackkey;
    SQLM_%%(tables[q1])_OperRow =
        SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_LastRow);
! check if a row was not found, if so report failure.!
    IF SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Lock = 2 THEN
%%SET sentSigs(,TOWCHAROWR)
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
%%SET sentSigs(,TOWCHAROWR)
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Allocated = 0 THEN
%%SET sentSigs(,TOWCHAROWR)
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_DBnumber2 /=
        SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2
    THEN
%%SET sentSigs(,TOWCHAROWR)
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
! check if row is locked, if so deallocate work row and report
  failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Lock > 0 THEN
%%SET sentSigs(,TOWCHAROWR)
        SEND towChaRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_%%(tables[q1])_OperRow;
        EXIT;
    FI;
! allocate work row.!
%%INCLUDE(allocateWorkRow(%%(tables[q1]),WORKLOCKtowChaRowTableKeyBTree%%(q3),WORKFULLtowChaRowTableKeyBTree%%(q3)))
%%IF(bTrees%%(q3)(2))
! cColorN is used in commit to not delete and insert keys which was
  not changed. Primary key NEVER changes so cColorN is set to 1. !
    SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Color2 = 1;
%%ENDIF
    GOTO towChaRowTableKeyContinue%%(q3);
%%END(towChaRowTableKeyCursor)
----------------------------------------------------------------------------




--------------------------------------------------------------------------
- Code component towChaRowTableKeyContinue, Chapter 16.3.4

- Parameters:
-       q1:             Table index

- IMP variables used:
-       tables          All table names in the block.
-       cols
-       aks
-       colsMinusPkI    Column numbers for all columns in table I except the
                        columns in the Primary Key and Rownumber columns.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       q3
-       l

- Included code components:
-       insertIntoInsertList
--------------------------------------------------------------------------
%%BEGIN(towChaRowTableKeyContinue)
!------------------------------------------------!
!       towChaRowTableKeyContinue !
!------------------------------------------------!
%%SET q1(%%(towChaRowTableKeyContinue[1]))
%%SET q3(%%(tabNos[q1]))
towChaRowTableKeyContinue%%(q3))
! lock operating row.!
    SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Lock = 1;
! copy each column except primary key components.!
%%IF(NOT bTrees%%(q3)(2))
%%SET bTreeCols%%(q3)_2()
%%ENDIF
%%LOOP(l <= cols%%(q3)[0] - 1)
%%IF(NOT bTreeCols%%(q3)_2(%%(l + 1)))
%%IF(colNull%%(q3)[l + 1] = 1)
    SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_%%(cols%%(q3)[l + 1])_Null =
        SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_%%(cols%%(q3)[l + 1])_Null;
%%ENDIF
%%IF(colTypes%%(q3)[l + 1] # "PACKED NUMSTRING")
    SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_%%(cols%%(q3)[l + 1])_Data =
        SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_%%(cols%%(q3)[l + 1])_Data;
%%ELSE
%%INCLUDE(copyPackNum("SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_%%(cols%%(q3)[l + 1])_Data", "SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_%%(cols%%(q3)[l + 1])_Data", %%(colSizes%%(q3)[l + 1])))
%%ENDIF
%%ENDIF
%%ENDLOOP(l)
! unpack column data.!
    DO SQLS_%%(tables[q1])_UnPack;
%%IF(bTrees%%(q3)(2) OR aks%%(q3)[0] > 0)
! insert row in insert list (double linked).!
    SQLM_%%(tables[q1])_GuardRow = SQLM_TableReference:SQLM_System;
    SQLM_%%(tables[q1])_NilRow = SQLM_%%(tables[q1])_GuardRow + 1;
%%INCLUDE(insertIntoInsertList(%%(q1)))
%%ENDIF
! send back success.!
%%IF(bTrees%%(q3)(2))
    SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Color2=1;
%%ENDIF
%%SET sentSigs(,TOWCHAROWR)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_%%(tables[q1])_OperRow,
        SQLM_%%(tables[q1])_WorkRow,
        SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2;
    EXIT;

! Work area is locked !
WORKLOCKtowChaRowTableKeyBTree%%(q3))
%%SET sentSigs(,TOWCHAROWR)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused !
        3 + 18 <= 8;
    EXIT;

! Work area is full !
WORKFULLtowChaRowTableKeyBTree%%(q3))
%%SET sentSigs(,TOWCHAROWR)
    SEND towChaRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
%%END(towChaRowTableKeyContinue)
---------------------------------------------------------------------------



----------------------------------------------------------------------------
-       17 HANDLE: TOWDELROW
--------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towDelRow, chapter 17.1

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       dr
-       i

- Included code components:
-       towdelrowTable
---------------------------------------------------------------------------
%%BEGIN(towDelRow)
!------------------------------------------------!
!       towDelRow !
!------------------------------------------------!
%%SET recSigs(,TOWDELROW)
    ENTER towDelRow WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        +,
        +,
        +,
        +
%%LOOP(dr <= 18)
        ,SQLX_DR%%(dr+5)
%%ENDLOOP(dr)
        ;
%%IF(tables[0] > 1)
    CASE SQLM_TableReference IS
%%LOOP(i, tabNos)
    WHEN %%(i) DO GOTO towDelRowTable%%(i);
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
    EXIT;
%%ENDIF
%%LOOP(i <= tables[0])
%%INCLUDE(towDelRowTable(%%(i)))
%%ENDLOOP(i)
%%END(towDelRow)
---------------------------------------------------------------------------



---------------------------------------------------------------------------
- Code component towDelRowTable, chapter 17.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       p3

- Included code components:
-       towDelRowTableKeyRow
-       towDelRowTableKeyCursor
-       towDelRowTableKeyBTree
-       towDelRowTableKeyContinue
---------------------------------------------------------------------------
%%BEGIN(towDelRowTable)
!------------------------------------------------!
!       towDelRowTable !
!------------------------------------------------!
%%SET p1(%%(towDelRowTable[1]))
%%SET p3(%%(tabNos[p1]))
%%IF(tables[0] > 1)
towDelRowTable%%(p3))
%%ENDIF
    CASE SQLX_KeyNumber IS
%%IF(NOT bTrees%%(p3)(2))
    WHEN 0,2 DO GOTO towDelRowTableKeyRow%%(p3);
    WHEN 1 DO GOTO towDelRowTableKeyCursor%%(p3);
%%ELSE
    WHEN 0 DO GOTO towDelRowTableKeyRow%%(p3);
    WHEN 1 DO GOTO towDelRowTableKeyCursor%%(p3);
    WHEN 2 DO GOTO towDelRowTableKeyBTree%%(p3);
%%ENDIF
    OTHERWISE DO;
    ESAC;
%%INCLUDE(towDelRowTableKeyRow(%%(p1)))
%%INCLUDE(towDelRowTableKeyCursor(%%(p1)))
%%IF(bTrees%%(p3)(2))
%%INCLUDE(towDelRowTableKeyBTree(%%(p1), 2))
%%ENDIF
%%INCLUDE(towDelRowTableKeyContinue(%%(p1)))
%%END(towDelRowTable)
-----------------------------------------------------------------------------






---------------------------------------------------------------------------
- Code component towDelRowTableKeyBTree, chapter 17.3.1

- Parameters:
-        q1:            Table index
-       q2:             Key number.

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreeColsI_J    Column numbers for all columns in table I btree J.

- IMP variables defined:
-       towGetSchLab

- Temporary IMP variables:
-       q3
-       dr

- Included code components:
-       allocateWorkRow
-       deAllocateWorkrow
---------------------------------------------------------------------------
%%BEGIN(towDelRowTableKeyBTree)
!------------------------------------------------!
!       towDelRowTableKeyBTree !
!------------------------------------------------!
%%SET q1(%%(towDelRowTableKeyBTree[1]))
%%SET q2(%%(towDelRowTableKeyBTree[2]))
%%SET q3(%%(tabNos[q1]))
towDelRowTableKeyBTree%%(q3))
! allocate work row.!
%%INCLUDE(allocateWorkRow(%%(tables[q1]),WORKLOCKtowDelRowTableKeyBTree%%(q3),WORKFULLtowDelRowTableKeyBTree%%(q3)))
! unpack key into work row.!
    DO SQLS_%%(tables[q1])_UnPackKey;
! find an operating row.!
    SQLM_%%(tables[q1])_RootRow = SQLM_TableReference:SQLM_System+2;
%%SET sentSigs(,TOWGETSCH)
    SEND towGetSch REFERENCE cOwnRef WITH
        SQLX_OtherBlock,
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLM_%%(tables[q1])_RootRow:SQLC_%%(tables[q1])_Right%%(q2),
        SQLM_%%(tables[q1])_WorkRow
%%LOOP(dr <= 15)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ,
        3,
        %%(bTreeCols%%(q3)_%%(q2)[0]),
        +,
%%SET towGetSchLab(%%(towGetSchLab + 1))
        %%(towGetSchLab);
    EXIT;
towGetSchLab%%(towGetSchLab))
    SQLM_%%(tables[q1])_WorkRow=SQLX_WorkRow;
    SQLM_%%(tables[q1])_OperRow=SQLX_Operrow;
! deallocate work row.!
%%INCLUDE(deAllocateWorkRow(%%(tables[q1])))
! check if a row is not found, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow = SQLM_TableReference:SQLM_System+1 THEN
%%SET sentSigs(,TOWDELROWR)
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue%%(q3);

! Work area is locked !
WORKLOCKtowDelRowTableKeyBTree%%(q3))
%%SET sentSigs(,TOWDELROWR)
    SEND towdelRowR WITH
        SQLX_OtherProtected,
! Error: Table work area locked for size alteration, operation refused!
        3 + 18 <= 8;
    EXIT;

! Work area is full!
WORKFULLtowDelRowTableKeyBTree%%(q3))
%%SET sentSigs(,TOWDELROWR)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
! Error: Table congestion, no work row free !
        3 + 8 <= 8;
    EXIT;
%%END(towDelRowTableKeyBTree)
-----------------------------------------------------------------------------







---------------------------------------------------------------------------
- Code component towDelRowTableKeyRow, chapter 17.3.2

- Parameters:
-       q1:             Table index.

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       q3

- Included code components:
---------------------------------------------------------------------------
%%BEGIN(towDelRowTableKeyRow)
!------------------------------------------------!
!       towDelRowTableKeyRow !
!------------------------------------------------!
%%SET q1(%%(towDelRowTableKeyRow[1]))
%%SET q3(%%(tabNos[q1]))
towDelRowTableKeyRow%%(q3))
! unpack key (set pOperRow).!
    DO SQLS_%%(tables[q1])_UnPackkey;
! check if row is outside table area, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
%%SET sentSigs(,TOWDELROWR)
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Allocated = 0 THEN
%%SET sentSigs(,TOWDELROWR)
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue%%(q3);
%%END(towDelRowTableKeyRow)
----------------------------------------------------------------------------





---------------------------------------------------------------------------
- Code component towDelRowTableKeyCursor, chapter 17.3.3

- Parameters:
-       q1:             Table index

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       q3

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(towDelRowTableKeyCursor)
!------------------------------------------------!
!       towDelRowTableKeyCursor !
!------------------------------------------------!
%%SET q1(%%(towDelRowTableKeyCursor[1]))
%%SET q3(%%(tabNos[q1]))
towDelRowTableKeyCursor%%(q3))
! unpack key (set pOperRow).!
    DO SQLS_%%(tables[q1])_UnPackkey;
    SQLM_%%(tables[q1])_OperRow =
        SQLM_%%(tables[q1])_WorkRow:%%(SQLC_%%(tables[q1])_LastRow);
! check if a row was not found, if so report failure.!
    IF SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_Lock = 2 THEN
%%SET sentSigs(,TOWDELROWR)
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Error: Invalid cursor position !
            3+16 <= 8;
        EXIT;
    FI;
! check if row is outside table area, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow >=
        SQLM_TableReference:SQLM_TableAllocated
    THEN
%%SET sentSigs(,TOWDELROWR)
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if row is not allocated, if so  report failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Allocated = 0 THEN
%%SET sentSigs(,TOWDELROWR)
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row not found !
            2+1 <= 8;
        EXIT;
    FI;
! check if DB number is the same, if not report failure.!
    IF SQLM_%%(tables[q1])_WorkRow:SQLC_%%(tables[q1])_DBnumber2 /=
        SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_DBnumber2
    THEN
%%SET sentSigs(,TOWDELROWR)
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row updated while accessing !
            2+4 <= 8;
        EXIT;
    FI;
    GOTO towDelRowTableKeyContinue%%(q3);
%%END(towDelRowTableKeyCursor)
------------------------------------------------------------------------------






---------------------------------------------------------------------------
- Code component towDelRowTableKeyContinue, chapter 17.3.4

- Parameters:
-       q1:             Table index.

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       q3

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(towDelRowTableKeyContinue)
!------------------------------------------------!
!       towDelRowTableKeyContinue !
!------------------------------------------------!
%%SET q1(%%(towDelRowTableKeyContinue[1]))
%%SET q3(%%(tabNos[q1]))
towDelRowTableKeyContinue%%(q3))
! check if row is locked, if so report failure.!
    IF SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Lock > 0 THEN
%%SET sentSigs(,TOWDELROWR)
        SEND towDelRowR WITH
            SQLX_OtherProtected,
! Search failure: Row locked for update or delete !
            2+2 <= 8,
            SQLM_%%(tables[q1])_OperRow;
        EXIT;
    FI;
! Lock Operating row.!
    SQLM_%%(tables[q1])_OperRow:SQLC_%%(tables[q1])_Lock  = 1;
! send back success.!
%%SET sentSigs(,TOWDELROWR)
    SEND towDelRowR WITH
        SQLX_OtherProtected,
        0,
        SQLM_%%(tables[q1])_OperRow;
    EXIT;
%%END(towDelRowTableKeyContinue)
---------------------------------------------------------------------------





---------------------------------------------------------------------------
-       18. HANDLE:TOWLETFLD
---------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towLetFld, chapter 18.1

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       i

- Included code components:
-       towLetFldTable
---------------------------------------------------------------------------
%%BEGIN(towLetFld)
!------------------------------------------------!
!       towLetFld !
!------------------------------------------------!
%%SET recSigs(,TOWLETFLD)
    ENTER towLetFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow,
        +,
        +,
        +
%%LOOP(dr <= 19)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
        ;
%%IF(tables[0]=1)
%%INCLUDE(towLetFldTable(1))
%%ELSE
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towLetFldTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
    EXIT;
%%ENDIF
%%END(towLetFld)
---------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towLetFldTable, chapter 18.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tables          All table names in the block.

- IMP variables defined:
-       None

- Temporary IMP variables:
-       None

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(towLetFldTable)
!------------------------------------------------!
!       towLetFldTable !
!------------------------------------------------!
%%SET p1(%%(towLetFldTable[1]))
    SQLM_%%(tables[p1])_WorkRow = SQLX_WorkRow;
! unpack data.!
    DO SQLS_%%(tables[p1])_UnPack;
! send back success.!
%%SET sentSigs(,TOWLETFLDR)
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
%%END(towLetFldTable)
---------------------------------------------------------------------------





---------------------------------------------------------------------------
-       19. HANDLE:TOWLETFLDFK
---------------------------------------------------------------------------

---------------------------------------------------------------------------
- Code component towLetFldFK, chapter 19.1

- IMP variables used:
-       tables          All table names in the block.
-       fkNullDefTabInds
-       fksNullDefI

- IMP variables defined:
-       None

- Temporary IMP variables:
-       i

- Included code components:
-       towLetFldFKTable
---------------------------------------------------------------------------
%%BEGIN(towLetFldFK)
%%IF(fkNullDefTabInds[0] > 0)
!------------------------------------------------!
!       towLetFldFK !
!------------------------------------------------!
%%SET recSigs(,TOWLETFLDFK)
    ENTER towLetFldFK WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_WorkRow,
        SQLX_KeyNumber;
%%IF(fkNullDefTabInds[0]=1)
%%INCLUDE(towLetFldFKTable(%%(fkNullDefTabInds[1])))
%%ELSE
    CASE SQLM_TableReference IS
%%LOOP(i, fkNullDefTabInds)
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towLetFldFKTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO;
    ESAC;
    EXIT;
%%ENDIF
%%ENDIF
%%END(towLetFldFK)
---------------------------------------------------------------------------



---------------------------------------------------------------------------
- Code component towLetFldFKTable, chapter 19.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreeColsI_J    Column numbers for all columns in table I btree J.
-       fksNullDefI     Key numbers for all FK with referential action SET NULL
-                       or SET DEFAULT in table I.
-       defValI_J       Default value for column J in table I. All values
-                       should be given as IMP strings.
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.


- IMP variables defined:
-       None

- Temporary IMP variables:
-       p3
-       l
-       k

- Included code components:
-       None
---------------------------------------------------------------------------
%%BEGIN(towLetFldFKTable)
!------------------------------------------------!
!       towLetFldFKTable !
!------------------------------------------------!
%%SET p1(%%(towLetFldFKTable[1]))
%%SET p3(%%(tabNos[p1]))
    SQLM_%%(tables[p1])_WorkRow = SQLX_WorkRow;
    CASE SQLX_KeyNumber IS
%%LOOP(l, fksNullDef%%(p3))
    WHEN %%(l) DO
%%IF(fkAct%%(p3)_%%(l) = "SET NULL")
%%LOOP(k, bTreeCols%%(p3)_%%(l))
        SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Null = 1;
%%ENDLOOP(k)
%%ELSIF(fkAct%%(p3)_%%(l) = "SET DEFAULT")
%%LOOP(k, bTreeCols%%(p3)_%%(l))
%%IF (defVal%%(p3)_%%(k) = "NULL")
        SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Null = 1;
%%ELSE
%%IF(colNull%%(p3)[k] = 1)
        SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Null = 0;
%%ENDIF
        SQLM_%%(tables[p1])_WorkRow:SQLC_%%(tables[p1])_%%(cols%%(p3)[k])_Data = %%(defVal%%(p3)_%%(k));
%%ENDIF
%%ENDLOOP(k)
%%ENDIF
%%ENDLOOP(l)
    OTHERWISE DO;
    ESAC;
! send back success.!
%%SET sentSigs(,TOWLETFLDR)
    SEND towLetFldR WITH
        SQLX_OtherProtected,
        0;
    EXIT;
%%END(towLetFldFKTable)
---------------------------------------------------------------------------
-----------------------------------------------------------------------------
-       29.HANDLE: TOWGETTABNAM
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-Code component towGetTabNam, chapter 29.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- Temporary IMP variables:
-       i

- Included code components:
-       towGetTabNamTable
-------------------------------------------------------------------------------
%%BEGIN(towGetTabNam)
!--------------------------------!
!       towGetTabNam!
!--------------------------------!
%%SET recSigs(,TOWGETTABNAM)
    RECEIVE towGetTabNam WITH
        SQLX_OtherProtected,
        SQLM_TableReference;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetTabNamTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%SET sentSigs(,TOWGETTABNAMACK)
        RETURN towGetTabNamAck WITH SQLX_OtherProtected, 1;
    ESAC;
%%END(towGetTabNam)
--------------------------------------------------------------------------




--------------------------------------------------------------------------
-Code component towGetTabNamTable, chapter 29.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tabSlogans      The table slogans for the tables in 'tables'.

- Temporary IMP variables:
-       None

- Included code components:
-       None
----------------------------------------------------------------------------
%%BEGIN(towGetTabNamTable)
!--------------------------------!
!       towGetTabNamTable!
!--------------------------------!
%%SET p1(%%(towGetTabNamTable[1]))
%%SET sentSigs(,TOWGETTABNAMACK)
    RETURN towGetTabNamAck WITH
        SQLX_OtherProtected,
        0,
        %%(tabSlogans[p1]);
%%END(towGetTabNamTable)
----------------------------------------------------------------------------





----------------------------------------------------------------------------
-       30. HANDLE: TOWGETTABDAT
-------------------------------------------------------------------------------

-------------------------------------------------------------------------
-Code component towGetTabDat, chapter 30.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- Temporary IMP variables:
-       i

- Included code components:
-       towGetTabDatTable
-------------------------------------------------------------------------------
%%BEGIN(towGetTabDat)
!--------------------------------!
!       towGetTabDat!
!--------------------------------!
%%SET recSigs(,TOWGETTABDAT)
    RECEIVE towGetTabDat WITH
        SQLX_OtherProtected,
        SQLM_TableReference;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetTabDatTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%SET sentSigs(,TOWGETTABDATACK)
        RETURN towGetTabDatAck WITH SQLX_OtherProtected, 1;
    ESAC;
%%END(towGetTabDat)
-----------------------------------------------------------------------------


--------------------------------------------------------------------------
-Code component towGetTabDatTable, chapter 30.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       tabSaes         The Size Alterations events for the table areas for
                        the tables in'tables'.
-       tabMaxSize      The maximum table area sizes for the tables in 'tables'.
-       tabRelDivs      The expansion steps for the table areas for the tables
                        in 'tables'.
-       locCodesI       The local status codes (numbers) for table I.
-       workSaes        The Size Alterations events for the work areas for the
                        tables in 'tables'
-       workRelDivs     The expansion steps for the work areas for the tables
                        in 'tables'.
-       workMaxSize     The maximum work area sizes for the tables in 'tables'.

- Temporary IMP variables:
-       p3

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetTabDatTable)
!--------------------------------!
!       towGetTabDatTable!
!--------------------------------!
%%SET p1(%%(towGetTabDatTable[1]))
%%SET p3(%%(tabNos[p1]))
    VARIABLENUMBER FOR SQLC_%%(tables[p1])_Lock TO SQLX_BaseAddress1;
    VARIABLENUMBER FOR SQLC_%%(tables[p1])_DBnumber TO SQLX_BaseAddress2;
%%SET sentSigs(,TOWGETTABDATACK)
    RETURN towGetTabDatAck WITH
        SQLX_OtherProtected,
        0,
%%IF(tabSaes[p3]="")
        1,
%%ELSE
        0,
%%ENDIF
        %%(tabSaes[p3]),
        %%(tabMaxSizes[p3]),
        SQLM_TableReference:SQLM_TableAllocated,
        SQLM_TableReference:SQLM_TableUsed,
        %%(tabRelDivs[p3]),
%%IF(workSaes[p3]="")
        1,
%%ELSE
        0,
%%ENDIF
        %%(workSaes[p3]),
        %%(workMaxSizes[p3]),
        SQLM_TableReference:SQLM_WorkAllocated,
        SQLM_TableReference:SQLM_WorkUsed,
        %%(workRelDivs[p3]),
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
%%IF(locCodes%%(p3)(?))
        %%(locCodes%%(p3)[0]),
%%ELSE
        0,
%%ENDIF
%%IF(bTrees%%(p3)[0] > 0)
        %%(bTrees%%(p3)[bTrees%%(p3)[0]]);%%-- Highest btree number
%%ELSE
        0;
%%ENDIF
%%END(towGetTabDatTable)
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
-       31. HANDLE:TOWGETFLDNAM
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-Code component towGetFldNam, chapter 31.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
- Temporary IMP variables:
-       i

- Included code components:
-       towGetFldNamTable
-------------------------------------------------------------------------------
%%BEGIN(towGetFldNam)
!--------------------------------!
!       towGetFldNam!
!--------------------------------!
%%SET recSigs(,TOWGETFLDNAM)
    RECEIVE towGetFldNam WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetFldNamTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%SET sentSigs(,TOWGETFLDNAMACK)
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 1;
    ESAC;
%%END(towGetFldNam)
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-Code component towGetFldNamTable, chapter 31.2

- Parameters:
-       p1:             Table index.

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).

- Temporary IMP variables:
-       j
-       p3

- Included code components:
-       towGetFldNamTableColumn
-------------------------------------------------------------------------------
%%BEGIN(towGetFldNamTable)
!--------------------------------!
!       towGetFldNamTable!
!--------------------------------!
%%SET p1(%%(towGetFldNamTable[1]))
%%SET p3(%%(tabNos[p1]))
    CASE SQLX_ColumnReference IS
%%LOOP(j <= cols%%(p3)[0])
    WHEN %%(j) DO
%%INCLUDE(towGetFldNamTableColumn(%%(p3),%%(j)))
%%ENDLOOP(j)
    OTHERWISE DO
%%SET sentSigs(,TOWGETFLDNAMACK)
        RETURN towGetFldNamAck WITH SQLX_OtherProtected, 2;
    ESAC;
%%END(towGetFldNamTable)
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-Code component towGetFldNamTableColumn, chapter 31.3

- Parameters:
-       q1:             Table number
-       q2:             Column number.

- IMP variables used:
-       tables          All table names in the block.
-       colSlogansI[J]  Slogan for column J in table I. Each element must have
                        exactly characters.

- Temporary IMP variables:
-       None

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetFldNamTableColumn)
!--------------------------------!
!       towGetFldNamTableColumn!
!--------------------------------!
%%SET q1(%%(towGetFldNamTableColumn[1]))
%%SET q2(%%(towGetFldNamTableColumn[2]))
%%SET sentSigs(,TOWGETFLDNAMACK)
    RETURN towGetFldNamAck WITH
        SQLX_OtherProtected,
        0,
        %%(colSlogans%%(q1)[q2]);
%%END(towGetFldNamTableColumn)
-----------------------------------------------------------------------------




-----------------------------------------------------------------------------
-       32. HANDLE: TOWGETSTRFLD
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-Code component towGetStrFld, chapter 32.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
- Temporary IMP variables:
-       i

- Included code components:
-       towGetStrFldTable
-------------------------------------------------------------------------------
%%BEGIN(towGetStrFld)
!--------------------------------!
!       towGetStrFld!
!--------------------------------!
%%SET recSigs(,TOWGETSTRFLD)
    RECEIVE towGetStrFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetStrFldTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%SET sentSigs(,TOWGETSTRFLDACK)
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
%%END(towGetStrFld)
--------------------------------------------------------------------------



--------------------------------------------------------------------------
-Code component towGetStrFldTable, chapter 32.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tabNos          The table numbers for the tables in 'tables'.
-       strColsI        The column numbers for all string and numstring
                        columns in table I.
-       colTypesI[J]    Column type for column J in table I. One of: "BITS",
                        "STRING", "NUMSTRING", "PACKED NUMSTRING", "SYMBOL",
                        "DBNUMBER".

- Temporary IMP variables:
-       j
-       k
-       p3
-       colTypes
-       Cols

- Included code components:
-       towGetStrFldTableColumn
-------------------------------------------------------------------------------
%%BEGIN(towGetStrFldTable)
!--------------------------------!
!       towGetStrFldTable!
!--------------------------------!
%%SET p1(%%(towGetStrFldTable[1]))
%%SET p3(%%(tabNos[i]))
%%IF(strCols%%(p3)[0] + numCols%%(p3)[0] > 0)
    CASE SQLX_ColumnReference IS
%%SET colTypes(str, num)
%%LOOP(k, colTypes)
%%LOOP(j, %%(k)Cols%%(p3))
    WHEN %%(j) DO
%%INCLUDE(towGetStrFldTableColumn(%%(p1),%%(j)))
%%ENDLOOP(j)
%%ENDLOOP(k)
    OTHERWISE DO
%%ENDIF
%%SET sentSigs(,TOWGETSTRFLDACK)
        RETURN towGetStrFldAck WITH SQLX_OtherProtected, 2;
%%IF(strCols%%(p3)[0] + numCols%%(p3)[0] > 0)
    ESAC;
%%ENDIF
%%END(towGetStrFldTable)
--------------------------------------------------------------------------



--------------------------------------------------------------------------
-Code component towGetStrFldTableColumn, chapter 32.3

- Parameters:
-       q1:             Table index
-       q2:             Column number.

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.
-       defValI_J       Default value for column J in table I. All
                        values should be given as IMP strings.
-       colDidNoI_J     The DID number column J in table I. Set only if column
                        J has a DID number.
-       colDidPosI_J    The DID position for column J in table I. Set only if
                        column J has a DID position.

- Temporary IMP variables:
-       q3

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetStrFldTableColumn)
!--------------------------------!
!       towGetStrFldTableColumn!
!--------------------------------!
%%SET q1(%%(towGetStrFldTableColumn[1]))
%%SET q2(%%(towGetStrFldTableColumn[2]))
%%SET q3(%%(tabNos[q1]))
%%IF(colNull%%(q3)[q2] = 1)
    VARIABLENUMBER FOR SQLC_%%(tables[q1])_%%(cols%%(q3)[q2])_Null TO
        SQLX_BaseAddress1;
%%ELSE
    SQLX_BaseAddress1=0;
%%ENDIF
    VARIABLENUMBER FOR SQLC_%%(tables[q1])_%%(cols%%(q3)[q2])_Data TO
        SQLX_BaseAddress2;
%%SET sentSigs(,TOWGETSTRFLDACK)
    RETURN towGetStrFldAck WITH
        SQLX_OtherProtected,
        0,
%%IF(colNull%%(q3)[q2] = 1)
%%IF(defVal%%(q3)_%%(q2)(?))
%%IF(defVal%%(q3)_%%(q2) = "NULL")
        4,
%%ELSE
        2,
%%ENDIF
%%ELSE
        0,
%%ENDIF
%%ELSE
%%IF(defVal%%(q3)_%%(q2)(?))
        3,
%%ELSE
        1,
%%ENDIF
%%ENDIF
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
%%IF(defVal%%(q3)_%%(q2)(?))
%%IF(defVal%%(q3)_%%(q2) # "NULL")
        %%(defVal%%(q3)_%%(q2)),
%%ELSE
        "",
%%ENDIF
%%ELSE
        "",
%%ENDIF
%%IF(NOT colDidNo%%(q3)_%%(q2)(?))
        1;
%%ELSE
        0, %%(colDidNo%%(q3)_%%(q2)), %%(colDidPos%%(q3)_%%(q2));
%%ENDIF
%%END(towGetStrFldTableColumn)
-----------------------------------------------------------------------------



-----------------------------------------------------------------------------
-       33. HANDLE: TOWGETNUMFLD
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-Code component towGetNumFld, chapter 33.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- Temporary IMP variables:
-       i

- Included code components:
-       towGetNumFldTable
-------------------------------------------------------------------------------
%%BEGIN(towGetNumFld)
!--------------------------------!
!       towGetNumFld!
!--------------------------------!
%%SET recSigs(,TOWGETNUMFLD)
    RECEIVE towGetNumFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetNumFldTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%SET sentSigs(,TOWGETNUMFLDACK)
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
%%END(towGetNumFld)
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-Code component towGetNumFldTable, chapter 33.2

- Parameters:
-       p1:             Table index.

- IMP variables used:
-       tabNos          The table numbers for the tables in 'tables'.
-       bitsColsI
-       symColsI

- Temporary IMP variables:
-       j
-       k
-       p3
-       colTypes
-       Cols

- Included code components:
-       towGetNumFldTableColumn
-------------------------------------------------------------------------------
%%BEGIN(towGetNumFldTable)
!--------------------------------!
!       towGetNumFldTable!
!--------------------------------!
%%SET p1(%%(towGetNumFldTable[1]))
%%SET p3(%%(tabNos[p1]))
%%IF(bitsCols%%(p3)[0] + symCols%%(p3)[0] > 0)
    CASE SQLX_ColumnReference IS
%%SET colTypes(bits, sym)
%%LOOP(k, colTypes)
%%LOOP(j, %%(k)Cols%%(p3))
    WHEN %%(j) DO
%%INCLUDE(towGetNumFldTableColumn(%%(p1),%%(j)))
%%ENDLOOP(j)
%%ENDLOOP(k)
    OTHERWISE DO
%%ENDIF
%%SET sentSigs(,TOWGETNUMFLDACK)
        RETURN towGetNumFldAck WITH SQLX_OtherProtected, 2;
%%IF(bitsCols%%(p3)[0] + symCols%%(p3)[0] > 0)
    ESAC;
%%ENDIF
%%END(towGetNumFldTable)
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-Code component towGetNumFldTableColumn, chapter 33.3

- Parameters:
-       q1:             Table index
-       q2              Column number.

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.
-       defValI_J       Default value for column J in table I. All
                        values should be given as IMP strings.
-       colMinI_J       The min value for column J in table I. Set for all
                        BITS columns (0 if not explicitly stated).
-       colMaxI_J       The max value for column J in table I. Set for all
                        BITS columns (2 ** <size> if not explicitly stated).
-       colDidNoI_J     The DID number column J in table I. Set only if column
                        J has a DID number.
-       colDidPosI_J    The DID position for column J in table I. Set only if
                        column J has a DID position.
-       symLitsI_J      Symbol value integers for column J in tableI in the
                        same order as 'symValsIJ'.

- Temporary IMP variables:
-       q3

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetNumFldTableColumn)
!--------------------------------!
!       towGetNumFldTableColumn!
!--------------------------------!
%%SET q1(%%(towGetNumFldTableColumn[1]))
%%SET q2(%%(towGetNumFldTableColumn[2]))
%%SET q3(%%(tabNos[q1]))
%%IF(colNull%%(q3)[q2] = 1)
    VARIABLENUMBER FOR SQLC_%%(tables[q1])_%%(cols%%(q3)[q2])_Null TO
        SQLX_BaseAddress1;
%%ELSE
    SQLX_BaseAddress1=0;
%%ENDIF
    VARIABLENUMBER FOR SQLC_%%(tables[q1])_%%(cols%%(q3)[q2])_Data TO
        SQLX_BaseAddress2;
%%SET sentSigs(,TOWGETNUMFLDACK)
    RETURN towGetNumFldAck WITH
        SQLX_OtherProtected,
        0,
%%IF(colNull%%(q3)[q2] = 1)
        0,
%%ELSE
        1,
%%ENDIF
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
%%IF(NOT defVal%%(q3)_%%(q2)(?))
        0, 0,
%%ELSE
%%IF(defVal%%(q3)_%%(q2) # "NULL")
        1, %%(defVal%%(q3)_%%(q2)),
%%ELSE
        2, 0,
%%ENDIF
%%ENDIF
%%IF(bitsCols%%(q3)(%%(q2)))
        %%(colMin%%(q3)_%%(q2)),
        %%(colMax%%(q3)_%%(q2)),
%%ELSE
        %%(symLits%%(q3)_%%(q2)[1]),
        %%(symLits%%(q3)_%%(q2)[symLits%%(q3)_%%(q2)[0]]),
%%ENDIF
%%IF(NOT colDidNo%%(q3)_%%(q2)(?))
        1;
%%ELSE
        0, %%(colDidNo%%(q3)_%%(q2)), %%(colDidPos%%(q3)_%%(q2));
%%ENDIF
%%END(towGetNumFldTableColumn)
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
-       34. HANDLE: TOWGETPCKFLD
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-Code component towGetPckFld, chapter 34.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- Temporary IMP variables:
-       i

- Included code components:
-       towGetPckFldTable
-------------------------------------------------------------------------------
%%BEGIN(towGetPckFld)
!--------------------------------!
!       towGetPckFld!
!--------------------------------!
%%SET recSigs(,TOWGETPCKFLD)
    RECEIVE towGetPckFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetPckFldTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%SET sentSigs(,TOWGETPCKFLDACK)
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
%%END(towGetPckFld)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
-Code component towGetPckFldTable, chapter 34.2

- IMP variables used:
- Temporary IMP variables:


- Included code components:
-       towGetPckFldTableColumn
-------------------------------------------------------------------------------
%%BEGIN(towGetPckFldTable)
!--------------------------------!
!       towGetPckFldTable!
!--------------------------------!
%%SET p1(%%(towGetPckFldTable[1]))
%%SET p3(%%(tabNos[p1]))
%%IF(packNumCols%%(p3)[0] > 0)
    CASE SQLX_ColumnReference IS
%%LOOP(j, packNumCols%%(p3))
    WHEN %%(j) DO
%%INCLUDE(towGetPckFldTableColumn(%%(p1),%%(j)))
%%ENDLOOP(j)
    OTHERWISE DO
%%ENDIF
%%SET sentSigs(,TOWGETPCKFLDACK)
        RETURN towGetPckFldAck WITH SQLX_OtherProtected, 2;
%%IF(packNumCols%%(p3)[0] > 0)
    ESAC;
%%ENDIF
%%END(towGetPckFldTable)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
-Code component towGetPckFldTableColumn, chapter 34.3

- Parameters:
-       q1:             Table index
-       q2:             Column number

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       colsI[J]        Column name for column J in table I. Includes dbnumber
-                       column (column 1) but not rownumber columns (column 0).
-       colNullI[J]     Nulls allowed for column J in table I, 1 is Nulls
                        allowed, 0 otherwise.
-       defValI_J       Default value for column J in table I. All
                        values should be given as IMP strings.
-       colMinI_J       The min value for column J in table I. Set for all
                        BITS columns (0 if not explicitly stated).
-       colMaxI_J       The max value for column J in table I. Set for all
                        BITS columns (2 ** <size> if not explicitly stated).
-       colDidNoI_J     The DID number column J in table I. Set only if column
                        J has a DID number.
-       colDidPosI_J    The DID position for column J in table I. Set only if
                        column J has a DID position.

- Temporary IMP variables:
-       q3

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetPckFldTableColumn)
!--------------------------------!
!       towGetPckFldTableColumn!
!--------------------------------!
%%SET q1(%%(towGetPckFldTableColumn[1]))
%%SET q2(%%(towGetPckFldTableColumn[2]))
%%SET q3(%%(tabNos[q1]))
%%IF(colNull%%(q3)[q2] = 1)
    VARIABLENUMBER FOR SQLC_%%(tables[q1])_%%(cols%%(q3)[q2])_Null TO
        SQLX_BaseAddress1;
%%ELSE
    SQLX_BaseAddress1=0;
%%ENDIF
    VARIABLENUMBER FOR SQLC_%%(tables[q1])_%%(cols%%(q3)[q2])_Data TO
        SQLX_BaseAddress2;
%%SET sentSigs(,TOWGETPCKFLDACK)
    RETURN towGetPckFldAck WITH
        SQLX_OtherProtected,
        0,
%%IF(colNull%%(q3)[q2] = 1)
        0,
%%ELSE
        1,
%%ENDIF
        SQLX_BaseAddress1,
        SQLX_BaseAddress2,
%%IF(NOT defVal%%(q3)_%%(q2)(?))
        0, 0, 0, 0, 0, 0, 0, 0, 0,
%%ELSE
%%IF(defVal%%(q3)_%%(q2) # "NULL")
        1,
        %%(defVal%%(q3)_%%(q2)).Length,
        %%(defVal%%(q3)_%%(q2)).W1,
        %%(defVal%%(q3)_%%(q2)).W2,
        %%(defVal%%(q3)_%%(q2)).W3,
%%IF(colSizes%%(q3)[q2] = 28)
        %%(defVal%%(q3)_%%(q2)).W4,
        %%(defVal%%(q3)_%%(q2)).W5,
        %%(defVal%%(q3)_%%(q2)).W6,
        %%(defVal%%(q3)_%%(q2)).W7,
%%ELSE
        0, 0, 0, 0,
%%ENDIF
%%ELSE
        2, 0, 0, 0, 0, 0, 0, 0, 0,
%%ENDIF
%%ENDIF
%%IF(NOT colDidNo%%(q3)_%%(q2)(?))
        1;
%%ELSE
        0, %%(colDidNo%%(q3)_%%(q2)), %%(colDidPos%%(q3)_%%(q2));
%%ENDIF
%%END(towGetPckFldTableColumn)
-----------------------------------------------------------------------------



-----------------------------------------------------------------------------
-       35. HANDLE: TOWGETKEYFLD
-------------------------------------------------------------------------------

-------------------------------------------------------------------------
-Code component towGetKeyFld, chapter 35.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- Temporary IMP variables:
-       i

- Included code components:
-       towGetKeyFldTable
-------------------------------------------------------------------------------
%%BEGIN(towGetKeyFld)
!--------------------------------!
!       towGetKeyFld!
!--------------------------------!
%%SET recSigs(,TOWGETKEYFLD)
    RECEIVE towGetKeyFld WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber,
        SQLX_ComponentReference;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetKeyFldTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%SET sentSigs(,TOWGETKEYFLDACK)
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 1;
    ESAC;
%%END(towGetKeyFld)
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-Code component towGetKeyFldTable, chapter 35.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.

- Temporary IMP variables:
-       j
-       p3

- Included code components:
-       towGetKeyFldTableKey
-------------------------------------------------------------------------------
%%BEGIN(towGetKeyFldTable)
!--------------------------------!
!       towGetKeyFldTable!
!--------------------------------!
%%SET p1(%%(towGetKeyFldTable[1]))
%%SET p3(%%(tabNos[p1]))
    CASE SQLX_KeyNumber IS
%%IF(NOT bTrees%%(p3)(2))
    WHEN 0, 2 DO
%%ELSE
    WHEN 0 DO
%%ENDIF
%%INCLUDE(towGetKeyFldTableKey(%%(p1), 0))
%%LOOP(j, bTrees%%(p3))
    WHEN %%(j) DO
%%INCLUDE(towGetKeyFldTableKey(%%(p1), %%(j)))
%%ENDLOOP(j)
    OTHERWISE DO
%%SET sentSigs(,TOWGETKEYFLDACK)
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 2;
    ESAC;
%%END(towGetKeyFldTable)
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-Code component towGetKeyFldTableKey, chapter 35.3

- Parameters:
-       q1              Table index
-       q2              Key number.

- IMP variables used:
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreeColsI_J    Column numbers for all columns in table I btree J.

- Temporary IMP variables:
-       q3
-       l

- Included code components:
-       towGetKeyFldTableKeyComponent
-------------------------------------------------------------------------------
%%BEGIN(towGetKeyFldTableKey)
!--------------------------------!
!       towGetKeyFldTableKey!
!--------------------------------!
%%SET q1(%%(towGetKeyFldTableKey[1]))
%%SET q2(%%(towGetKeyFldTableKey[2]))
%%SET q3(%%(tabNos[q1]))
    CASE SQLX_ComponentReference IS
%%IF(q2 = 0)
    WHEN 0 DO
%%INCLUDE(towGetKeyFldTableKeyComponent(0))
%%ELSE
%%LOOP(l <= bTreeCols%%(q3)_%%(q2)[0])
    WHEN %%(l - 1) DO
%%INCLUDE(towGetKeyFldTableKeyComponent(%%(bTreeCols%%(q3)_%%(q2)[l])))
%%ENDLOOP(l)
%%ENDIF
    OTHERWISE DO
%%SET sentSigs(,TOWGETKEYFLDACK)
        RETURN towGetKeyFldAck WITH SQLX_OtherProtected, 3;
    ESAC;
%%END(towGetKeyFldTableKey)
--------------------------------------------------------------------------



--------------------------------------------------------------------------
-Code component towGetKeyFldTableKeyComponent, chapter 35.4

- Parameters:
-       r1:             Column number.

- IMP variables used:
-       None

- Temporary IMP variables:
-       None

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetKeyFldTableKeyComponent)
!--------------------------------------!
!       towGetKeyFldTableKeyComponent!
!--------------------------------------!
%%SET r1(%%(towGetKeyFldTableKeyComponent[1]))
%%SET sentSigs(,TOWGETKEYFLDACK)
    RETURN towGetKeyFldAck WITH
        SQLX_OtherProtected,
        0,
        %%(r1);
%%END(towGetKeyFldTableKeyComponent)
-----------------------------------------------------------------------------



-----------------------------------------------------------------------------
-       36. HANDLE: TOWGETKEYDAT
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
- Code component towGetKeyDat, chapter 36.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'table
- Temporary IMP variables:
-       i

- Included code components:
-       towGetKeyDatTable
-------------------------------------------------------------------------------
%%BEGIN(towGetKeyDat)
!--------------------------------!
!       towGetKeyDat!
!--------------------------------!
%%SET recSigs(,TOWGETKEYDAT)
    RECEIVE towGetKeyDat WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetKeyDatTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%SET sentSigs(,TOWGETKEYDATACK)
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 1;
    ESAC;
%%END(towGetKeyDat)
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-Code component towGetKeyDatTable, chapter 36.2

- Parameters:
-       p1:             Table index.

- IMP variables used:
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreesI         Key numbers for all btrees in table I, may be empty.

- Temporary IMP variables:
-       j
-       p3

- Included code components:
-       towGetKeyDatTableKey
-----------------------------------------------------------------------------
%%BEGIN(towGetKeyDatTable)
!--------------------------------!
!       towGetKeyDatTable!
!--------------------------------!
%%SET p1(%%(towGetKeyDatTable[1]))
%%SET p3(%%(tabNos[p1]))
    CASE SQLX_KeyNumber IS
%%IF(NOT (bTrees%%(p3)(2)))
    WHEN 2 DO
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 0, 0, 1;
%%ENDIF
%%LOOP(j, bTrees%%(p3))
    WHEN %%(j) DO
%%INCLUDE(towGetKeyDatTableKey(%%(p1),%%(j)))
%%ENDLOOP(j)
    OTHERWISE DO
%%SET sentSigs(,TOWGETKEYDATACK)
        RETURN towGetKeyDatAck WITH SQLX_OtherProtected, 2;
    ESAC;
%%END(towGetKeyDatTable)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
-Code component towGetKeyDatTableKey, chapter 36.3

- Parameters:
-       q1:             Table index
-       q2:             Key number.

IMP-variables used:
-       tabNos          The table numbers for the tables in 'tables'.
-       bTreesI         Key numbers for all bTrees in table I, may be empty.
-       aks             Key numbers for all AK in table I, may be empty.
-       fks             Key numbers for all FK in table I, may be empty.

- Temporary IMP variables:
-       q3

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetKeyDatTableKey)
!--------------------------------!
!       towGetKeyDatTableKey!
!--------------------------------!
%%SET q1(%%(towGetKeyDatTableKey[1]))
%%SET q2(%%(towGetKeyDatTableKey[2]))
%%SET q3(%%(tabNos[q1]))
%%SET sentSigs(,TOWGETKEYDATACK)
    RETURN towGetKeyDatAck WITH
        SQLX_OtherProtected,
        0,
%%IF(q2 = 2)
        0,
%%ELSIF(aks%%(q3)(%%(q2)))
        1,
%%ELSIF(fks%%(q3)(%%(q2)))
        3,
%%ELSE
        2,
%%ENDIF
        %%(bTreeCols%%(q3)_%%(q2)[0]);
    EXIT;
%%END(towGetKeyDatTableKey)
-----------------------------------------------------------------------------




-------------------------------------------------------------------------------
-       37. HANDLE: TOWGETFKS
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-Code component towGetFks, chapter 37.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.
-       fkTabInds       ????
- Temporary IMP variables:
-       i

- Included code components:
-       towGetFksTable
-------------------------------------------------------------------------------
%%BEGIN(towGetFks)
!--------------------------------!
!       towGetFks!
!--------------------------------!
%%SET recSigs(,TOWGETFKS)
    RECEIVE towGetFks WITH
        SQLX_OtherProtected,
        SQLM_TableReference;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetFksTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%SET sentSigs(,TOWGETFKSACK)
        RETURN towGetFksAck WITH SQLX_OtherProtected, 1;
    ESAC;
%%END(towGetFks)
-------------------------------------------------------------------------------



-------------------------------------------------------------------------------
-Code component towGetFksTable, chapter 37.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tabNos          The table numbers for the tables in 'tables'.
-       fksI            Key numbers for all FK in table I, may be empty.

- Temporary IMP variables:
-       p3

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetFksTable)
!--------------------------------!
!       towGetFksTable!
!--------------------------------!
%%SET p1(%%(towGetFksTable[1]))
%%SET p3(%%(tabNos[p1]))
! send back success.!
%%SET sentSigs(,TOWGETFKSACK)
    RETURN towGetFksAck WITH
        SQLX_OtherProtected,
        0,
        %%(fks%%(p3)[0]),
%%IF(fks%%(p3)[0] > 0)
        %%(fks%%(p3)[1]);
%%ELSE
        0;
%%ENDIF
%%END(towGetFksTable)
--------------------------------------------------------------------------





------------------------------------------------------------------------------
-       38. HANDLE: TOWGETFKINF
------------------------------------------------------------------------------
---------------------------------------------------------------------------
-Code component towGetFkInf, chapter 38.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- Temporary IMP variables:
-       i

- Included code components:
-       towGetFkInfTable
-------------------------------------------------------------------------------
%%BEGIN(towGetFkInf)
!--------------------------------!
!       towGetFkInf!
!--------------------------------!
%%SET recSigs(,TOWGETFKINF)
    RECEIVE towGetFkInf WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_KeyNumber;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetFkInfTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%SET sentSigs(,TOWGETFKINFACK)
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 1;
    ESAC;
%%END(towGetFkInf)
--------------------------------------------------------------------------



--------------------------------------------------------------------------
-Code component towGetFkInfTable, chapter 38.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tabNos          The table numbers for the tables in 'tables'.
-       fksI            Key numbers for all FK in table I, may be empty.
-       fktabI_J        Delete action for FK J in table I, one of the strings
                        "RESTRICT", "CASCADE", "SET NULL" or "SET DEFAULT".

- Temporary IMP variables:
-       p3
-       j

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetFkInfTable)
!--------------------------------!
!       towGetFkInfTable!
!--------------------------------!
%%SET p1(%%(towGetFkInfTable[1]))
%%SET p3(%%(tabNos[p1]))
%%IF(fks%%(p3)[0] > 0)
    CASE SQLX_KeyNumber IS
%%LOOP(j, fks%%(p3))
    WHEN %%(j) DO
%%SET sentSigs(,TOWGETFKINFACK)
        RETURN towGetFkInfAck WITH
            SQLX_OtherProtected,
            0,
            "%%(fkTab%%(p3)_%%(j))";
%%ENDLOOP(j)
    OTHERWISE DO;
%%ENDIF
%%SET sentSigs(,TOWGETFKINFACK)
        RETURN towGetFkInfAck WITH SQLX_OtherProtected, 2;
%%IF(fks%%(p3)[0] > 0)
    ESAC;
%%ENDIF
%%END(towGetFkInfTable)
----------------------------------------------------------------------------





----------------------------------------------------------------------------
        39. HANDLE: towGetFlt
----------------------------------------------------------------------------

--------------------------------------------------------------------------
-Code component towGetFlt, chapter 39.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- Temporary IMP variables:
-       i

- Included code components:
-       towGetFltTable
-------------------------------------------------------------------------------
%%BEGIN(towGetFlt)
!--------------------------------!
!       towGetFlt!
!--------------------------------!
%%SET recSigs(,TOWGETFLT)
    RECEIVE towGetFlt WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_FaultCode;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetFltTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%SET sentSigs(,TOWGETFLTACK)
        RETURN towGetFltAck WITH SQLX_OtherProtected, 1;
    ESAC;
%%END(towGetFlt)
-----------------------------------------------------------------------




-----------------------------------------------------------------------
-Code component towGetFltTable, chapter 39.2

- Parameters:
-       p1:             Table index.

- IMP variables used:
-       tabNos          The table numbers for the tables in 'tables'.
-       locCodesI       The local status codes (numbers) for tables I. Set only                         if the table has local status codes.

- Temporary IMP variables:
-       p3
-       j

- Included code components:
-       towGetFltTableFault
-----------------------------------------------------------------------------
%%BEGIN(towGetFltTable)
!--------------------------------!
!       towGetFltTable!
!--------------------------------!
%%SET p1(%%(towGetFltTable[1]))
%%SET p3(%%(tabNos[p1]))
%%IF(locCodes%%(p3)(?))
    CASE SQLX_FaultCode IS
%%LOOP(j <= locCodes%%(p3)[0])
    WHEN %%(locCodes%%(p3)[j]) DO
%%INCLUDE(towGetFltTableFault(%%(p3), %%(j)))
%%ENDLOOP(j)
    OTHERWISE DO
%%ENDIF
%%SET sentSigs(,TOWGETFLTACK)
        RETURN towGetFltAck WITH SQLX_OtherProtected, 2;
%%IF(locCodes%%(p3)(?))
    ESAC;
%%ENDIF
%%END(towGetFltTable)
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-Code component towGetFltTableFault, chapter 39.3

- Parameters:
-       q1:             Table number
-       q2:             Fault index

IMP-variables used:
-       locStringsI     The meaning of the codes in 'locCodesI'(strings).
                        Set only if the table has local status codes.

- Temporary IMP variables:
-       None

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetFltTableFault)
!--------------------------------!
!       towGetFltTableFault!
!--------------------------------!
%%SET q1(%%(towGetFltTableFault[1]))
%%SET q2(%%(towGetFltTableFault[2]))
%%SET sentSigs(,TOWGETFLTACK)
   RETURN towGetFltAck WITH
        SQLX_OtherProtected,
        0,
        %%(locStrings%%(q1)[q2]);
%%END(towGetFltTableFault)
----------------------------------------------------------------------------



----------------------------------------------------------------------------    -       40. HANDLE: TOWGETPREFLT
----------------------------------------------------------------------------
--------------------------------------------------------------------------
-Code component towGetPreFlt, chapter 40.1

IMP-variables used:
-       codeTabInds
-       tabNos

- Temporary IMP variables:
-       i

- Included code components:
-       towGetPreFltTable
-------------------------------------------------------------------------------
%%BEGIN(towGetPreFlt)
!--------------------------------!
!       towGetPreFlt!
!--------------------------------!
%%SET recSigs(,TOWGETPREFLT)
    RECEIVE towGetPreFlt WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_FaultCode;
%%IF(codeTabInds[0] > 0)
    SQLX_ReturnCode=0;
    CASE SQLM_TableReference IS
%%LOOP(i, codeTabInds)
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetPreFltTable(%%(tabNos[i])))
%%ENDLOOP(i)
    OTHERWISE DO
%%ENDIF
        SQLX_ReturnCode=1;
%%IF(codeTabInds[0] > 0)
    ESAC;
%%ENDIF
%%SET sentSigs(,TOWGETPREFLTACK)
    RETURN towGetPreFltAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_FaultCode;
%%END(towGetPreFlt)
--------------------------------------------------------------------------
-Code component towGetPreFltTable, chapter 40.2

- Parameters:
-       q1:             Table number

IMP-variables used:
-       locCodesI
-       locStringsI     The meaning of the codes in 'locCodesI'(strings).
                        Set only if the table has local status codes.

- Temporary IMP variables:
-       j

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetPreFltTable)
!--------------------------------!
!       towGetPreFlt!
!--------------------------------!
%%SET q1(%%(towGetPreFltTable[1]))
    IF SQLX_FaultCode > %%(locCodes%%(q1)[locCodes%%(q1)[0]]) THEN
        SQLX_FaultCode=%%(locCodes%%(q1)[locCodes%%(q1)[0]]);
%%LOOP(j <= locCodes%%(q1)[0] - 1)
    ELSIF SQLX_FaultCode > %%(locCodes%%(q1)[locCodes%%(q1)[0] - j]) THEN
        SQLX_FaultCode=%%(locCodes%%(q1)[locCodes%%(q1)[0] - j]);
%%ENDLOOP(j)
    ELSE
        SQLX_ReturnCode=2;
    FI;
%%END(towGetPreFltTable)
----------------------------------------------------------------------------


----------------------------------------------------------------------------
-       41. HANDLE: TOWGETSYMBOL
----------------------------------------------------------------------------

--------------------------------------------------------------------------
-Code component towGetSymbol, chapter 41.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- Temporary IMP variables:
-       i

- Included code components:
-       towGetSymbolTable
-------------------------------------------------------------------------------
%%BEGIN(towGetSymbol)
!--------------------------------!
!       towGetSymbol!
!--------------------------------!
%%SET recSigs(,TOWGETSYMBOL)
    RECEIVE towGetSymbol WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference,
        SQLX_SymbolValue;
    SQLX_ReturnCode=0;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetSymbolTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO SQLX_ReturnCode=1;
    ESAC;
%%SET sentSigs(,TOWGETSYMBOLACK)
    RETURN towGetSymbolAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_Symbol;
%%END(towGetSymbol)
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-Code component towGetSymbolTable, chapter 41.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tabNos          The table numbers for the tables in 'tables'.
-       symColsI        Column numbers for all symbol columns in table I.

- Temporary IMP variables:
-       p3
-       j

- Included code components:
-       towGetSymbolTableColumn
-----------------------------------------------------------------------------
%%BEGIN(towGetSymbolTable)
!--------------------------------!
!       towGetSymbolTable!
!--------------------------------!
%%SET p1(%%(towGetSymbolTable[1]))
%%SET p3(%%(tabNos[p1]))
%%IF(symCols%%(p3)[0] > 0)
   CASE SQLX_ColumnReference IS
%%LOOP(j, symCols%%(p3))
    WHEN %%(j) DO
%%INCLUDE(towGetSymbolTableColumn(%%(p1),%%(j)))
%%ENDLOOP(j)
    OTHERWISE DO
%%ENDIF
        SQLX_ReturnCode=2;
%%IF(symCols%%(p3)[0] > 0)
    ESAC;
%%ENDIF
%%END(towGetSymbolTable)
----------------------------------------------------------------------


----------------------------------------------------------------------
-Code component towGetSymbolTableColumn, chapter 41.3

- Parameters:
-       q1:             Table index
-       q2              Column number.

- IMP variables used:
-       tabNos          The table numbers for the tables in 'tables'.
-       symValsI_J      Symbol values for column J in tableI.
-       symLitsI_J      Symbol value integers for column J in tableI in the
                        same order as 'symValsIJ'.

- Temporary IMP variables:
-       q3
-       l

- Included code components:
-       None
-----------------------------------------------------------------------------
%%BEGIN(towGetSymbolTableColumn)
!--------------------------------!
!       towGetSymbolTableColumn!
!--------------------------------!
%%SET q1(%%(towGetSymbolTableColumn[1]))
%%SET q2(%%(towGetSymbolTableColumn[2]))
%%SET q3(%%(tabNos[p1]))
    CASE SQLX_SymbolValue IS
%%LOOP(l <= symLits%%(q3)_%%(q2)[0])
    WHEN %%(symLits%%(q3)_%%(q2)[l]) DO
        SQLX_Symbol="%%(symVals%%(q3)_%%(q2)[l])";
%%ENDLOOP(l)
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
%%END(towGetSymbolTableColumn)
----------------------------------------------------------------------


----------------------------------------------------------------------------
-       42. HANDLE: TOWGETSYMVAL
----------------------------------------------------------------------------

--------------------------------------------------------------------------
-Code component towGetSymVal, chapter 42.1

- IMP variables used:
-       tables          All table names in the block.
-       tabNos          The table numbers for the tables in 'tables'.

- Temporary IMP variables:
-       i

- Included code components:
-       towGetSymValTable
-----------------------------------------------------------------------------
%%BEGIN(towGetSymVal)
!--------------------------------!
!       towGetSymVal!
!--------------------------------!
%%SET recSigs(,TOWGETSYMVAL)
    RECEIVE towGetSymVal WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference,
        SQLX_Symbol;
    SQLX_ReturnCode=0;
    CASE SQLM_TableReference IS
%%LOOP(i <= tables[0])
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetSymValTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO SQLX_ReturnCode=1;
    ESAC;
%%SET sentSigs(,TOWGETSYMVALACK)
    RETURN towGetSymValAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_SymbolValue;
%%END(towGetSymVal)
--------------------------------------------------------------------------


--------------------------------------------------------------------------
-Code component towGetSymValTable, chapter 42.2

- Parameters:
-       p1:             Table index

- IMP variables used:
-       tabNos          The table numbers for the tables in 'tables'.
-       symColsI        Column numbers for all symbol columns in table I.

- Temporary IMP variables:
-       p3
-       j

- Included code components:
-       towGetSymValTableColumn
------------------------------------------------------------------------------
%%BEGIN(towGetSymValTable)
!--------------------------------!
!       towGetSymValTable!
!--------------------------------!
%%SET p1(%%(towGetSymValTable[1]))
%%SET p3(%%(tabNos[p1]))
%%IF(symCols%%(p3)[0] > 0)
    CASE SQLX_ColumnReference IS
%%LOOP(j, symCols%%(p3))
    WHEN %%(j) DO
%%INCLUDE(towGetSymValTableColumn(%%(p1),%%(j)))
%%ENDLOOP(j)
    OTHERWISE DO
%%ENDIF
        SQLX_ReturnCode=2;
%%IF(symCols%%(p3)[0] > 0)
    ESAC;
%%ENDIF
%%END(towGetSymValTable)
----------------------------------------------------------------------


----------------------------------------------------------------------
-Code component towGetSymValTableColumn, chapter 42.3

- Parameters:
-       q1:             Table index
-       q2:             Column number.

- IMP variables used:

-       tabNos          The table numbers for the tables in 'tables'.
-       symValsI_J      Symbol values for column J in tableI.
-       symLitsI_J      Symbol value integers for column J in tableI in the
                        same order as 'symValsIJ'.

- Temporary IMP variables:
-       q3
-       k

- Included code components:
-       None
-----------------------------------------------------------------------------
%%BEGIN(towGetSymValTableColumn)
!--------------------------------!
!       towGetSymValTableColumn!
!--------------------------------!
%%SET q1(%%(towGetSymValTableColumn[1]))
%%SET q2(%%(towGetSymValTableColumn[2]))
%%SET q3(%%(tabNos[q1]))
    CASE SQLX_Symbol IS
%%LOOP(k <= symVals%%(q3)_%%(q2)[0])
    WHEN "%%(symVals%%(q3)_%%(q2)[k])" DO
        SQLX_SymbolValue=%%(symLits%%(q3)_%%(q2)[k]);
%%ENDLOOP(k)
    OTHERWISE DO SQLX_ReturnCode=3;
    ESAC;
%%END(towGetSymValTableColumn)
----------------------------------------------------------------------



----------------------------------------------------------------------
-       43. HANDLE: TOWGETPRESYM
----------------------------------------------------------------------

----------------------------------------------------------------------
-Code component towGetPreSym, chapter 43.1

- IMP variables used:

-       tabNos          The table numbers for the tables in 'tables'.
-       symTabsInds     ????

- Temporary IMP variables:
-       i

- Included code components:
-       towGetPreSymTable
-----------------------------------------------------------------------------
%%BEGIN(towGetPreSym)
!--------------------------------!
!       towGetPreSym!
!--------------------------------!
%%SET recSigs(,TOWGETPRESYM)
    RECEIVE towGetPreSym WITH
        SQLX_OtherProtected,
        SQLM_TableReference,
        SQLX_ColumnReference,
        SQLX_SymbolValue;
%%IF(symTabInds[0] > 0)
    SQLX_ReturnCode=0;
    CASE SQLM_TableReference IS
%%LOOP(i, symTabInds)
    WHEN %%(tabNos[i]) DO
%%INCLUDE(towGetPreSymTable(%%(i)))
%%ENDLOOP(i)
    OTHERWISE DO
%%ENDIF
        SQLX_ReturnCode=1;
%%IF(symTabInds[0] > 0)
    ESAC;
%%ENDIF
%%SET sentSigs(,TOWGETPRESYMACK)
    RETURN towGetPreSymAck WITH
        SQLX_OtherProtected,
        SQLX_ReturnCode,
        SQLX_SymbolValue,
        SQLX_Symbol;
%%END(towGetPreSym)
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-Code component towGetPreSymTable, chapter 43.2

- Parameters:
-       p1:             Table index

- IMP variables used:

-       tabNos          The table numbers for the tables in 'tables'.
-       symColsI        Column numbers for all symbol columns in table I.

- Temporary IMP variables:
-       p3
-       j

- Included code components:
-       towGetPreSymTableColumn
-------------------------------------------------------------------------------
%%BEGIN(towGetPreSymTable)
!--------------------------------!
!       towGetPreSymTable!
!--------------------------------!
%%SET p1(%%(towGetPreSymTable[1]))
%%SET p3(%%(tabNos[p1]))
    CASE SQLX_ColumnReference IS
%%LOOP(j, symCols%%(p3))
    WHEN %%(j) DO
%%INCLUDE(towGetPreSymTableColumn(%%(p1),%%(j)))
%%ENDLOOP(j)
    OTHERWISE DO SQLX_ReturnCode=2;
    ESAC;
%%END(towGetPreSymTable)
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-Code component towGetPreSymTableColumn, chapter 43.3

- Parameters:
-       q1:             Table index
-       q2:             Column number.

- IMP variables used:

-       tabNos          The table numbers for the tables in 'tables'.
-       symValsI_J      Symbol values for column J in tableI.
-       symLitsI_J      Symbol value integers for column J in tableI in the
                        same order as 'symValsI_J'.

- Temporary IMP variables:
-       q3
-       l

- Included code components:
-       None
-------------------------------------------------------------------------------
%%BEGIN(towGetPreSymTableColumn)
!--------------------------------!
!       towGetPreSymTableColumn!
!--------------------------------!
%%SET q1(%%(towGetPreSymTableColumn[1]))
%%SET q2(%%(towGetPreSymTableColumn[2]))
%%SET q3(%%(tabNos[q1]))
    IF SQLX_SymbolValue > %%(symLits%%(q3)_%%(q2)[symLits%%(q3)_%%(q2)[0]]) THEN
        SQLX_SymbolValue=%%(symLits%%(q3)_%%(q2)[symLits%%(q3)_%%(q2)[0]]);
        SQLX_Symbol="%%(symVals%%(q3)_%%(q2)[symLits%%(q3)_%%(q2)[0]])";
%%LOOP(l <= symLits%%(q3)_%%(q2)[0] - 1)
    ELSIF SQLX_SymbolValue > %%(symLits%%(q3)_%%(q2)[symLits%%(q3)_%%(q2)[0] - l]) THEN
        SQLX_SymbolValue=%%(symLits%%(q3)_%%(q2)[symLits%%(q3)_%%(q2)[0] - l]);
        SQLX_Symbol="%%(symVals%%(q3)_%%(q2)[symLits%%(q3)_%%(q2)[0] - l])";
%%ENDLOOP(l)
    ELSE
        SQLX_ReturnCode=3;
    FI;
%%END(towGetPreSymTableColumn)
-------------------------------------------------------------------------------
------------------------------------------------------------------------
-  7. DATA MANIPULATION STATMENTS
-------------------------------------------------------------------------

-------------------------------------------------------------------------
-Code component  remSelectStat, chapter 7.1.1

-IMP-VARIABLES
        - tabNo         The table number.
        - keyNo         The chosen key.
        - bTreesI       Key numbers for all btrees in in table I, may be empty.
        - indMax        Max size  of a file, currently 65535.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - sigCount      The number of signals needed - 1.
        - towGetLab     Label counter for towGetRow and towGetFld, initially
        -               set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(remSelectStat)
!--------------------------------------!
!       remSelectStat   !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Set default SQLCODE and return label when returning from the row
$ lookup in table owner.!
    PROTECTEDP:SQLX_SQLCODE=0;
%%SET towGetLab(%%(towGetLab + 1))
    PROTECTEDP:SQLX_SQLRETURN=%%(towGetLab);
%%INCLUDE(saveSigPtrs("G"))
! Pack key and which columns to retreive in the signal. Then send the
$ signal to the table owner.!
%%LOOP(j <= sigAssVars0[0])
    %%(sigAssPtrs0[j]):%%(sigAssVars0[j]) = %%(sigAssExprs0[j]);
%%ENDLOOP(j)
%%SET drs()
%%INCLUDE(packKeyX(%%(keyNo)))
%%INCLUDE(packRequestX(0))
%%SET sentSigs(,TOWGETROW)
%%IF(multiNo%%(tabNo)(?))
    SEND towGetRow REFERENCE %%(blockRef) WITH
%%ELSE
    SEND towGetRow REFERENCE SQLM_Remote(%%(tabNo - remTabNos[1])).block WITH
%%ENDIF
        cOwnRef,
        PROTECTEDP,
%%IF(multiNo%%(tabNo)(?))
        %%(multiNo%%(tabNo))
%%ELSE
        SQLM_Remote(%%(tabNo - remTabNos[1])).table,
%%ENDIF
        %%(keyNo),
        +,
        +
%%LOOP(dr <= 19)
%%IF(drs(%%(dr+4)))
        ,SQLX_DR%%(dr+4)
%%ELSE
        ,+
%%ENDIF
%%ENDLOOP(dr)
        ;
    EXIT;
! Return from table owner. If the lookup was not successful abort the
  select statement!
towGetLab%%(towGetLab))
    IF SQLCODE /= 0 GOTO EXITremSelectStat%%(statNo);
! Unpack wanted columns !
%%INCLUDE(restoreSigPtrs(0, "G"))
%%INCLUDE(unPackX(0))
! Loop until no more columns are wanted !
%%LOOP(i <= sigCount)
! Set return label when returning from column retrive. !
%%SET towGetLab(%%(towGetLab + 1))
    PROTECTEDP:SQLX_SQLRETURN=%%(towGetLab);
! Pack which columns to retrieve and send signal to table owner. !
%%LOOP(j <= sigAssVars%%(i)[0])
    %%(sigAssPtrs%%(i)[j]):%%(sigAssVars%%(i)[j]) = %%(sigAssExprs%%(i)[j]);
%%ENDLOOP(j)
%%SET drs()
%%INCLUDE(packRequestX(%%(i)))
%%SET sentSigs(,TOWGETFLD)
%%IF(multiNo%%(tabNo)(?))
    SEND towGetFld REFERENCE %%(blockRef) WITH
%%ELSE
    SEND towGetFld REFERENCE SQLM_Remote(%%(tabNo - remTabNos[1])).block WITH
%%ENDIF
        cOwnRef,
        PROTECTEDP,
%%IF(multiNo%%(tabNo)(?))
        %%(multiNo%%(tabNo))
%%ELSE
        SQLM_Remote(%%(tabNo - remTabNos[1])).table,
%%ENDIF
        SQLX_OperRow,
        SQLX_DBnumber2,
        +
%%LOOP(dr <= 19)
%%IF(drs(%%(dr+4)))
        ,SQLX_DR%%(dr+4)
%%ELSE
        ,+
%%ENDIF
%%ENDLOOP(dr)
        ;
    EXIT;
! Return from table owner. If the column retrieval failed the selection
  is aborted. !
towGetLab%%(towGetLab))
    IF SQLCODE /= 0 GOTO EXITremSelectStat%%(statNo);
! Unpack wanted data !
%%INCLUDE(restoreSigPtrs(%%(i), "G"))
%%INCLUDE(unPackX(%%(i)))
%%ENDLOOP(i)
    SQLCODE=PROTECTEDP:SQLX_SQLCODE;
EXITremSelectStat%%(statNo))
%%END(remSelectStat)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
-Code component locSelectStat, chapter 7.2.1

-IMP-VARIABLES
        - tabName       The table name.
        - tabNo         The table number.
        - keyNo         The chosen key.
        - bTreesI       Key numbers for all btrees in in table I, may be empty.
        - bTreecolsI_J  Column numbers for all columns in table I btree J.
        - indMax        Max size  of a file, currently 65535.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - sigCount      The number of signals needed - 1.
        - colNullI[J]   Nulls allowed for column J in table I, 1 is NULLs
        -               allowed, 0 otherwise.
        - keyExprs      The test expressions in the order of the key columns.
        - defValI_J     Default value for column J in table I.
        - towGetSchLab  Label counter for towGetSch and towGetFld, initially
        -               set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(locSelectStat)
!--------------------------------------!
!       locSelectStat   !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
%%IF(bTrees%%(tabNo)(%%(keyNo)))
    SQLM_TableReference = %%(tabNo);
! Allocate a work area, if none is found report failure. !
%%INCLUDE(allocateWorkRow(%%(tabName), WORKLOCKlocSelectStat%%(statNo), WORKFULLlocSelectStat%%(statNo)))
! Save the primary key in work area. !
%%LOOP(i <= bTreeCols%%(tabNo)_%%(keyNo)[0])
%%SET colNo(%%(bTreeCols%%(tabNo)_%%(keyNo)[i]))
%%SET colName(%%(cols%%(tabNo)[colNo]))
%%IF(colNull%%(tabNo)[colNo] = 1)
%%IF(keyExprs[i] = "NULL")
    SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_%%(colName)_Null = 1;
%%ELSE
    SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_%%(colName)_Null = 0;
%%ENDIF
%%ENDIF
%%IF(keyExprs[i] # "NULL")
%%IF(colTypes%%(tabNo)[colNo] # "PACKED NUMSTRING")
    SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_%%(colName)_Data =
        %%(keyExprs[i]);
%%ELSE
%%INCLUDE(copyPackNum("SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_%%(colName)_Data", "%%(keyExprs[i])", %%(colSizes%%(tabNo)[colNo])))
%%ENDIF
%%ENDIF
%%ENDLOOP(i)
! Find row which have the primary key as stored in the work row.!
    SQLM_%%(tabName)_RootRow = SQLM_TableReference:SQLM_System+2;
%%SET sentSigs(,TOWGETSCH)
    SEND towGetSch REFERENCE cOwnref WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        %%(keyNo),
        SQLM_%%(tabName)_RootRow:SQLC_%%(tabName)_Right%%(keyNo),
        SQLM_%%(tabName)_WorkRow,
        +,+,+,+,+,+,+,+,+,+,+,+,+,+,+,
        3,
        %%(bTreeCols%%(tabNo)_%%(keyNo)[0]),
        +,
%%SET towGetSchLab(%%(towGetSchLab + 1))
        %%(towGetSchLab);
    EXIT;
towGetSchLab%%(towGetSchLab))
! Restore some data !
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_%%(tabName)_WorkRow=SQLX_WorkRow;
    SQLM_%%(tabName)_OperRow=SQLX_OperRow;
! deallocate work row !
%%INCLUDE(deAllocateWorkRow(%%(tabName)))
    SQLCODE=2+1 <= 8;
! check if row is found, if not report failure !
    IF SQLM_%%(tabName)_OperRow = SQLM_TableReference:SQLM_System+1
        GOTO EXITlocSelectStat%%(statNo);
! check if row is not read locked, if so report failure !
    IF SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_Lock>1 THEN
        SQLCODE=2+3 <= 8;
        GOTO EXITlocSelectStat%%(statNo);
    FI;
%%ELSIF(keyNo = 0)      !row access !
    SQLM_%%(tabName)_OperRow=%%(keyExprs);
    SQLM_TableReference=%%(tabNo);
    SQLCODE=2+1 <= 8;
    IF NOT SQLM_%%(tabName)_OperRow < SQLM_TableReference:SQLM_TableAllocated
        GOTO EXITlocSelectStat%%(statNo);
    IF SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_Allocated = 0
        GOTO EXITlocSelectStat%%(statNo);
    IF SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_Lock > 1 THEN
        SQLCODE=2+3 <= 8;
        GOTO EXITlocSelectStat%%(statNo);
    FI;
%%ELSIF(keyExprs = "WORK")
    SQLM_%%(tabName)_OperRow = PROTECTEDP:SQLX_SQLWORKROW;
%%ELSE
    SQLM_%%(tabName)_OperRow = PROTECTEDP:SQLX_SQLOPERROW;
%%ENDIF
    SQLCODE=0;
!  retrieve data from work row. !
%%INCLUDE(getData)
%%IF(bTrees%%(tabNo)(%%(keyNo)))
    GOTO EXITlocSelectStat%%(statNo);
WORKLOCKlocSelectStat%%(statNo))
    SQLCODE=3+18 <= 8;
    GOTO EXITlocSelectStat%%(statNo);
WORKFULLlocSelectStat%%(statNo))
    SQLCODE=3+8 <= 8;
%%ENDIF
%%IF(keyNo # 1)
EXITlocSelectStat%%(statNo))
%%ENDIF
%%END(locSelectStat)
-------------------------------------------------------------------------



--------------------------------------------------------------------------
-Code component remUpdateVolatileStat, chapter 7.3

-IMP-VARIABLES
        - indMax        Max size  of a file, currently 65535.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - sigCount      The number of signals needed - 1.

        - towChaVolRowLab       Label counter for towGetRow and towGetFld,
        -                       initiallyset to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(remUpdateVolatileStat)
!--------------------------------------!
!       remUpdateVolatileStat!
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
%%INCLUDE(saveSigPtrs("P"))
! Loop for each hunk of columns to update !
%%LOOP(i <= sigCount + 1)
%%SET towChaVolRowLab(%%(towChaVolRowLab + 1))
! Update some columns !
    PROTECTEDP:SQLX_SQLRETURN=%%(towChaVolRowLab);
%%IF(i # 1)
%%INCLUDE(restoreSigPtrs(%%(i - 1), "P"))
%%ENDIF
%%LOOP(j <= sigAssVars%%(i - 1)[0])
    %%(sigAssPtrs%%(i - 1)[j]):%%(sigAssVars%%(i - 1)[j]) = %%(sigAssExprs%%(i - 1)[j]);
%%ENDLOOP(j)
%%SET drs()
%%INCLUDE(packX(%%(i - 1), "U"))
%%SET sentSigs(,TOWCHAVOLROW)
%%IF(multiNo%%(tabNo)(?))
    SEND towChaVolRow REFERENCE %%(blockRef) WITH
%%ELSE
    SEND towChaVolRow REFERENCE SQLM_Remote(%%(tabNo - remTabNos[1])).block WITH
%%ENDIF
        cOwnRef,
        PROTECTEDP,
%%IF(multiNo%%(tabNo)(?))
        %%(multiNo%%(tabNo)),
%%ELSE
        SQLM_Remote(%%(tabNo - remTabNos[1])).table,
%%ENDIF
        %%(keyExprs),
        +,
        +
%%LOOP(dr <= 19)
%%IF(drs(%%(dr+4)))
        ,SQLX_DR%%(dr+4)
%%ELSE
        ,+
%%ENDIF
%%ENDLOOP(dr)
        ;
    EXIT;
towChaVolRowLab%%(towChaVolRowLab))
! If update failed abort command !
    IF SQLCODE /= 0 GOTO EXITremUpdateVolatileStat%%(statNo);
%%ENDLOOP(i)
EXITremUpdateVolatileStat%%(statNo))
%%END(remUpdateVolatileStat)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
-Code component  locUpdateVolatileStat, chapter 7.4

-IMP-VARIABLES
        - tabName       The table name.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
-------------------------------------------------------------------------
%%BEGIN(locUpdateVolatileStat)
!--------------------------------------!
!       locUpdateVolatileStat   !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
    SQLM_%%(tabName)_OperRow=%%(keyExprs);
    SQLCODE=2+1 <= 8;
    IF NOT SQLM_%%(tabName)_OperRow < SQLM_TableReference:SQLM_TableAllocated
        GOTO EXITlocUpdateVolatileStat%%(statNo);
    IF SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_Allocated = 0
        GOTO EXITlocUpdateVolatileStat%%(statNo);
! Copy variables into columns !
%%INCLUDE(putData)
    SQLCODE=0;
EXITlocUpdateVolatileStat%%(statNo))
%%END(locUpdateVolatileStat)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
-Code component insertStat, chapter 7.5

-IMP-VARIABLES
        - indMax        Max size  of a file, currently 65535.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - sigCount      The number of signals needed - 1.
        - trhInsRowLab  Label counter for trhInsRow , initially
        -               set to 0, incremented before each use.
        - trhLetFldLab  Label counter for trhLetFld, initially
        -               set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(insertStat)
!--------------------------------------!
!       insertStat      !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITinsertStat%%(statNo);
    FI;
! Pack signal with required data and primary key. Then send insert
  signal to transaction handler. !
%%SET trhInsRowLab(%%(trhInsRowLab + 1))
    PROTECTEDP:SQLX_SQLRETURN=%%(trhInsRowLab);
%%INCLUDE(saveSigPtrs("P"))
%%LOOP(j <= sigAssVars0[0])
    %%(sigAssPtrs0[j]):%%(sigAssVars0[j]) = %%(sigAssExprs0[j]);
%%ENDLOOP(j)
%%SET drs()
%%INCLUDE(packKeyX(%%(keyNo)))
%%INCLUDE(packX(0, "I"))
%%SET sentSigs(,TRHINSROW)
    SEND trhInsRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref,
%%IF(multiNo%%(tabNo)(?))
        %%(blockRef),
        %%(multiNo%%(tabNo)),
%%ELSIF(tabNos(%%(tabNo)))
        cOwnRef,
        %%(tabNo),
%%ELSE
        SQLM_Remote(%%(tabNo - remTabNos[1])).block,
        SQLM_Remote(%%(tabNo - remTabNos[1])).table,
%%ENDIF
        2                 ! primary key !
%%LOOP(dr <= 19)
%%IF(drs(%%(dr+4)))
        ,SQLX_DR%%(dr+4)
%%ELSE
        ,+
%%ENDIF
%%ENDLOOP(dr)
        ;
    EXIT;
trhInsRowLab%%(trhInsRowLab))
    IF SQLCODE /= 0 GOTO EXITinsertStat%%(statNo);
! Send let field signal to transaction handler until all data is
  transferred to the table. Abort the command if any signal fails. !
%%LOOP(i <= sigCount)
%%SET trhLetFldLab(%%(trhLetFldLab + 1))
    PROTECTEDP:SQLX_SQLRETURN=%%(trhLetFldLab);
%%INCLUDE(restoreSigPtrs(%%(i), "P"))
%%LOOP(j <= sigAssVars%%(i)[0])
    %%(sigAssPtrs%%(i)[j]):%%(sigAssVars%%(i)[j]) = %%(sigAssExprs%%(i)[j]);
%%ENDLOOP(j)
%%SET drs()
%%INCLUDE(packX(%%(i), "I"))
%%SET sentSigs(,TRHLETFLD)
    SEND trhLetFld WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref,
        +,
        +,
        +
%%LOOP(dr <= 19)
%%IF(drs(%%(dr+4)))
        ,SQLX_DR%%(dr+4)
%%ELSE
        ,+
%%ENDIF
%%ENDLOOP(dr)
        ;
    EXIT;
trhLetFldLab%%(trhLetFldLab))
    IF SQLCODE /= 0 GOTO EXITinsertStat%%(statNo);
%%ENDLOOP(i)
! Exit !
EXITinsertStat%%(statNo))
%%END(insertStat)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
-Code component  workUpdateStat

-IMP-VARIABLES
        - tabName       The table name.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
-------------------------------------------------------------------------
%%BEGIN(workUpdateStat)
!--------------------------------------!
!       workUpdateStat   !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
    IF PROTECTEDP:SQLX_SQLWORKROW = 0 THEN
        SQLCODE=3 + 16 <= 8;
    ELSE
        SQLM_%%(tabName)_OperRow=PROTECTEDP:SQLX_SQLWORKROW;
! Copy variables into columns !
%%INCLUDE(putData)
        SQLCODE=0;
    FI;
%%END(workUpdateStat)
-------------------------------------------------------------------------




-------------------------------------------------------------------------
-Code component  updateStat, chapter 7.6

-IMP-VARIABLES
        - tabNo         The table number.
        - keyNo         The chosen key.
        - bTreesI       Key numbers for all btrees in in table I, may be empty.
        - indMax        Max size  of a file, currently 65535.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - sigCount      The number of signals needed - 1.
        - trhChaRowLab  Label counter for trhChaRow, initially
        -               set to 0, incremented before each use.
        - trhLetFldLab  Label counter for trhLetFld, initially
        -               set to 0, incremented before each use.
-------------------------------------------------------------------------

%%BEGIN(updateStat)
!--------------------------------------!
!       updateStat      !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITupdateStat%%(statNo);
    FI;
! Pack signal with required data and primary key. Then send update
  signal to transaction handler. !
%%SET trhChaRowLab(%%(trhChaRowLab + 1))
    PROTECTEDP:SQLX_SQLRETURN=%%(trhChaRowLab);
%%INCLUDE(saveSigPtrs("P"))
%%LOOP(j <= sigAssVars0[0])
    %%(sigAssPtrs0[j]):%%(sigAssVars0[j]) = %%(sigAssExprs0[j]);
%%ENDLOOP(j)
%%SET drs()
%%INCLUDE(packKeyX(%%(keyNo)))
%%INCLUDE(packX(0, "U"))
%%SET sentSigs(,TRHCHAROW)
    SEND trhChaRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef,
%%IF(multiNo%%(tabNo)(?))
        %%(blockRef),
        %%(multiNo%%(tabNo)),
%%ELSIF(tabNos(%%(tabNo)))
        cOwnRef,
        %%(tabNo),
%%ELSE
        SQLM_Remote(%%(tabNo - remTabNos[1])).block,
        SQLM_Remote(%%(tabNo - remTabNos[1])).table,
%%ENDIF
        %%(keyNo)
%%LOOP(dr <= 19)
%%IF(drs(%%(dr+4)))
        ,SQLX_DR%%(dr+4)
%%ELSE
        ,+
%%ENDIF
%%ENDLOOP(dr)
        ;
    EXIT;
trhChaRowLab%%(trhChaRowLab))
! If not successful abort command !
    IF SQLCODE /= 0 GOTO EXITupdateStat%%(statNo);
! Send let field signal to transaction handler until all data is
  transferred to the table. Abort the command if any signal fails. !
%%LOOP(i <= sigCount)
%%SET trhLetFldLab(%%(trhLetFldLab + 1))
    PROTECTEDP:SQLX_SQLRETURN=%%(trhChaRowLab);
%%INCLUDE(restoreSigPtrs(%%(i), "P"))
%%LOOP(j <= sigAssVars%%(i)[0])
    %%(sigAssPtrs%%(i)[j]):%%(sigAssVars%%(i)[j]) = %%(sigAssExprs%%(i)[j]);
%%ENDLOOP(j)
%%SET drs()
%%INCLUDE(packX(%%(i), "U"))
%%SET sentSigs(,TRHLETFLD)
    SEND trhLetFld WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref,
        +,
        +,
        +
%%LOOP(dr <= 19)
%%IF(drs(%%(dr+4)))
        ,SQLX_DR%%(dr+4)
%%ELSE
        ,+
%%ENDIF
%%ENDLOOP(dr)
        ;
    EXIT;
trhLetFldLab%%(trhLetFldLab))
    IF SQLCODE /= 0 GOTO EXITupdateStat%%(statNo);
%%ENDLOOP (i)
EXITupdateStat%%(statNo))
%%END(updateStat)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
-Code component  deleteStat, chapter 7.7

-IMP-VARIABLES
        - keyNo         The chosen key.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - sigCount      The number of signals needed - 1.
        - trhDelRowLab  Label counter for trhDelRow, initially
        -               set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(deleteStat)
!--------------------------------------!
!       deleteStat      !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if inside a transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
        GOTO EXITdeleteStat%%(statNo);
    FI;
! Pack signal with primary key. Then send delete signal to transaction
  handler. !
%%SET trhDelRowLab(%%(trhDelRowLab + 1))
    PROTECTEDP:SQLX_SQLRETURN=%%(trhDelRowLab);
%%LOOP(j <= sigAssVars0[0])
    %%(sigAssPtrs0[j]):%%(sigAssVars0[j]) = %%(sigAssExprs0[j]);
%%ENDLOOP(j)
%%SET drs()
%%INCLUDE(packKeyX(%%(keyNo)))
%%SET sentSigs(,TRHDELROW)
    SEND trhDelRow WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef,
%%IF(multiNo%%(tabNo)(?))
        %%(blockRef),
        %%(multiNo%%(tabNo)),
%%ELSIF(tabNos(%%(tabNo)))
        cOwnRef,
        %%(tabNo),
%%ELSE
        SQLM_Remote(%%(tabNo - remTabNos[1])).block,
        SQLM_Remote(%%(tabNo - remTabNos[1])).table,
%%ENDIF
        %%(keyNo)
%%LOOP(dr <= 19)
%%IF(drs(%%(dr+4)))
        ,SQLX_DR%%(dr+4)
%%ELSE
        ,+
%%ENDIF
%%ENDLOOP(dr)
        ;
    EXIT;
trhDelRowLab%%(trhDelRowLab))
EXITdeleteStat%%(statNo))
%%END(deleteStat)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
- 8. CURSOR HANDLING STATMENTS
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-Code component remOpenStat, chapter 8.1

-IMP-VARIABLES
        - keyNo         The chosen key.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - towOpenLab    Label counter for towOpen, initially
        -               set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(remOpenStat)
!--------------------------------------!
!       remOpenStat     !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if cursor already is opened, if so report failure !
    IF PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITremOpenStat%%(statNo);
    FI;
! Pack signal with cursor key. Then send open signal to table owner. !
%%SET towOpenLab(%%(towOpenLab + 1))
    PROTECTEDP:SQLX_SQLRETURN=%%(towOpenLab);
%%LOOP(j <= sigAssVars0[0])
    %%(sigAssPtrs0[j]):%%(sigAssVars0[j]) = %%(sigAssExprs0[j]);
%%ENDLOOP(j)
%%SET drs()
%%INCLUDE(packKeyX(%%(keyNo)))
%%SET sentSigs(,TOWOPEN)
%%IF(multiNo%%(tabNo)(?))
    SEND towOpen REFERENCE %%(blockRef) WITH
%%ELSE
    SEND towOpen REFERENCE SQLM_Remote(%%(tabNo - remTabNos[1])).block WITH
%%ENDIF
        cOwnRef,
        PROTECTEDP,
%%IF(multiNo%%(tabNo)(?))
        %%(multiNo%%(tabNo)),
%%ELSE
        SQLM_Remote(%%(tabNo - remTabNos[1])).table,
%%ENDIF
        %%(keyOp),
        %%(keyNo),
        +,
        +
%%LOOP(dr <= 18)
%%IF(drs(%%(dr+5)))
        ,SQLX_DR%%(dr+5)
%%ELSE
        ,+
%%ENDIF
%%ENDLOOP(dr)
        ;
    EXIT;
towOpenLab%%(towOpenLab))
! If open fails report failure !
    IF SQLCODE /= 0 GOTO EXITremOpenStat%%(statNo);
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor=SQLX_OperRow;
! Exit !
EXITremOpenStat%%(statNo))
%%END(remOpenStat)
-------------------------------------------------------------------------



--------------------------------------------------------------------------
-Code component  locOpenStat, chapter 8.2

-IMP-VARIABLES
        - tabName       The table name.
        - tabNo         The table number.
        - keyNo         The chosen key.
        - bTreesI       Key numbers for all btrees in in table I, may be empty.
        - bTreecolsI_J  Column numbers for all columns in table I btree J.
        - indMax        Max size  of a file, currently 65535.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - colNullI[J]   Nulls allowed for column J in table I, 1 is NULLs
        -               allowed, 0 otherwise.
        - keyExprs      The test expressions in the order of the key columns.
        - defValI_J     Default value for column J in table I.
-------------------------------------------------------------------------
%%BEGIN(locOpenStat)
!--------------------------------------!
!       locOpenStat     !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if cursor already is opened, if so report failure. !
    IF PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor /= 0 THEN
        SQLCODE=3+12 <= 8;
        GOTO EXITlocOpenStat%%(statNo);
    FI;
! Check that the work area is locked, if so report failure !
    SQLM_TableReference=%%(tabNo);
    IF SQLM_TableReference:SQLM_WorkLock /= 0 THEN
        SQLCODE=3+18 <= 8;
        GOTO EXITlocOpenStat%%(statNo);
    FI;
! Allocate work row, report if the allocate fails. !
%%INCLUDE(allocateWorkRow(%%(tabName), WORKLOCKlocOpenStat%%(statNo), WORKFULLlocOpenStat%%(statNo)))
    SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_Lock=2;
%%IF(bTrees%%(tabNo)(%%(keyNo)))
%%LOOP(i <= keyExprs[0])
%%SET colNo(%%(bTreeCols%%(tabNo)_%%(keyNo)[i]))
%%SET colName(%%(cols%%(tabNo)[colNo]))
%%IF(colNull%%(tabNo)[colNo] = 1)
%%IF(keyExprs[i] = "NULL")
    SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_%%(colName)_Null = 1;
%%ELSE
    SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_%%(colName)_Null = 0;
%%ENDIF
%%ENDIF
%%IF(keyExprs[i] # "NULL")
    SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_%%(colName)_Data=%%(keyExprs[i]);
%%ENDIF
%%ENDLOOP(i)
! If the cursor is a btree store 0 in cLastRow if the key operation is
  PREVIOUS otherwise the highest row number (65535 if 16 bit address)
  is stored in cLastRow (key operation THIS or THIS OR PREVIOUS). !
%%IF(keyOp = 1)
    SQLM_%%(tabName)_WorkRow:%%(SQLC_%%(tabName)_LastRow)=0;
%%ELSE
    SQLM_%%(tabName)_WorkRow:%%(SQLC_%%(tabName)_LastRow)=%%(indMax);
%%ENDIF
%%ELSE
! If the cursor is a row number a THIS OR PREVIOUS key operation is
  converted to a PREVIOUS key operation by increasing the row number by
  one. !
%%IF(keyOp = 2)
    SQLM_%%(tabName)_WorkRow:%%(SQLC_%%(tabName)_LastRow)=%%(keyExprs[i])+1;
%%ELSE
    SQLM_%%(tabName)_WorkRow:%%(SQLC_%%(tabName)_LastRow)=%%(keyExprs[i]);
%%ENDIF
%%ENDIF
! Store cursor identity (row number) in cursor. !
    PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor=SQLM_%%(tabName)_WorkRow;
    SQLCODE=0;
    GOTO EXITlocOpenStat%%(statNo);
WORKLOCKlocOpenStat%%(statNo))
    SQLCODE=3+18 <= 8;
    GOTO EXITlocOpenStat%%(statNo);
WORKFULLlocOpenStat%%(statNo))
    SQLCODE=3+8 <= 8;
EXITlocOpenStat%%(statNo))
%%END(locOpenStat)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
-Code component remCloseStat, chapter 8.3

-IMP-VARIABLES
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - towCloseLab   Label counter for towClose, initially
        -               set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(remCloseStat)
!--------------------------------------!
!       remCloseStat    !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if cursor already is closed, if so report failure !
    IF PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITremCloseStat%%(statNo);
    FI;
! Send close signal to table owner. !
%%SET towCloseLab(%%(towCloseLab + 1))
%%SET sentSigs(,TOWCLOSE)
%%IF(multiNo%%(tabNo)(?))
    SEND towClose REFERENCE %%(blockRef) WITH
%%ELSE
    SEND towClose REFERENCE SQLM_Remote(%%(tabNo - remTabNos[1])).block WITH
%%ENDIF
        PROTECTEDP,
%%IF(multiNo%%(tabNo)(?))
        %%(multiNo%%(tabNo)),
%%ELSE
        SQLM_Remote(%%(tabNo - remTabNos[1])).table,
%%ENDIF
        PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor
    WAIT FOR towCloseAck IN towCloseLab%%(towCloseLab);
towCloseLab%%(towCloseLab))
%%SET recSigs(,TOWCLOSEACK)
    RETRIEVE towCloseAck WITH
        PROTECTEDP,
        SQLCODE;
    PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor=0;
EXITremCloseStat%%(statNo))
%%END(remCloseStat)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
-Code component  locCloseStat, chapter 8.4

-IMP-VARIABLES
        - tabName       The table name.
        - indMax        Max size  of a file, currently 65535.
-------------------------------------------------------------------------
%%BEGIN(locCloseStat)
!--------------------------------------!
!       locCloseStat    !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
    IF  PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
    ELSE
! Close cursor. !
      SQLM_%%(tabName)_WorkRow=PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor;
%%INCLUDE(deAllocateWorkRow(%%(tabName)))
      SQLCODE=0;
    FI;
%%END(locCloseStat)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
-Code component  remFetchStat, chapter 8.5

-IMP-VARIABLES
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - sigCount      The number of signals needed - 1.
        - towGetLab     Label counter for  towgetFld og towGetRow, initially
        -               set to 0, incremented before each use.-
------------------------------------------------------------------------
%%BEGIN(remFetchStat)
!--------------------------------------!
!       remFetchStat    !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if cursor is open, if not report failure. !
    IF PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITremFetchStat%%(statNo);
    FI;
%%SET label(0)
%%LOOP(i <= sigCount + 1)
%%IF(sigPreds%%(i - 1)[0] > 0)
%%SET label(1)
%%ENDIF
%%ENDLOOP(i)
%%IF(label = 1)
NEXTremFetchStat%%(statNo))
%%ENDIF
! Pack cursor key and which columns to retrieve in the signal. Then send
$ the signal to the table owner. !
    PROTECTEDP:SQLX_SQLCODE=0;
%%SET towGetLab(%%(towGetLab + 1))
    PROTECTEDP:SQLX_SQLRETURN=%%(towGetLab);
%%INCLUDE(saveSigPtrs("G"))
%%SET drs()
%%INCLUDE(packKeyX(1))
%%INCLUDE(packRequestX(0))
%%SET sentSigs(,TOWGETROW)
%%IF(multiNo%%(tabNo)(?))
    SEND towGetRow REFERENCE %%(blockRef) WITH
%%ELSE
    SEND towGetRow REFERENCE SQLM_Remote(%%(tabNo - remTabNos[1])).block WITH
%%ENDIF
        cOwnRef,
        PROTECTEDP,
%%IF(multiNo%%(tabNo)(?))
        %%(multiNo%%(tabNo)),
%%ELSE
        SQLM_Remote(%%(tabNo - remTabNos[1])).table,
%%ENDIF
        1,  ! cursor key !
        +,
        +
%%LOOP(dr <= 19)
%%IF(drs(%%(dr+4)))
        ,SQLX_DR%%(dr+4)
%%ELSE
        ,+
%%ENDIF
%%ENDLOOP(dr)
        ;
    EXIT;
towGetLab%%(towGetLab))
    IF SQLCODE /= 0 GOTO EXITremFetchStat%%(statNo);
%%INCLUDE(restoreSigPtrs(0, "G"))
%%INCLUDE(unPackX(0))
! Get required data if more test are needed to see if the right row was
  found. First makes the test with the data taken so far and if the test
  was successful and more data is needed to check more columns, request
  more column data from the table owner. !
%%LOOP(j, sigPreds0)
%%INCLUDE(scanPredicate(%%(tabNo), %%(tabName), %%(j), "SUCCESS0remFetchStat%%(statNo)", "NEXTremFetchStat%%(statNo)", "P"))
%%ENDLOOP(j)
%%IF(sigPreds0[0] > 0)
SUCCESS0remFetchStat%%(statNo))
%%ENDIF
%%LOOP(i <= sigCount)
%%SET towGetLab(%%(towGetLab + 1))
    PROTECTEDP:SQLX_SQLRETURN=%%(towGetLab);
%%SET drs()
%%INCLUDE(packRequestX(%%(i)))
%%SET sentSigs(,TOWGETFLD)
%%IF(multiNo%%(tabNo)(?))
    SEND towGetFld REFERENCE %%(blockRef) WITH
%%ELSE
    SEND towGetFld REFERENCE SQLM_Remote(%%(tabNo - remTabNos[1])).block WITH
%%ENDIF
        cOwnRef,
        PROTECTEDP,
%%IF(multiNo%%(tabNo)(?))
        %%(multiNo%%(tabNo)),
%%ELSE
        SQLM_Remote(%%(tabNo - remTabNos[1])).table,
%%ENDIF
        SQLX_OperRow,
        SQLX_DBnumber2,
        +
%%LOOP(dr <= 19)
%%IF(drs(%%(dr+4)))
        ,SQLX_DR%%(dr+4)
%%ELSE
        ,+
%%ENDIF
%%ENDLOOP(dr)
        ;
    EXIT;
towGetLab%%(towGetLab))
    IF SQLCODE /= 0 GOTO EXITremFetchStat%%(statNo);
%%INCLUDE(restoreSigPtrs(%%(i), "G"))
%%INCLUDE(unPackX(%%(i)))
%%LOOP(j, sigPreds%%(i))
%%INCLUDE(scanPredicate(%%(tabNo), %%(tabName), %%(j), "SUCCESS%%(i)remFetchStat%%(statNo)", "NEXTremFetchStat%%(statNo)", "P"))
%%ENDLOOP(j)
%%IF(sigPreds%%(i)[0] > 0)
SUCCESS%%(i)remFetchStat%%(statNo))
%%ENDIF
%%ENDLOOP(i)
    SQLCODE=PROTECTEDP:SQLX_SQLCODE;
EXITremFetchStat%%(statNo))
%%END(remFetchStat)
-------------------------------------------------------------------------




-------------------------------------------------------------------------
-Code component locFetchStat, chapter 8.6

-IMP-VARIABLES
        - tabName       The table name.
        - tabNo         The table number.
        - keyNo         The chosen key.
        - bTreesI       Key numbers for all btrees in in table I, may be empty.
        - bTreecolsI_J  Column numbers for all columns in table I btree J.
        - colsI[J]      Column numbers
        - indMax        Max size  of a file, currently 65535.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - colNullI[J]   Nulls allowed for column J in table I, 1 is NULLs
        -               allowed, 0 otherwise.
        - towGetSchLab  Label counter for towGetSch, initially
        -               set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(locFetchStat)
!--------------------------------------!
!       locFetchStat!
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if cursor is open, if not report failure !
    IF PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor = 0 THEN
        SQLCODE=3+11 <= 8;
        GOTO EXITlocFetchStat%%(statNo);
    FI;
! Find an operating row !
%%IF(preds > 0)
NEXTlocFetchStat%%(statNo))
%%ENDIF
%%IF(bTrees%%(tabNo)(%%(keyNo)))
    SQLM_%%(tabName)_WorkRow=PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor;
    SQLM_%%(tabName)_RootRow = SQLM_TableReference:SQLM_System+2;
%%SET sentSigs(,TOWGETSCH)
    SEND towGetSch REFERENCE cOwnRef WITH
        +,
        PROTECTEDP,
        SQLM_TableReference,
        %%(keyNo),
        SQLM_%%(tabName)_RootRow:SQLC_%%(tabName)_Right%%(keyNo),
        SQLM_%%(tabName)_WorkRow
%%LOOP(dr <= 15)
        ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr),
        %%(keyOp),
        %%(keyPrefix),
        SQLM_TableReference:SQLM_System+1,   ! pNilRow !
%%SET towGetSchLab(%%(towGetSchLab + 1))
        %%(towGetSchLab);
    EXIT;
towGetSchLab%%(towGetSchLab))
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_%%(tabName)_WorkRow=SQLX_WorkRow;
    SQLM_%%(tabName)_OperRow=SQLX_OperRow;
! check if row is not found, if so report failure !
    IF SQLM_%%(tabName)_OperRow = SQLM_TableReference:SQLM_System+1 THEN
        SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_Lock=2;
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat%%(statNo);
    FI;
! check if row is locked, if so report failure !
    IF SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_Lock > 1 THEN
        SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_Lock=2;
        SQLCODE=2+3 <= 8;
        GOTO EXITlocFetchStat%%(statNo);
    FI;
! update cursor !
%%SET colNo(%%(bTreeCols%%(tabNo)_%%(keyNo)[keyPrefix]))
%%SET colName(%%(cols%%(tabNo)[colNo]))
%%IF(colNull%%(tabNo)[colNo] = 1)
    SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_%%(colName)_Null=
        SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(colName)_Null;
%%ENDIF
%%IF(colTypes%%(tabNo)[colNo] # "PACKED NUMSTRING")
    SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_%%(colName)_Data=
        SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(colName)_Data;
%%ELSE
%%INCLUDE(copyPackNum("SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_%%(colName)_Data", "SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_%%(colName)_Data", %%(colSizes%%(tabNo)[colNo])))
%%ENDIF
    SQLM_%%(tabName)_WorkRow:%%(SQLC_%%(tabName)_LastRow)=
        SQLM_%%(tabName)_OperRow;
%%ELSE
%%-- row access
    SQLM_%%(tabName)_WorkRow=PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor;
%%IF(keyOp = 0)
    SQLM_%%(tabName)_OperRow=SQLM_%%(tabName)_WorkRow:%%(SQLC_%%(tabName)_LastRow);
%%ELSE
    IF SQLM_%%(tabName)_WorkRow:%%(SQLC_%%(tabName)_LastRow) = 0 THEN
        SQLX_OperRow=SQLM_TableReference:SQLM_System+1;
    ELSE
%%SET sentSigs(,TOWGETSCH)
        SEND towGetSch REFERENCE cOwnRef WITH
            +,
            PROTECTEDP,
            SQLM_TableReference,
            %%(keyNo),
            SQLM_%%(tabName)_WorkRow:%%(SQLC_%%(tabName)_LastRow),
            SQLM_%%(tabName)_WorkRoW
%%LOOP(dr <= 15)
            ,SQLX_DR%%(dr+4)
%%ENDLOOP(dr)
            ,
            %%(keyOp),
            +,
            +,
%%SET towGetSchLab(%%(towGetSchLab +1))
            %%(towGetSchLab);
        EXIT;
    FI;
towGetSchLab%%(towGetSchLab))
    PROTECTEDP=SQLX_OtherProtected;
    SQLM_%%(tabName)_WorkRow=SQLX_WorkRow;
    SQLM_%%(tabName)_OperRow=SQLX_OperRow;
%%ENDIF
! check if row is not found, if so report failure !
    IF SQLM_%%(tabName)_OperRow >= SQLM_TableReference:SQLM_TableAllocated THEN
        SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_Lock=2;
! Search failure: row not found !
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat%%(statNo);
    FI;
    IF SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_Allocated = 0 THEN
        SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_Lock=2;
! Search failure: row not found !
        SQLCODE=2+1 <= 8;
        GOTO EXITlocFetchStat%%(statNo);
    FI;
! check if row is locked, if so report failure !
    IF SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_Lock > 1 THEN
        SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_Lock=2;
        SQLCODE=2+3 <= 8;
        GOTO EXITlocFetchStat%%(statNo);
    FI;
! update cursor !
%%IF(keyOp = 0)
    SQLM_%%(tabName)_WorkRow:%%(SQLC_%%(tabName)_LastRow)=
        SQLM_TableReference:SQLM_System+1;
%%ELSE
    SQLM_%%(tabName)_WorkRow:%%(SQLC_%%(tabName)_LastRow)=
        SQLM_%%(tabName)_OperRow;
%%ENDIF
%%ENDIF
    SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_DBnumber2=
        SQLM_%%(tabName)_OperRow:SQLC_%%(tabName)_DBnumber2;
! Do additional tests, if the fails try another row. !
%%LOOP(j <= preds)
%%INCLUDE(scanPredicate(%%(tabNo), %%(tabName), %%(j), "SUCCESSlocFetchStat%%(statNo)", "NEXTlocFetchStat%%(statNo)", "P"))
%%ENDLOOP(j)
%%IF(preds > 0)
SUCCESSlocFetchStat%%(statNo))
%%ENDIF
! Everything is allright, copy columns into variables. !
%%INCLUDE(getData)
! Set cursor to indicate that a row was found and return success !
    SQLM_%%(tabName)_WorkRow:SQLC_%%(tabName)_Lock=0;
    SQLCODE=0;
EXITlocFetchStat%%(statNo))
%%END(locFetchStat)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
- 9. TRANSACTION HANDLING STATMENT
-------------------------------------------------------------------------

------------------------------------------------------------------------
-Code component startStat, chapter 9.1

-IMP-VARIABLES

        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - indMax        Max size  of a file, currently 65535.
        - trhStaTransLab        Label counter for trhStaTrans, initially
        -                       set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(startStat)
!--------------------------------------!
!       startStat!
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if inside a transaction, if so report failure !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
        SQLCODE=3+15 <= 8;
%%SET trhStaTransLab(%%(trhStaTransLab + 1))
        GOTO trhStaTransLab%%(trhStaTransLab);
    FI;
    PROTECTEDP:SQLX_SQLRETURN=%%(trhStaTransLab);
%%SET sentSigs(,TRHSTATRANS)
    SEND trhStaTrans WITH
        PROTECTEDP,
        cOwnRef,
%%IF(LOGPATCH(1))
        1,
%%ELSE
        0,
%%ENDIF
        %%(transId);
    EXIT;
trhStaTransLab%%(trhStaTransLab))
%%END(startStat)
-------------------------------------------------------------------------



------------------------------------------------------------------------
-Code component  prepareStat, chapter 9.2

-IMP-VARIABLES

        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - indMax        Max size  of a file, currently 65535.
        - trhVerTransLab        Label counter for trhVerTrans, initially
        -                       set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(prepareStat)
!--------------------------------------!
!       prepareStat     !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
%%SET trhVerTransLab(%%(trhVerTransLab +1))
        GOTO trhVerTransLab%%(trhVerTransLab);
    FI;
! Request to prepare a transaction for commit. !
    PROTECTEDP:SQLX_SQLRETURN=%%(trhVerTransLab);
%%SET sentSigs(,TRHVERTRANS)
    SEND trhVerTrans WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnref;
    EXIT;
trhVerTransLab%%(trhVerTransLab))
%%END(prepareStat)
-------------------------------------------------------------------------



------------------------------------------------------------------------
-Code component commitStat, chapter 9.3

-IMP-VARIABLES

        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - indMax        Max size  of a file, currently 65535.
        - trhComrTransLab       Label counter for trhComTrans, initially
        -                       set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(commitStat)
!--------------------------------------!
!       commitStat      !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
%%SET trhComTransLab(%%(trhComTransLab + 1))
        GOTO trhComTransLab%%(trhComTransLab);
    FI;
! Request to commit a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=%%(trhComTransLab);
%%SET sentSigs(,TRHCOMTRANS)
    SEND trhComTrans WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhComTransLab%%(trhComTransLab))
! Close transaction !
    PROTECTEDP:SQLTRANSID=0;
%%END(commitStat)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
-Code component  rollbackStat, chapter 9.4

-IMP-VARIABLES

        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - indMax        Max size  of a file, currently 65535.
        - trhRollBckLab         Label counter for trhRollBck, initially
        -                       set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(rollbackStat)
!--------------------------------------!
!       rollbackStat    !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! Check if inside another transaction, if not report failure !
    IF PROTECTEDP:SQLTRANSID = 0 THEN
        SQLCODE=3+13 <= 8;
%%SET trhRollBckLab(%%(trhRollBckLab + 1))
        GOTO trhRollBckLab%%(trhRollBckLab);
    FI;
! Request to rollback a transaction. !
    PROTECTEDP:SQLX_SQLRETURN=%%(trhRollBckLab);
%%SET sentSigs(,TRHROLLBCK)
    SEND trhRollBck WITH
        PROTECTEDP:SQLTRANSID,
        PROTECTEDP,
        cOwnRef;
    EXIT;
trhRollBckLab%%(trhRollBckLab))
! Close the transaction !
    PROTECTEDP:SQLTRANSID=0;
%%END(rollbackStat)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
- 10. PROTECTED REGION STATMENTS
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-Code component beginStat, chapter 10.1

-IMP-VARIABLES
        - tabName       The table name.
        - indMax        Max size  of a file, currently 65535.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
-------------------------------------------------------------------------
%%BEGIN(beginStat)
!--------------------------------------!
!       beginStat       !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
DISABLE INTERRUPT;
! Check that the protected area is not locked !
    IF SQLM_ProtectedLock = 1 THEN
        SQLCODE=3+19 <= 8;
        GOTO EXITbeginStat%%(statNo);
    FI;
! Find a protected region !
    IF SQLM_ProtectedAllocated = SQLM_ProtectedUsed THEN
        SQLCODE=3+17 <= 8;
    ELSE
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedLast-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat%%(statNo);
        FOR FIRST PROTECTEDP
            FROM SQLM_ProtectedAllocated-1
            WHERE PROTECTEDP:SQLM_Allocated = 0
            GOTO PROTECTEDALLOCATEDbeginStat%%(statNo);
! We should never get here !
        SQLCODE=3+17 <= 8;
    FI;
    GOTO EXITbeginStat%%(statNo);
PROTECTEDALLOCATEDbeginStat%%(statNo))
    IF PROTECTEDP = 0 THEN
        SQLM_ProtectedLast = SQLM_ProtectedAllocated;
    ELSE
        SQLM_ProtectedLast = PROTECTEDP;
    FI;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed+1;
    PROTECTEDP:SQLM_Allocated = 1;
    SQLCODE = 0;
EXITbeginStat%%(statNo))
ENABLE INTERRUPT;
%%END(beginStat)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
-Code component endStat, chapter 10.2

-IMP-VARIABLES
        - tabName       The table name.
        - indMax        Max size  of a file, currently 65535.
        - statNo        Statment number, initialized to 0, incremented in all
        -               statments.
        - towCloseLab   Label counter for towClose and towGetFld, initially
        -               set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(endStat)
!--------------------------------------!
!       endStat !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
! If there are any cursors open, close them. !
%%LOOP(i <= curNames[0])
    IF PROTECTEDP:SQLM_%%(curNames[i])_Cursor /= 0 THEN
%%IF(curLocal[i] = 1)
        SQLM_%%(curTabNames[i])_WorkRow=PROTECTEDP:SQLM_%%(curNames[curNo])_Cursor;
%%INCLUDE(deAllocateWorkRow(%%(curTabNames[i])))
%%ELSE
%%SET sentSigs(,TOWCLOSE)
%%IF(multiNo%%(curTabNos[i])(?))
        SEND towClose REFERENCE %%(curBlockRefs[i]) WITH
            PROTECTEDP,
            %%(multiNo%%(curTabNos[i])),
%%ELSE
        SEND towClose REFERENCE SQLM_Remote(%%(curTabNos[i] - remTabNos[1])).block WITH
            PROTECTEDP,
            SQLM_Remote(%%(curTabNos[i] - remTabNos[1])).table,
%%ENDIF
            PROTECTEDP:SQLM_%%(curNames[i])_Cursor;
        WAIT FOR towCloseAck IN TOWCLOSEACK%%(statNo);
TOWCLOSEACK%%(statNo))
%%SET recSigs(,TOWCLOSEACK)
        RETRIEVE towCloseAck WITH
            PROTECTEDP;
%%ENDIF
    FI;
    PROTECTEDP:SQLM_%%(curNames[i])_Cursor=0;
%%ENDLOOP(i)
! Roll back any ongoing transaction !
    IF PROTECTEDP:SQLTRANSID /= 0 THEN
%%SET trhRollBckLab(%%(trhRollBckLab + 1))
! Request to rollback a transaction. !
        PROTECTEDP:SQLX_SQLRETURN=%%(trhRollBckLab);
%%SET sentSigs(,TRHROLLBCK)
        SEND trhRollBck WITH
            PROTECTEDP:SQLTRANSID,
            PROTECTEDP,
            cOwnRef;
        EXIT;
    FI;
trhRollBckLab%%(trhRollBckLab))
! Deallocate protected region !
DISABLE INTERRUPT;
    PROTECTEDP:SQLM_Allocated=0;
    SQLM_ProtectedUsed=SQLM_ProtectedUsed-1;
    SQLCODE=0;
ENABLE INTERRUPT;
%%END(endStat)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
- 11. MISCELLANEOUS STATMENTS
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-Code component continueStat, chapter 11.1

-IMP-VARIABLES
        - continueBLab  Label counter for CONTINUEB, initially
        -               set to 0, incremented before each use.
        - continueCLab  Label counter for CONTINUEC, initially
        -               set to 0, incremented before each use.
        - exprs
        - timeUnit
-------------------------------------------------------------------------
%%BEGIN(continueStat)
!--------------------------------------!
!       continueStat    !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
%%IF(level = "B")
%%SET sentSigs(,CONTINUEB)
    SEND CONTINUEB REFERENCE cOwnRef WITH
        PROTECTEDP,
%%SET continueBLab(%%(continueBLab + 1))
        %%(continueBLab)
%%ELSE
%%SET sentSigs(,CONTINUEC)
    SEND CONTINUEC REFERENCE cOwnRef WITH
        PROTECTEDP,
%%SET continueCLab(%%(continueCLab + 1))
        %%(continueCLab)
%%ENDIF
%%IF(exprs # "")
        DELAY %%(exprs) %%(timeUnit)
%%ENDIF
        ;
    EXIT;
%%IF(level = "B")
continueBLab%%(continueBLab))
%%ELSE
continueCLab%%(continueCLab))
%%ENDIF
%%END(continueStat)
-------------------------------------------------------------------------




-------------------------------------------------------------------------
-Code component  getDbnumberStat, chapter 11.2

-IMP-VARIABLES
        - trhGetDBnoLab         Label counter for trhGetDBno, initially
        -                       set to 0, incremented before each use.
-------------------------------------------------------------------------
%%BEGIN(getDbnumberStat)
!--------------------------------------!
!       getDbnumberStat !
!--------------------------------------!
%%SET statNo(%%(statNo + 1))
%%SET sentSigs(,TRHGETDBNO)
    SEND trhGetDBno WITH
        PROTECTEDP,
        cOwnRef
        WAIT FOR trhGetDBnoAck IN RETURNLABELgetDbnumberStat%%(statNo);
RETURNLABELgetDbnumberStat%%(statNo))
%%SET recSigs(,TRHGETDBNOACK)
    RETRIEVE trhgetDBnoAck WITH
        %%(vars).PART1,
        %%(vars).PART2;
%%END(getDbnumberStat)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
-Code component  recTowGetR, chapter 12
-------------------------------------------------------------------------
%%BEGIN(recTowGetR)
!--------------------------------------!
!       recTowGetR      !
!--------------------------------------!
%%IF(towGetLab > 0)
%%SET recSigs(,TOWGETR)
   ENTER towGetR WITH
        PROTECTEDP,
        SQLCODE,
        SQLX_OperRow,
        SQLX_DBnumber2
%%LOOP(dr <= 21)
        ,SQLX_DR%%(dr+2)
%%ENDLOOP(dr)
        ;
%%IF(towGetLab = 1)
    GOTO towGetLab1;
%%ELSE
    CASE PROTECTEDP:SQLX_SQLRETURN IS
%%LOOP(i <= towGetLab)
    WHEN %%(i) DO GOTO towGetLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recTowGetR)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
-Code component recTowChaVolRowR, chapter 13

-------------------------------------------------------------------------
%%BEGIN(recTowChaVolRowR)
!--------------------------------------!
!       recTowChaVolRowR        !
!--------------------------------------!
%%IF(towChaVolRowLab > 0)
%%SET recSigs(,TOWCHAVOLROWR)
    ENTER towChaVolRowR WITH
        PROTECTEDP,
        SQLCODE;
%%IF(towChaVolRowLab = 1)
    GOTO towChaVolRowLab1;
%%ELSE
    CASE PROTECTEDP:SQLX_SQLRETURN IS
%%LOOP(i <= towChaVolRowLab)
    WHEN %%(i) DO GOTO towChaVolRowLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recTowChaVolRowR)
-------------------------------------------------------------------------




-------------------------------------------------------------------------
-Code component recTrhInsRowR, chapter 14
-------------------------------------------------------------------------
%%BEGIN(recTrhInsRowR)
!--------------------------------------!
!       recTrhInsRowR   !
!--------------------------------------!
%%IF(trhInsRowLab > 0)
%%SET recSigs(,TRHINSROWR)
    ENTER trhInsRowR WITH
        PROTECTEDP,
        SQLCODE;
%%IF(trhInsRowLab = 1)
    GOTO trhInsRowLab1;
%%ELSE
    CASE PROTECTEDP:SQLX_SQLRETURN IS
%%LOOP(i <= trhInsRowLab)
    WHEN %%(i) DO GOTO trhInsRowLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recTrhInsRowR)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
-Code component recTrhLetFldR, chapter 15
-------------------------------------------------------------------------
%%BEGIN(recTrhLetFldR)
!--------------------------------------!
!       recTrhLetFldR    !
!--------------------------------------!
%%IF(trhLetFldLab > 0)
%%SET recSigs(,TRHLETFLDR)
    ENTER TrhLetFldR WITH
        PROTECTEDP,
        SQLCODE;
%%IF(trhLetFldLab = 1)
    GOTO trhLetFldLab1;
%%ELSE
    CASE PROTECTEDP:SQLX_SQLRETURN IS
%%LOOP(i <= trhLetFldLab)
    WHEN %%(i) DO GOTO trhLetFldLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recTrhLetFldR)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
-Code component recTrhChaRowR, chapter 16
-------------------------------------------------------------------------
%%BEGIN(recTrhChaRowR)
!--------------------------------------!
!       recTrhChaRowR   !
!--------------------------------------!
%%IF(trhChaRowLab > 0)
%%SET recSigs(,TRHCHAROWR)
    ENTER trhChaRowR WITH
        PROTECTEDP,
        SQLCODE;
%%IF(trhChaRowLab = 1)
    GOTO trhChaRowLab1;
%%ELSE
    CASE PROTECTEDP:SQLX_SQLRETURN IS
%%LOOP(i <= trhChaRowLab)
    WHEN %%(i) DO GOTO trhChaRowLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recTrhChaRowR)
-------------------------------------------------------------------------




-------------------------------------------------------------------------
-Code component recTrhDelRowR, chapter 17
-------------------------------------------------------------------------
%%BEGIN(recTrhDelRowR)
!--------------------------------------!
!       recTrhDelRowR   !
!--------------------------------------!
%%IF(trhDelRowLab > 0)
%%SET recSigs(,TRHDELROWR)
    ENTER trhDelRowR WITH
        PROTECTEDP,
        SQLCODE;
%%IF(trhDelRowLab = 1)
    GOTO trhDelRowLab1;
%%ELSE
    CASE PROTECTEDP:SQLX_SQLRETURN IS
%%LOOP(i <= trhDelRowLab)
    WHEN %%(i) DO GOTO trhDelRowLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recTrhDelRowR)
-------------------------------------------------------------------------




-------------------------------------------------------------------------
-Code component recTowOpenR, chapter 18
-------------------------------------------------------------------------
%%BEGIN(recTowOpenR)
!--------------------------------------!
!       recTowOpenR     !
!--------------------------------------!
%%IF(towOpenLab > 0)
%%SET recSigs(,TOWOPENR)
    ENTER towOpenR WITH
        PROTECTEDP,
        SQLCODE,
        SQLX_OperRow;
%%IF(towOpenLab = 1)
    GOTO towOpenLab1;
%%ELSE
    CASE PROTECTEDP:SQLX_SQLRETURN IS
%%LOOP(i <= towOpenLab)
    WHEN %%(i) DO GOTO towOpenLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recTowOpenR)
-------------------------------------------------------------------------







-------------------------------------------------------------------------
-Code component recTrhStaTransR, chapter 19
-------------------------------------------------------------------------
%%BEGIN(recTrhStaTransR)
!--------------------------------------!
!       recTrhStaTransR !
!--------------------------------------!
%%IF(trhStaTransLab > 0)
%%SET recSigs(,TRHSTATRANSR)
    ENTER trhStaTransR WITH
        PROTECTEDP,
        SQLCODE,
        PROTECTEDP:SQLTRANSID;
%%IF(trhStaTransLab = 1)
    GOTO trhStaTransLab1;
%%ELSE
    CASE PROTECTEDP:SQLX_SQLRETURN IS
%%LOOP(i <= trhStaTransLab)
    WHEN %%(i) DO GOTO trhStaTransLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
    EXIT;
%%ENDIF
%%ENDIF
%%END(recTrhStaTransR)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
-Code component recTrhVerTransR, chapter 20
-------------------------------------------------------------------------
%%BEGIN(recTrhVerTransR)
!--------------------------------------!
!       recTrhVerTransR !
!--------------------------------------!
%%IF(trhVerTransLab > 0)
%%SET recSigs(,TRHVERTRANSR)
    ENTER trhVerTransR WITH
        PROTECTEDP,
        SQLCODE,
        PROTECTEDP:SQLBLOCK,
        PROTECTEDP:SQLTABLE;
%%IF(trhVerTransLab = 1)
    GOTO trhVerTransLab1;
%%ELSE
    CASE PROTECTEDP:SQLX_SQLRETURN IS
%%LOOP(i <= trhVerTransLab)
    WHEN %%(i) DO GOTO trhVerTransLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recTrhVerTransR)
-------------------------------------------------------------------------



-------------------------------------------------------------------------
-Code component recTrhComTransR, chapter 21
-------------------------------------------------------------------------
%%BEGIN(recTrhComTransR)
!--------------------------------------!
!       recTrhComTransR !
!--------------------------------------!
%%IF(trhComTransLab > 0)
%%SET recSigs(,TRHCOMTRANSR)
    ENTER trhComTransR WITH
        PROTECTEDP,
        SQLCODE,
        PROTECTEDP:SQLBLOCK,
        PROTECTEDP:SQLTABLE;
%%IF(trhComTransLab = 1)
    GOTO trhComTransLab1;
%%ELSE
    CASE PROTECTEDP:SQLX_SQLRETURN IS
%%LOOP(i <= trhComTransLab)
    WHEN %%(i) DO GOTO trhComTransLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recTrhComTransR)
-------------------------------------------------------------------------


-------------------------------------------------------------------------
-Code component recTrhRollBckR, chapter 22
-------------------------------------------------------------------------
%%BEGIN(recTrhRollBckR)
!--------------------------------------!
!       recTrhRollBckR  !
!--------------------------------------!
%%IF(trhRollBckLab > 0)
%%SET recSigs(,TRHROLLBCKR)
    ENTER trhRollBckR WITH
        PROTECTEDP,
        SQLCODE;
%%IF(trhRollBckLab = 1)
    GOTO trhRollBckLab1;
%%ELSE
    CASE PROTECTEDP:SQLX_SQLRETURN IS
%%LOOP(i <= trhRollBckLab)
    WHEN %%(i) DO GOTO trhRollBckLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recTrhRollBckR)
-------------------------------------------------------------------------




-------------------------------------------------------------------------
-Code component recContinueB, chapter ??
-------------------------------------------------------------------------
%%BEGIN(recContinueB)
!--------------------------------------!
!       recContinueB !
!--------------------------------------!
%%IF(continueBLab > 0)
%%SET recSigs(,CONTINUEB)
    ENTER CONTINUEB WITH
        PROTECTEDP,
        SQLX_ReturnLabel;
%%IF(continueBLab = 1)
    GOTO continueBLab1;
%%ELSE
    CASE SQLX_ReturnLabel IS
%%LOOP(i <= continueBLab)
    WHEN %%(i) DO GOTO continueBLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recContinueB)
-------------------------------------------------------------------------

-------------------------------------------------------------------------
-Code component recContinueC, chapter ??
-------------------------------------------------------------------------
%%BEGIN(recContinueC)
!--------------------------------------!
!       recContinueC !
!--------------------------------------!
%%IF(continueCLab > 0)
%%SET recSigs(,CONTINUEC)
    ENTER CONTINUEC WITH
        PROTECTEDP,
        SQLX_ReturnLabel;
%%IF(continueCLab = 1)
    GOTO continueCLab1;
%%ELSE
    CASE SQLX_ReturnLabel IS
%%LOOP(i <= continueCLab)
    WHEN %%(i) DO GOTO continueCLab%%(i);
%%ENDLOOP(i)
    OTHERWISE DO ! nothing ! ;
    ESAC;
%%ENDIF
    EXIT;
%%ENDIF
%%END(recContinueC)
-------------------------------------------------------------------------




-------------------------------------------------------------------------
-Code component recTusReAllProt, chapter 

- Used by the transaction handler to reallocate a protection individual
- that holds information on a verified transaction.
-------------------------------------------------------------------------
%%BEGIN(recTusReAllProt)
!--------------------------------------!
!        recTusReAllProt !
!--------------------------------------!
%%SET recSigs(,TUSREALLPROT)
    RECEIVE TusReAllProt WITH
        PROTECTEDP,
        SQLX_OtherProtected;
    PROTECTEDP:SQLM_Allocated = 1;
%%SET sentSigs(,TUSREALLPROTACK)
    RETURN TusReAllProtAck WITH
        SQLX_OtherProtected;
%%END(recTusReAllProt)
-------------------------------------------------------------------------
