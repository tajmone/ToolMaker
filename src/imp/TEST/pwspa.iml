IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                 1.




pwspa.tst

   1.   
====>   1

  *1*   303 I : 1 times

   2.   %%SET optimize(lr0,trow,ntrow)
====>   1

  *1*   303 I : 1 times

   3.   %%SET recovery(panic,global,single)
====>   1

  *1*   303 I : 1 times

   4.   %%SET semantic(on)
====>   1

  *1*   303 I : 1 times

   5.   %%SET name(MACRO)
====>   1

  *1*   303 I : 1 times



pwsint.tst

   1.1  /* -------------------------- PWSINT --------------------------------
        ------- */
====>   1

  *1*   303 I : 1 times

   2.1  /*									     */
   3.1  /* File: PWSINT.SKL		- Interface file 		1987-05-05   */
   4.1  /*									     */
   5.1  /*	Host   :  Dec-Pascal/VMS					     */
   6.1  /*	Target :  Dec-C/VMS						     */
   7.1  /* ------------------------------------------------------------------
        ------- */
   8.1  
   9.1  %%BEGIN(idata)
====>   1

  *1*   303 I : 1 times

  10.1  
====>   1

  *1*   303 I : 0 times
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                 2.



  11.1  	/* Parser definitions */
  12.1  
  13.1  #define PWSTKMX	   32		/* Stack length      */
  14.1  #define	PWLAMX	   5		/* Look-ahead length */
  15.1  #define	PWSCOST    5		/* SHifting cost     */
  16.1  
  17.1  
  18.1  %%BEGIN(notincl)
====>   1

  *1*   303 I : 0 times

  19.1  Denna text skall ej inkluderas i parsern!
  20.1  %%END(foonotincl)
====>         1

  *1*   203 W : Label "foonotincl" differs from corresponding BEGIN label.

  21.1  	/* Scanner interface */
====>   1

  *1*   303 I : 0 times

  22.1  	/* ----------------- */
  23.1  
  24.1  #include "swscan.h"
  25.1  
  26.1  typedef SWSYMDF PWSYMDF;
  27.1  
  28.1  extern PWSYMDF token;
  29.1  
  30.1  	/* Semantic attribute interface */
  31.1  	/* ---------------------------- */
  32.1  
  33.1  #include <stdio.h>
  34.1  #include "macro.h"
  35.1  
  36.1  typedef struct {		/* Semantic attribute definitions  */
  37.1  	SWSRCP srcp;		/* Source position propagated from terminals.*/
  38.1  	SWSTR sval;		/* String propagated from terminals. */
  39.1  	boolean flag;		/* Multi purpose flag. */
  40.1  	char *ref;		/* Multi purpose pointer. */
  41.1  	 } PWSEMDF;
  42.1  
  43.1  
  44.1  %%END(fooidata)
====>         1

  *1*   203 W : Label "fooidata" differs from corresponding BEGIN label.

  45.1  %%BEGIN(icode)
====>   1

  *1*   303 I : 1 times

IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                 3.


  46.1  
====>   1

  *1*   303 I : 0 times

  47.1  #define pwscan(token) swscan(token)
  48.1  
  49.1  extern pwrpoi();		/* Error recovery - restart point  */
  50.1  extern pwisym();		/* Error recovery - insert symbol  */
  51.1  extern pwdsym();		/* Error recovery - delete symbol  */
  52.1  extern pwmess();		/* Error recovery - error message  */
  53.1  %%END(icode)
  54.1  



pwspa.tst

   6.   %%PROCESS("pwsint.tst")
====>   1

  *1*   303 I : 1 times

   7.   /* -------------------------- PWSPA ---------------------------------
        ------- */
====>   1

  *1*   303 I : 1 times

   8.   /*									     */
   9.   /* Skeleton: PWSPA		- Parser module			1987-08-06   */
  10.   /*									     */
  11.   /*	Host:	Dec-Pascal/VMS						     */
  12.   /*	Target: Dec-C/VMS						     */
  13.   /* ------------------------------------------------------------------
        ------- */
  14.   /*									     */
  15.   /* Function: The PWSPA module contains the entry point of the LALR(1)
        	     */
  16.   /*	     parser - PWPARS.	 					     */
  17.   /* ------------------------------------------------------------------
        ------- */
  18.   /* Interface - Scanner & Semantic (defined in the interface file)	   
          */
  19.   /* ------------------------------					     */
  20.   /* PWSYMDF = 								     */
  21.   /*	union								     */
  22.   /*	   {								     */
  23.   /*		....							     */
  24.   /*	     int code;							     */
  25.   /*	   };								     */
  26.   /*									     */
  27.   /* PWSEMDF =								     */
  28.   /*	union								     */
  29.   /*	   {								     */
  30.   /*		...							     */
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                 4.


  31.   /*	   };								     */
  32.   /*									     */
  33.   /* Interface - routines (defined in the interface file)			     */
  34.   /* --------------------							     */
  35.   /* pwscan( ... );							     */
  36.   /* pwmess( ... );   							     */
  37.   /* pwrpoi( ... );   							     */
  38.   /* pwisym( ... );   							     */
  39.   /* pwdsym( ... );							     */
  40.   /*									     */
  41.   /* Interface - data (generated by PWS)					     */
  42.   /* ----------------							     */
  43.   /* xxxxx.DEF   - Parser constants					     */
  44.   /* xxxxx.TBL   - Parser tables and structures				     */
  45.   /* xxxxx.VOC   - Vocabulary information					     */
  46.   /* ------------------------------------------------------------------
        ------- */
  47.   
  48.   #include <setjmp.h>
  49.   
  50.   
  51.   #define  PWTRUE  1
  52.   #define  PWFALSE 0
  53.   typedef  short  PWBOOL ;
  54.   
  55.   	/* Interface data definitions */
  56.   	/* -------------------------- */
  57.   
  58.   %%INCLUDE(idata)
====>   1

  *1*   303 I : 1 times

  59.   
====>   1

  *1*   303 I : 1 times

  60.   short	   pwstkp;		/*  Stack pointer		     */
  61.   PWSYMDF  pwsyst[PWSTKMX];	/*  Symbol stack		     */
  62.   %%IF( semantic(on) )
====>   1     2

  *1*   303 I : 1 times
  *2*   303 I : 1 times

  63.   PWSEMDF  pwsest[PWSTKMX];	/*  Semantic stack		     */ 
====>   1

  *1*   303 I : 1 times

  64.   %%ENDIF
  65.   
====>   1

  *1*   303 I : 1 times
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                 5.



  66.   		/* Interface routines */
  67.   		/* ------------------ */
  68.   
  69.   %%INCLUDE(icode)
====>   1

  *1*   303 I : 1 times

  70.   
====>   1

  *1*   303 I : 1 times

  71.   %%IF( semantic(on))
====>   1     2

  *1*   303 I : 1 times
  *2*   303 I : 1 times

  72.   extern pwsema();
====>   1

  *1*   303 I : 1 times

  73.   %%ENDIF
  74.   
====>   1

  *1*   303 I : 1 times

  75.   		/* Parser constants */
  76.   		/* ---------------- */
  77.   
  78.   #define  ERROR   	0		/* Action - Error	 */
  79.   #define  SHIFT   	1		/* Action - Shift	 */
  80.   #define  SHFT_RED  	2		/* Action - Shift_Reduce */
  81.   #define  REDUCE  	3		/* Action - Reduce	 */
  82.   #define  ACCEPT  	4		/* Action - Accept	 */
  83.   
  84.   #define  ERR_SYM 	0		/* Error token		  */
  85.   #define  ENDMARK	1		/* End of file token code */
  86.   
  87.   	     /* Recovery method */
  88.   	     /* --------------- */
  89.   
  90.   #define  NONE_REC    	0		/* No recovery found	    */
  91.   #define  IN_REC  	1		/* Insertion of symbol(s)   */
  92.   #define  DEL_REC	2		/* Deletion of symbol(s)    */
  93.   #define  REP_REC    	3		/* Replacement of symbol(s) */
  94.   #define  BAK_REC    	4		/* Stack backup		    */
  95.   #define  HALT_REC     	5		/* System halted	    */
  96.   
  97.   	     /* Error class */
  98.   	     /* ----------- */
  99.   
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                 6.


 100.   #define  LEX_ERR	1		/* Non valid scanner symbol found */
 101.   #define  SYN_ERR	2		/* Normal syntax error		  */
 102.   #define  OFLW_ERR	3		/* Parse stack overflow		  */
 103.   #define  TAB_ERR	4		/* Parse table error		  */
 104.   	   
 105.   	     /* Error severity */
 106.   	     /* -------------- */   
 107.   
 108.   #define  WAR_SEV	1		/* Warnings		*/
 109.   #define  ERR_SEV	2		/* Repairable error	*/
 110.   #define  FAT_SEV	3		/* Fatal error		*/
 111.   #define  SYS_SEV	4		/* System & limit error */
 112.   
 113.   %%IF( recovery(single))
====>   1     2

  *1*   303 I : 1 times
  *2*   303 I : 1 times

 114.   		/* Error recovery constants */
====>   1

  *1*   303 I : 1 times

 115.   		/* ------------------------ */
 116.   	
 117.   #define  PALARNG	PWLAMX+1	/* Look-ahead symbol (array) range   */
 118.   %%ENDIF
 119.   
====>   1

  *1*   303 I : 1 times

 120.   	/* PWS generated parser constants */
 121.   	/* ------------------------------ */
 122.   
 123.   #include "%%(name).DEF"
====>             1       2

  *1*   303 I : 1 times
  *2*   303 I : 1 times

 124.   
 125.   typedef  short PTSET;	  		  /* Set representation		     */
 126.   typedef	 PTSET  PTTSET[(PATMX/PASETSZ)+1];/* Terminal set		     */
 127.   
 128.   #define  PASTATMN  1			  /* Minimal statement number	     */
 129.   #define  PASTARNG  PASTATMX-PASTATMN+1    /* State number (array) ran
        ge      */
 130.   typedef  short  PTSTARNG;		  /* and range type		     */
 131.   
 132.   #define  PATMN  1			  /* Minimal terminal number	     */
 133.   #define  PATRNG  PATMX-PATMN+1		  /* Terminal symbol (array) range   
        */
 134.   typedef  short  PTTRNG;			  /* and range type		     */
 135.   
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                 7.


 136.   #define  PANTSMN  (PATMX+1)		  /* Minimal non terminal number     */
 137.   #define  PANTSRNG PAVOCMX-PANTSMN+1	  /* Non terminal symbol (array) 
        rng */
 138.   typedef  short  PTNTSRNG;		  /* and range type		     */
 139.   
 140.   #define  PAPRDMN  1			  /* Minimal production number       */
 141.   #define  PAPRDRNG PAPRDMX-PAPRDMN+1	  /* Production (array) range	   
          */
 142.   typedef  short  PTPRDRNG;		  /* and range type		     */
 143.   
 144.   typedef  char /* TINY */ PTACTRNG;	  /* Action range type		     */
 145.   typedef  short  PTCCRNG;		  /* Condition code type	     */
 146.   
 147.   #define  PATCRNG (PATCMX+1)	    	  /* Terminal code (array) range    
         */
 148.   typedef  short   PTTCRNG;		  /* Terminal code type		     */
 149.   typedef  short   PTENTRNG;		  /* Parse table entry range type    */
 150.   typedef  short   PTVOCRNG;		  /* Vocabulary number range type    */
 151.   
 152.   %%IF( optimize(trow) AND NOT optimize(tmerge) AND NOT optimize(tsplit
        ))
====>   1     2                      3                        4

  *1*   303 I : 1 times
  *2*   303 I : 1 times
  *3*   303 I : 1 times
  *4*   303 I : 1 times

 153.   typedef  short	 RDSIXRNG;		  /* Row Displacement Index Range    */
====>   1

  *1*   303 I : 1 times

 154.   %%ENDIF
 155.   
====>   1

  *1*   303 I : 1 times

 156.   %%IF( optimize(trow) OR optimize(tmerge) OR optimize(tsplit))
====>   1     2                 3                   4

  *1*   303 I : 1 times
  *2*   303 I : 1 times
  *3*   303 I : 0 times
  *4*   303 I : 0 times

 157.   typedef	 short	 PTAIRRNG;		  /* Action Index Row Value Range    */
====>   1

  *1*   303 I : 1 times

 158.   %%ENDIF
 159.   %%IF( optimize(tmerge) OR optimize(tsplit))
====>   1     2                   3

IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                 8.


  *1*   303 I : 1 times
  *2*   303 I : 1 times
  *3*   303 I : 1 times

 160.   typedef	 short	 PTAICRNG;		  /* Action Index Column Value Range */
====>   1

  *1*   303 I : 0 times

 161.   %%ENDIF
 162.   %%IF( optimize(ntrow) OR optimize(ntmerge) OR optimize(ntsplit))
====>   1     2                  3                    4

  *1*   303 I : 1 times
  *2*   303 I : 1 times
  *3*   303 I : 0 times
  *4*   303 I : 0 times

 163.   typedef	 short	 PTGIRRNG;		  /* Goto Index Row Value Range	     */
====>   1

  *1*   303 I : 1 times

 164.   %%ENDIF
 165.   %%IF( optimize(ntmerge) OR optimize(ntsplit))
====>   1     2                    3

  *1*   303 I : 1 times
  *2*   303 I : 1 times
  *3*   303 I : 1 times

 166.   typedef	 short	 PTGICRNG;		  /* Goto Index Column Value Range   */
====>   1

  *1*   303 I : 0 times

 167.   %%ENDIF
 168.   
====>   1

  *1*   303 I : 1 times

 169.   
 170.   		/* Terminal table */
 171.   		/* -------------- */
 172.   
 173.   typedef  PTENTRNG  ACTROW[PAACOLMX-PATMN+1]; /* Row in action table	 
            */
 174.   %%IF( NOT optimize(trow))
====>   1         2

  *1*   303 I : 1 times
  *2*   303 I : 1 times

 175.   typedef  ACTROW  ACTTAB[PAAROWMX-PASTATMN+1];/* Action table		     */
====>   1
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                 9.



  *1*   303 I : 0 times

 176.   %%ENDIF
 177.   %%IF( optimize(trow) AND NOT optimize(tmerge) AND NOT optimize(tsplit
        ))
====>   1     2                      3                        4

  *1*   303 I : 1 times
  *2*   303 I : 1 times
  *3*   303 I : 1 times
  *4*   303 I : 1 times

 178.   typedef  RDSIXRNG RDSIXROW[PARCOLMX-PATMN+1];/* Row Displacement Inde
        x Row   */
====>   1

  *1*   303 I : 1 times

 179.   %%ENDIF
 180.   %%IF( optimize(tmerge) OR optimize(tsplit) OR optimize(trow))
====>   1     2                   3                   4

  *1*   303 I : 1 times
  *2*   303 I : 1 times
  *3*   303 I : 1 times
  *4*   303 I : 1 times

 181.   typedef  PTAIRRNG ACTIXROW[PASTARNG];	     /* Indirect ACTION rows	  
           */
====>   1

  *1*   303 I : 1 times

 182.   %%ENDIF
 183.   %%IF( optimize(tmerge) OR optimize(tsplit))
====>   1     2                   3

  *1*   303 I : 1 times
  *2*   303 I : 1 times
  *3*   303 I : 1 times

 184.   typedef  PTAICRNG ACTIXCOL[PATRNG];	     /* Indirect ACTION columns  
            */
====>   1

  *1*   303 I : 0 times

 185.   typedef  PTSET  ERRSET[(PAECOLMX/PASETSZ)+1];/* Set of error entries	
             */
 186.   typedef  ERRSET ERRTAB[PAEROWMX-PASTATMN+1]; /* Non ERROR table		    
         */
 187.   %%IF( optimize(tsplit))
====>   1

  *1*   303 I : 0 times
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                10.



 188.   typedef  PTCCRNG  ACTCCROW[PASTARNG];	     /* Condition ACTION row	  
           */
 189.   typedef  PTCCRNG  ACTCCCOL[PATRNG];	     /* Condition ACTION column  
            */
 190.   %%ENDIF
 191.   %%IF( optimize(error))
====>   1

  *1*   303 I : 0 times

 192.   typedef  PTTRNG  ERRIXROW[PASTARNG];	     /* Indirect ERROR rows	    
         */
 193.   typedef  PTSTARNG ERRIXCOL[PATRNG];	     /* Indirect ERROR columns   
            */
 194.   %%ENDIF
 195.   %%ENDIF
 196.   %%IF( recovery(global))
====>   1     2

  *1*   303 I : 1 times
  *2*   303 I : 1 times

 197.   typedef  struct  {
====>   1

  *1*   303 I : 1 times

 198.   	    PTTRNG  tsym;
 199.   	    PTTRNG  ssym;
 200.   	 } CONTREC;
 201.   typedef  CONTREC  CONTTAB[PASTARNG];	    /* Continuation function	   
          */
 202.   %%ENDIF
 203.   
====>   1

  *1*   303 I : 1 times

 204.   typedef  struct {
 205.   %%IF( recovery(global))
====>   1     2

  *1*   303 I : 1 times
  *2*   303 I : 1 times

 206.   	    CONTTAB  cont;
====>   1

  *1*   303 I : 1 times

 207.   %%ENDIF
 208.   	    PTTSET  sepa;
====>   1

  *1*   303 I : 1 times
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                11.



 209.   	    PTTSET  fiduc;
 210.   	    PTTSET  skip;
 211.   	 } RECTAB;
 212.   
 213.   typedef  struct  {
 214.   %%IF( NOT optimize(trow))
====>   1         2

  *1*   303 I : 1 times
  *2*   303 I : 1 times

 215.   	     ACTTAB    act;			    /* ACTION table	     */
====>   1

  *1*   303 I : 0 times

 216.   %%ENDIF
 217.   %%IF( optimize(trow))
====>   1     2

  *1*   303 I : 1 times
  *2*   303 I : 1 times

 218.   	     ACTROW    act;			    /* ACTION table	     */
====>   1

  *1*   303 I : 1 times

 219.   %%ENDIF
 220.   %%IF( optimize(trow) AND NOT optimize(tmerge) AND NOT optimize(tsplit
        ))
====>   1     2                      3                        4

  *1*   303 I : 1 times
  *2*   303 I : 1 times
  *3*   303 I : 1 times
  *4*   303 I : 1 times

 221.   	     RDSIXROW  actri;			    /* Row Displacement Index*/
====>   1

  *1*   303 I : 1 times

 222.   %%ENDIF
 223.   %%IF( optimize(tsplit) OR optimize(tmerge) OR optimize(trow))
====>   1     2

  *1*   303 I : 1 times
  *2*   303 I : 1 times

 224.   	     ACTIXROW  actrix; 			    /* ACTION row mapping    */
 225.   %%ENDIF
 226.   %%IF( optimize(tsplit) OR optimize(tmerge))
 227.   	     ACTIXCOL  actcix;			    /*  -"-  col mapping     */
 228.   %%IF( optimize(tsplit))
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                12.


 229.   	     ACTCCROW  actrc;			    /*  -"-  row conditions  */
 230.   	     ACTCCCOL  actcc;			    /*  -"-  col conditions  */
 231.   %%ENDIF
 232.   	     ERRTAB    err;			    /* Non ERROR table       */
 233.   %%IF( optimize(error))
 234.   	     ERRIXROW  errrix;			    /* -"- row mapping       */
 235.   	     ERRIXCOL  errcix;			    /*       -"- col mapping */
 236.   %%ENDIF
 237.   %%ENDIF
 238.   	     RECTAB    recover;			    /* Error recovery info   */
 239.   	 } TERMTAB;	
 240.   
 241.   		/* Non terminal table */
 242.   		/* ------------------ */
 243.   
 244.   
 245.   typedef  PTENTRNG  GTOROW[PAGCOLMX-PANTSMN+1];	
 246.   %%IF( NOT optimize(ntrow))
 247.   typedef  GTOROW  GTOTAB[PAGROWMX-PASTATMN+1];
 248.   %%ENDIF
 249.   %%IF( optimize(ntsplit) OR optimize(ntmerge) OR optimize(ntrow))
 250.   typedef  PTGIRRNG  GTOIXROW[PASTARNG];
 251.   %%ENDIF
 252.   %%IF( optimize(ntsplit) OR optimize(ntmerge) )
 253.   typedef  PTGICRNG  GTOIXCOL[PANTSRNG];
 254.   %%IF( optimize(ntsplit))
 255.   typedef  PTCCRNG  GTOCCROW[PASTARNG];
 256.   typedef  PTCCRNG  GTOCCCOL[PANTSRNG];
 257.   %%ENDIF
 258.   %%ENDIF
 259.   typedef  PTVOCRNG  PRDTBL[PAPRDRNG];
 260.   
 261.   
 262.   typedef  struct {
 263.   %%IF( NOT optimize(ntrow))
 264.   	    GTOTAB    gto;		       /* GOTO table	       */
 265.   %%ENDIF
 266.   %%IF( optimize(ntrow))
 267.   	    GTOROW    gto;		       /* GOTO table	       */
 268.   %%ENDIF
 269.   %%IF( optimize(ntsplit) OR optimize(ntmerge) OR optimize(ntrow))
 270.   	    GTOIXROW  gtorix;		       /* GOTO row mapping     */
 271.   %%ENDIF
 272.   %%IF( optimize(ntsplit) OR optimize(ntmerge))
 273.   	    GTOIXCOL  gtocix;		       /*  -"- col mapping     */
 274.   %%IF( optimize(ntsplit))
 275.   	    GTOCCROW  gtorc;		       /*  -"- row conditions  */
 276.   	    GTOCCCOL  gtocc;		       /*  -"- col conditions  */
 277.   %%ENDIF
 278.   %%ENDIF
 279.   	    PRDTBL    lhs;		       /* Left hand side symbol*/
 280.   	    PRDTBL    rhsz;		       /* Size of the RHS      */
 281.   	 } NTSTAB;
 282.   
 283.   
 284.   		/* Vocabulary */
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                13.


 285.   		/* ---------- */
 286.   
 287.   typedef  char  *SYMBREF;
 288.   typedef  struct {
 289.   	    PTTCRNG  scc;		      /* Scanner code value  */
 290.   	    short    icost; 		      /* Insertion cost      */
 291.   	    short    dcost;		      /* Deletion cost       */
 292.   	    SYMBREF  name;     		      /* Name string	     */
 293.   	    SYMBREF  psym;		      /* Print name	     */
 294.   	 } VOCREC;
 295.   typedef  VOCREC  VOCTAB[PATRNG];	/* Vocabulary  */
 296.   			     
 297.   typedef  PTSTARNG  PARSTKDF[PWSTKMX];
 298.   
 299.   		/* Generated data structures */
 300.   		/* ------------------------- */
 301.   
 302.   #include "%%(name).TBL"
 303.   
 304.   		/* Variables used in the parsing process */
 305.   		/* ------------------------------------- */
 306.   
 307.   static  PTSTARNG   currstat;  		/* Current state number */
 308.   static  PTENTRNG   arg;			/* Argument		*/
 309.   static  PTACTRNG   action;		/* Action type		*/
 310.   static  PWBOOL     endparse;		/* Termination flag	*/
 311.   static  PARSTKDF   parsstk;		/* Parse stack		*/
 312.   static  PTTRNG     scix_tbl[PATCRNG];	/* Converts scanner code*/
 313.   					/* to internal value	*/
 314.   static  PWSYMDF    token;		/* Scanner token	*/
 315.   
 316.   static  PTSET	   bitmsk[PASETSZ] = {  /* Set mask		*/
 317.   			0000001,   0000002,   0000004,
 318.   			0000010,   0000020,   0000040,
 319.   			0000100,   0000200,   0000400,
 320.   			0001000,   0002000,   0004000,
 321.   			0010000,   0020000,   0040000,
 322.   			0100000
 323.   		   };
 324.   
 325.   %%IF( recovery(single))
 326.   	  	/* Error recovery look-ahead buffer */
 327.   	  	/* -------------------------------- */
 328.   
 329.   static  PWSYMDF    la_buff[PALARNG];	/* Buffer	   	*/
 330.   static 	char /* TINY */ la_ptr;		/* Current pointer	*/
 331.   static  char /* TINY */ la_end;		/* Last item	   	*/
 332.   %%ENDIF
 333.   
 334.   
 335.   static  jmp_buf pwjmpb;	/* Buffer for long jump */
 336.   
 337.   
 338.   /* = = = = = = = = = = = =  C O M M O N = = = = = = = = = = = = = = =
         = = =  */
 339.   /*									     */
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                14.


 340.   
 341.   /* ----------------------- PAABORT ----------------------------------
        ------- */
 342.   /*									     */
 343.   static paabort(symbol, class, severity) 
 344.   
 345.   PWSYMDF  *symbol;		/* IN  - Current token		     */
 346.   short	 class;			/* IN  - Error classification	     */
 347.   short	 severity;		/* IN  - Error severity code	     */
 348.   
 349.   {
 350.         pwmess(symbol, HALT_REC, class, severity);
 351.         longjmp(pwjmpb, PWTRUE);	/* Jump out to top level */
 352.   }
 353.   
 354.   /* ----------------------- ADD_SET ----------------------------------
        ------- */
 355.   /*									     */
 356.   /* Add one element to a set						     */
 357.   
 358.   #define add_set(a,s) (s[a / PASETSZ] |= bitmsk[a % PASETSZ])
 359.   
 360.   
 361.   /* ---------------------- CLR_SET -----------------------------------
        ------- */
 362.   /*									     */
 363.   /* Clear a PWS set						  	     */
 364.   
 365.   static clr_set(s, upper)
 366.   
 367.   PTSET  s[];			/* OUT  - Cleared set			     */
 368.   short  upper;			/* IN	- Upper set range 		     */
 369.   
 370.   {
 371.      short   i;
 372.   
 373.      for (i = 0; i <= upper; i++)
 374.   	s[i] = 0;
 375.   }
 376.   
 377.   /* -------------------------- IN_SET --------------------------------
        ------- */
 378.   /*									     */
 379.   /* Check member inclusion						     */
 380.   
 381.   #define in_set(a,s) (s[a / PASETSZ] & bitmsk[a % PASETSZ])
 382.   
 383.   
 384.   /* ----------------------- PARSINIT ---------------------------------
        ------- */
 385.   /*							     		     */
 386.   static parsinit()
 387.   
 388.   {
 389.      short i;
 390.   
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                15.


 391.   %%IF( recovery(single))
 392.      la_ptr = 0;
 393.      la_end = 0;
 394.   %%ENDIF
 395.      pwstkp = 0; currstat = 1;  endparse = PWFALSE; parsstk[0] = 1;
 396.   	  
 397.   	/* Scanner interface */
 398.   
 399.      for (i = 0; i <= PATCMX; i++)
 400.   	scix_tbl[i] = ERR_SYM;
 401.      for (i = PATMN; i <= PATMX; i++)
 402.   	scix_tbl[pavoctbl[i-PATMN].scc] = i;
 403.   } 
 404.   
 405.   
 406.   /* -------------------------- PUSHSTAT ------------------------------
        ------- */
 407.   /*									     */
 408.   static pushstat(pushtok)
 409.   
 410.   PWBOOL  pushtok;	/* IN - PWTRUE = Push token on symbol stack */
 411.   {
 412.      if (++pwstkp < PWSTKMX) {
 413.   	parsstk[pwstkp] = currstat;
 414.           if (pushtok) {
 415.   
 416.   #ifdef MOVMEM
 417.   	     movmem(&token, &pwsyst[pwstkp], sizeof(PWSYMDF));
 418.   #else
 419.   	     pwsyst[pwstkp] = token;
 420.   #endif
 421.   	}
 422.      } else {
 423.   	token.code = pavoctbl[token.code-PATMN].scc;
 424.   	paabort(&token, OFLW_ERR, SYS_SEV);
 425.      }
 426.   } 
 427.   
 428.   
 429.   /* -------------------------- READSYMB ------------------------------
        ------- */
 430.   /*									     */
 431.   static readsymb(sym)
 432.   
 433.   PWSYMDF  *sym;		/* OUT  - Scanned token		     */
 434.   
 435.   {
 436.   %%IF( recovery(single))
 437.      if (la_ptr < la_end) {
 438.   		 /* Read symbol from the look-ahead set */
 439.   	la_ptr++;
 440.   #ifdef MOVMEM
 441.   	movmem(&la_buff[la_ptr], sym, sizeof(PWSYMDF));
 442.   #else
 443.   	*sym = la_buff[la_ptr];
 444.   #endif
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                16.


 445.      } else {
 446.   %%ENDIF
 447.   	do {
 448.   	    pwscan(sym);
 449.   	    if ((sym->code > PATCMX) || (sym->code < 0))
 450.   		 sym->code = ERR_SYM;
 451.   	    else sym->code = scix_tbl[sym->code];
 452.   	    if (sym->code == ERR_SYM)
 453.   		 pwmess(sym, DEL_REC, LEX_ERR, FAT_SEV);
 454.   	} while (sym->code == ERR_SYM);
 455.   %%IF( recovery(single))
 456.      }
 457.   %%ENDIF
 458.   }
 459.   
 460.   /* ----------------------------- ACT_TBL ----------------------------
        ------- */
 461.   /*									     */
 462.   static act_tbl(state, sym, action, arg)
 463.   
 464.   PTSTARNG   state;		/* IN  - State number		     */
 465.   PTTRNG     sym;			/* IN  - Symbol number		     */
 466.   PTACTRNG   *action;		/* OUT - Parser action		     */
 467.   PTENTRNG   *arg;		/* OUT - Parser argument (prod/state)*/
 468.   
 469.   {
 470.      PTENTRNG ent;		/* Action table entry	*/
 471.   
 472.   %%IF( optimize(tmerge) OR optimize(tsplit))
 473.   %%IF( optimize(error))
 474.      if (in_set(pattbl.errcix[sym-PATMN],
 475.   	      pattbl.err[pattbl.errrix[state-PASTATMN]-PASTATMN]))
 476.   %%ENDIF
 477.   %%IF( NOT optimize(error))
 478.      if (in_set(sym, pattbl.err[state-PASTATMN]))
 479.   %%ENDIF
 480.   %%IF( optimize(tsplit) )
 481.          if (pattbl.actrc[state-PASTATMN] < pattbl.actcc[sym-PATMN]) 
 482.   	    ent = pattbl.actrix[state-PASTATMN];
 483.          else if (pattbl.actrc[state-PASTATMN] > pattbl.actcc[sym-PATMN
        ])
 484.   	    ent = pattbl.actcix[sym-PATMN];
 485.          else
 486.   %%ENDIF
 487.   %%IF( optimize(trow))
 488.   	    ent = pattbl.act[pattbl.actrix[state-PASTATMN]-PASTATMN+
 489.   			       pattbl.actcix[sym-PATMN]-PATMN];
 490.   %%ENDIF
 491.   %%IF( NOT optimize(trow))
 492.   	    ent = pattbl.act[pattbl.actrix[state-PASTATMN]-PASTATMN]
 493.   			      [pattbl.actcix[sym-PATMN]-PATMN];
 494.   %%ENDIF
 495.      else ent = ERROR;
 496.   %%ENDIF
 497.   %%IF( NOT optimize(tmerge) AND NOT optimize(tsplit))
 498.   %%IF( optimize(trow))
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                17.


 499.      if (pattbl.actri[pattbl.actrix[state-PASTATMN]-PASTATMN+sym-PATMN]
         == state)
 500.   	ent = pattbl.act[pattbl.actrix[state-PASTATMN]-PASTATMN+sym-PATMN];
 501.      else ent = ERROR;
 502.   %%ENDIF
 503.   %%IF( NOT optimize(trow))
 504.      ent = pattbl.act[state-PASTATMN] [sym-PATMN];
 505.   %%ENDIF
 506.   %%ENDIF
 507.         
 508.      *action = ent / PAIX;
 509.      *arg    = ent % PAIX;
 510.   } 
 511.   
 512.   
 513.   /* -------------------------- GOTO_TBL ------------------------------
        ------- */
 514.   /*									     */
 515.   static goto_tbl(state, sym, action, arg)
 516.   
 517.   PTSTARNG  state;		/* IN  - State number		     */
 518.   PTNTSRNG  sym;			/* IN  - Symbol number		     */
 519.   PTACTRNG  *action;		/* OUT - Parser action		     */
 520.   PTENTRNG  *arg;			/* OUT - Parser argument (prod/state)*/
 521.   
 522.   {
 523.      PTENTRNG ent;	/* Goto table entry   */
 524.   
 525.   %%IF( optimize(ntsplit))
 526.      if (pantstbl.gtorc[state-PASTATMN] < pantstbl.gtocc[sym-PANTSMN])
 527.   	ent = pantstbl.gtorix[state-PASTATMN];
 528.      else if (pantstbl.gtorc[state-PASTATMN] > pantstbl.gtocc[sym-PANTS
        MN])
 529.   	ent = pantstbl.gtocix[sym-PANTSMN];
 530.      else
 531.   %%ENDIF
 532.   %%IF( optimize(ntmerge) OR optimize(ntsplit))
 533.   %%IF( optimize(ntrow))
 534.   	ent = pantstbl.gto[pantstbl.gtorix[state-PASTATMN]-PASTATMN+
 535.   			     pantstbl.gtocix[sym-PANTSMN]-PANTSMN];
 536.   %%ENDIF
 537.   %%IF( NOT optimize(ntrow))
 538.   	ent = pantstbl.gto[pantstbl.gtorix[state-PASTATMN]-PASTATMN]
 539.   			    [pantstbl.gtocix[sym-PANTSMN]-PANTSMN];
 540.   %%ENDIF
 541.   %%ENDIF
 542.   %%IF( NOT optimize(ntmerge) AND NOT optimize(ntsplit))
 543.   %%IF( optimize(ntrow))
 544.   	ent = pantstbl.gto[pantstbl.gtorix[state-PASTATMN]-PASTATMN+
 545.   			   sym-PANTSMN];
 546.   %%ENDIF
 547.   %%IF( NOT optimize(ntrow))
 548.   	ent = pantstbl.gto[state-PASTATMN] [sym-PANTSMN];
 549.   %%ENDIF
 550.   %%ENDIF
 551.   
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                18.


 552.      *action = ent / PAIX;
 553.      *arg    = ent % PAIX;
 554.   } 
 555.   
 556.   
 557.   
 558.   /* = = = = = = = = = = = = = E R R O R   R E C O V E R Y = = = = = = 
        = = = = */
 559.   /*									     */
 560.   /*    The error recovery algorithm tries to modify current configurat
        ion     */
 561.   /*    in such a way that parsing can be resumed correctly.		     */
 562.   /*    Current configuration is characterized by				     */
 563.   /*		w = x t y      , where  x = parsed input		     */
 564.   /*					t = current token		     */
 565.   /*					y = unprocessed input		     */
 566.   /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
        = = = = */
 567.   
 568.   typedef  struct {
 569.   	   PWSYMDF  err_tok;
 570.   	   PWSYMDF  res_tok;
 571.   	   short    method;
 572.   	   short    class;
 573.   	   short    severity;
 574.   	 } ERR_REC;
 575.   
 576.   static	ERR_REC errdescr; 
 577.   	    
 578.   %%IF( recovery(single) OR recovery(global) OR recovery(panic))
 579.   /* -------------------------- EPUSH ---------------------------------
        ------- */
 580.   /*									     */
 581.   static epush(state, stack, sp)
 582.   
 583.   PTSTARNG  state;    	/* IN  - State to push		     */
 584.   PARSTKDF  stack;	/* IN/OUT - Parser stack	     */
 585.   short	    *sp;    	/* IN/OUT - Curr. stack pointer      */
 586.   
 587.   {
 588.   	if (++(*sp) < PWSTKMX) {
 589.   	     stack[*sp] = state;
 590.   	} else
 591.   	     paabort(&errdescr.err_tok, OFLW_ERR, SYS_SEV);
 592.   }
 593.   
 594.   
 595.   /* -------------------------- LEGALACT ------------------------------
        ------- */
 596.   static PWBOOL  legalact(stack, stack_p, sym)
 597.   
 598.   PARSTKDF  stack;	/* IN  - Current stack		  	*/
 599.   short	  stack_p; 	/* IN  - Current stack pointer		*/
 600.   PTTRNG    sym;		/* IN  - Symbol code			*/
 601.   			/* RET - Returns true if "symbol" is	*/
 602.   			/*	 read (shifted) in current state*/
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                19.


 603.   
 604.   {
 605.    	PTSTARNG  state;	/* Current state		*/
 606.   	PTACTRNG  action;	/* Current parser action	*/
 607.   	PTENTRNG  arg;		/* Current parser argument	*/
 608.   
 609.   	PARSTKDF  t_stk;	/* Temporary parser stack	*/
 610.   	short	  i;		/* For loop index		*/
 611.   
 612.   
 613.   	for (i=0; i<=stack_p; i=i+1)		/* Copy stack */
 614.   	      t_stk[i] = stack[i]; 
 615.   
 616.   	 state = stack[stack_p];
 617.   
 618.   	 for (;;) {
 619.   	    act_tbl(state, sym, &action, &arg);
 620.   	    switch (action) {
 621.   
 622.   	       case ERROR:  return(PWFALSE);
 623.   
 624.   	       case SHIFT:
 625.   	       case SHFT_RED:	
 626.   	       case ACCEPT: return(PWTRUE);
 627.   
 628.   	       case REDUCE:
 629.   		       do {
 630.   			    stack_p = stack_p - pantstbl.rhsz[arg-PAPRDMN];
 631.   			    goto_tbl(t_stk[stack_p], pantstbl.lhs[arg-PAPRDMN],
 632.   				     &action, &arg);
 633.   			    epush(state, t_stk, &stack_p);
 634.   		       } while (action != SHIFT);
 635.   	
 636.   		       state = arg; t_stk[stack_p] = state;
 637.   	    }
 638.   	 }
 639.   }
 640.   			     
 641.   	
 642.   /* -------------------------- GLEGSYM -------------------------------
        ------- */
 643.   /*									     */
 644.   static glegsym(stack, stack_p, legals)		/* Get legal symbols   */
 645.   
 646.   PARSTKDF  stack;	/* IN  - Current stack		     */
 647.   short	  stack_p;	/* IN  - Current stack pointer	     */
 648.   PTTSET    legals;	/* OUT - Legal symbols in curr state	*/
 649.   
 650.   {
 651.   	short  sym;		/* Loop index	*/
 652.   
 653.   	clr_set(legals, PATMX/PASETSZ);
 654.   	for (sym = 1; sym <= PATMX; sym++)
 655.   	      if (legalact(stack, stack_p, sym)) 
 656.   		   add_set(sym, legals);
 657.   }
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                20.


 658.   
 659.   
 660.   %%IF( recovery(panic))
 661.   /* ------------------------- BACKUP ---------------------------------
        ------- */
 662.   /*									     */
 663.   static short backup(stack, stack_p, sym)
 664.   
 665.   PARSTKDF    stack;	     /* IN  - Current stack	     */
 666.   short	    stack_p;	     /* IN  - Current stack pointer  */
 667.   PTTRNG	    sym;	     /* IN  - Recovery symbol	     */
 668.   	      		     /* RET - New stack pointer. 0 if*/
 669.   			     /*       symbol is not accepted */
 670.   /* ------------------------------------------------------------------
        ------- */
 671.   /* Backup the parse stack until current symbol is accepted	     	    
         */
 672.   /* (shifted) or the parse stack becomes empty				     */
 673.   /* ------------------------------------------------------------------
        ------- */
 674.   
 675.   {
 676.   	while ((stack_p > 0) && (!legalact(stack, stack_p, sym)))
 677.   		stack_p = stack_p - 1;
 678.   
 679.   	return(stack_p);
 680.   }
 681.   %%ENDIF
 682.   
 683.   /* -------------------- DELSYM --------------------------------------
        ------- */
 684.   /*									     */
 685.   static delsym(dsymb)
 686.   
 687.   PWSYMDF  *dsymb;	/* IN  - Symbol to delete	     */
 688.   			/* OUT - New symbol		     */
 689.   
 690.   {
 691.   	short  t;
 692.   
 693.   	t = dsymb->code;
 694.   	dsymb->code = pavoctbl[dsymb->code-PATMN].scc;
 695.   	pwdsym(dsymb, pavoctbl[t-PATMN].name);
 696.   	readsymb(dsymb);
 697.   	if (errdescr.method == IN_REC)
 698.   	    errdescr.method = REP_REC;
 699.   	else if (errdescr.method != REP_REC)
 700.   	    errdescr.method = DEL_REC;
 701.   }
 702.   
 703.   %%IF( recovery(single) OR recovery(global))
 704.   /* -------------------------- INSYM ---------------------------------
        ------- */
 705.   /*									     */
 706.   static insym(isym, gen_symb)
 707.   
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                21.


 708.   short	 isym;		/* IN  - Symbol code to insert       */
 709.   PWSYMDF  *gen_symb;	/* OUT - Created symbol		     */
 710.         
 711.   {
 712.   	pwisym(pavoctbl[isym-PATMN].scc, pavoctbl[isym-PATMN].name,
 713.   		pavoctbl[isym-PATMN].psym, gen_symb);
 714.   	if (errdescr.method == DEL_REC)
 715.   	     errdescr.method = REP_REC;
 716.   	else if (errdescr.method != REP_REC)
 717.   	     errdescr.method = IN_REC; 
 718.   	gen_symb->code = isym;
 719.   }
 720.   %%ENDIF
 721.   	 
 722.         
 723.   %%IF( recovery(panic) AND NOT recovery(global))
 724.   /* -------------------------- SKIPSYMS ------------------------------
        ------- */
 725.   /*									     */
 726.   static skipsyms(first, stopsys, err_tok)
 727.   	       
 728.   PWBOOL    first;		/* IN  - Called once before? */
 729.   PTTSET    stopsys;		/* IN  - Stop symbols	     */
 730.   PWSYMDF   *err_tok;		/* IN/OUT - Current token    */
 731.   
 732.   /* ------------------------------------------------------------------
        ------- */
 733.   /*									     */
 734.   /* Discard input symbols until 						     */
 735.   /*	a) Token is in "stopsys"					     */
 736.   /*	b) Token is in the fiducial set					     */
 737.   /*     							 		     */
 738.   /* Skip symbols are discarded					  	     */
 739.   /* ------------------------------------------------------------------
        ------- */
 740.   {
 741.   	if (!first)
 742.   	     delsym(err_tok);
 743.   
 744.   	while ((!in_set(err_tok->code, stopsys)) &&
 745.   	       (!in_set(err_tok->code, pattbl.recover.fiduc)) &&
 746.   	       (err_tok->code != ENDMARK) ||
 747.   	       (in_set(err_tok->code, pattbl.recover.skip)))
 748.   		  delsym(err_tok);
 749.   }
 750.   
 751.   /* -------------------- PANIC ---------------------------------------
        ------- */
 752.   /*									     */
 753.   static panic(leg_sys, err_stk, err_stkp, err_tok, newstat) 
 754.   
 755.   PTTSET    leg_sys;		/* IN - Legal symbols in current state  */
 756.   PARSTKDF  err_stk;		/* IN  - Current parser stack		*/
 757.   short	  *err_stkp;		/* IN/OUT  - Current stack pointer	*/
 758.   PWSYMDF   *err_tok;		/* IN/OUT  - Current token		*/  
 759.   PTSTARNG  *newstat;		/* OUT - New state after recovery	*/
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                22.


 760.   
 761.   {
 762.   	PWBOOL  first;			/* First skip?       */
 763.   	short	new_stkp;		/* Temporary pointer */
 764.   
 765.   	first = PWTRUE;
 766.         
 767.   	do {
 768.   	    skipsyms(first, leg_sys, err_tok);
 769.   	    new_stkp = backup(err_stk, *err_stkp, err_tok->code);
 770.   	    first = PWFALSE;
 771.   	} while ((new_stkp <= 0) && (err_tok->code != ENDMARK));
 772.   
 773.   	if ((new_stkp != err_stkp) && (new_stkp > 0))
 774.   	     errdescr.method = BAK_REC;
 775.   
 776.   	*err_stkp = new_stkp;
 777.   	*newstat = err_stk[*err_stkp];
 778.   }
 779.   %%ENDIF
 780.   
 781.   
 782.   %%IF( recovery(global))
 783.   /* = = = = = = = = = = G L O B A L   R E C O V E R Y = = = = = = = = 
        = = = = */
 784.   /*									     */
 785.   /* 	 The global recovery technique is a "true local corrector", i.e. 
        it  */
 786.   /*	 will always return a legal configuration for any input.	     */
 787.   /*	 Logically the algorithm can be described as follows		     */
 788.   /*  	   1) Roerich method (Karlsruhe)				     */
 789.   /*		a.  Find a continuation "u" of "x", such that "xu" is	     */
 790.   /*		    accepted.						     */
 791.   /*	 	b.  De composite "ty" into "qsy'", where q is a string       */
 792.   /* 		c.  Delete "q"						     */
 793.   /*		d.  Insert u' (a prefix of u) between "x" and "sy'" giving   */
 794.   /*	   	    xu' s y'. 						     */
 795.   %%IF( recovery(panic))
 796.   /* 									     */
 797.   /*    	   2) Panic mode						     */
 798.   /*		If "q" contains a fiducial symbol "a"  then 		     */
 799.   /*		a. Pop stack until "a" is accepted.			     */
 800.   /*		b. If not succeeded resume at step 1			     */
 801.   %%ENDIF
 802.   /* ------------------------------------------------------------------
        ------- */
 803.   typedef  struct {
 804.   	    PTSTARNG   r_state;		/* Recovery state	     */
 805.   	    PWBOOL     r_sepa;		/* Insert separator??	     */
 806.   	    PTSTARNG   r_sstat;		/* Where to insert separator */ 
 807.   	 } REC_POI;
 808.   
 809.   
 810.   /* ---------------------------- ACCEPTBL ----------------------------
        ------- */
 811.   /*									     */
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                23.


 812.   static acceptbl(sym, stack, stack_p, token, found, point)
 813.   
 814.   PTTRNG    sym;		/* IN  - Terminal symbol code	  */
 815.   PARSTKDF  stack;	/* IN  - Parse stack		  */
 816.   int	  stack_p;	/* IN  - Stack pointer		  */
 817.   PWSYMDF   *token;	/* IN  - Current  token		  */
 818.   PWBOOL    *found;	/* OUT - "Symbol" accepted??	  */
 819.   REC_POI   *point;	/* OUT - Recovery poi. description*/
 820.   /* ------------------------------------------------------------------
        ------- */
 821.   /*									     */
 822.   /* Check whether "symbol" is reachable from current state using 	    
         */
 823.   /* the continuation grammar. 				 		     */
 824.   /* ------------------------------------------------------------------
        ------- */
 825.   {
 826.   	PWBOOL     done;		/* Terminator flag   	   */
 827.   	PTSTARNG   state;		/* Current state      	   */
 828.   	PTACTRNG   action;		/* Parser action	   */
 829.   	PTACTRNG   sep_act;		/*     -"-  separator test */
 830.   	PTENTRNG   arg;			/* Parser prod/state	   */
 831.   	PTENTRNG   sep_arg;		/*     -"-  separator test */
 832.   	PWBOOL     sepa_acc;		/* Separator is accepted?? */
 833.   	PARSTKDF   t_stk;		/* Temporary parser stack  */
 834.   	PARSTKDF   stk;			/* Temporary stack	   */
 835.   	short	   sp;			/* Temporary stack pointer */
 836.   	short	   i;			/* Copy loop index	   */
 837.   
 838.   	for (i = 0; i <= stack_p; i = i + 1)
 839.   	       t_stk[i] = stack[i];
 840.   
 841.   	state = t_stk[stack_p];
 842.   	done = PWFALSE;
 843.   	
 844.   	while (!done) {
 845.   	    act_tbl(state, sym, &action, &arg);
 846.   	    if ((action == SHIFT) || (action == SHFT_RED) || 
 847.   		(action == ACCEPT)) {
 848.   		     /* Symbol is directly accepted */
 849.   
 850.   		 done = PWTRUE;
 851.   		 *found = PWTRUE;
 852.   		 point->r_state = state;
 853.   	    } else {
 854.   		 /* Use the continuation grammar */
 855.   		
 856.   		 act_tbl(state, pattbl.recover.cont[state-PASTATMN].tsym, 
 857.   			 &action, &arg);
 858.   		 act_tbl(state, pattbl.recover.cont[state-PASTATMN].ssym,
 859.   			 &sep_act, &sep_arg);
 860.   		 if ((action != sep_act) || (arg != sep_arg)) {
 861.   			/* A separator is legal. Check if current  */
 862.   			/* symbol is accepted behind the separator */
 863.   			
 864.   		      sp = stack_p; 
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                24.


 865.   		      for (i = 0; i <= stack_p; i = i + 1)
 866.   			    stk[i] = t_stk[i];
 867.   		      sepa_acc  = PWFALSE;
 868.   		      while (!sepa_acc) 
 869.   
 870.   			  switch (sep_act) {
 871.   
 872.   			     case ERROR:
 873.   			     case ACCEPT:
 874.   				    sepa_acc = PWTRUE;
 875.   				    break;
 876.   
 877.   			     case SHIFT: 
 878.   				    sepa_acc = PWTRUE;
 879.   				    epush(sep_arg, stk, &sp);
 880.   				    break;
 881.   				    
 882.   			     case SHFT_RED:
 883.   				    epush(1, stk, &sp);
 884.   				    sepa_acc = PWTRUE;
 885.   
 886.   			     case REDUCE:			
 887.   				    do {
 888.    					 sp = sp -
 889.   					      pantstbl.rhsz[sep_arg-PAPRDMN];
 890.   					 goto_tbl(stk[sp],
 891.   						 pantstbl.lhs[sep_arg-PAPRDMN],
 892.   						 &sep_act, &sep_arg);
 893.   					 epush(1, stk, &sp);
 894.   				    } while (sep_act != SHIFT);
 895.   				    
 896.   				    stk[sp] = sep_arg;
 897.   				    break;
 898.   			  }
 899.   
 900.   		      if ((sep_act == SHIFT) || (sep_act == SHFT_RED)) 
 901.   			    if (legalact(stk, sp, sym)) {
 902.   				    /* Separator is to be inserted */
 903.   				 point->r_state = stk[sp];
 904.   				 point->r_sepa = PWTRUE;
 905.   				 point->r_sstat = state;
 906.   				 done = PWTRUE;
 907.   				 *found = PWTRUE;
 908.   			    }
 909.   		 } /* Test for separator */
 910.   		  
 911.   		 if (!*found)
 912.   
 913.   		      switch (action) {
 914.   			     
 915.   			 case ERROR: 
 916.   				paabort(token, TAB_ERR, SYS_SEV);
 917.   				break;
 918.   			
 919.   			 case ACCEPT:
 920.   				done = PWTRUE;
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                25.


 921.   				break;
 922.   
 923.   			 case SHIFT:
 924.   				state = arg;
 925.   				epush(state, t_stk, &stack_p);
 926.   				break;
 927.   
 928.   			 case SHFT_RED:
 929.   				epush(state, t_stk, &stack_p);
 930.   
 931.   			 case REDUCE:
 932.   				do {
 933.   				     stack_p = stack_p -
 934.   					       pantstbl.rhsz[arg-PAPRDMN];
 935.   				     goto_tbl(t_stk[stack_p],
 936.   					      pantstbl.lhs[arg-PAPRDMN],
 937.   					      &action, &arg);
 938.   				     epush(state, t_stk, &stack_p);
 939.   				} while (action != SHIFT);
 940.   				
 941.   				state = arg;
 942.   				t_stk[stack_p] = state;
 943.   				break;
 944.   			}
 945.   	    } /* NOT direct acceptable */
 946.   	} /* while */
 947.   }
 948.   
 949.   /* --------------------------- SEARCH -------------------------------
        ------- */
 950.   /*								    	     */
 951.   static search(stack, stack_p, token, point)  /* Search recovery point
        	     */
 952.   
 953.   PARSTKDF  stack;	/* IN - Current stack		       */
 954.   short	  *stack_p;	/* IN/OUT - Current stack pointer      */
 955.   PWSYMDF   *token;	/* IN/OUT - Current symbol	       */
 956.   REC_POI   *point;	/* OUT  - Descriptor of where to       */
 957.   			/*	  restart the parser	       */
 958.   
 959.   {
 960.   	PTSTARNG  state; 	  /* Current state  	       */
 961.   	PWBOOL    rp_found;	  /* Recovery point found??    */
 962.   %%IF( recovery(panic))
 963.   	short	  new_stkp; 	  /* Temp. stack pointer       */
 964.   %%ENDIF
 965.   
 966.   
 967.   	state = stack[*stack_p];
 968.   	point->r_state = state;
 969.   	point->r_sepa = PWFALSE;
 970.   	point->r_sstat = 1;
 971.   
 972.   	rp_found = PWFALSE;
 973.   	do {
 974.   	     if (!in_set(token->code, pattbl.recover.skip))
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                26.


 975.   		  acceptbl(token->code, stack, *stack_p, token, &rp_found,
 976.   			   point);
 977.   	    
 978.   	     if (!rp_found) {
 979.   %%IF( recovery(panic))
 980.   		  new_stkp = 0;
 981.   		  if (in_set(token->code, pattbl.recover.fiduc))
 982.   			new_stkp = backup(stack, *stack_p, token->code);
 983.   		  if (new_stkp > 0) {
 984.   		       rp_found = PWTRUE;
 985.   		       *stack_p = new_stkp;
 986.   		       point->r_state = stack[*stack_p];
 987.   		       errdescr.method = BAK_REC;
 988.   		  } else 
 989.   %%ENDIF
 990.   		       delsym(token);
 991.   	     }
 992.   	} while (!rp_found);
 993.   }
 994.   
 995.   
 996.   /* -------------------------- REACH ---------------------------------
        ------- */
 997.   /*									     */
 998.   static reach(stack, stack_p, token, point)
 999.   
1000.   PARSTKDF   stack;		/* IN/OUT - Current stack	   */
1001.   int	   *stack_p;		/* IN/OUT - Current stack pointer  */	
1002.   PWSYMDF    *token;		/* IN/OUT - Current symbol	   */
1003.   REC_POI    *point;		/* IN - Recovery point descriptor  */
1004.   /* ------------------------------------------------------------------
        ------- */
1005.   /*									     */
1006.   /* 	Use the continuation functions and insert symbols upto current   
            */
1007.   /* 	token.								     */
1008.   /* ------------------------------------------------------------------
        ------- */
1009.   {
1010.   	PTSTARNG  state;	/* Current state	  */
1011.   	PTTRNG    cont_sym;	/* Continuation symbol    */
1012.   	PWSYMDF   gen_symb;	/* Generated symbol	  */
1013.   	PTACTRNG  action;	/* Current parser action  */
1014.   	PTENTRNG  arg;		/* Current prod/state	  */
1015.   
1016.   	state = stack[*stack_p];
1017.   	while (state != point->r_state) {
1018.   	    if (point->r_sepa)
1019.   		 if (state == point->r_sstat)
1020.   		      cont_sym = pattbl.recover.cont[state-PASTATMN].ssym;
1021.   		 else cont_sym = pattbl.recover.cont[state-PASTATMN].tsym;
1022.   	    else cont_sym = pattbl.recover.cont[state-PASTATMN].tsym;
1023.   
1024.   	    act_tbl(state, cont_sym, &action, &arg);
1025.   	    switch (action) {
1026.   	      
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                27.


1027.   		case SHIFT:
1028.   			state = arg;
1029.   			insym(cont_sym, &gen_symb);
1030.   			epush(state, stack, stack_p);
1031.   #ifdef MOVMEM
1032.   			movmem(&gen_symb, &pwsyst[*stack_p], sizeof(PWSYMDF));
1033.   #else
1034.   			pwsyst[*stack_p] = gen_symb;
1035.   #endif
1036.   			break;
1037.   
1038.   		case SHFT_RED:
1039.   			insym(cont_sym, &gen_symb);
1040.   			epush(state, stack, stack_p);
1041.   #ifdef MOVMEM
1042.   			movmem(&gen_symb, &pwsyst[*stack_p], sizeof(PWSYMDF));
1043.   #else
1044.   			pwsyst[*stack_p] = gen_symb;
1045.   #endif
1046.   
1047.   		case REDUCE:
1048.   			do {
1049.   			     *stack_p = *stack_p - pantstbl.rhsz[arg-PAPRDMN];
1050.   %%IF( semantic(on))
1051.   			     pwsema(arg);
1052.   %%ENDIF
1053.   			     goto_tbl(stack[*stack_p],
1054.   				      pantstbl.lhs[arg-PAPRDMN],
1055.   				      &action, &arg);
1056.   			     epush(state, stack, stack_p);
1057.   			} while (action != SHIFT);
1058.   			state = arg;
1059.   			stack[*stack_p] = state;
1060.   	    }
1061.   	} /* while */
1062.   }
1063.   
1064.   
1065.   /* -------------------------- GLOBAL --------------------------------
        ------- */
1066.   /*									     */
1067.   static global(err_stk, err_stkp, err_tok, newstat)
1068.   
1069.   PARSTKDF   err_stk;		/* IN/OUT - Current parse stack     */
1070.   short	   *err_stkp;		/* IN/OUT - Current stack pointer   */
1071.   PWSYMDF    *err_tok;		/* IN/OUT - Current token	    */
1072.   PTSTARNG   *newstat;		/* OUT - State after recovery	    */	
1073.   
1074.   {
1075.   	REC_POI  point;		/* Recovery point descriptor */
1076.   
1077.   	search(err_stk, err_stkp, err_tok, &point);
1078.   	reach(err_stk, err_stkp, err_tok, &point);
1079.   	*newstat = err_stk[*err_stkp];
1080.   } 
1081.   %%ENDIF
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                28.


1082.   	      
1083.   %%IF( recovery(single))
1084.   /* = = = = = = = = = = S I N G L E   R E C O V E R Y = = = = = = = = 
        = = = = */
1085.   /*									     */
1086.   /* 	 The single recovery technique tries to REPAIR the error by findi
        ng  */
1087.   /* 	 the least cost single symbol correction. One single symbol of   
            */
1088.   /* 		- insertion						     */
1089.   /*		- deletion						     */
1090.   /*		- replacement						     */
1091.   /* 	 is concidered. The cost of the repair is the sum of the ADAPTION
            */
1092.   /* 	 cost and the MODIFICATION cost. The adaption cost indicates how 
            */
1093.   /* 	 well a correction fits in the context. The modification cost is 
            */
1094.   /* 	 based on the insertion/deletion cost given in the input. A	     
        */
1095.   /* 	 correction is applied if the cost is below a predefined threshol
        d   */
1096.   /* 	 value.								     */
1097.   /* ------------------------------------------------------------------
        ------- */
1098.   #define  SH_COST  PWSCOST	      /* The cost of shifting one symbol   
          */
1099.   #define  INF_COST (SH_COST*PWLAMX)    /* Infinity	     		     */
1100.   #define  THRESH   (PWLAMX-3)*SH_COST  /* Acceptance cost		     */
1101.   
1102.   /* --------------------------- READ_LA ------------------------------
        ------- */
1103.   /*									     */
1104.   static read_la(token)
1105.   
1106.   PWSYMDF  *token;		/* IN - Current token	 */
1107.   
1108.   {	int	  i;
1109.   	PWSYMDF   symbol;
1110.   
1111.   #ifdef MOVMEM
1112.   	movmem(token, &la_buff[0], sizeof(PWSYMDF));
1113.   #else
1114.   	la_buff[0] = *token;
1115.   #endif
1116.   	for (i=la_ptr+1; i<=la_end; i++)
1117.   	      /* Move old look_ahead to the beginning of the buffer */
1118.   #ifdef MOVMEM
1119.   	    movmem(&la_buff[i], &la_buff[i-la_ptr], sizeof(PWSYMDF));
1120.   #else
1121.   	    la_buff[i-la_ptr] = la_buff[i];
1122.   #endif
1123.   	la_end = la_end - la_ptr;
1124.   	la_ptr = -1;
1125.   
1126.   	while ((la_buff[la_end].code != ENDMARK) &&
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                29.


1127.   	       (la_end < PWLAMX)) {
1128.   	    la_end = la_end + 1;
1129.   	    do {
1130.   		 pwscan(&symbol);
1131.   		 if ((symbol.code > PATCMX) || (symbol.code < 0))
1132.   		      symbol.code = ERR_SYM;
1133.   		 else symbol.code = scix_tbl[symbol.code];
1134.   		 if (symbol.code == ERR_SYM)
1135.   		      pwmess(&symbol, DEL_REC, LEX_ERR, FAT_SEV);
1136.   	    } while (symbol.code == ERR_SYM);
1137.   #ifdef MOVMEM
1138.   	    movmem(&symbol, &la_buff[la_end], sizeof(PWSYMDF));
1139.   #else
1140.   	    la_buff[la_end] = symbol;
1141.   #endif
1142.   	 }
1143.   }
1144.   
1145.   /* -------------------------- RDLASYM -------------------------------
        ------- */
1146.   /*									     */
1147.   static  PTTRNG rdlasym(index)
1148.   
1149.   char /* TINY */ index;	/* IN  - I:th look-ahead symbol      */
1150.   		 	/* RET - Token code		     */
1151.   /* ------------------------------------------------------------------
        ------- */
1152.   /*									     */
1153.   /* 	    Fetches the i:th look-ahead symbol code from the look-ahead s
        et  */
1154.   /* ------------------------------------------------------------------
        ------- */
1155.   {
1156.   	if (index > la_end)
1157.   	     return(ENDMARK);
1158.   	else 
1159.   	     return(la_buff[index].code);
1160.   }
1161.   
1162.   	
1163.   /* -------------------------- LAPARSE -------------------------------
        ------- */
1164.   /*									     */
1165.   static laparse(sym, next_la, stack, stack_p, cost)
1166.   
1167.   PTTRNG    sym;		/* IN  - Current terminal symbol     */
1168.   char /* TINY */ next_la;/* IN  - Index to next look-ahead sy */
1169.   PARSTKDF  stack;	/* IN  - Parse stack		     */
1170.   short	  stack_p;	/* IN  - Current stack pointer	     */
1171.   short	  *cost;	/* OUT - Adaption cost		     */
1172.   /* ------------------------------------------------------------------
        ------- */
1173.   /* 									     */
1174.   /* 	    Continue the parsing process by reading tokens from the	     
        */
1175.   /* 	    look-ahead set. The parse is terminated when		     */
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                30.


1176.   /* 			- out of read ahead 				     */
1177.   /*			- a new error is encountered			     */
1178.   /* 	    Note! No semantic actions are carried out			     */
1179.   /* ------------------------------------------------------------------
        ------- */
1180.   {
1181.   	PWBOOL   done ;		/* Terminator flag	     */
1182.   	char /* TINY */ sh_cnt;	/* Number of shifted symbols */
1183.   	PTSTARNG state;		/* Current state number      */
1184.   	PTACTRNG action;	/* Parser action	     */
1185.   	PTENTRNG arg; 		/*   "-   argument	     */
1186.   
1187.   	short	 i;		/* Loop index		     */
1188.   	PARSTKDF t_stk;		/* Temporary stack	     */
1189.   
1190.   	for (i = 0; i <= stack_p; i = i + 1)	/* Copy stack */
1191.   	       t_stk[i] = stack[i];	
1192.   
1193.   	done = PWFALSE;  sh_cnt = 0;
1194.   	state = t_stk[stack_p];
1195.   
1196.   	while (!done) {
1197.   	    act_tbl(state, sym, &action, &arg);
1198.   	
1199.   	    switch (action) {
1200.   
1201.   	       case ERROR: 
1202.   		      done = PWTRUE;
1203.   		      break;
1204.   	
1205.   	       case SHIFT:
1206.   		      state = arg;
1207.   		      epush(state, t_stk, &stack_p);
1208.   		      sh_cnt = sh_cnt + 1;
1209.   		      if (sh_cnt == PWLAMX) 
1210.   			   done = PWTRUE;
1211.   		      else {
1212.   			   sym = rdlasym(next_la);
1213.   			   next_la = next_la + 1;
1214.   		      }
1215.   		      break;
1216.   
1217.   	       case SHFT_RED:
1218.   		      epush(state, t_stk, &stack_p);
1219.   		      sh_cnt = sh_cnt + 1;
1220.   		      if (sh_cnt == PWLAMX)
1221.   			   done = PWTRUE;
1222.   		      else {
1223.   			   sym = rdlasym(next_la);
1224.   			   if (next_la < PWLAMX) 
1225.   				next_la = next_la + 1;
1226.   		      }
1227.   
1228.   	       case REDUCE:
1229.   		      do {
1230.   			   stack_p = stack_p - pantstbl.rhsz[arg-PAPRDMN];
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                31.


1231.   			   goto_tbl(t_stk[stack_p], pantstbl.lhs[arg-PAPRDMN],
1232.   				    &action, &arg);
1233.   			   epush(state, t_stk, &stack_p);
1234.   		      } while (action != SHIFT); 
1235.   
1236.   		      state = arg;
1237.   		      t_stk[stack_p] = state;
1238.   		      break;
1239.   
1240.   	       case ACCEPT:
1241.   		      done = PWTRUE;  sh_cnt = PWLAMX;
1242.   		      break;
1243.   
1244.   	    }
1245.   	}
1246.   
1247.   	*cost = INF_COST - (sh_cnt*SH_COST);
1248.   }
1249.   
1250.   
1251.          
1252.   /* -------------------------- TRY_IN --------------------------------
        ------- */
1253.   /*									     */
1254.   static try_in(legals, stack, stack_p, sym, cost, choice)
1255.   
1256.   PTTSET   legals;	/* IN  - Set of legal symbols	     */
1257.   PARSTKDF stack;		/* IN  - Current parser stack	     */
1258.   short	 stack_p;	/* IN  - Current stack pointer       */
1259.   PTTRNG   *sym;		/* OUT - Best insertion symbol       */
1260.   short	 *cost;		/* OUT - Best cost so far	     */
1261.   short	 *choice;	/* OUT - Best choice so far	     */
1262.   /* ------------------------------------------------------------------
        ------- */
1263.   /*									     */
1264.   /* 	Tries to insert a symbol from the legal set in front of current  
            */
1265.   /*	token								     */
1266.   /*		x t y  => x st y	, where s becomes current symbol     */
1267.   /* ------------------------------------------------------------------
        ------- */
1268.   {
1269.   	short	 i;
1270.   	short	 mod_cost;	/* Modification cost	 */
1271.   	short	 ad_cost;	/* Adaption cost 	 */
1272.   	short	 tot_cost;	/* Total insertion cost  */
1273.   
1274.   	for (i=1; i<=PATMX; i++) {  /* For all legal symbols */
1275.   	      if (in_set(i, legals)) {
1276.   		   mod_cost = pavoctbl[i-PATMN].icost;
1277.   		   if (mod_cost < *cost) {
1278.   			laparse(i, 0, stack, stack_p, &ad_cost);
1279.   			tot_cost = ad_cost + mod_cost;
1280.   			if (tot_cost < *cost) {
1281.   			     *cost = tot_cost;
1282.   			     *choice = IN_REC;
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                32.


1283.   			     *sym = i;
1284.   			}
1285.   		   }
1286.   	      }
1287.   	}
1288.   }
1289.   
1290.   /* -------------------------- TRY_REP -------------------------------
        ------- */
1291.   /*									     */
1292.   static try_rep(legals, stack, stack_p, sym, cost, choice)
1293.   
1294.   PTTSET   legals;	/* IN  - Set of legal symbols	     */
1295.   PARSTKDF stack;		/* IN  - Current parser stack	     */
1296.   short	 stack_p;	/* IN  - Current stack pointer       */
1297.   PTTRNG   *sym;		/* OUT - Best replacement symbol     */
1298.   short	 *cost;		/* OUT - Best cost so far	     */
1299.   short	 *choice;	/* OUT - Best choice so far	     */
1300.   /* ------------------------------------------------------------------
        ------- */
1301.   /*									     */
1302.   /* 	Tries to replace currrent symbol with a new terminal.	    	     */
1303.   /*		x t y  => x s y		, where s becomes current symbol     */
1304.   /* ------------------------------------------------------------------
        ------- */
1305.   {
1306.   	short	 i;
1307.   	short	 mod_cost;	/* Modification cost	 */
1308.   	short	 ad_cost;	/* Adaption cost 	 */
1309.   	short	 tot_cost;	/* Total replacment cost */
1310.   
1311.   	for (i=1; i<=PATMX; i++) {  /* For all legal symbols */
1312.   	      if (in_set(i, legals)) {
1313.   		   mod_cost = (pavoctbl[i-PATMN].icost +
1314.   			       pavoctbl[rdlasym(0)-PATMN].dcost) / 2 + 1;
1315.   		   if (mod_cost < *cost) {
1316.   			laparse(i, 1, stack, stack_p, &ad_cost);
1317.   			tot_cost = ad_cost + mod_cost;
1318.   			if (tot_cost < *cost) {
1319.   			     *cost = tot_cost;
1320.   			     *choice = REP_REC;
1321.   			     *sym = i;
1322.   			}
1323.   		   }
1324.   	      }
1325.   	}
1326.   }
1327.   
1328.   
1329.   /* ----------------------- TRY_DEL ----------------------------------
        ------- */
1330.   /*									     */
1331.   static try_del(stack, stack_p, cost, choice)
1332.   
1333.   PARSTKDF  stack;	/* IN  - Current parser stack	       */
1334.   short	  stack_p;	/* IN  - Current stack pointer         */
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                33.


1335.   short	  *cost;	/* IN/OUT - Best cost so far	       */
1336.   short	  *choice;	/* IN/OUT - Best choice so far         */
1337.   /* ------------------------------------------------------------------
        ------- */
1338.   /*									     */
1339.   /* 	Tries to delete current symbol.					     */
1340.   /*		x t y  => x  y						     */
1341.   /* ------------------------------------------------------------------
        ------- */
1342.   
1343.   {
1344.   	short mod_cost;		/* Modification cost	*/
1345.   	short ad_cost;  		/* Adaption cost	*/
1346.   	short tot_cost;		/* Total deletion cost  */
1347.   
1348.   	mod_cost = pavoctbl[rdlasym(0)-PATMN].dcost;
1349.   	if (mod_cost < *cost) {
1350.   	      laparse(rdlasym(1), 2, stack, stack_p, &ad_cost);
1351.   	      tot_cost = ad_cost + mod_cost;
1352.   	      if (tot_cost < *cost) {
1353.   		    *cost = tot_cost;
1354.   		    *choice = DEL_REC;
1355.   	      }
1356.   	 }
1357.   }
1358.   
1359.   /* -------------------------- INSERT --------------------------------
        ------- */
1360.   /*									     */
1361.   static insert(sym, token)
1362.   
1363.   PTTRNG   sym;		/* IN  - Symbol code to insert       */
1364.   PWSYMDF  *token;	/* OUT - Constructed token	     */
1365.   	       
1366.   {
1367.    	insym(sym, token);
1368.   }
1369.   
1370.   /* -------------------------- REPLACE -------------------------------
        ------- */
1371.   /*									     */
1372.   static replace(sym, token)
1373.   
1374.   PTTRNG  sym;		/* IN - Replacement symbol code	     */
1375.   PWSYMDF *token;		/* OUT - Constructed token	     */
1376.   
1377.   {
1378.   	delsym(token);
1379.   	insym(sym, token);
1380.   }
1381.   
1382.   /* -------------------------- DELETE --------------------------------
        ------- */
1383.   /*									     */
1384.   static delete(token)
1385.   
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                34.


1386.   PWSYMDF  *token;	/* OUT - New token	     */
1387.   
1388.   {
1389.   	readsymb(token);
1390.   	delsym(token);
1391.   }
1392.   
1393.   /* ------------------------ SINGLE ----------------------------------
        ------- */
1394.   /*									     */
1395.   static single(leg_sys, err_stk, err_stkp, err_tok, newstat)
1396.   
1397.   PTTSET   leg_sys;	/* IN  - Legal symbols in current state */
1398.   PARSTKDF err_stk;	/* IN/OUT - Current parser stack	*/
1399.   short	 *err_stkp;	/* IN/OUT - Current stack pointer	*/
1400.   PWSYMDF  *err_tok;	/* IN/OUT - Current token		*/
1401.   PTSTARNG *newstat;	/* OUT - Recovery state			*/
1402.     
1403.   {
1404.   	short	choice;   /* Recovery action performed */
1405.   	short	cost;	  /* Best cost so far	       */
1406.   	PTTRNG  sym;	  /* Insert symbol	       */
1407.   
1408.   	choice = NONE_REC;  cost = INF_COST;
1409.   	read_la(err_tok);
1410.   
1411.   	try_in(leg_sys, err_stk, *err_stkp, &sym, &cost, &choice);
1412.   	try_rep(leg_sys, err_stk, *err_stkp, &sym, &cost, &choice);
1413.   	try_del(err_stk, *err_stkp, &cost, &choice);
1414.   
1415.   	if (cost > THRESH)
1416.   	     choice = NONE_REC;
1417.   
1418.   	 switch (choice) {
1419.   
1420.   	    case IN_REC:
1421.   		   insert(sym, err_tok);
1422.   		   break;
1423.   	    case DEL_REC:  
1424.   		   delete(err_tok);
1425.   		   break;
1426.   	    case REP_REC: 
1427.   		   replace(sym, err_tok);
1428.   		   break;
1429.   	    default:
1430.   		   readsymb(err_tok);
1431.   	 }
1432.   
1433.   	 *newstat = err_stk[*err_stkp];
1434.   }
1435.   %%ENDIF
1436.   %%ENDIF
1437.   
1438.   /* -------------------------- RECOVER -------------------------------
        ------- */
1439.   /*									     */
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                35.


1440.   static  recover(err_stk, err_stkp, err_symb, rec_stat)
1441.   
1442.   PARSTKDF   err_stk;	/* IN/OUT - Updated parse stack	     */
1443.   short	   *err_stkp;	/* IN/OUT - Updated stack pointer    */
1444.   PWSYMDF    *err_symb;	/* IN/OUT - Current token	     */
1445.   PTSTARNG   *rec_stat;	/* OUT  - State after recovery       */
1446.   
1447.   {
1448.      PTTSET legal_sy;		/* Legal symbols     */
1449.   
1450.   #ifdef MOVMEM
1451.      movmem(err_symb, &errdescr.err_tok, sizeof(PWSYMDF));
1452.   #else
1453.      errdescr.err_tok = *err_symb;
1454.   #endif
1455.      errdescr.err_tok.code = pavoctbl[errdescr.err_tok.code-PATMN].scc;
1456.      errdescr.method = NONE_REC;
1457.      errdescr.class = SYN_ERR;
1458.      errdescr.severity = ERR_SEV;
1459.   %%IF( recovery(single) OR recovery(panic) OR recovery(global))
1460.      glegsym(err_stk, *err_stkp, legal_sy);
1461.   %%IF( recovery(single))
1462.      single(legal_sy, err_stk, err_stkp, err_symb, rec_stat);
1463.      if (errdescr.method == NONE_REC) {
1464.   %%ENDIF
1465.   %%IF( recovery(global))
1466.   	global(err_stk, err_stkp, err_symb, rec_stat);
1467.   	pwmess(&errdescr.err_tok, errdescr.method, errdescr.class, 
1468.   		errdescr.severity); 
1469.   %%ENDIF
1470.   %%IF( recovery (panic) AND NOT recovery(global))
1471.   	panic(legal_sy, err_stk, err_stkp, err_symb, rec_stat);
1472.   	pwmess(&errdescr.err_tok, errdescr.method, errdescr.class,
1473.   		errdescr.severity); 
1474.   %%ENDIF
1475.   %%IF( NOT recovery(panic) AND NOT recovery(global) AND NOT recovery(h
        alt))
1476.   	delete(err_symb);
1477.   	pwmess(&errdescr.err_tok,  DEL_REC, SYN_ERR, ERR_SEV);
1478.   %%ENDIF
1479.   %%IF( recovery(single))
1480.      } else
1481.   	pwmess(&errdescr.err_tok, errdescr.method, SYN_ERR, errdescr.severit
        y);
1482.   %%ENDIF
1483.   #ifdef MOVMEM
1484.      movmem(err_symb, &errdescr.res_tok, sizeof(PWSYMDF));
1485.   #else
1486.      errdescr.res_tok = *err_symb;
1487.   #endif
1488.      errdescr.res_tok.code = pavoctbl[errdescr.res_tok.code-PATMN].scc;
1489.      pwrpoi(&errdescr.res_tok);
1490.   %%ENDIF
1491.   %%IF( recovery(halt))
1492.   %%IF( recovery(single) OR recovery(panic) OR recovery(global))
1493.      if (errdescr.method == NONE_REC)
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                36.


1494.   %%ENDIF
1495.          paabort(&errdescr.err_tok, SYN_ERR, FAT_SEV);
1496.   %%ENDIF
1497.   }
1498.   
1499.   
1500.   /* -------------------------- PWPARS --------------------------------
        ------- */
1501.   /*									     */
1502.   /* PWPARS  - Parser routine. Entry point				     */
1503.   /* ------------------------------------------------------------------
        ------- */
1504.   pwpars( ) 
1505.   
1506.   { 
1507.      parsinit();
1508.      readsymb(&token);
1509.      pushstat(PWTRUE);
1510.   
1511.      if (setjmp(&pwjmpb)) return;
1512.   
1513.      while (!endparse) {
1514.   
1515.         act_tbl(currstat, token.code, &action, &arg);
1516.   
1517.   	switch (action) {
1518.   
1519.   	case ERROR:
1520.   		recover(parsstk, &pwstkp, &token, &currstat);
1521.   		if (pwstkp == 0) 
1522.   		     endparse = PWTRUE;
1523.   		break;
1524.   
1525.   	case SHIFT:
1526.   		currstat = arg;
1527.   		pushstat(PWTRUE);
1528.   		readsymb(&token);
1529.   		break;
1530.   
1531.   	case SHFT_RED:
1532.   		pushstat(PWTRUE);
1533.   		readsymb(&token);
1534.   
1535.    	case REDUCE:
1536.   
1537.   		do {
1538.   		     pwstkp = pwstkp - pantstbl.rhsz[arg-PAPRDMN];	
1539.   %%IF( semantic(on))
1540.   		     pwsema(arg);
1541.   %%ENDIF
1542.   		     goto_tbl(parsstk[pwstkp], pantstbl.lhs[arg-PAPRDMN],
1543.   			      &action, &arg);
1544.   		     pushstat(PWFALSE);
1545.   		} while (action != SHIFT);
1546.   
1547.   		currstat = arg;
IMP -- Incremental Macro Processor 2.0.4 beta - pwspa.tst -                37.


1548.   		parsstk[pwstkp] = currstat;
1549.   		break;
1550.   
1551.   	case ACCEPT:
1552.   		endparse = PWTRUE;
1553.   		break;
1554.   	} 
1555.      } 
1556.   
1557.   } 
1558.   


        7 W : Maximum number of messages exceeded.


No errors detected.
2 warning(s) issued.
276 informational message(s) produced.

