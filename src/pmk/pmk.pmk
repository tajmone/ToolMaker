-----------------------------------------------------------------------------
--
-- pmk.pmk
--
-- pmk - ParserMaker grammar description file
--
-----------------------------------------------------------------------------

%%OPTIONS

	List Grammar, Items, Tables, Statistics;
	Library '%%(tmkLibrary)';	

%%IMPORT

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "pws.h"
#include "pmkList.h"
#include "pwsLexCode.h"
#include "set.h"
#include "pmk_i.h"
#include "tmk.h"
#include "pwSymSet.h"
#include "pwsGrm.h"
#include "pmkScan.h"
extern pmkScContext pmkCtxt;

%%END

%%EXPORT

extern TmkSrcp
	rulesSrcp,
	declarationsSrcp,
	exportSrcp,
	scannerSrcp,
	insertsymbolSrcp,
	deletesymbolSrcp;

%%SCANNER pmkScan(pmkCtxt, token);

%%INSERTSYMBOL

    /* Make the requested token */
    sym->code = code;

    switch (code) {

    case 2:			/* IDENTIFIER */
    case 3:			/* QUOTED_STRING */
    case 4:			/* ANGLE_BRACKETED_STRING */
	if (*pstr != '\0') {
	    sym->sval = (char *)malloc(strlen(pstr) + 1);
	    strcpy(sym->sval, pstr);
	} else {
	    sym->sval = (char *)malloc(strlen(sstr) + 1);
	    strcpy(sym->sval, sstr);
	}/*if*/
	sym->ival = 0;
	break;

    case 5:			/* INTEGER */
	sym->ival = 0;
	break;
    }/*switch*/

%%END

%%DECLARATIONS

TmkSrcp
	rulesSrcp,
	declarationsSrcp,
	exportSrcp,
	scannerSrcp,
	insertsymbolSrcp,
	deletesymbolSrcp;

StrListP grmAttrDecls, grmAttrNames;

CodeNodeP pmkImportSection = NULL,
	  exportSection = NULL,
	  declSection = NULL,
	  scannerSection = NULL,
	  insertSymbSection = NULL,
	  deleteSymbSection = NULL;

static Boolean optimizeObsolete = FALSE;
static Boolean scan_if_sect, attr_sect, errhand_sect, rules_sect;
static search_kind searchResult; /* Variable used for lookup calls */
static SETDEF(sym_kind_set, unknown_symb + 1); /* For lookup calls */
int symRef;        /* Variable used for lookup calls */

static int i;
static attr_kind reading_attr_class = nts_attr; /* Type of attributes when reading */
                                     /* attribute section.              */
static SymSet occupied_code_values = NULL; /* Occupied terminal code values */
static SymSet terminals_set = NULL;        /* Variable used to read a list  */
                                            /* of terminals.                 */
static SymSet modify_intersect_set = NULL; /* Variable used to keep         */
                                            /* intersection of red and nored */
                                            /* sets modifiers.               */
static prod_elnode * temp_lhs;              /* lhs of current production     */
static char * syms_str;                  /* Variable used to construct    */
                                            /* error messages.               */
static char numStr[20];

/*-----------------------------------------------------------------------------
 * makeSymStr - makes a string of symbols in the set s separated by commas.
 *-----------------------------------------------------------------------------
 */
static char *makeSymStr(s)
SymSet s;
{
    char *temp;
    int totlen = 0;
    int nr = 0;
    int i;

    for (i = 0; i < SymSetSize(s); i++) {
	if (SymSetMem(s,i)) {
	    totlen += strlen(vocabulary[i]->name) + 3;
	}/*if*/
    }/*for*/

    temp = (char *)calloc(totlen, sizeof(char));
    nr=0;
    for (i = 0; i < SymSetSize(s); i++) {
	if (SymSetMem(s, i)) {
	    if (nr > 0) strcat(temp, ", ");
	    strcat(temp, vocabulary[i]->name);
	    nr++;
	}/*if*/
    }/*for*/
    return(temp);
}/*makeSymStr()*/

%%TERMINALS

    IDENTIFIER = 2;
    STRING = 3;
    ANG_BRACK_STRING = 4;
    INTEGER = 5;
    '%%' = 99, 3, 2 => '%%...%%';

%%ATTRIBUTES
	ival %% int %1%%,
        sval %% char *%1%%,
	sval2 %% char *%1%%,
	srcp %% TmkSrcp %1%%,
	q_str %% Boolean %1 /* quoted_ string flag */%%,
        nullf %% Boolean %1 /* null flag */%%,
	icost %% int %1 /* Insert cost given in TERMINAL section */%%,
	dcost %% int %1 /* Delete cost given in TERMINAL section */%%,
	code %% int %1 /* terminals code value given in TERMINAL section */%%,
	red_set %% SymSet %1 /* modifier sets */%%,
	nored_set %% SymSet %1 /* modifier sets */%%,
	altr_node %% altr_lst *%1 /* list of alternatives (in EBNF alternation) */%%,
	altr_last %% altr_lst *%1%%,
	rhslist %% rhs_node *%1 /* list of alternative righthand sides */%%,
        rhslist_last %% rhs_node *%1 /* last element in the list above. This used to
                                        to avoid making a reversed list */%%,
	rule_elnode %% prod_elnode *%1 /* list of rhs elements (see prod_elnode's def) */%%,
	rule_elnode_last %% prod_elnode *%1%%;

%%RULES

pmk_document 
    = skip_sections 
	  %%{
	    term_sec_given = FALSE;
 	    scan_if_sect = FALSE;
	    attr_sect = FALSE;
	    errhand_sect = FALSE;
	    rules_sect = FALSE;
	 }%%
    other_sections
	  %%
	    if (!rules_sect) {
	      /* ERROR: No RULES section. */
	      pmkLog(NULL, 238, sevERR, "");
	    }
	    if (!SeriousErr) order_gram();
	  %%
    ;

skip_sections
    = -- empty
    ! skip_sections skip_section
    ;

other_sections
    = other_sections other_section
    ! other_section
    ;

other_section 
    = scanner_interface_section 
	%%
        if (scan_if_sect)
	   pmkLog(%scanner_interface_section.srcp, 235, sevERR, "");
	if (rules_sect)
	   pmkLog(%scanner_interface_section.srcp, 236, sevERR, "");
	scan_if_sect = TRUE;
	%%
    ! attribute_section
	%%
        if (attr_sect)
	   pmkLog(%attribute_section.srcp, 235, sevERR, "");
	if (rules_sect)
	   pmkLog(%attribute_section.srcp, 236, sevERR, "");
	attr_sect = TRUE;
	%%
    ! error_handling_section 
	%%
        if (errhand_sect)
	   pmkLog(%error_handling_section.srcp, 235, sevERR, "");
	if (rules_sect)
	   pmkLog(%error_handling_section.srcp, 236, sevERR, "");
	errhand_sect = TRUE;
	%%
    ! rule_section
	%%
	if (rules_sect)
	   pmkLog(%rule_section.srcp, 235, sevERR, "");
        rules_sect = TRUE;
	%%
    ! declaration_section
	%%
	if (rules_sect)
	   pmkLog(%declaration_section.srcp, 236, sevERR, "");
	declarationsSrcp = %declaration_section.srcp;
	%%
    ! export_section
	%%
	if (rules_sect)
	   pmkLog(%export_section.srcp, 236, sevERR, "");
	exportSrcp = %export_section.srcp;
	%%
    ! scanner_section
	%%
	if (rules_sect)
	   pmkLog(%scanner_section.srcp, 236, sevERR, "");
	scannerSrcp = %scanner_section.srcp;
	%%
    ! insertsymbol_section
	%%
	if (rules_sect)
	   pmkLog(%insertsymbol_section.srcp, 236, sevERR, "");
	insertsymbolSrcp = %insertsymbol_section.srcp;
	%%
    ! deletesymbol_section
	%%
	if (rules_sect)
	   pmkLog(%deletesymbol_section.srcp, 236, sevERR, "");
	deletesymbolSrcp = %deletesymbol_section.srcp;
	%%
    ;

declaration_section
    = '%%DECLARATIONS'
      -- Followed by language specific text skipped by the scanner.
	endOpt
	%%
	  %declaration_section.srcp = %'%%DECLARATIONS'.srcp;
	  if (declSection)
	    pmkLog(%'%%DECLARATIONS'.srcp, 60, sevERR, "");
	  else
  	    declSection = tmkNewCode(%'%%DECLARATIONS'.fpos, %'%%DECLARATIONS'.length);
	%%
    ;

scanner_interface_section
	= TERMINALS_aux terminal_definitions endOpt
	%%
	  %scanner_interface_section.srcp = %TERMINALS_aux.srcp;
        %%
	;

TERMINALS_aux = '%%TERMINALS'
	  %%
	    %TERMINALS_aux.srcp = %'%%TERMINALS'.srcp;
	    %TERMINALS_aux.ival = %'%%TERMINALS'.ival;
	    occupied_code_values = SymSetAlloc();
	    SymSetIns(occupied_code_values, 0);
	    SymSetIns(occupied_code_values, 1);
	    term_sec_given = TRUE;
	  %%
        ;

terminal_definitions = terminal_definition
	! terminal_definitions terminal_definition
	;

terminal_definition = terminal '=' token_code error_recovery_data ';'
	  %%
	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, t_symb);
	    lookup(%terminal.sval, sym_kind_set, &symRef, &searchResult);
	    if (searchResult == new_search || searchResult == found_search) {
		if (searchResult == found_search) {
		    /* ERROR terminal defined twice, old definition overridden
		     */
		    pmkLog(&%terminal.srcp, 121, sevWAR,
			  vocabulary[symRef]->name);
		}/*if*/
		vocabulary[symRef]->symbol_typ = t_symb;
		vocabulary[symRef]->code = %token_code.ival;
		SymSetIns(occupied_code_values, %token_code.ival);
		if (%token_code.ival > tc_val) tc_val = %token_code.ival;

		if (!(%error_recovery_data.nullf)) {
		    vocabulary[symRef]->syminfo.ter_info.icost =
			%error_recovery_data.icost;
		    if (%error_recovery_data.icost > icostMax) {
			icostMax = %error_recovery_data.icost;
		    }/*if*/
		    vocabulary[symRef]->syminfo.ter_info.dcost =
			%error_recovery_data.dcost;
		    if (%error_recovery_data.dcost > dcostMax) {
			dcostMax = %error_recovery_data.dcost;
		    }/*if*/
		    if (%error_recovery_data.sval) {
		        /* Use a print string, excluding string quotes */
		        %error_recovery_data.sval[strlen(%error_recovery_data.sval)-1] = '\0';
		        vocabulary[symRef]->syminfo.ter_info.psymb =
			  &%error_recovery_data.sval[1];
		    } else {
		        /* Insert and delete costs, but no print symbol */
		        vocabulary[symRef]->syminfo.ter_info.psymb = NULL;
                    }/*if*/
  		} else {
		    vocabulary[symRef]->syminfo.ter_info.icost = 1;
		    vocabulary[symRef]->syminfo.ter_info.dcost = 1;
		    vocabulary[symRef]->syminfo.ter_info.psymb = NULL;
		}/*if*/
	    } else if (searchResult == confl_search) {
		/* ERROR Ambiguous symbol, Terminal expected.
		 * This error should'nt happen since no other
		 * symbol kinds can occurr before scanner interface.
		 */
     		pmkLog(&%terminal.srcp, 123, sevSYS,
		      vocabulary[symRef]->name);
	    }/*if*/
	  %%
	;

terminal = symbol
	;


symbol = term_or_nonterm
	  %%
	    %symbol.q_str = FALSE;
	  %%
	! STRING
	  %%
	    %symbol.sval = %STRING.sval;
	    %symbol.q_str = TRUE;
	    %symbol.srcp = %STRING.srcp;
	  %%
	;


term_or_nonterm = IDENTIFIER  
	  %%
	    %term_or_nonterm.sval = %IDENTIFIER.sval;
	    %term_or_nonterm.srcp = %IDENTIFIER.srcp;
	  %%
	! ANG_BRACK_STRING
	  %%
	    %term_or_nonterm.sval = %ANG_BRACK_STRING.sval;
	    %term_or_nonterm.srcp = %ANG_BRACK_STRING.srcp;
	  %%
	;

token_code = INTEGER
	  %%
	    if (SymSetMem(occupied_code_values, %INTEGER.ival)) {
		/* ERROR Terminal code already in use
		 */
		sprintf(numStr, "`%u", %INTEGER.ival);
		pmkLog(&%INTEGER.srcp, 120, sevERR, numStr);
	    } else {
		%token_code.ival = %INTEGER.ival;
	    }/*if*/
	  %%
	;

error_recovery_data = -- Empty
	  %%
	    %error_recovery_data.nullf = TRUE;
	  %%
	! ',' insert_cost ',' delete_cost print_symbol
	  %%
	    %error_recovery_data.icost = %insert_cost.icost;
	    %error_recovery_data.dcost = %delete_cost.dcost;
	    %error_recovery_data.sval = %print_symbol.sval;
	    %error_recovery_data.nullf = FALSE;
	  %%
	;

insert_cost = -- Empty
	  %%
	    %insert_cost.icost = 1;
	  %%
	! INTEGER
	  %%
	    %insert_cost.icost = %INTEGER.ival;
	  %%
	;

delete_cost = -- Empty
	  %%
	    %delete_cost.dcost = 1;
	  %%
	! INTEGER
	  %%
	    %delete_cost.dcost = %INTEGER.ival;
	  %%
	;

print_symbol = -- Empty
	  %%
	    %print_symbol.sval = NULL;
	  %%
	! '=>' terminal
	  %%
	    %print_symbol.sval = %terminal.sval;
	  %%
	;

attribute_section 
        = '%%ATTRIBUTES' attributes ';' endOpt
	%%
	  %attribute_section.srcp = %'%%ATTRIBUTES'.srcp;
	%%
	;

attributes = attribute
	%%
	  if (%attribute.sval)
	    grmAttrDecls = appendStrList(%attribute.sval, NULL);
	  else
	    grmAttrDecls = NULL;
	  grmAttrNames = appendStrList(%attribute.sval2, NULL);
	%%
	! attributes ',' attribute
	%%
          if (%attribute.sval)
	    grmAttrDecls = appendStrList(%attribute.sval, grmAttrDecls);
	  grmAttrNames = appendStrList(%attribute.sval2, grmAttrNames);
          if ((%attribute.sval && !%attributes.sval) ||
	      (!%attribute.sval && %attributes.sval))
	    tmkLog(%attribute.srcp, 65, sevERR, "grammar attribute");
	%%
	;

attribute = IDENTIFIER optional_decl
	  %%
            %attribute.sval = %optional_decl.sval;
	    %attribute.sval2 = %IDENTIFIER.sval;
	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, attr_symb);
	    lookup(%IDENTIFIER.sval, sym_kind_set, &symRef, &searchResult);
	    if (new_search == searchResult) {
		vocabulary[symRef]->symbol_typ = attr_symb;
		vocabulary[symRef]->syminfo.attr_class = nts_attr;
	    } else if (found_search == searchResult) {
  		if (vocabulary[symRef]->syminfo.attr_class != nts_attr &&	
		    vocabulary[symRef]->syminfo.attr_class != unk_attr)	{
		    vocabulary[symRef]->syminfo.attr_class = voc_attr;
		} else if (vocabulary[symRef]->syminfo.attr_class == nts_attr) {
		    /* ERROR Attribute defined twice
		     */
		    pmkLog(&%IDENTIFIER.srcp, 119, sevWAR, %IDENTIFIER.sval);
		}/*if*/
	    } else {
		/* ERROR Ambiguous symbol. Attribute expected.
		 */
    		pmkLog(&%IDENTIFIER.srcp, 118, sevERR, %IDENTIFIER.sval);
	    }/*if*/
	  %%
	;

optional_decl
    = -- empty
	%%
	  %optional_decl.sval = NULL;
	%%
    ! '%%'
	%%
	  %optional_decl.sval = %'%%'.sval;
	%%
    -- Followed by language specific text skipped by the scanner.
    ;

error_handling_section 
	=    recovery_aux recovery_parts endOpt
	%%
	  %error_handling_section.srcp = %recovery_aux.srcp;
	%%
	;

recovery_aux = '%%RECOVERY'
	%%
	  %recovery_aux.srcp = %'%%RECOVERY'.srcp;
	%%
	;

recovery_parts = -- Empty
	! recovery_parts recovery_part
	;

recovery_part = meta_part
	! separator_part
	! fiducial_part
	! skip_part
	;

meta_part = 'META' meta_definitions
	%%
	  pmkLog(&%'META'.srcp, 132, sevWAR, "META");
	%%
	;

meta_definitions = meta_definition
	! meta_definitions meta_definition
	;

meta_definition = meta_name '=' '(' terminals ')' repair_terminal ';'
	;

meta_name = terminal
	%%
	  terminals_set = SymSetAlloc();
	%%
	;

terminals = terminal -- terminals index is kept in terminals_set.
                     -- terminals_set is allocated once a
                     -- terminal list is expected.
	  %%
	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, t_symb);
	    lookup(%terminal.sval, sym_kind_set, &symRef, &searchResult);
	    if (new_search == searchResult || searchResult == found_search) {
		if (searchResult == new_search) {
		    vocabulary[symRef]->symbol_typ = t_symb;
		    vocabulary[symRef]->syminfo.ter_info.icost = 1;
		    vocabulary[symRef]->syminfo.ter_info.dcost = 1;
		    vocabulary[symRef]->syminfo.ter_info.psymb = NULL;
		}/*if*/
		SymSetIns(terminals_set, symRef);
	    } else if (searchResult == confl_search) {
		/* ERROR Ambiguous symbol, Terminal expected. */
		pmkLog(&%terminal.srcp, 117, sevERR, %terminal.sval);
		SymSetIns(terminals_set, symRef);
	    }/*if*/
	  %%
	! terminals ',' terminal
	  %%
	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, t_symb);
	    lookup(%terminal.sval, sym_kind_set, &symRef, &searchResult);
	    if (new_search == searchResult || searchResult == found_search) {
		if (searchResult == new_search) {
		    vocabulary[symRef]->symbol_typ = t_symb;
		    vocabulary[symRef]->syminfo.ter_info.icost = 1;
		    vocabulary[symRef]->syminfo.ter_info.dcost = 1;
		    vocabulary[symRef]->syminfo.ter_info.psymb = NULL;
		}/*if*/
		SymSetIns(terminals_set, symRef);
	    } else if (searchResult == confl_search) {
		/* ERROR Ambiguous symbol, Terminal expected.
		 */
		pmkLog(&%terminal.srcp, 117, sevERR, %terminal.sval);
		SymSetIns(terminals_set, symRef);
	    }/*if*/
	  %%
	;

repair_terminal = -- Empty
	! '=>' terminal
	;

separator_part = separator_aux '(' terminals ')' ';'
	  %%
	    recovery_spec.separators = terminals_set;
	  %%
	;

separator_aux = 'SEPARATOR'
	  %%
	    terminals_set = SymSetAlloc();
	  %%
	 ;

fiducial_part = fiducial_aux '(' terminals ')' ';'
	  %%
	    recovery_spec.fiducials = terminals_set;
	  %%
	;

fiducial_aux = 'FIDUCIAL'
	  %%
	    terminals_set = SymSetAlloc();
	  %%
	 ;

skip_part = skip_aux  '(' terminals ')' ';'
	  %%
	    recovery_spec.skips = terminals_set;
	  %%
	;

skip_aux = 'SKIP'
	  %%
	    terminals_set = SymSetAlloc();
	  %%
	;

rule_section 
        = '%%RULES' %% init_action_structs(TRUE); %% rules endOpt
	%%
	  %rule_section.srcp = %'%%RULES'.srcp;
	  rulesSrcp = %'%%RULES'.srcp;
        %%
	;

rules = rule
	! rules rule
	;

rule =   nonterminal '=' rhss ';'
	  %%
	    /* Main routine for analysis of rhss associated with a single lhs
	     */
	    if (!SeriousErr) analyze_rhss(temp_lhs, %rhss.rhslist);
	  %%
	;



nonterminal = term_or_nonterm
	  %%
	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, nts_symb);
	    lookup(%term_or_nonterm.sval, sym_kind_set, &symRef,
		   &searchResult);
	    if (new_search == searchResult) {
		vocabulary[symRef]->symbol_typ = nts_symb;
		vocabulary[symRef]->syminfo.firstp = -1;
	    }/*if*/
	    temp_lhs = prod_elnodeAlloc();
	    temp_lhs->node_kind = sym_node_kind;
	    temp_lhs->node_info.sym_node.sym_ind = symRef;
	    temp_lhs->node_info.sym_node.lhs_sym = TRUE;
	    temp_lhs->node_info.sym_node.newnont = FALSE;
	    if (confl_search == searchResult) {
		pmkLog(&%term_or_nonterm.srcp, 116, sevERR,
		      %term_or_nonterm.sval);
	    }/*if*/
	  %%
	;

rhss = rhs
	  %%
	    %rhss.rhslist_last = %rhs.rhslist;
	  %%
	! rhss '!' rhs
	  %%
	    %2rhss.rhslist_last->nxtrhs = %rhs.rhslist;
	    %1rhss.rhslist = %2rhss.rhslist;
	    %1rhss.rhslist_last = %rhs.rhslist;
	  %%
	;

rhs = symbols_or_actions modifiers
	  %%
	    if (%symbols_or_actions.nullf) {
		/* Allocated a null node
		 */
		%symbols_or_actions.rule_elnode = prod_elnodeAlloc();
		%symbols_or_actions.rule_elnode->node_kind = null_node_kind;
		%symbols_or_actions.rule_elnode_last =
		    %symbols_or_actions.rule_elnode;
	    }/*if*/
	    if (!(%modifiers.nullf)) {
		/* Allocate a modifier node
		 */
		%modifiers.rule_elnode = prod_elnodeAlloc();
		%modifiers.rule_elnode->node_kind = mod_node_kind;
		%modifiers.rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%modifiers.rule_elnode->node_info.modify_node->red =
		    %modifiers.red_set;
		%modifiers.rule_elnode->node_info.modify_node->nored =
		    %modifiers.nored_set;
		%symbols_or_actions.rule_elnode_last->nxtnode =
		    %modifiers.rule_elnode;
	    }/*if*/

	    %rhs.rhslist = rhs_nodeAlloc();
	    %rhs.rhslist->rhs = %symbols_or_actions.rule_elnode;
	  %%

	;

symbols_or_actions = %-('%+','%-') -- Empty
	  %%
	    %symbols_or_actions.nullf = TRUE;
	  %%
	! symbols_or_actions symbol_or_action
	  %%
	    /* Make list
	     */
	    if (%2symbols_or_actions.nullf) {
		if (%symbol_or_action.nullf) {
		    %1symbols_or_actions.nullf = TRUE;
		} else {
		    %1symbols_or_actions.nullf = FALSE;
		    %1symbols_or_actions.rule_elnode =
			%symbol_or_action.rule_elnode;
		    %1symbols_or_actions.rule_elnode_last =
			%symbol_or_action.rule_elnode_last;
		}/*if*/
	    } else if (%symbol_or_action.nullf) {
		%1symbols_or_actions.nullf = FALSE;
		%1symbols_or_actions.rule_elnode =
		    %2symbols_or_actions.rule_elnode;
		%1symbols_or_actions.rule_elnode_last =
		    %2symbols_or_actions.rule_elnode_last;
	    } else {
		%1symbols_or_actions.nullf = FALSE;
		%2symbols_or_actions.rule_elnode_last->nxtnode =
		    %symbol_or_action.rule_elnode;
		%1symbols_or_actions.rule_elnode =
		    %2symbols_or_actions.rule_elnode;
		%1symbols_or_actions.rule_elnode_last =
		    %symbol_or_action.rule_elnode_last;
	    }/*if*/
	  %%
	;

Alternatives = Alternatives  '|' modifiers symbols_or_actions modifiers
	  %%
	    if (%symbols_or_actions.nullf) {
		%symbols_or_actions.rule_elnode = prod_elnodeAlloc();
		%symbols_or_actions.rule_elnode->node_kind = null_node_kind;
		%symbols_or_actions.rule_elnode_last =
		    %symbols_or_actions.rule_elnode;
		if (!(%2modifiers.nullf) && !(%1modifiers.nullf)) {
		    /* Test red and nored sets intersection
		     */
		    if (%1modifiers.red_set != NULL &&
			%2modifiers.nored_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(%1modifiers.red_set, %1modifiers.nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&%2modifiers.srcp, 113, sevERR, syms_str);
			    free(syms_str);
			    %1modifiers.red_set = NULL;
			}/*if*/
		    }/*if*/
		    if (%1modifiers.nored_set != NULL &&
			%2modifiers.red_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(%1modifiers.red_set, %1modifiers.nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&%2modifiers.srcp, 113, sevERR, syms_str);
			    free(syms_str);
			    %1modifiers.red_set = NULL;
			}/*if*/
		    }/*if*/
		}/*if*/
	    }/*if*/

	    /* Make list
	     */
	    if (!(%2modifiers.nullf)) {
		%2modifiers.rule_elnode = prod_elnodeAlloc();
		%2modifiers.rule_elnode->node_kind = mod_node_kind;
		%2modifiers.rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%2modifiers.rule_elnode->node_info.modify_node->red =
		    %2modifiers.red_set;
		%2modifiers.rule_elnode->node_info.modify_node->nored =
		    %2modifiers.nored_set;
		%symbols_or_actions.rule_elnode_last->nxtnode =
		    %2modifiers.rule_elnode;
		%symbols_or_actions.rule_elnode_last = %2modifiers.rule_elnode;
	    }/*if*/

	    %2Alternatives.altr_last->nxtalt = altr_lstAlloc();

	    if (!(%1modifiers.nullf)) {
		%1modifiers.rule_elnode = prod_elnodeAlloc();
		%1modifiers.rule_elnode->node_kind = mod_node_kind;
		%1modifiers.rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%1modifiers.rule_elnode->node_info.modify_node->red =
		    %1modifiers.red_set;
		%1modifiers.rule_elnode->node_info.modify_node->nored =
		    %1modifiers.nored_set;
		%1modifiers.rule_elnode->nxtnode =
		    %symbols_or_actions.rule_elnode;
		%2Alternatives.altr_last->nxtalt->altr =
		    %1modifiers.rule_elnode;
	    } else {
		%2Alternatives.altr_last->nxtalt->altr =
		    %symbols_or_actions.rule_elnode;
	    }/*if*/

	    %1Alternatives.altr_node = %2Alternatives.altr_node;
	    %1Alternatives.altr_last = %2Alternatives.altr_last->nxtalt;
	  %%

	! modifiers symbols_or_actions modifiers
	  %%
	    if (%symbols_or_actions.nullf) {
		%symbols_or_actions.rule_elnode = prod_elnodeAlloc();
		%symbols_or_actions.rule_elnode->node_kind = null_node_kind;
		%symbols_or_actions.rule_elnode_last =
		    %symbols_or_actions.rule_elnode;
		if (!(%2modifiers.nullf) && !(%1modifiers.nullf)) {
		    /* Test red and nored sets intersection
		     */
		    if (%1modifiers.red_set != NULL &&
			%2modifiers.nored_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(%1modifiers.red_set, %1modifiers.nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&%2modifiers.srcp, 113, sevERR, syms_str);
			    free(syms_str);
			    %1modifiers.red_set = NULL;
			}/*if*/
		    }/*if*/

		    /* Test red and nored sets intersection
		     */
		    if (%1modifiers.nored_set != NULL &&
			%2modifiers.red_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(%1modifiers.red_set, %1modifiers.nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&%2modifiers.srcp,113,sevERR,syms_str);
			    free(syms_str);
			    %1modifiers.red_set = NULL;
			}/*if*/
		    }/*if*/
		}/*if*/
	    }/*if*/

	    if (!(%2modifiers.nullf)) {
		%2modifiers.rule_elnode = prod_elnodeAlloc();
		%2modifiers.rule_elnode->node_kind = mod_node_kind;
		%2modifiers.rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%2modifiers.rule_elnode->node_info.modify_node->red =
		    %2modifiers.red_set;
		%2modifiers.rule_elnode->node_info.modify_node->nored =
		    %2modifiers.nored_set;
		%symbols_or_actions.rule_elnode_last->nxtnode =
		    %2modifiers.rule_elnode;
		%symbols_or_actions.rule_elnode_last =
		    %2modifiers.rule_elnode;
	    }/*if*/

	    %Alternatives.altr_node = altr_lstAlloc();

	    if (!(%1modifiers.nullf)) {
		%1modifiers.rule_elnode = prod_elnodeAlloc();
		%1modifiers.rule_elnode->node_kind = mod_node_kind;
		%1modifiers.rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%1modifiers.rule_elnode->node_info.modify_node->red =
		    %1modifiers.red_set;
		%1modifiers.rule_elnode->node_info.modify_node->nored =
		    %1modifiers.nored_set;
		%1modifiers.rule_elnode->nxtnode =
		    %symbols_or_actions.rule_elnode;
		%Alternatives.altr_node->altr = %1modifiers.rule_elnode;
	    } else {
		%Alternatives.altr_node->altr =
		    %symbols_or_actions.rule_elnode;
	    }/*if*/

	    %Alternatives.altr_last = %Alternatives.altr_node;
	  %% 
	;


symbol_or_action = symbol
	  %%
	    SetClear(sym_kind_set, unknown_symb + 1);
	    if (%symbol.q_str) {
		SetIns(sym_kind_set, t_symb);
	    } else {
		SetIns(sym_kind_set, t_symb);
		SetIns(sym_kind_set, nts_symb);
	    }/*if*/

	    lookup(%symbol.sval, sym_kind_set, &symRef, &searchResult);
	    if (confl_search == searchResult) {
		/* ERROR Ambiguous symbol Terminal or non terminal expected
		 */
		%symbol_or_action.nullf = TRUE;
		pmkLog(&%symbol.srcp, 115, sevERR, %symbol.sval);
	    } else {
		SymSetIns(on_right, symRef);
		%symbol_or_action.rule_elnode = prod_elnodeAlloc();
		%symbol_or_action.rule_elnode->node_kind = sym_node_kind;
		%symbol_or_action.rule_elnode->node_info.sym_node.sym_ind =
		    symRef;
		%symbol_or_action.rule_elnode->node_info.sym_node.lhs_sym =
		    FALSE;
		%symbol_or_action.rule_elnode->node_info.sym_node.newnont =
		    FALSE;
		SymSetIns(on_right, symRef);
		%symbol_or_action.rule_elnode_last =
		    %symbol_or_action.rule_elnode;
		%symbol_or_action.nullf = FALSE;
	    }/*if*/
	  %%
        ! '{' modifiers symbols_or_actions modifiers '}'
	  %%
	    if (%symbols_or_actions.nullf) {
		/* ERROR Repetition of Null string ignored
		 */
		%symbol_or_action.nullf = TRUE;
		pmkLog(&%'{'.srcp,114,sevWAR,"");
	    } else {
		/* Generate a new symbol node (with a new symbol).
		 * Keep symbols_or_actions's rule_nodelist in the symbol node
		 */
		SetClear(sym_kind_set, unknown_symb + 1);
		SetIns(sym_kind_set, nts_symb);
		lookup(gensym(), sym_kind_set, &symRef, &searchResult);
		vocabulary[symRef]->symbol_typ = nts_symb;
		vocabulary[symRef]->syminfo.firstp = -1;
		if (confl_search == searchResult ||
		    found_search == searchResult)
		{
		    /* This shouldn't happen */
		    printf("Non terminal generated by PMK is equal to user's symbol");
		}/*if*/

		/* Make list */
		if (!(%2modifiers.nullf)) {
		    %2modifiers.rule_elnode = prod_elnodeAlloc();
		    %2modifiers.rule_elnode->node_kind = mod_node_kind;
		    %2modifiers.rule_elnode->node_info.modify_node =
			modify_recAlloc();
		    %2modifiers.rule_elnode->node_info.modify_node->red =
			%2modifiers.red_set;
		    %2modifiers.rule_elnode->node_info.modify_node->nored =
			%2modifiers.nored_set;
		    %symbols_or_actions.rule_elnode_last->nxtnode =
			%2modifiers.rule_elnode;
		    %symbols_or_actions.rule_elnode_last =
			%2modifiers.rule_elnode;
		}/*if*/
		SymSetIns(on_right, symRef);
		%symbol_or_action.rule_elnode = prod_elnodeAlloc();
		%symbol_or_action.rule_elnode->node_kind = sym_node_kind;
		%symbol_or_action.rule_elnode->node_info.sym_node.sym_ind =
		    symRef;
		%symbol_or_action.rule_elnode->node_info.sym_node.newnont =
		    TRUE;
		%symbol_or_action.rule_elnode->node_info.sym_node.rplc_info =
		    rept_rplc;
		if (!(%1modifiers.nullf)) {
		    %1modifiers.rule_elnode = prod_elnodeAlloc();
		    %1modifiers.rule_elnode->node_kind = mod_node_kind;
		    %1modifiers.rule_elnode->node_info.modify_node =
			modify_recAlloc();
		    %1modifiers.rule_elnode->node_info.modify_node->red =
			%1modifiers.red_set;
		    %1modifiers.rule_elnode->node_info.modify_node->nored =
			%1modifiers.nored_set;
		    %1modifiers.rule_elnode->nxtnode =
			%symbols_or_actions.rule_elnode;
		    %symbol_or_action.rule_elnode->node_info.sym_node.rplc_seq=
			%1modifiers.rule_elnode;
		} else {
		    %symbol_or_action.rule_elnode->node_info.sym_node.rplc_seq=
			%symbols_or_actions.rule_elnode;
		}/*if*/
		%symbol_or_action.rule_elnode_last =
		    %symbol_or_action.rule_elnode;
		%symbol_or_action.nullf = FALSE;
	    }/*if*/
	  %%

        ! '[' modifiers symbols_or_actions modifiers ']'
	  %%{
	    /* Convert this to "'(' '|' modifiers symbols_or_actions modifiers ')' */
	    altr_lst *altrs;
	    altr_lst *altr;

	    /* Create the empty alternative */
	    altrs = altr_lstAlloc();
	    altrs->altr = prod_elnodeAlloc();
	    altrs->altr->node_kind = null_node_kind;

	    /* Then the other part */
	    if (%symbols_or_actions.nullf) {
		%symbols_or_actions.rule_elnode = prod_elnodeAlloc();
		%symbols_or_actions.rule_elnode->node_kind = null_node_kind;
		%symbols_or_actions.rule_elnode_last =
		    %symbols_or_actions.rule_elnode;
		if (!(%2modifiers.nullf) && !(%1modifiers.nullf)) {
		    /* Test red and nored sets intersection
		     */
		    if (%1modifiers.red_set != NULL &&
			%2modifiers.nored_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(%1modifiers.red_set, %1modifiers.nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&%2modifiers.srcp, 113, sevERR, syms_str);
			    free(syms_str);
			    %1modifiers.red_set = NULL;
			}/*if*/
		    }/*if*/
		    if (%1modifiers.nored_set != NULL &&
			%2modifiers.red_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(%1modifiers.red_set, %1modifiers.nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&%2modifiers.srcp, 113, sevERR, syms_str);
			    free(syms_str);
			    %1modifiers.red_set = NULL;
			}/*if*/
		    }/*if*/
		}/*if*/
	    }/*if*/

	    /* Make list */
	    if (!(%2modifiers.nullf)) {
		%2modifiers.rule_elnode = prod_elnodeAlloc();
		%2modifiers.rule_elnode->node_kind = mod_node_kind;
		%2modifiers.rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%2modifiers.rule_elnode->node_info.modify_node->red =
		    %2modifiers.red_set;
		%2modifiers.rule_elnode->node_info.modify_node->nored =
		    %2modifiers.nored_set;
		%symbols_or_actions.rule_elnode_last->nxtnode =
		    %2modifiers.rule_elnode;
		%symbols_or_actions.rule_elnode_last = %2modifiers.rule_elnode;
	    }/*if*/

	    altr = altr_lstAlloc();

	    if (!(%1modifiers.nullf)) {
		%1modifiers.rule_elnode = prod_elnodeAlloc();
		%1modifiers.rule_elnode->node_kind = mod_node_kind;
		%1modifiers.rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%1modifiers.rule_elnode->node_info.modify_node->red =
		    %1modifiers.red_set;
		%1modifiers.rule_elnode->node_info.modify_node->nored =
		    %1modifiers.nored_set;
		%1modifiers.rule_elnode->nxtnode =
		    %symbols_or_actions.rule_elnode;
		altr->altr = %1modifiers.rule_elnode;
	    } else {
		altr->altr = %symbols_or_actions.rule_elnode;
	    }/*if*/
	    altrs->nxtalt = altr;

	    /* Generate a new symbol node (with a new symbol)
	     * keep symbols_or_actions's rule_nodelist in the symbol node
	     */
	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, nts_symb);
	    lookup(gensym(), sym_kind_set, &symRef, &searchResult);
	    vocabulary[symRef]->symbol_typ = nts_symb;
	    vocabulary[symRef]->syminfo.firstp = -1;
	    if (confl_search == searchResult || found_search == searchResult) {
		/* This shouldn't happen */
		printf("Non terminal generated by PMK is equal to user's symbol");
	    }/*if*/

	    /* Make list */
	    SymSetIns(on_right, symRef);
	    %symbol_or_action.rule_elnode = prod_elnodeAlloc();
	    %symbol_or_action.rule_elnode->node_kind = sym_node_kind;
	    %symbol_or_action.rule_elnode->node_info.sym_node.sym_ind = symRef;
	    %symbol_or_action.rule_elnode->node_info.sym_node.newnont = TRUE;
	    %symbol_or_action.rule_elnode->node_info.sym_node.rplc_info = altrs_rplc;
	    %symbol_or_action.rule_elnode->node_info.sym_node.altrs_seq = altrs;
	    %symbol_or_action.rule_elnode_last = %symbol_or_action.rule_elnode;
	    %symbol_or_action.nullf = FALSE;

	  }%%

        ! '(' Alternatives ')'
	  %%
	    /* Generate a new symbol node (with a new symbol)
	     * keep symbols_or_actions's rule_nodelist in the symbol node
	     */
	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, nts_symb);
	    lookup(gensym(), sym_kind_set, &symRef, &searchResult);
	    vocabulary[symRef]->symbol_typ = nts_symb;
	    vocabulary[symRef]->syminfo.firstp = -1;
	    if (confl_search == searchResult || found_search == searchResult) {
		/* This shouldn't happen */
		printf("Non terminal generated by PMK is equal to user's symbol");
	    }/*if*/

	    /* Make list */
	    SymSetIns(on_right, symRef);
	    %symbol_or_action.rule_elnode = prod_elnodeAlloc();
	    %symbol_or_action.rule_elnode->node_kind = sym_node_kind;
	    %symbol_or_action.rule_elnode->node_info.sym_node.sym_ind = symRef;
	    %symbol_or_action.rule_elnode->node_info.sym_node.newnont = TRUE;
	    %symbol_or_action.rule_elnode->node_info.sym_node.rplc_info =
		altrs_rplc;
	    %symbol_or_action.rule_elnode->node_info.sym_node.altrs_seq =
		%Alternatives.altr_node;
	    %symbol_or_action.rule_elnode_last = %symbol_or_action.rule_elnode;
	    %symbol_or_action.nullf = FALSE;
	  %%

	! modifiers action modifiers %-('%+', '%-')
	  %%
	    if (!(%2modifiers.nullf) && !(%1modifiers.nullf)) {
		/* Test red and nored sets intersection */
		if (%1modifiers.red_set != NULL &&
		    %2modifiers.nored_set != NULL)
		{
		    if (modify_intersect_set == NULL) {
			modify_intersect_set = SymSetAlloc();
		    }/*if*/
		    SymSetClear(modify_intersect_set);
		    SymSetInter(%1modifiers.red_set, %1modifiers.nored_set,
				modify_intersect_set);
		    if (!(SymSetEmpty(modify_intersect_set))) {
			syms_str = makeSymStr(modify_intersect_set);
			pmkLog(&%2modifiers.srcp, 113, sevERR, syms_str);
			free(syms_str);
			%1modifiers.red_set = NULL;
		    }/*if*/
		}/*if*/
		if (%1modifiers.nored_set != NULL &&
		    %2modifiers.red_set != NULL)
		{
		    if (modify_intersect_set == NULL) {
			modify_intersect_set = SymSetAlloc();
		    }/*if*/
		    SymSetClear(modify_intersect_set);
		    SymSetInter(%1modifiers.red_set, %1modifiers.nored_set,
				modify_intersect_set);
		    if (!(SymSetEmpty(modify_intersect_set))) {
			syms_str = makeSymStr(modify_intersect_set);
			pmkLog(&%2modifiers.srcp, 113, sevERR, syms_str);
			free(syms_str);
			%1modifiers.red_set = NULL;
		    }/*if*/
		}/*if*/
	    }/*if*/
     
	    if (!(%2modifiers.nullf)) {
		%2modifiers.rule_elnode = prod_elnodeAlloc();
		%2modifiers.rule_elnode->node_kind = mod_node_kind;
		%2modifiers.rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%2modifiers.rule_elnode->node_info.modify_node->red =
		    %2modifiers.red_set;
		%2modifiers.rule_elnode->node_info.modify_node->nored =
		    %2modifiers.nored_set;
		%action.rule_elnode->nxtnode = %2modifiers.rule_elnode;
		%action.rule_elnode_last = %2modifiers.rule_elnode;
	    }/*if*/

	    if (!(%1modifiers.nullf)) {
		%1modifiers.rule_elnode = prod_elnodeAlloc();
		%1modifiers.rule_elnode->node_kind = mod_node_kind;
		%1modifiers.rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%1modifiers.rule_elnode->node_info.modify_node->red =
		    %1modifiers.red_set;
		%1modifiers.rule_elnode->node_info.modify_node->nored =
		    %1modifiers.nored_set;
		%1modifiers.rule_elnode->nxtnode = %action.rule_elnode;
		%symbol_or_action.rule_elnode = %1modifiers.rule_elnode;
		%symbol_or_action.rule_elnode_last = %action.rule_elnode_last;
		%symbol_or_action.nullf = FALSE;
	    } else {
		%symbol_or_action.rule_elnode = %action.rule_elnode;
		%symbol_or_action.rule_elnode_last = %action.rule_elnode_last;
		%symbol_or_action.nullf = FALSE;
	    }/*if*/
	  %%  
	;

modifiers = -- Empty
	  %%
	    %modifiers.nullf = TRUE;
	  %%
	! modifiers modifier
	  %%
	    /* Merge modifier sets
	     */
	    if (!(%2modifiers.nullf)) {
		if (%2modifiers.red_set == NULL) {
		    if (%modifier.red_set != NULL) {
			%1modifiers.red_set = %modifier.red_set;
		    }/*if*/
		} else if (%modifier.red_set == NULL) {
		    %1modifiers.red_set = %2modifiers.red_set;
		} else {
		    SymSetUnion(%2modifiers.red_set, %modifier.red_set,
				%1modifiers.red_set);
		}/*if*/
		if (%2modifiers.nored_set == NULL) {
		    if (%modifier.nored_set != NULL) {
			%1modifiers.nored_set = %modifier.nored_set;
		    }/*if*/
		} else if (%modifier.nored_set == NULL) {
		    %1modifiers.nored_set = %2modifiers.nored_set;
		} else {
		    SymSetUnion(%2modifiers.nored_set, %modifier.nored_set,
				%1modifiers.nored_set);
		}/*if*/
		%1modifiers.nullf = FALSE;
	    } else {
		%1modifiers.red_set = %modifier.red_set;
		%1modifiers.nored_set = %modifier.nored_set;
		%1modifiers.nullf = FALSE;
	    }/*if*/

	    /* Test red and nored sets intersection
	     */
	    if (%1modifiers.red_set != NULL &&
		%1modifiers.nored_set != NULL)
	    {
		if (modify_intersect_set == NULL) {
		    modify_intersect_set = SymSetAlloc();
		}/*if*/
		SymSetClear(modify_intersect_set);
		SymSetInter(%1modifiers.red_set, %1modifiers.nored_set,
			    modify_intersect_set);
		if (!(SymSetEmpty(modify_intersect_set))) {
		     syms_str = makeSymStr(modify_intersect_set);
		     pmkLog(&%modifier.srcp, 113, sevERR, syms_str);
		     free(syms_str);
		     %1modifiers.red_set = NULL;
		}/*if*/
	    }/*if*/
	  %%
	;

modifier = reduce_modifier
	  %%
	    %modifier.red_set = %reduce_modifier.red_set;
	    %modifier.nored_set = NULL;
	  %% 
	! reduce_not_modifier
	  %%
	    %modifier.nored_set = %reduce_not_modifier.nored_set;
	    %modifier.red_set = NULL;
	  %%
	;

reduce_modifier = <+red_aux> '(' terminals ')'
	  %%
	    %reduce_modifier.red_set = terminals_set;
	  %%
	;

<+red_aux> = '%+'
	  %%
	    terminals_set = SymSetAlloc();
	    %<+red_aux>.srcp = %'%+'.srcp;
	  %%
        ;

reduce_not_modifier = <-red_aux>  '(' terminals ')'
	  %%
	    %reduce_not_modifier.nored_set = terminals_set;
	  %%
	;

<-red_aux> = '%-'
	  %%
	    terminals_set = SymSetAlloc();
	    %<-red_aux>.srcp = %'%-'.srcp;
	  %%
        ;

action = '%%'
	  %%
	    %action.rule_elnode = prod_elnodeAlloc();
	    %action.rule_elnode->node_kind = act_node_kind;
	    %action.rule_elnode->node_info.act_node.act_srcp = %'%%'.srcp;
	    %action.rule_elnode->node_info.act_node.act_start = %'%%'.fpos;
	    %action.rule_elnode->node_info.act_node.act_length = %'%%'.length;
	    %action.rule_elnode_last = %action.rule_elnode;
	  %%
	  -- Followed by language specific text skipped by the scanner.
	;

----------------------------------------------------------------------------------
--  Sections containing skipped code
----------------------------------------------------------------------------------
export_section
    = '%%EXPORT'
      -- Followed by language specific text skipped by the scanner.
	endOpt
	%%
	  %export_section.srcp = %'%%EXPORT'.srcp;
	  if (exportSection)
	    pmkLog(%'%%EXPORT'.srcp, 60, sevERR, "");
	  else
  	    exportSection = tmkNewCode(%'%%EXPORT'.fpos, %'%%EXPORT'.length);
	%%
    ;

scanner_section
    = '%%SCANNER'
      -- Followed by language specific text skipped by the scanner.
	endOpt
	%%
	  %scanner_section.srcp = %'%%SCANNER'.srcp;
	  if (scannerSection)
	    pmkLog(%'%%SCANNER'.srcp, 60, sevERR, "");
	  else
  	    scannerSection = tmkNewCode(%'%%SCANNER'.fpos, %'%%SCANNER'.length);
	%%
    ;

insertsymbol_section
    = '%%INSERTSYMBOL'
      -- Followed by language specific text skipped by the scanner.
	endOpt
	%%
	  %insertsymbol_section.srcp = %'%%INSERTSYMBOL'.srcp;
	  if (insertSymbSection)
	    pmkLog(%'%%INSERTSYMBOL'.srcp, 60, sevERR, "");
	  else
  	    insertSymbSection = tmkNewCode(%'%%INSERTSYMBOL'.fpos, %'%%INSERTSYMBOL'.length);
	%%
    ;

deletesymbol_section
    = '%%DELETESYMBOL'
      -- Followed by language specific text skipped by the scanner.
	endOpt
	%%
	  %deletesymbol_section.srcp = %'%%DELETESYMBOL'.srcp;
	  if (deleteSymbSection)
	    pmkLog(%'%%DELETESYMBOL'.srcp, 60, sevERR, "");
	  else
  	    deleteSymbSection = tmkNewCode(%'%%DELETESYMBOL'.fpos, %'%%DELETESYMBOL'.length);
	%%
    ;

-----------------------------------------------------------------------------
-- skip section
-----------------------------------------------------------------------------

skip_section
    = SKIPHEADER
      -- Followed by language specific text skipped by the scanner.
      endOpt
    ;

-----------------------------------------------------------------------------
-- messages section grammar
-----------------------------------------------------------------------------

endOpt
    = -- empty
    ! '%%END'
    ;
