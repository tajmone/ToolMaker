########## smk ##########
==> smk.tmk <==
%%OPTIONS
    Prefix 'smk';
    Target 'c';
    Library '../../../../lib/c';
%%IMPORT
#include "tmkCommon.h"
#include "name.h"
#include "action.h"
%%END
%%TOKEN
    NAME SmkToken;
    CODE code    %% int %1%%;
    SRCP srcp    %% TmkSrcp %1%%;
    ATTRIBUTES
         action  %% Action %1%%,
         name    %% Name %1%%,
         fnumber %% double %1%%,
         inumber %% int %1%%;
%%END
%%SRCP
    NAME TmkSrcp;
    COLUMN col;
    ROW    line;
    FILE   file;
%%END

==> smk.pml <==

==> smk.pmt <==
%%SET tmkTokenName("SmkToken")
%%SET tmkTokenCode("code")
%%SET tmkTokenSrcp("srcp")
%%SET tmkTokenDecl (" int code", " TmkSrcp srcp", " Action action", " Name name", " double fnumber", " int inumber")
%%SET tmkSrcpName("TmkSrcp")
%%SET tmkSrcpRow("line")
%%SET tmkSrcpCol("col")
%%SET tmkSrcpFile("file")
%%BEGIN(tmkImport)

#include "tmkCommon.h"
#include "name.h"
#include "action.h"
%%END(tmkImport)
%%SET tmkForce(1)
%%SET tmkOs("SunOS")
%%SET pmkOs("SunOS")
%%SET currentOs("cygwin")
%%SET tmkTarget("c")
%%SET pmkTarget("c")
%%SET tmkLibrary("../../../../lib/c")
%%SET pmkLibrary("../..")
%%SET tmkPrefix("smk")
%%SET parserPrefix("smk")
%%SET listerPrefix("smk")
%%SET tmkCodeDecl(" int code")
%%SET tmkGrmAttrDecl(" Action action", " AST ast", " Name name", " double fnumber", " int inumber", " TmkSrcp srcp")
%%SET tmkGrmAttrNames("action", "ast", "name", "fnumber", "inumber", "srcp")
%%BEGIN(pmkImport)

#include <stdio.h>
#include "smk_i.h"
#include "smkScan.h"
#include "smkList.h"
#include "ast.h"
#include "definition.h"
#include "name.h"
#include "scanner.h"
#include "token.h"
#include "voc.h"
#include "set.h"
#include "map.h"
#include "pack.h"
#include "action.h"
extern smkContext lexContext;
%%END(pmkImport)
%%PROCESS("%%(tmkLibrary)/Common.imp")
%%SET pmStackMax(32)
%%SET pmLookAheadMax(5)
%%SET pmCost(5)
%%BEGIN(pmIScan)
 smkScan(lexContext, token);
%%END(pmIScan)
%%BEGIN(pmISym)

    /* Make the requested token
     */
    sym->code = code;
    sym->name=nameSearch("<PARSE ERROR>");
    sym->srcp.file=1;
%%END(pmISym)
%%SET pmOptimize(Lr0)
%%SET pmActPack(RDS)
%%SET pmGtoPack(RDS)
%%SET pmRec(Single, Multiple, Panic)
%%SET pmHeader("PMK -- ParserMaker 2.1(17) (1997-07-28 17:52)")
%%SET pmVersion("2.1")
%%SET pmCorrection("17")
%%BEGIN(pmDecl)
extern Scanner grmScanner;		/* Current scanner */
extern TokenType grmTokenType;		/* Current token type */
%%END(pmDecl)
%%SET pmStates(84)
%%SET pmStateTyp(1)
%%SET pmTerms(71)
%%SET pmTermTyp(1)
%%SET pmActTyp(2)
%%SET pmArgTyp(1)
%%SET pmActRDSvectorLen(1552)
%%BEGIN(pmActTab)
{11,529,683,434,683,683,690,698,706,257,161,514,683,683,683,683,683,683
,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683
,683,683,683,683,683,714,273,442,291,683,683,233,547,274,683,683,683,683
,1050,659,4,659,659,683,683,291,585,81,683,770,305,659,818,882,906,930,659
,794,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,1050,802,659
,810,898,1034,409,363,363,81,1010,1018,299,129,345,858,962,866,1026,1050
,651,242,651,651,786,946,363,401,730,986,770,305,651,818,882,906,930,651
,794,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,1050,802,651
,810,898,1034,1042,129,345,738,1010,1018,129,345,233,858,962,866,1026,449
,393,1042,299,778,786,946,289,770,305,986,818,882,906,930,394,794,826,834
,842,850,874,890,914,922,938,954,970,978,994,1002,1050,802,1042,810,898
,1034,1042,355,355,346,1010,1018,138,619,131,858,962,866,1026,483,722,530
,99,209,786,946,355,505,417,986,626,193,522,131,483,483,483,483,131,483
,483,483,483,483,483,483,483,483,483,483,483,483,483,483,538,483,0,483,483
,483,0,483,561,0,483,483,0,483,483,483,483,483,483,499,0,595,0,0,483,483
,0,83,483,483,0,0,83,0,499,499,499,499,602,499,499,499,499,499,499,499,499
,499,499,499,499,499,499,499,0,499,185,499,499,499,0,499,403,403,499,499
,0,499,499,499,499,499,499,131,0,595,0,0,499,499,0,369,499,499,0,0,0,0,818
,882,906,930,602,794,826,834,842,850,874,890,914,922,938,954,970,978,994
,1002,0,802,185,810,898,1034,0,138,403,403,1010,1018,0,131,131,858,962,866
,1026,491,0,595,0,0,786,946,0,369,131,986,0,0,0,0,491,491,491,491,602,491
,491,491,491,491,491,491,491,491,491,491,491,491,491,491,0,491,185,491,491
,491,0,491,0,0,491,491,0,491,491,491,491,491,491,499,0,0,0,0,491,491,0,0
,491,491,0,0,0,0,499,499,499,499,0,499,499,499,499,499,499,499,499,499,499
,499,499,499,499,499,0,499,0,499,499,499,0,499,0,0,499,499,0,499,499,499
,499,499,499,131,0,0,0,0,499,499,0,0,499,499,0,0,0,0,818,882,906,930,0,794
,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,0,802,0,810,898
,1034,0,138,0,0,1010,1018,307,131,131,858,962,866,1026,0,283,0,0,0,786,946
,0,0,131,986,770,305,0,818,882,906,930,283,794,826,834,842,850,874,890,914
,922,938,954,970,978,994,1002,1050,802,0,810,898,1034,0,129,345,0,1010,1018
,0,0,0,858,962,866,1026,0,0,0,307,0,786,946,0,770,305,986,818,882,906,930
,0,794,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,1050,802
,0,810,898,1034,0,0,0,0,1010,1018,0,0,0,858,962,866,1026,0,0,0,0,0,786,946
,0,770,305,986,818,882,906,930,0,794,826,834,842,850,874,890,914,922,938
,954,970,978,994,1002,1050,802,0,810,898,1034,0,0,0,0,1010,1018,0,0,0,858
,962,866,1026,0,0,0,0,0,786,946,0,0,0,986,818,882,906,930,0,794,826,834
,842,850,874,890,914,922,938,954,970,978,994,1002,0,802,0,810,898,1034,0
,0,0,0,1010,1018,0,371,371,858,962,866,1026,0,635,0,329,233,786,946,0,0
,0,986,770,305,371,818,882,906,930,635,794,826,834,842,850,874,890,914,922
,938,954,970,978,994,1002,1050,802,635,810,898,1034,0,0,0,0,1010,1018,0
,0,0,858,962,866,1026,0,0,0,0,0,786,946,0,0,0,986,818,882,906,930,0,794
,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,0,802,0,810,898
,1034,0,0,0,0,1010,1018,0,411,411,858,962,866,1026,0,0,0,0,0,786,946,0,0
,0,986,818,882,906,930,0,794,826,834,842,850,874,890,914,922,938,954,970
,978,994,1002,0,802,0,810,898,0,0,138,0,0,1010,1018,0,0,0,858,962,866,1026
,0,0,0,0,0,786,946,0,0,131,986,818,882,906,930,0,794,826,834,842,850,874
,890,914,922,938,954,970,978,994,1002,0,802,0,810,898,1034,0,0,0,0,1010
,1018,0,0,0,858,962,866,1026,0,0,0,0,0,786,946,0,0,0,986,818,882,906,930
,0,794,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,0,802,0
,810,898,1034,0,0,0,0,1010,1018,0,0,0,858,962,866,1026,0,0,0,0,0,786,946
,0,0,0,986,818,882,906,930,0,794,826,834,842,850,874,890,914,922,938,954
,970,978,994,1002,0,802,0,810,898,0,0,0,0,0,1010,1018,0,0,0,858,962,866
,1026,0,0,0,0,0,786,946,0,0,0,986,818,882,906,930,0,794,826,834,842,850
,874,890,914,922,938,954,970,978,994,1002,0,802,0,810,898,0,0,0,0,0,1010
,1018,0,0,0,858,962,866,1026,0,0,0,0,0,786,946,0,0,0,986,818,882,906,930
,0,794,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,0,802,0
,810,898,0,0,0,0,0,1010,1018,0,0,0,858,962,866,1026,0,0,0,0,0,786,946,0
,0,0,986,818,882,906,930,0,794,826,834,842,850,874,890,914,922,938,954,970
,978,994,1002,0,802,0,810,898,0,1050,138,131,131,1010,1018,131,138,0,858
,962,866,1026,131,131,131,131,0,786,946,131,131,131,986,131,0,0,131,131
,131,27,27,0,131,27,0,0,0,0,0,0,27,27,27,27,0,0,0,27,27,27,0,27,0,0,27,0
,27,138,131,131,0,0,131,0,0,0,0,0,0,0,131,131,131,0,0,0,131,131,131,0,131
,0,0,131,0,131,138,131,131,0,0,131,0,0,0,0,0,0,0,131,131,131,0,0,0,131,131
,131,0,131,0,0,131,0,131,138,131,131,0,0,131,0,0,0,0,0,0,0,131,131,131,0
,0,0,131,131,131,0,131,0,0,131,0,131,138,131,131,0,0,131,0,0,0,0,0,0,0,131
,131,131,0,0,0,131,131,131,0,131,0,0,131,0,131,138,131,131,0,0,131,0,0,0
,0,0,0,0,131,131,131,0,0,0,131,131,131,0,131,0,0,131,0,131,138,131,131,0
,0,131,0,0,0,0,0,0,0,131,131,131,0,0,0,131,131,131,0,131,0,0,131,0,131,138
,131,131,0,0,131,0,0,0,0,0,0,0,131,131,131,0,0,465,131,131,131,0,131,0,0
,131,0,131,138,131,131,0,473,131,0,0,0,0,0,0,0,131,131,131,0,0,0,131,131
,131,338,131,0,0,131,0,131,19,19,0,0,19,331,331,0,0,0,0,673,19,19,19,0,0
,0,19,19,19,0,19,0,331,19,331,19,51,51,0,0,51,0,0,0,0,0,0,0,51,51,51,0,0
,0,51,51,51,643,51,0,233,51,0,51,601,67,0,0,633,0,0,0,0,0,643,0,625,641
,657,0,0,0,617,649,67,0,665,0,0,67,0,609,643}
%%END(pmActTab)
%%SET pmActRDScheckLen(1585)
%%SET pmRDScheckTyp(1)
%%SET pmActRowMapTyp(2)
%%BEGIN(pmRDScheck)
{8,64,30,48,30,30,30,30,30,30,18,18,30,30,30,30,30,30,30,30,30,30,30,30
,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,32,32,50,68,30,30,68
,52,67,30,30,30,30,69,29,1,29,29,30,30,68,71,8,30,29,29,29,29,29,29,29,29
,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,49,52,52
,7,29,29,14,60,60,29,29,29,29,72,39,73,39,39,29,29,52,47,33,29,39,39,39
,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39
,39,39,33,14,14,34,39,39,13,13,38,39,39,39,39,54,47,55,14,38,39,39,31,19
,19,39,19,19,19,19,56,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19
,35,19,19,19,31,11,11,58,19,19,74,66,74,19,19,19,19,15,36,24,6,19,19,19
,11,6,11,19,66,19,21,74,15,15,15,15,74,15,15,15,15,15,15,15,15,15,15,15
,15,15,15,15,26,15,84,15,15,15,84,15,5,84,15,15,84,15,15,15,15,15,15,16
,84,25,84,84,15,15,84,5,15,15,84,84,5,84,16,16,16,16,25,16,16,16,16,16,16
,16,16,16,16,16,16,16,16,16,84,16,25,16,16,16,84,16,59,59,16,16,84,16,16
,16,16,16,16,17,84,20,84,84,16,16,84,59,16,16,84,84,84,84,17,17,17,17,20
,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,84,17,20,17,17,17,84,17,12
,12,17,17,84,17,17,17,17,17,17,42,84,23,84,84,17,17,84,12,17,17,84,84,84
,84,42,42,42,42,23,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,84,42,23
,42,42,42,84,42,84,84,42,42,84,42,42,42,42,42,42,43,84,84,84,84,42,42,84
,84,42,42,84,84,84,84,43,43,43,43,84,43,43,43,43,43,43,43,43,43,43,43,43
,43,43,43,84,43,84,43,43,43,84,43,84,84,43,43,84,43,43,43,43,43,43,44,84
,84,84,84,43,43,84,84,43,43,84,84,84,84,44,44,44,44,84,44,44,44,44,44,44
,44,44,44,44,44,44,44,44,44,84,44,84,44,44,44,84,44,84,84,44,44,61,44,44
,44,44,44,44,84,65,84,84,84,44,44,84,84,44,44,65,65,84,65,65,65,65,65,65
,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,84,65,65,65,84,61,61,84
,65,65,84,84,84,65,65,65,65,84,84,84,61,84,65,65,84,28,28,65,28,28,28,28
,84,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,84,28,28,28,84,84
,84,84,28,28,84,84,84,28,28,28,28,84,84,84,84,84,28,28,84,40,40,28,40,40
,40,40,84,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,84,40,40,40
,84,84,84,84,40,40,84,84,84,40,40,40,40,84,84,84,84,84,40,40,84,84,84,40
,53,53,53,53,84,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,84,53,84,53
,53,53,84,84,84,84,53,53,84,53,53,53,53,53,53,84,27,84,27,27,53,53,84,84
,84,53,37,37,53,37,37,37,37,27,37,37,37,37,37,37,37,37,37,37,37,37,37,37
,37,37,37,27,37,37,37,84,84,84,84,37,37,84,84,84,37,37,37,37,84,84,84,84
,84,37,37,84,84,84,37,46,46,46,46,84,46,46,46,46,46,46,46,46,46,46,46,46
,46,46,46,84,46,84,46,46,46,84,84,84,84,46,46,84,46,46,46,46,46,46,84,84
,84,84,84,46,46,84,84,84,46,63,63,63,63,84,63,63,63,63,63,63,63,63,63,63
,63,63,63,63,63,84,63,84,63,63,84,84,63,84,84,63,63,84,84,84,63,63,63,63
,84,84,84,84,84,63,63,84,84,63,63,51,51,51,51,84,51,51,51,51,51,51,51,51
,51,51,51,51,51,51,51,84,51,84,51,51,51,84,84,84,84,51,51,84,84,84,51,51
,51,51,84,84,84,84,84,51,51,84,84,84,51,45,45,45,45,84,45,45,45,45,45,45
,45,45,45,45,45,45,45,45,45,84,45,84,45,45,45,84,84,84,84,45,45,84,84,84
,45,45,45,45,84,84,84,84,84,45,45,84,84,84,45,57,57,57,57,84,57,57,57,57
,57,57,57,57,57,57,57,57,57,57,57,84,57,84,57,57,84,84,84,84,84,57,57,84
,84,84,57,57,57,57,84,84,84,84,84,57,57,84,84,84,57,62,62,62,62,84,62,62
,62,62,62,62,62,62,62,62,62,62,62,62,62,84,62,84,62,62,84,84,84,84,84,62
,62,84,84,84,62,62,62,62,84,84,84,84,84,62,62,84,84,84,62,22,22,22,22,84
,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,84,22,84,22,22,84,84,84,84
,84,22,22,84,84,84,22,22,22,22,84,84,84,84,84,22,22,84,84,84,22,9,9,9,9
,84,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,84,9,84,9,9,84,70,83,83,83,9,9,83,70,84
,9,9,9,9,83,83,83,83,84,9,9,83,83,83,9,83,84,84,83,70,83,0,0,84,70,0,84
,84,84,84,84,84,0,0,0,0,84,84,84,0,0,0,84,0,84,84,0,84,0,75,75,75,84,84
,75,84,84,84,84,84,84,84,75,75,75,84,84,84,75,75,75,84,75,84,84,75,84,75
,76,76,76,84,84,76,84,84,84,84,84,84,84,76,76,76,84,84,84,76,76,76,84,76
,84,84,76,84,76,77,77,77,84,84,77,84,84,84,84,84,84,84,77,77,77,84,84,84
,77,77,77,84,77,84,84,77,84,77,78,78,78,84,84,78,84,84,84,84,84,84,84,78
,78,78,84,84,84,78,78,78,84,78,84,84,78,84,78,79,79,79,84,84,79,84,84,84
,84,84,84,84,79,79,79,84,84,84,79,79,79,84,79,84,84,79,84,79,80,80,80,84
,84,80,84,84,84,84,84,84,84,80,80,80,84,84,84,80,80,80,84,80,84,84,80,84
,80,81,81,81,84,84,81,84,84,84,84,84,84,84,81,81,81,84,84,10,81,81,81,84
,81,84,84,81,84,81,82,82,82,84,10,82,84,84,84,84,84,84,84,82,82,82,84,84
,84,82,82,82,10,82,84,84,82,84,82,2,2,84,84,2,10,10,84,84,84,84,2,2,2,2
,84,84,84,2,2,2,84,2,84,10,2,10,2,3,3,84,84,3,84,84,84,84,84,84,84,3,3,3
,84,84,84,3,3,3,41,3,84,41,3,84,3,4,4,84,84,4,84,84,84,84,84,41,84,4,4,4
,84,84,84,4,4,4,84,4,84,84,4,84,4,41,84,84,84,84,84,84,84,84,84,84,84,84
,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84}
%%END(pmRDScheck)
%%BEGIN(pmActRowMap)
{1164,56,1424,1452,1480,209,150,34,0,1136,1424,150,313,105,100,210,264,318
,9,156,318,221,1086,372,210,264,243,736,583,53,0,156,31,106,140,152,201
,736,150,106,633,1514,372,426,480,936,786,97,1,30,41,886,47,683,159,121
,173,986,164,259,53,527,1036,836,0,533,202,47,42,19,1142,61,72,107,161,1193
,1222,1251,1280,1309,1338,1367,1396,1136}
%%END(pmActRowMap)
%%BEGIN(pmContTab)
{{44,44}
,{1,1}
,{44,44}
,{44,44}
,{45,45}
,{64,64}
,{64,64}
,{64,64}
,{1,1}
,{60,60}
,{49,49}
,{49,49}
,{49,49}
,{49,49}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{3,3}
,{60,60}
,{3,3}
,{3,3}
,{60,60}
,{3,3}
,{3,3}
,{3,3}
,{3,3}
,{3,3}
,{60,60}
,{3,3}
,{3,3}
,{42,42}
,{11,11}
,{11,11}
,{11,11}
,{42,42}
,{11,11}
,{60,60}
,{15,15}
,{3,3}
,{60,60}
,{3,3}
,{1,1}
,{1,1}
,{1,1}
,{60,60}
,{49,49}
,{65,65}
,{3,3}
,{65,65}
,{3,3}
,{60,60}
,{49,49}
,{49,49}
,{2,2}
,{42,42}
,{3,3}
,{60,60}
,{37,37}
,{49,49}
,{49,49}
,{1,1}
,{60,60}
,{64,64}
,{2,2}
,{3,3}
,{3,3}
,{3,3}
,{3,3}
,{36,36}
,{64,64}
,{2,2}
,{36,36}
,{3,3}
,{45,45}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
}
%%END(pmContTab)
%%BEGIN(pmSeparators)
{0,0,0,0,0,0,0,0,0}
%%END(pmSeparators)
%%BEGIN(pmFiducials)
{0,0,0,0,0,0,0,0,0}
%%END(pmFiducials)
%%BEGIN(pmSkips)
{0,0,0,0,0,0,0,0,0}
%%END(pmSkips)
%%SET pmNonTerms(50)
%%SET pmNonTermTyp(1)
%%SET pmGtoTyp(2)
%%SET pmGtoRDSvectorLen(143)
%%BEGIN(pmGtoTab)
{0,0,0,762,762,457,754,754,249,249,97,137,250,746,746,554,554,521,521,90
,321,321,546,425,441,441,666,666,225,553,169,762,762,57,754,754,249,249
,258,266,513,746,746,481,554,537,386,378,321,321,433,546,122,385,666,666
,337,313,762,762,74,754,754,249,249,58,458,762,746,746,754,450,249,497,49
,241,506,746,554,474,17,666,674,426,554,546,506,153,554,466,674,546,481
,385,33,546,226,153,569,577,314,114,234,73,145,577,34,106,353,218,89,450
,65,121,361,105,177,25,610,201,322,489,217,418,458,377,113,41,265,545,281
,297,593,210,146,154,162,170,178,186,194,202,42}
%%END(pmGtoTab)
%%SET pmGtoRowMapTyp(1)
%%BEGIN(pmGtoRowMap)
{79,8,85,88,43,1,64,68,19,87,0,66,80,84,39,0,88,82,3,0,97,2,105,100,2,103
,2,1,55,64,1,123,1,125,1,126,1,29,1,56,28,1,96,98,72,78,38,1,1,1,1,10,1
,9,1,0,1,107,1,75,44,97,4,5,0,1,115,0,0,96,102,0,129,0,126,127,128,129,130
,131,132,133,134,135}
%%END(pmGtoRowMap)
%%SET pmProds(131)
%%SET pmLhsTyp(1)
%%SET pmRhszTyp(1)
%%BEGIN(pmLhs)
{73,81,110,110,93,111,111,103,103,104,104,120,120,107,107,79,79,94,94,94
,94,94,94,94,94,89,90,74,74,72,115,108,108,106,116,116,105,105,95,96,82
,82,82,121,121,121,112,112,109,118,118,119,119,117,117,101,101,99,99,83
,84,88,88,76,76,76,76,87,87,113,113,97,114,91,91,91,86,86,102,102,100,100
,92,92,98,98,98,98,98,98,98,98,80,80,80,80,80,85,85,85,85,85,85,85,85,85
,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,78,77
,75}
%%END(pmLhs)
%%BEGIN(pmRhsz)
{7,0,0,2,2,0,2,0,1,0,1,0,1,1,2,0,1,2,2,2,2,2,2,2,2,2,3,1,2,4,3,1,2,5,0,1
,6,3,1,4,0,1,2,0,2,2,1,2,4,0,2,1,2,3,4,1,2,4,4,0,0,0,2,2,5,5,5,1,1,0,2,5
,1,0,1,2,0,1,1,3,1,3,1,2,1,2,2,2,4,5,5,6,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1
,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
%%END(pmRhsz)
%%SET pmSccMax(71)
%%SET pmSccTyp(1)
%%SET pmICostTyp(1)
%%SET pmDCostTyp(1)
%%BEGIN(pmVocTab)
{{1,255,255,"EndOfText",""}
,{2,1,1,"'='",""}
,{3,1,1,"';'",""}
,{4,1,1,"':'",""}
,{5,1,1,"'/'",""}
,{6,1,1,"'!'",""}
,{7,1,1,"'*'",""}
,{8,1,1,"'+'",""}
,{9,1,1,"'?'",""}
,{10,1,1,"'{'",""}
,{11,1,1,"'}'",""}
,{12,1,1,"'-'",""}
,{13,1,1,"'.'",""}
,{14,1,1,"'('",""}
,{15,1,1,"')'",""}
,{16,1,1,"'C'",""}
,{17,1,1,"'K'",""}
,{18,1,1,"'M'",""}
,{19,1,1,"'NO'",""}
,{20,1,1,"'`%`%'",""}
,{21,1,1,"'ADA'",""}
,{22,1,1,"'COL'",""}
,{23,1,1,"'DES'",""}
,{24,1,1,"'DFA'",""}
,{25,1,1,"'ERR'",""}
,{26,1,1,"'GCS'",""}
,{27,1,1,"'LES'",""}
,{28,1,1,"'MAP'",""}
,{29,1,1,"'NFA'",""}
,{30,1,1,"'POS'",""}
,{31,1,1,"'RDS'",""}
,{32,1,1,"'ROW'",""}
,{33,1,1,"'SCR'",""}
,{34,1,1,"'SET'",""}
,{35,1,1,"'TOK'",""}
,{36,1,1,"Class",""}
,{37,1,1,"'AUTO'",""}
,{38,1,1,"'`%`%DO'",""}
,{39,1,1,"'BYTE'",""}
,{40,1,1,"'LIST'",""}
,{41,1,1,"String",""}
,{42,1,1,"Number",""}
,{43,1,1,"'`%`%END'",""}
,{44,1,1,"'`%`%SET'",""}
,{45,1,1,"'`%`%MAP'",""}
,{46,1,1,"'TOKEN'",""}
,{47,1,1,"'TRACE'",""}
,{48,1,1,"'`%`%CODE'",""}
,{49,1,1,"'`%`%RULE'",""}
,{50,1,1,"'`%`%SKIP'",""}
,{51,1,1,"'ESCAPE'",""}
,{52,1,1,"'ROWCOL'",""}
,{53,1,1,"'EXCLUDE'",""}
,{54,1,1,"'VERBOSE'",""}
,{55,1,1,"SKIPHEADER",""}
,{56,1,1,"'`%`%EXPORT'",""}
,{57,1,1,"'`%`%READER'",""}
,{58,1,1,"'`%`%ACTION'",""}
,{59,1,1,"'_UNKNOWN'",""}
,{60,1,1,"Identifier",""}
,{61,1,1,"'POSITION'",""}
,{62,1,1,"'`%`%CONTEXT'",""}
,{63,1,1,"'`%`%PREHOOK'",""}
,{64,1,1,"'`%`%SCANNER'",""}
,{65,1,1,"'SCREENING'",""}
,{66,1,1,"'`%`%POSTHOOK'",""}
,{67,1,1,"'_ENDOFTEXT'",""}
,{68,1,1,"'`%`%SCREENING'",""}
,{69,1,1,"'`%`%DEFINITION'",""}
,{70,1,1,"'`%`%VOCABULARY'",""}
,{71,1,1,"'`%`%DECLARATION'",""}
}
%%END(pmVocTab)
%%SET pmSem(On)
%%BEGIN(pmSemantics)
    switch (rule) {
          case 2: { /* __genSym#0 =; */
{
  vocRead(optVocabulary);
}	break;}
    case 27: { /* <map section> = '`%`%MAP' <maps> <end opt>; */
{
  mapUsed=1;
}	break;}
    case 30: { /* <map> = <class> '=' <class> ';'; */
{
  mapPut(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name,%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].name);
}	break;}
    case 34: { /* <definition rule> = <identifier> '=' <selection rule opt> <action opt> ';'; */
{
  register Definition definition;

  definition=definitionGet(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name);
  if(definition==NULL) definition=definitionPut(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name);
  if(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].ast)
    if(definition->ast)
      smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp,233,sevERR,"");
    else
      definition->ast=%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].ast;
  if(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].action)
    if(definition->action)
      smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp,246,sevERR,"");
    else
      definition->action=%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].action;
}	break;}
    case 36: { /* <selection rule opt> = <selection rule>; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast;
}	break;}
    case 35: { /* <selection rule opt> =; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=NULL;
}	break;}
    case 37: { /* <scanner section> = '`%`%SCANNER' <scanner name> <auto opt> <vocabulary section opt> <screening section opt> <token sections>; */
{
  if(grmScanner) {
    vocCheck(grmScanner);
    tokenCheck(grmScanner);
  }
}	break;}
    case 38: { /* <scanner section> = <scanner copy> <screening section opt> <token sections>; */
{
  if(grmScanner) {
    vocCheck(grmScanner);
    tokenCheck(grmScanner);
  }
}	break;}
    case 39: { /* <scanner name> = <identifier>; */
{
  grmScanner=scannerPut(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name);
}	break;}
    case 40: { /* <scanner copy> = '`%`%SCANNER' <scanner name> ':' <identifier>; */
{
  register Scanner scanner;

  if(grmScanner) {
    scanner=scannerGet(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].name);
    if(scanner) {
      vocCopyAll(grmScanner,scanner->voc);
      tokenCopyAll(grmScanner,scanner->token);
      grmScanner->vocLock=1;
    }
    else
      smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].srcp,234,sevERR,"");
  }
}	break;}
    case 42: { /* <auto opt> = 'AUTO'; */
{
  if(grmScanner) grmScanner->vocAuto=1;
}	break;}
    case 43: { /* <auto opt> = 'NO' 'AUTO'; */
{
  if(grmScanner) grmScanner->vocAuto=0;
}	break;}
    case 41: { /* <auto opt> =; */
{
  if(grmScanner) grmScanner->vocAuto=1;
}	break;}
    case 46: { /* <vocabulary section opt> = '`%`%VOCABULARY' <token definitions>; */
{
  if(grmScanner) grmScanner->vocLock=1;
}	break;}
    case 45: { /* <vocabulary section opt> = '`%`%VOCABULARY' <identifier>; */
{
  register Scanner scanner;

  if(grmScanner) {
    scanner=scannerGet(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].name);
    if(scanner) {
      vocCopyAll(grmScanner,scanner->voc);
      grmScanner->vocLock=1;
    }
    else
      smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].srcp,234,sevERR,"");
  }
}	break;}
    case 49: { /* <token definition> = <token name> '=' <number> ';'; */
{
  if(grmScanner) {
    vocPut(grmScanner, &%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name, &%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].srcp, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].inumber);
  }
}	break;}
    case 55: { /* <screening definition> = <token name> 'NO' 'SCREENING' ';'; */
{
  register Voc voc;

  voc=vocGet(grmScanner,%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name);
  if(voc)
    voc->screening=0;
  else if((voc=vocPut(grmScanner, &%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name, NULL, -1))==NULL)
    smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp,213,sevERR,"");
  else
    voc->screening=0;
}	break;}
    case 54: { /* <screening definition> = <token name> 'SCREENING' ';'; */
{
  register Voc voc;

  voc=vocGet(grmScanner,%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name);
  if(voc)
    voc->screening=optScreen>0 ? 1 : 0;
  else if((voc=vocPut(grmScanner, &%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name, NULL, -1))==NULL)
    smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp,213,sevERR,"");
  else
    voc->screening=optScreen>0 ? 1 : 0;
}	break;}
    case 60: { /* __genSym#1 =; */
 grmTokenType=tokenRULE; 	break;}
    case 61: { /* __genSym#2 =; */
 grmTokenType=tokenSKIP; 	break;}
    case 65: { /* <token> = <token name> '=' <lookahead rule> <action opt2> ';'; */
{
  if(grmScanner) {
    register Token token;

    if(token=tokenPut(grmScanner,grmTokenType,&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name)) {
      token->a.ast=%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].ast;
      token->action=%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].action;
      token->sequence=astToName(token->a.ast);
    }
  }
}	break;}
    case 66: { /* <token> = <token name> '=' '_ENDOFTEXT' <action opt2> ';'; */
{
  if(grmScanner) {
    register Token token;

    if(token=tokenPut(grmScanner,grmTokenType,&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name)) {
      token->type|=tokenEOT;
      token->a.ast=NULL;
      token->action=%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].action;
    }
  }
}	break;}
    case 67: { /* <token> = <token name> '=' '_UNKNOWN' <action opt2> ';'; */
{
  if(grmScanner) {
    register Token token;

    if(token=tokenPut(grmScanner,grmTokenType,&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name)) {
      token->type|=tokenUNKNOWN;
      token->a.ast=NULL;
      token->action=%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].action;
    }
  }
}	break;}
    case 64: { /* <token> = <token name> ';'; */
{
  if(tokenRemove(grmScanner,grmTokenType,%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name)<0)
    smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp,211,sevERR,"");
}	break;}
    case 72: { /* <screen token> = <screen token name> '=' <identifier> <action opt> ';'; */
{
  if(grmScanner) {
    register Token token;
    register Voc voc;

    if(voc=vocGet(grmScanner,%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].name)) {
      if(token=tokenPut(grmScanner,tokenSCREEN,&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name)) {
    token->a.screen=voc;
    token->action=%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].action;
      }
    }
    else
      smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].srcp,236,sevERR,"");
  }
}	break;}
    case 75: { /* <action opt2> = '`%`%'; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].action=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].action;
}	break;}
    case 76: { /* <action opt2> = '`%`%DO' <identifier>; */
{
  register Definition definition;

  definition=definitionGet(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].name);
  if(definition==NULL || definition->action==NULL)
    smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].srcp,245,sevERR,"");
  else
    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].action=definition->action;
}	break;}
    case 74: { /* <action opt2> =; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].action=NULL;
}	break;}
    case 78: { /* <action opt> = '`%`%'; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].action=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].action;
}	break;}
    case 77: { /* <action opt> =; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].action=NULL;
}	break;}
    case 80: { /* <lookahead rule> = <selection rule> '/' <selection rule>; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=astLookahead(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].ast);
}	break;}
    case 82: { /* <selection rule> = <selection rule> '!' <concat rule>; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=astSelect(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].ast);
}	break;}
    case 84: { /* <concat rule> = <concat rule> <closure rule>; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=astConcat(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].ast);
}	break;}
    case 86: { /* <closure rule> = <operand> '*'; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=astClosure(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast,0,-1);
}	break;}
    case 87: { /* <closure rule> = <operand> '+'; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=astClosure(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast,1,-1);
}	break;}
    case 88: { /* <closure rule> = <operand> '?'; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=astClosure(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast,0,1);
}	break;}
    case 89: { /* <closure rule> = <operand> '{' <number> '}'; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=astClosure(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast,%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].inumber,%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].inumber);
}	break;}
    case 90: { /* <closure rule> = <operand> '{' '-' <number> '}'; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=astClosure(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast,0,%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].inumber);
}	break;}
    case 91: { /* <closure rule> = <operand> '{' <number> '-' '}'; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=astClosure(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast,%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].inumber,-1);
}	break;}
    case 92: { /* <closure rule> = <operand> '{' <number> '-' <number> '}'; */
{
  if(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].inumber>%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].inumber)
    smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].srcp,237,sevERR,"");
  else
    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=astClosure(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast,%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].inumber,%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].inumber);
}	break;}
    case 93: { /* <operand> = <identifier>; */
{
  register Definition definition;

  definition=definitionGet(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name);
  if(definition==NULL || definition->ast==NULL)
    smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp,239,sevERR,"");
  else
    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=definition->ast;
}	break;}
    case 94: { /* <operand> = <string>; */
{
  register AST ast;

  if(ast=astString(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name))
    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=ast;
  else
    smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp,220,sevERR,"");
}	break;}
    case 95: { /* <operand> = <class>; */
{
  register AST ast;

  if(ast=astClass(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name))
    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=ast;
  else
    smkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp,238,sevERR,"");
}	break;}
    case 96: { /* <operand> = '.'; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=astCut();
}	break;}
    case 97: { /* <operand> = '(' <selection rule> ')'; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ast=%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].ast;
}	break;}
    case 98: { /* <identifier> = Identifier; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 99: { /* <identifier> = 'ADA'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 100: { /* <identifier> = 'AUTO'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 101: { /* <identifier> = 'BYTE'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 102: { /* <identifier> = 'C'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 103: { /* <identifier> = 'COL'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 104: { /* <identifier> = 'DES'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 105: { /* <identifier> = 'DFA'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 106: { /* <identifier> = 'ERR'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 107: { /* <identifier> = 'ESCAPE'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 108: { /* <identifier> = 'EXCLUDE'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 109: { /* <identifier> = 'GCS'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 110: { /* <identifier> = 'K'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 111: { /* <identifier> = 'LES'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 112: { /* <identifier> = 'LIST'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 113: { /* <identifier> = 'M'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 114: { /* <identifier> = 'MAP'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 115: { /* <identifier> = 'NFA'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 116: { /* <identifier> = 'NO'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 117: { /* <identifier> = 'POS'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 118: { /* <identifier> = 'POSITION'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 119: { /* <identifier> = 'RDS'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 120: { /* <identifier> = 'ROWCOL'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 121: { /* <identifier> = 'ROW'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 122: { /* <identifier> = 'SCR'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 123: { /* <identifier> = 'SCREENING'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 124: { /* <identifier> = 'SET'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 125: { /* <identifier> = 'TOK'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 126: { /* <identifier> = 'TOKEN'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 127: { /* <identifier> = 'TRACE'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 128: { /* <identifier> = 'VERBOSE'; */
{ %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp; %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name; }	break;}
    case 129: { /* <string> = String; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp;
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name;
}	break;}
    case 130: { /* <number> = Number; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp;
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].inumber=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].inumber;
}	break;}
    case 131: { /* <class> = Class; */
{
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp;
  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].name=%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].name;
}	break;}
%%END(pmSemantics)
%%SET vocFileName ("smk.voc")
%%BEGIN (pmVoc)
   0    0 Unknown                  main
   1    1 EndOfText                main
   2    2 '='                      main
   3    3 ';'                      main
   4    4 ':'                      main
   5    5 '/'                      main
   6    6 '!'                      main
   7    7 '*'                      main
   8    8 '+'                      main
   9    9 '?'                      main
  10   10 '{'                      main
  11   11 '}'                      main
  12   12 '-'                      main
  13   13 '.'                      main
  14   14 '('                      main
  15   15 ')'                      main
  16   16 'C'                      main
  17   17 'K'                      main
  18   18 'M'                      main
  19   19 'NO'                     main
  20   20 '`%`%'                     main
  21   21 'ADA'                    main
  22   22 'COL'                    main
  23   23 'DES'                    main
  24   24 'DFA'                    main
  25   25 'ERR'                    main
  26   26 'GCS'                    main
  27   27 'LES'                    main
  28   28 'MAP'                    main
  29   29 'NFA'                    main
  30   30 'POS'                    main
  31   31 'RDS'                    main
  32   32 'ROW'                    main
  33   33 'SCR'                    main
  34   34 'SET'                    main
  35   35 'TOK'                    main
  36   36 Class                    main
  37   37 'AUTO'                   main
  38   38 '`%`%DO'                   main
  39   39 'BYTE'                   main
  40   40 'LIST'                   main
  41   41 String                   main
  42   42 Number                   main
  43   43 '`%`%END'                  main
  44   44 '`%`%SET'                  main
  45   45 '`%`%MAP'                  main
  46   46 'TOKEN'                  main
  47   47 'TRACE'                  main
  48   48 '`%`%CODE'                 main
  49   49 '`%`%RULE'                 main
  50   50 '`%`%SKIP'                 main
  51   51 'ESCAPE'                 main
  52   52 'ROWCOL'                 main
  53   53 'EXCLUDE'                main
  54   54 'VERBOSE'                main
  55   55 SKIPHEADER               main
  56   56 '`%`%EXPORT'               main
  57   57 '`%`%READER'               main
  58   58 '`%`%ACTION'               main
  59   59 '_UNKNOWN'               main
  60   60 Identifier               main
  61   61 'POSITION'               main
  62   62 '`%`%CONTEXT'              main
  63   63 '`%`%PREHOOK'              main
  64   64 '`%`%SCANNER'              main
  65   65 'SCREENING'              main
  66   66 '`%`%POSTHOOK'             main
  67   67 '_ENDOFTEXT'             main
  68   68 '`%`%SCREENING'            main
  69   69 '`%`%DEFINITION'           main
  70   70 '`%`%VOCABULARY'           main
  71   71 '`%`%DECLARATION'          main
%%END (pmVoc)
%%PROCESS("%%(pmkLibrary)/Parse.imp")
%%PROCESS("%%(pmkLibrary)/Err.imp")

==> smk.voc <==
   0    0 Unknown                  main
   1    1 EndOfText                main
   2    2 '='                      main
   3    3 ';'                      main
   4    4 ':'                      main
   5    5 '/'                      main
   6    6 '!'                      main
   7    7 '*'                      main
   8    8 '+'                      main
   9    9 '?'                      main
  10   10 '{'                      main
  11   11 '}'                      main
  12   12 '-'                      main
  13   13 '.'                      main
  14   14 '('                      main
  15   15 ')'                      main
  16   16 'C'                      main
  17   17 'K'                      main
  18   18 'M'                      main
  19   19 'NO'                     main
  20   20 '%%'                     main
  21   21 'ADA'                    main
  22   22 'COL'                    main
  23   23 'DES'                    main
  24   24 'DFA'                    main
  25   25 'ERR'                    main
  26   26 'GCS'                    main
  27   27 'LES'                    main
  28   28 'MAP'                    main
  29   29 'NFA'                    main
  30   30 'POS'                    main
  31   31 'RDS'                    main
  32   32 'ROW'                    main
  33   33 'SCR'                    main
  34   34 'SET'                    main
  35   35 'TOK'                    main
  36   36 Class                    main
  37   37 'AUTO'                   main
  38   38 '%%DO'                   main
  39   39 'BYTE'                   main
  40   40 'LIST'                   main
  41   41 String                   main
  42   42 Number                   main
  43   43 '%%END'                  main
  44   44 '%%SET'                  main
  45   45 '%%MAP'                  main
  46   46 'TOKEN'                  main
  47   47 'TRACE'                  main
  48   48 '%%CODE'                 main
  49   49 '%%RULE'                 main
  50   50 '%%SKIP'                 main
  51   51 'ESCAPE'                 main
  52   52 'ROWCOL'                 main
  53   53 'EXCLUDE'                main
  54   54 'VERBOSE'                main
  55   55 SKIPHEADER               main
  56   56 '%%EXPORT'               main
  57   57 '%%READER'               main
  58   58 '%%ACTION'               main
  59   59 '_UNKNOWN'               main
  60   60 Identifier               main
  61   61 'POSITION'               main
  62   62 '%%CONTEXT'              main
  63   63 '%%PREHOOK'              main
  64   64 '%%SCANNER'              main
  65   65 'SCREENING'              main
  66   66 '%%POSTHOOK'             main
  67   67 '_ENDOFTEXT'             main
  68   68 '%%SCREENING'            main
  69   69 '%%DEFINITION'           main
  70   70 '%%VOCABULARY'           main
  71   71 '%%DECLARATION'          main

==> smkCommon.h <==
#ifndef _smkCommon_H_
#define _smkCommon_H_
/* smkCommon.h

   Common definitions for smk

   This file is generated from information in 'smk.tmk'

*/

/* The import section (%%IMPORT) */

#include "tmkCommon.h"
#include "name.h"
#include "action.h"

/* The source position type (%%SRCP) */

      /* ... must be imported! */


/* The token type (%%TOKEN) */

typedef struct SmkToken {
    int code;
    TmkSrcp srcp;
    Action action;
    Name name;
    double fnumber;
    int inumber;
} SmkToken;

#endif



==> smkErr.c <==
/*----------------------------------------------------------------------*\

  smkErr.c

  Parser error handler 

\*----------------------------------------------------------------------*/

/* %%IMPORT */

#include <stdio.h>
#include "smk_i.h"
#include "smkScan.h"
#include "smkList.h"
#include "ast.h"
#include "definition.h"
#include "name.h"
#include "scanner.h"
#include "token.h"
#include "voc.h"
#include "set.h"
#include "map.h"
#include "pack.h"
#include "action.h"
extern smkContext lexContext;
/* END %%IMPORT */

#include "smkList.h"
#include "smkCommon.h"

#define MaxTokens 5


static char insStr[101] = "";	/* Inserted symbol strings */
static int insToks = 0;

static char delStr[201] = "";	/* Deleted symbol strings */
static int delToks = 0;

/*-----------------------------------------------------------------------------
 * smkRPoi - Recovery point, output a message indicating the position.
 *-----------------------------------------------------------------------------
 */
void smkRPoi(token)
    SmkToken *token;		/* IN the restart symbol */
{
    if (delToks > MaxTokens) {
       /* Output a recovery point error message
       */
       smkLog(&(token->srcp), 100, sevINF, "");
    }/*if*/

    /* Clear both token print strings */
    insStr[0] = '\0';
    delStr[0] = '\0';

    insToks = 0;
    delToks = 0;
}/*smkRPoi()*/


/*-----------------------------------------------------------------------------
 * smkISym - A symbol is to be inserted, collect it for later output, and
 *	    construct the requested token for use by the parser.
 *-----------------------------------------------------------------------------
 */
void smkISym(code, symString, printString, token)
     int code;	/* IN terminal code number */
    char *symString;			/* IN terminal string */
    char *printString;			/* IN the terminals print symbol */
    SmkToken *token;		/* OUT the created scanner symbol */
{
    char *selectedString;

    if (insToks < MaxTokens) {
	/* Concatenate the token string
	 */
	if (insToks > 0) strcat(insStr, " ");
	if (code == 0) strcat(insStr, "<unknown token>");
	else if (code == 1) strcat(insStr, "<end of file>");
        else {
            if (*printString != '\0') selectedString = printString;
            else selectedString = symString;
            if (selectedString[0] == '\'') {
                strcat(insStr, &selectedString[1]);
                insStr[strlen(insStr)-1] = '\0';
            } else
                strcat(insStr, selectedString);
        }
    } else if (insToks == MaxTokens) {
	strcat(insStr, " ...");
    }/*if*/
    insToks++;
#define sym token
#define sstr symString
#define pstr printString

    /* Make the requested token
     */
    sym->code = code;
    sym->name=nameSearch("<PARSE ERROR>");
    sym->srcp.file=1;
#undef sym
#undef sstr
#undef pstr
}/*smkISym()*/


/*-----------------------------------------------------------------------------
 * smkDSym - The indicated symbol is deleted by the parser, collect its string
 *	    for later output.
 *-----------------------------------------------------------------------------
 */
void smkDSym(token, symString, printString)
    SmkToken *token;		/* IN terminal */
    char *symString;			/* IN terminal string */
    char *printString;			/* IN terminals print string */
{
    char *selectedString;

    if (delToks < MaxTokens) {
	/* Concatenate the symbol strings */
	if (delToks > 0) strcat(delStr, " ");
	if (token->code == 0) strcat(delStr, "<unknown token>");
	else if (token->code == 1) strcat(delStr, "<end of file>");
	else {
#ifdef DELETEIDENTIFIERASINPUTTED
            if (token->code == 2) selectedString = token->chars;
            else
#endif
            if (*printString != '\0') selectedString = printString;
            else selectedString = symString;
            if (selectedString[0] == '\'') {
                strcat(delStr, &selectedString[1]);
                delStr[strlen(delStr)-1] = '\0';
            } else
                strcat(delStr, selectedString);
        }
    } else if (delToks == MaxTokens) {
	strcat(delStr, " ...");
    }/*if*/
    delToks++;
}/*smkDSym()*/


/*-----------------------------------------------------------------------------
 * smkMess - An error message should be output, symbol indicates point of error.
 *-----------------------------------------------------------------------------
 * Method:	1 = Symbol(s) insertion	       Message:	% inserted
 *		2 = Symbol(s) deletion			% deleted
 *		3 = Symbol(s) replacement		% replaced by %
 *	        4 = Stack backup			Malformed phrase
 *		5 = Halted				%. System halted
 *
 * Code:	1 = Unknown token (error token from scanner)
 *		2 = Syntax error
 *		3 = Parse stack overflow
 *		4 = Table error
 *
 * Severity:	1 = Warning
 *		2 = Error (repairable)
 *		3 = Fatal error
 *		4 = System error & Limit error
 *-----------------------------------------------------------------------------
 */
void smkMess(sym, method, code, severity)
    SmkToken *sym;	/* IN error token */
    int method;			/* IN recovery method */
    int code;			/* IN error classification */
    int severity;		/* IN error severity code */
{
    smkSev sev;

    switch (severity) {
    case 1: sev = sevWAR; break;
    case 2: sev = sevERR; break;
    case 3: sev = sevFAT; break;
    case 4: sev = sevSYS; break;
    default: sev = sevSYS; break;
    }

    switch (code) {

    case 1:
	/* Unknown symbol, deleted */
	smkLog(&(sym->srcp), 102, sev, "Unknown Token");
	break;

    case 2:
	/* Syntax Error */
	switch (method) {

	case 1:
	    /* Insert */
	    smkLog(&(sym->srcp), 101, sev, insStr);
	    break;

	case 2:
	    /* Delete */
	    smkLog(&(sym->srcp), 102, sev, delStr);
	    break;

	case 3:
	    /* Replace */
	    delStr[strlen(delStr)+1] = '\0';
	    delStr[strlen(delStr)] = smkSEPARATOR; /* Separator */
	    strcat(delStr, insStr);
	    smkLog(&(sym->srcp), 103, sev, delStr);
	    break;

	case 4:
	    /* Stack backed up */
	    smkLog(&(sym->srcp), 104, sev, "");
	    break;

	case 5:
	    /* Syntax error, system halted */
	    smkLog(&(sym->srcp), 105, sev, "");
	    break;
	}
	break;

    case 3:
	/* Parse stack overflow */
	smkLog(&(sym->srcp), 106, sev, "");
	break;

    case 4:
	/* Parse table error */
	smkLog(&(sym->srcp), 107, sev, "");
	break;
    }

    if (method == 5) {
	/* System halted, output informational message */
	smkLog(&(sym->srcp), 108, sevINF, "");
    }
}/*smkMess()*/

==> smkPaSema.c <==
/*----------------------------------------------------------------------*\

    smkPaSema.c

    ParserMaker generated semantic actions

\*----------------------------------------------------------------------*/

/* %%IMPORT */

#include <stdio.h>
#include "smk_i.h"
#include "smkScan.h"
#include "smkList.h"
#include "ast.h"
#include "definition.h"
#include "name.h"
#include "scanner.h"
#include "token.h"
#include "voc.h"
#include "set.h"
#include "map.h"
#include "pack.h"
#include "action.h"
extern smkContext lexContext;
/* END %%IMPORT */

/* System dependencies
 * -------------------
 */

/* These datatypes should be defined to be unsigned integers of length 1, 2
 * and 4 bytes respectively.
 */
typedef unsigned char UByte1;
typedef unsigned short UByte2;
typedef unsigned int UByte4;

/* Token and Srcp definition */
#include "smkCommon.h"

/* Attribute stacks *\
\* ---------------- */
/* %%ATTRIBUTES */
/* The semantic attributes for grammar symbols */
typedef struct smkGrammar {
    Action action;
    AST ast;
    Name name;
    double fnumber;
    int inumber;
    TmkSrcp srcp;
} smkGrammar;

/* END %%ATTRIBUTES */

extern short smkStkP;
extern SmkToken smkSySt[];
extern smkGrammar smkSeSt[];

/* %%DECLARATIONS - User data and routines */

extern Scanner grmScanner;		/* Current scanner */
extern TokenType grmTokenType;		/* Current token type */

/* END %%DECLARATIONS */


/*----------------------------------------------------------------------------
 * smkPaSema - The semantic actions
 *----------------------------------------------------------------------------
 */
void smkPaSema(rule)
int rule;			/* IN production number */
{
    switch (rule) {
          case 2: { /* __genSym#0 =; */
{
  vocRead(optVocabulary);
}	break;}
    case 27: { /* <map section> = '%%MAP' <maps> <end opt>; */
{
  mapUsed=1;
}	break;}
    case 30: { /* <map> = <class> '=' <class> ';'; */
{
  mapPut(smkSeSt[smkStkP+1].name,smkSeSt[smkStkP+3].name);
}	break;}
    case 34: { /* <definition rule> = <identifier> '=' <selection rule opt> <action opt> ';'; */
{
  register Definition definition;

  definition=definitionGet(smkSeSt[smkStkP+1].name);
  if(definition==NULL) definition=definitionPut(smkSeSt[smkStkP+1].name);
  if(smkSeSt[smkStkP+3].ast)
    if(definition->ast)
      smkLog(&smkSeSt[smkStkP+1].srcp,233,sevERR,"");
    else
      definition->ast=smkSeSt[smkStkP+3].ast;
  if(smkSeSt[smkStkP+4].action)
    if(definition->action)
      smkLog(&smkSeSt[smkStkP+1].srcp,246,sevERR,"");
    else
      definition->action=smkSeSt[smkStkP+4].action;
}	break;}
    case 36: { /* <selection rule opt> = <selection rule>; */
{
  smkSeSt[smkStkP+1].ast=smkSeSt[smkStkP+1].ast;
}	break;}
    case 35: { /* <selection rule opt> =; */
{
  smkSeSt[smkStkP+1].ast=NULL;
}	break;}
    case 37: { /* <scanner section> = '%%SCANNER' <scanner name> <auto opt> <vocabulary section opt> <screening section opt> <token sections>; */
{
  if(grmScanner) {
    vocCheck(grmScanner);
    tokenCheck(grmScanner);
  }
}	break;}
    case 38: { /* <scanner section> = <scanner copy> <screening section opt> <token sections>; */
{
  if(grmScanner) {
    vocCheck(grmScanner);
    tokenCheck(grmScanner);
  }
}	break;}
    case 39: { /* <scanner name> = <identifier>; */
{
  grmScanner=scannerPut(&smkSeSt[smkStkP+1].srcp, smkSeSt[smkStkP+1].name);
}	break;}
    case 40: { /* <scanner copy> = '%%SCANNER' <scanner name> ':' <identifier>; */
{
  register Scanner scanner;

  if(grmScanner) {
    scanner=scannerGet(smkSeSt[smkStkP+4].name);
    if(scanner) {
      vocCopyAll(grmScanner,scanner->voc);
      tokenCopyAll(grmScanner,scanner->token);
      grmScanner->vocLock=1;
    }
    else
      smkLog(&smkSeSt[smkStkP+4].srcp,234,sevERR,"");
  }
}	break;}
    case 42: { /* <auto opt> = 'AUTO'; */
{
  if(grmScanner) grmScanner->vocAuto=1;
}	break;}
    case 43: { /* <auto opt> = 'NO' 'AUTO'; */
{
  if(grmScanner) grmScanner->vocAuto=0;
}	break;}
    case 41: { /* <auto opt> =; */
{
  if(grmScanner) grmScanner->vocAuto=1;
}	break;}
    case 46: { /* <vocabulary section opt> = '%%VOCABULARY' <token definitions>; */
{
  if(grmScanner) grmScanner->vocLock=1;
}	break;}
    case 45: { /* <vocabulary section opt> = '%%VOCABULARY' <identifier>; */
{
  register Scanner scanner;

  if(grmScanner) {
    scanner=scannerGet(smkSeSt[smkStkP+2].name);
    if(scanner) {
      vocCopyAll(grmScanner,scanner->voc);
      grmScanner->vocLock=1;
    }
    else
      smkLog(&smkSeSt[smkStkP+2].srcp,234,sevERR,"");
  }
}	break;}
    case 49: { /* <token definition> = <token name> '=' <number> ';'; */
{
  if(grmScanner) {
    vocPut(grmScanner, &smkSeSt[smkStkP+1].srcp, smkSeSt[smkStkP+1].name, &smkSeSt[smkStkP+3].srcp, smkSeSt[smkStkP+3].inumber);
  }
}	break;}
    case 55: { /* <screening definition> = <token name> 'NO' 'SCREENING' ';'; */
{
  register Voc voc;

  voc=vocGet(grmScanner,smkSeSt[smkStkP+1].name);
  if(voc)
    voc->screening=0;
  else if((voc=vocPut(grmScanner, &smkSeSt[smkStkP+1].srcp, smkSeSt[smkStkP+1].name, NULL, -1))==NULL)
    smkLog(&smkSeSt[smkStkP+1].srcp,213,sevERR,"");
  else
    voc->screening=0;
}	break;}
    case 54: { /* <screening definition> = <token name> 'SCREENING' ';'; */
{
  register Voc voc;

  voc=vocGet(grmScanner,smkSeSt[smkStkP+1].name);
  if(voc)
    voc->screening=optScreen>0 ? 1 : 0;
  else if((voc=vocPut(grmScanner, &smkSeSt[smkStkP+1].srcp, smkSeSt[smkStkP+1].name, NULL, -1))==NULL)
    smkLog(&smkSeSt[smkStkP+1].srcp,213,sevERR,"");
  else
    voc->screening=optScreen>0 ? 1 : 0;
}	break;}
    case 60: { /* __genSym#1 =; */
 grmTokenType=tokenRULE; 	break;}
    case 61: { /* __genSym#2 =; */
 grmTokenType=tokenSKIP; 	break;}
    case 65: { /* <token> = <token name> '=' <lookahead rule> <action opt2> ';'; */
{
  if(grmScanner) {
    register Token token;

    if(token=tokenPut(grmScanner,grmTokenType,&smkSeSt[smkStkP+1].srcp, smkSeSt[smkStkP+1].name)) {
      token->a.ast=smkSeSt[smkStkP+3].ast;
      token->action=smkSeSt[smkStkP+4].action;
      token->sequence=astToName(token->a.ast);
    }
  }
}	break;}
    case 66: { /* <token> = <token name> '=' '_ENDOFTEXT' <action opt2> ';'; */
{
  if(grmScanner) {
    register Token token;

    if(token=tokenPut(grmScanner,grmTokenType,&smkSeSt[smkStkP+1].srcp, smkSeSt[smkStkP+1].name)) {
      token->type|=tokenEOT;
      token->a.ast=NULL;
      token->action=smkSeSt[smkStkP+4].action;
    }
  }
}	break;}
    case 67: { /* <token> = <token name> '=' '_UNKNOWN' <action opt2> ';'; */
{
  if(grmScanner) {
    register Token token;

    if(token=tokenPut(grmScanner,grmTokenType,&smkSeSt[smkStkP+1].srcp, smkSeSt[smkStkP+1].name)) {
      token->type|=tokenUNKNOWN;
      token->a.ast=NULL;
      token->action=smkSeSt[smkStkP+4].action;
    }
  }
}	break;}
    case 64: { /* <token> = <token name> ';'; */
{
  if(tokenRemove(grmScanner,grmTokenType,smkSeSt[smkStkP+1].name)<0)
    smkLog(&smkSeSt[smkStkP+1].srcp,211,sevERR,"");
}	break;}
    case 72: { /* <screen token> = <screen token name> '=' <identifier> <action opt> ';'; */
{
  if(grmScanner) {
    register Token token;
    register Voc voc;

    if(voc=vocGet(grmScanner,smkSeSt[smkStkP+3].name)) {
      if(token=tokenPut(grmScanner,tokenSCREEN,&smkSeSt[smkStkP+1].srcp, smkSeSt[smkStkP+1].name)) {
    token->a.screen=voc;
    token->action=smkSeSt[smkStkP+4].action;
      }
    }
    else
      smkLog(&smkSeSt[smkStkP+3].srcp,236,sevERR,"");
  }
}	break;}
    case 75: { /* <action opt2> = '%%'; */
{
  smkSeSt[smkStkP+1].action=smkSySt[smkStkP+1].action;
}	break;}
    case 76: { /* <action opt2> = '%%DO' <identifier>; */
{
  register Definition definition;

  definition=definitionGet(smkSeSt[smkStkP+2].name);
  if(definition==NULL || definition->action==NULL)
    smkLog(&smkSeSt[smkStkP+2].srcp,245,sevERR,"");
  else
    smkSeSt[smkStkP+1].action=definition->action;
}	break;}
    case 74: { /* <action opt2> =; */
{
  smkSeSt[smkStkP+1].action=NULL;
}	break;}
    case 78: { /* <action opt> = '%%'; */
{
  smkSeSt[smkStkP+1].action=smkSySt[smkStkP+1].action;
}	break;}
    case 77: { /* <action opt> =; */
{
  smkSeSt[smkStkP+1].action=NULL;
}	break;}
    case 80: { /* <lookahead rule> = <selection rule> '/' <selection rule>; */
{
  smkSeSt[smkStkP+1].ast=astLookahead(smkSeSt[smkStkP+1].ast, smkSeSt[smkStkP+3].ast);
}	break;}
    case 82: { /* <selection rule> = <selection rule> '!' <concat rule>; */
{
  smkSeSt[smkStkP+1].ast=astSelect(smkSeSt[smkStkP+1].ast, smkSeSt[smkStkP+3].ast);
}	break;}
    case 84: { /* <concat rule> = <concat rule> <closure rule>; */
{
  smkSeSt[smkStkP+1].ast=astConcat(smkSeSt[smkStkP+1].ast, smkSeSt[smkStkP+2].ast);
}	break;}
    case 86: { /* <closure rule> = <operand> '*'; */
{
  smkSeSt[smkStkP+1].ast=astClosure(smkSeSt[smkStkP+1].ast,0,-1);
}	break;}
    case 87: { /* <closure rule> = <operand> '+'; */
{
  smkSeSt[smkStkP+1].ast=astClosure(smkSeSt[smkStkP+1].ast,1,-1);
}	break;}
    case 88: { /* <closure rule> = <operand> '?'; */
{
  smkSeSt[smkStkP+1].ast=astClosure(smkSeSt[smkStkP+1].ast,0,1);
}	break;}
    case 89: { /* <closure rule> = <operand> '{' <number> '}'; */
{
  smkSeSt[smkStkP+1].ast=astClosure(smkSeSt[smkStkP+1].ast,smkSeSt[smkStkP+3].inumber,smkSeSt[smkStkP+3].inumber);
}	break;}
    case 90: { /* <closure rule> = <operand> '{' '-' <number> '}'; */
{
  smkSeSt[smkStkP+1].ast=astClosure(smkSeSt[smkStkP+1].ast,0,smkSeSt[smkStkP+4].inumber);
}	break;}
    case 91: { /* <closure rule> = <operand> '{' <number> '-' '}'; */
{
  smkSeSt[smkStkP+1].ast=astClosure(smkSeSt[smkStkP+1].ast,smkSeSt[smkStkP+3].inumber,-1);
}	break;}
    case 92: { /* <closure rule> = <operand> '{' <number> '-' <number> '}'; */
{
  if(smkSeSt[smkStkP+3].inumber>smkSeSt[smkStkP+5].inumber)
    smkLog(&smkSeSt[smkStkP+5].srcp,237,sevERR,"");
  else
    smkSeSt[smkStkP+1].ast=astClosure(smkSeSt[smkStkP+1].ast,smkSeSt[smkStkP+3].inumber,smkSeSt[smkStkP+5].inumber);
}	break;}
    case 93: { /* <operand> = <identifier>; */
{
  register Definition definition;

  definition=definitionGet(smkSeSt[smkStkP+1].name);
  if(definition==NULL || definition->ast==NULL)
    smkLog(&smkSeSt[smkStkP+1].srcp,239,sevERR,"");
  else
    smkSeSt[smkStkP+1].ast=definition->ast;
}	break;}
    case 94: { /* <operand> = <string>; */
{
  register AST ast;

  if(ast=astString(smkSeSt[smkStkP+1].name))
    smkSeSt[smkStkP+1].ast=ast;
  else
    smkLog(&smkSeSt[smkStkP+1].srcp,220,sevERR,"");
}	break;}
    case 95: { /* <operand> = <class>; */
{
  register AST ast;

  if(ast=astClass(smkSeSt[smkStkP+1].name))
    smkSeSt[smkStkP+1].ast=ast;
  else
    smkLog(&smkSeSt[smkStkP+1].srcp,238,sevERR,"");
}	break;}
    case 96: { /* <operand> = '.'; */
{
  smkSeSt[smkStkP+1].ast=astCut();
}	break;}
    case 97: { /* <operand> = '(' <selection rule> ')'; */
{
  smkSeSt[smkStkP+1].ast=smkSeSt[smkStkP+2].ast;
}	break;}
    case 98: { /* <identifier> = Identifier; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 99: { /* <identifier> = 'ADA'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 100: { /* <identifier> = 'AUTO'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 101: { /* <identifier> = 'BYTE'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 102: { /* <identifier> = 'C'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 103: { /* <identifier> = 'COL'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 104: { /* <identifier> = 'DES'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 105: { /* <identifier> = 'DFA'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 106: { /* <identifier> = 'ERR'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 107: { /* <identifier> = 'ESCAPE'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 108: { /* <identifier> = 'EXCLUDE'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 109: { /* <identifier> = 'GCS'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 110: { /* <identifier> = 'K'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 111: { /* <identifier> = 'LES'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 112: { /* <identifier> = 'LIST'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 113: { /* <identifier> = 'M'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 114: { /* <identifier> = 'MAP'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 115: { /* <identifier> = 'NFA'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 116: { /* <identifier> = 'NO'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 117: { /* <identifier> = 'POS'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 118: { /* <identifier> = 'POSITION'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 119: { /* <identifier> = 'RDS'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 120: { /* <identifier> = 'ROWCOL'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 121: { /* <identifier> = 'ROW'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 122: { /* <identifier> = 'SCR'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 123: { /* <identifier> = 'SCREENING'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 124: { /* <identifier> = 'SET'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 125: { /* <identifier> = 'TOK'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 126: { /* <identifier> = 'TOKEN'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 127: { /* <identifier> = 'TRACE'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 128: { /* <identifier> = 'VERBOSE'; */
{ smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp; smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name; }	break;}
    case 129: { /* <string> = String; */
{
  smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp;
  smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name;
}	break;}
    case 130: { /* <number> = Number; */
{
  smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp;
  smkSeSt[smkStkP+1].inumber=smkSySt[smkStkP+1].inumber;
}	break;}
    case 131: { /* <class> = Class; */
{
  smkSeSt[smkStkP+1].srcp=smkSySt[smkStkP+1].srcp;
  smkSeSt[smkStkP+1].name=smkSySt[smkStkP+1].name;
}	break;}
    default: break; }
}/*smkPaSema()*/


==> smkParse.c <==
/*----------------------------------------------------------------------*\

    smkParse.c

    ParserMaker generated parser

\*----------------------------------------------------------------------*/

/* %%IMPORT */

#include <stdio.h>
#include "smk_i.h"
#include "smkScan.h"
#include "smkList.h"
#include "ast.h"
#include "definition.h"
#include "name.h"
#include "scanner.h"
#include "token.h"
#include "voc.h"
#include "set.h"
#include "map.h"
#include "pack.h"
#include "action.h"
extern smkContext lexContext;
/* END %%IMPORT */

#include <strings.h>
#include <memory.h>
#include <setjmp.h>

#include "smkParse.h"

#define PMTRUE 1
#define PMFALSE 0
typedef unsigned char PmBoolean; /* For logical values */

/* System dependencies */

/* These datatypes should be defined to be unsigned integers of length 1, 2
 * and 4 bytes respectively.
 */
typedef unsigned char UByte1;
typedef unsigned short UByte2;
typedef unsigned int UByte4;

/* Token definition */
#include "smkCommon.h"

/* %%ATTRIBUTES - The semantic attributes for grammar symbols */
typedef struct smkGrammar {
    Action action;
    AST ast;
    Name name;
    double fnumber;
    int inumber;
    TmkSrcp srcp;
} smkGrammar;

/* END %%ATTRIBUTES */

/* Parser constants *\
\* ---------------- */
#define ERROR_ACT 0			/* Action - Error */
#define SHIFT_ACT 1			/* Action - Shift */
#define SHIFTRED_ACT 2		/* Action - Shift_Reduce */
#define REDUCE_ACT 3		/* Action - Reduce */
#define ACCEPT_ACT 4		/* Action - Accept */

#define ERR_SYM 0		/* Error token */
#define ENDMARK 1		/* End of file token code */

/* Recovery method *\
\* --------------- */
#define NONE_REC 0		/* No recovery found */
#define IN_REC 1		/* Insertion of symbol(s) */
#define DEL_REC 2		/* Deletion of symbol(s) */
#define REP_REC 3		/* Replacement of symbol(s) */
#define BAK_REC 4		/* Stack backup */
#define HALT_REC 5		/* System halted */

/* Error class *\
\* ----------- */
#define LEX_ERR 1		/* Non valid scanner symbol found */
#define SYN_ERR 2		/* Normal syntax error */
#define OFLW_ERR 3		/* Parse stack overflow */
#define TAB_ERR 4		/* Parse table error */

/* Error severity *\
\* -------------- */
#define WAR_SEV 1		/* Warnings */
#define ERR_SEV 2		/* Repairable error */
#define FAT_SEV 3		/* Fatal error */
#define SYS_SEV 4		/* System & limit error */

/* Parser constants *\
\* ---------------- */
#define SccMax 71		/* Max scanner code value */
#define TermMin 1		/* Minimum terminal number */
#define Terms 71		/* Number of terminals in grammar */
#define StateMin 1		/* Minimum state number */
#define States 84		/* Number of states */
#define ProdMin 1		/* Minimum production number */
#define Prods 131		/* Number of productions */
#define PmStkMax 32		/* Parse stack size */
#define	PmLaMax 5		/* Look-ahead length */
#define	PmCost 5		/* Shifting cost */

/* Types *\
\* ----- */
typedef unsigned char TermSet[(Terms + TermMin + 7) >> 3]; /* Terminal set */
typedef UByte1 ParseStack[PmStkMax]; /* Parse stack */

/* Terminal table *\
\* -------------- */

typedef struct {
    UByte1 tsym;		/* Normal continuation */
    UByte1 ssym;		/* Separator continuation */
} ContRec;

typedef struct {
    ContRec cont[84];		/* Continuation function */
    TermSet sepa;		/* Separator symbols */
    TermSet fiduc;		/* Fiducial symbols */
    TermSet skip;		/* Symbols to skip */
} RecTab;

typedef struct  {
    UByte2 act[1552];		/* Action table */
    UByte1 actCheck[1585];	/* Row Displacement Check Vector*/
    UByte2 actRix[84];		/* Action row mapping */
    RecTab recover;		/* Error recovery info */
} TermTab;

static TermTab act = {
{11,529,683,434,683,683,690,698,706,257,161,514,683,683,683,683,683,683
,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683,683
,683,683,683,683,683,714,273,442,291,683,683,233,547,274,683,683,683,683
,1050,659,4,659,659,683,683,291,585,81,683,770,305,659,818,882,906,930,659
,794,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,1050,802,659
,810,898,1034,409,363,363,81,1010,1018,299,129,345,858,962,866,1026,1050
,651,242,651,651,786,946,363,401,730,986,770,305,651,818,882,906,930,651
,794,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,1050,802,651
,810,898,1034,1042,129,345,738,1010,1018,129,345,233,858,962,866,1026,449
,393,1042,299,778,786,946,289,770,305,986,818,882,906,930,394,794,826,834
,842,850,874,890,914,922,938,954,970,978,994,1002,1050,802,1042,810,898
,1034,1042,355,355,346,1010,1018,138,619,131,858,962,866,1026,483,722,530
,99,209,786,946,355,505,417,986,626,193,522,131,483,483,483,483,131,483
,483,483,483,483,483,483,483,483,483,483,483,483,483,483,538,483,0,483,483
,483,0,483,561,0,483,483,0,483,483,483,483,483,483,499,0,595,0,0,483,483
,0,83,483,483,0,0,83,0,499,499,499,499,602,499,499,499,499,499,499,499,499
,499,499,499,499,499,499,499,0,499,185,499,499,499,0,499,403,403,499,499
,0,499,499,499,499,499,499,131,0,595,0,0,499,499,0,369,499,499,0,0,0,0,818
,882,906,930,602,794,826,834,842,850,874,890,914,922,938,954,970,978,994
,1002,0,802,185,810,898,1034,0,138,403,403,1010,1018,0,131,131,858,962,866
,1026,491,0,595,0,0,786,946,0,369,131,986,0,0,0,0,491,491,491,491,602,491
,491,491,491,491,491,491,491,491,491,491,491,491,491,491,0,491,185,491,491
,491,0,491,0,0,491,491,0,491,491,491,491,491,491,499,0,0,0,0,491,491,0,0
,491,491,0,0,0,0,499,499,499,499,0,499,499,499,499,499,499,499,499,499,499
,499,499,499,499,499,0,499,0,499,499,499,0,499,0,0,499,499,0,499,499,499
,499,499,499,131,0,0,0,0,499,499,0,0,499,499,0,0,0,0,818,882,906,930,0,794
,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,0,802,0,810,898
,1034,0,138,0,0,1010,1018,307,131,131,858,962,866,1026,0,283,0,0,0,786,946
,0,0,131,986,770,305,0,818,882,906,930,283,794,826,834,842,850,874,890,914
,922,938,954,970,978,994,1002,1050,802,0,810,898,1034,0,129,345,0,1010,1018
,0,0,0,858,962,866,1026,0,0,0,307,0,786,946,0,770,305,986,818,882,906,930
,0,794,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,1050,802
,0,810,898,1034,0,0,0,0,1010,1018,0,0,0,858,962,866,1026,0,0,0,0,0,786,946
,0,770,305,986,818,882,906,930,0,794,826,834,842,850,874,890,914,922,938
,954,970,978,994,1002,1050,802,0,810,898,1034,0,0,0,0,1010,1018,0,0,0,858
,962,866,1026,0,0,0,0,0,786,946,0,0,0,986,818,882,906,930,0,794,826,834
,842,850,874,890,914,922,938,954,970,978,994,1002,0,802,0,810,898,1034,0
,0,0,0,1010,1018,0,371,371,858,962,866,1026,0,635,0,329,233,786,946,0,0
,0,986,770,305,371,818,882,906,930,635,794,826,834,842,850,874,890,914,922
,938,954,970,978,994,1002,1050,802,635,810,898,1034,0,0,0,0,1010,1018,0
,0,0,858,962,866,1026,0,0,0,0,0,786,946,0,0,0,986,818,882,906,930,0,794
,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,0,802,0,810,898
,1034,0,0,0,0,1010,1018,0,411,411,858,962,866,1026,0,0,0,0,0,786,946,0,0
,0,986,818,882,906,930,0,794,826,834,842,850,874,890,914,922,938,954,970
,978,994,1002,0,802,0,810,898,0,0,138,0,0,1010,1018,0,0,0,858,962,866,1026
,0,0,0,0,0,786,946,0,0,131,986,818,882,906,930,0,794,826,834,842,850,874
,890,914,922,938,954,970,978,994,1002,0,802,0,810,898,1034,0,0,0,0,1010
,1018,0,0,0,858,962,866,1026,0,0,0,0,0,786,946,0,0,0,986,818,882,906,930
,0,794,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,0,802,0
,810,898,1034,0,0,0,0,1010,1018,0,0,0,858,962,866,1026,0,0,0,0,0,786,946
,0,0,0,986,818,882,906,930,0,794,826,834,842,850,874,890,914,922,938,954
,970,978,994,1002,0,802,0,810,898,0,0,0,0,0,1010,1018,0,0,0,858,962,866
,1026,0,0,0,0,0,786,946,0,0,0,986,818,882,906,930,0,794,826,834,842,850
,874,890,914,922,938,954,970,978,994,1002,0,802,0,810,898,0,0,0,0,0,1010
,1018,0,0,0,858,962,866,1026,0,0,0,0,0,786,946,0,0,0,986,818,882,906,930
,0,794,826,834,842,850,874,890,914,922,938,954,970,978,994,1002,0,802,0
,810,898,0,0,0,0,0,1010,1018,0,0,0,858,962,866,1026,0,0,0,0,0,786,946,0
,0,0,986,818,882,906,930,0,794,826,834,842,850,874,890,914,922,938,954,970
,978,994,1002,0,802,0,810,898,0,1050,138,131,131,1010,1018,131,138,0,858
,962,866,1026,131,131,131,131,0,786,946,131,131,131,986,131,0,0,131,131
,131,27,27,0,131,27,0,0,0,0,0,0,27,27,27,27,0,0,0,27,27,27,0,27,0,0,27,0
,27,138,131,131,0,0,131,0,0,0,0,0,0,0,131,131,131,0,0,0,131,131,131,0,131
,0,0,131,0,131,138,131,131,0,0,131,0,0,0,0,0,0,0,131,131,131,0,0,0,131,131
,131,0,131,0,0,131,0,131,138,131,131,0,0,131,0,0,0,0,0,0,0,131,131,131,0
,0,0,131,131,131,0,131,0,0,131,0,131,138,131,131,0,0,131,0,0,0,0,0,0,0,131
,131,131,0,0,0,131,131,131,0,131,0,0,131,0,131,138,131,131,0,0,131,0,0,0
,0,0,0,0,131,131,131,0,0,0,131,131,131,0,131,0,0,131,0,131,138,131,131,0
,0,131,0,0,0,0,0,0,0,131,131,131,0,0,0,131,131,131,0,131,0,0,131,0,131,138
,131,131,0,0,131,0,0,0,0,0,0,0,131,131,131,0,0,465,131,131,131,0,131,0,0
,131,0,131,138,131,131,0,473,131,0,0,0,0,0,0,0,131,131,131,0,0,0,131,131
,131,338,131,0,0,131,0,131,19,19,0,0,19,331,331,0,0,0,0,673,19,19,19,0,0
,0,19,19,19,0,19,0,331,19,331,19,51,51,0,0,51,0,0,0,0,0,0,0,51,51,51,0,0
,0,51,51,51,643,51,0,233,51,0,51,601,67,0,0,633,0,0,0,0,0,643,0,625,641
,657,0,0,0,617,649,67,0,665,0,0,67,0,609,643}
,
{8,64,30,48,30,30,30,30,30,30,18,18,30,30,30,30,30,30,30,30,30,30,30,30
,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,32,32,50,68,30,30,68
,52,67,30,30,30,30,69,29,1,29,29,30,30,68,71,8,30,29,29,29,29,29,29,29,29
,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,49,52,52
,7,29,29,14,60,60,29,29,29,29,72,39,73,39,39,29,29,52,47,33,29,39,39,39
,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39
,39,39,33,14,14,34,39,39,13,13,38,39,39,39,39,54,47,55,14,38,39,39,31,19
,19,39,19,19,19,19,56,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19
,35,19,19,19,31,11,11,58,19,19,74,66,74,19,19,19,19,15,36,24,6,19,19,19
,11,6,11,19,66,19,21,74,15,15,15,15,74,15,15,15,15,15,15,15,15,15,15,15
,15,15,15,15,26,15,84,15,15,15,84,15,5,84,15,15,84,15,15,15,15,15,15,16
,84,25,84,84,15,15,84,5,15,15,84,84,5,84,16,16,16,16,25,16,16,16,16,16,16
,16,16,16,16,16,16,16,16,16,84,16,25,16,16,16,84,16,59,59,16,16,84,16,16
,16,16,16,16,17,84,20,84,84,16,16,84,59,16,16,84,84,84,84,17,17,17,17,20
,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,84,17,20,17,17,17,84,17,12
,12,17,17,84,17,17,17,17,17,17,42,84,23,84,84,17,17,84,12,17,17,84,84,84
,84,42,42,42,42,23,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,84,42,23
,42,42,42,84,42,84,84,42,42,84,42,42,42,42,42,42,43,84,84,84,84,42,42,84
,84,42,42,84,84,84,84,43,43,43,43,84,43,43,43,43,43,43,43,43,43,43,43,43
,43,43,43,84,43,84,43,43,43,84,43,84,84,43,43,84,43,43,43,43,43,43,44,84
,84,84,84,43,43,84,84,43,43,84,84,84,84,44,44,44,44,84,44,44,44,44,44,44
,44,44,44,44,44,44,44,44,44,84,44,84,44,44,44,84,44,84,84,44,44,61,44,44
,44,44,44,44,84,65,84,84,84,44,44,84,84,44,44,65,65,84,65,65,65,65,65,65
,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,84,65,65,65,84,61,61,84
,65,65,84,84,84,65,65,65,65,84,84,84,61,84,65,65,84,28,28,65,28,28,28,28
,84,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,84,28,28,28,84,84
,84,84,28,28,84,84,84,28,28,28,28,84,84,84,84,84,28,28,84,40,40,28,40,40
,40,40,84,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,84,40,40,40
,84,84,84,84,40,40,84,84,84,40,40,40,40,84,84,84,84,84,40,40,84,84,84,40
,53,53,53,53,84,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,84,53,84,53
,53,53,84,84,84,84,53,53,84,53,53,53,53,53,53,84,27,84,27,27,53,53,84,84
,84,53,37,37,53,37,37,37,37,27,37,37,37,37,37,37,37,37,37,37,37,37,37,37
,37,37,37,27,37,37,37,84,84,84,84,37,37,84,84,84,37,37,37,37,84,84,84,84
,84,37,37,84,84,84,37,46,46,46,46,84,46,46,46,46,46,46,46,46,46,46,46,46
,46,46,46,84,46,84,46,46,46,84,84,84,84,46,46,84,46,46,46,46,46,46,84,84
,84,84,84,46,46,84,84,84,46,63,63,63,63,84,63,63,63,63,63,63,63,63,63,63
,63,63,63,63,63,84,63,84,63,63,84,84,63,84,84,63,63,84,84,84,63,63,63,63
,84,84,84,84,84,63,63,84,84,63,63,51,51,51,51,84,51,51,51,51,51,51,51,51
,51,51,51,51,51,51,51,84,51,84,51,51,51,84,84,84,84,51,51,84,84,84,51,51
,51,51,84,84,84,84,84,51,51,84,84,84,51,45,45,45,45,84,45,45,45,45,45,45
,45,45,45,45,45,45,45,45,45,84,45,84,45,45,45,84,84,84,84,45,45,84,84,84
,45,45,45,45,84,84,84,84,84,45,45,84,84,84,45,57,57,57,57,84,57,57,57,57
,57,57,57,57,57,57,57,57,57,57,57,84,57,84,57,57,84,84,84,84,84,57,57,84
,84,84,57,57,57,57,84,84,84,84,84,57,57,84,84,84,57,62,62,62,62,84,62,62
,62,62,62,62,62,62,62,62,62,62,62,62,62,84,62,84,62,62,84,84,84,84,84,62
,62,84,84,84,62,62,62,62,84,84,84,84,84,62,62,84,84,84,62,22,22,22,22,84
,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,84,22,84,22,22,84,84,84,84
,84,22,22,84,84,84,22,22,22,22,84,84,84,84,84,22,22,84,84,84,22,9,9,9,9
,84,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,84,9,84,9,9,84,70,83,83,83,9,9,83,70,84
,9,9,9,9,83,83,83,83,84,9,9,83,83,83,9,83,84,84,83,70,83,0,0,84,70,0,84
,84,84,84,84,84,0,0,0,0,84,84,84,0,0,0,84,0,84,84,0,84,0,75,75,75,84,84
,75,84,84,84,84,84,84,84,75,75,75,84,84,84,75,75,75,84,75,84,84,75,84,75
,76,76,76,84,84,76,84,84,84,84,84,84,84,76,76,76,84,84,84,76,76,76,84,76
,84,84,76,84,76,77,77,77,84,84,77,84,84,84,84,84,84,84,77,77,77,84,84,84
,77,77,77,84,77,84,84,77,84,77,78,78,78,84,84,78,84,84,84,84,84,84,84,78
,78,78,84,84,84,78,78,78,84,78,84,84,78,84,78,79,79,79,84,84,79,84,84,84
,84,84,84,84,79,79,79,84,84,84,79,79,79,84,79,84,84,79,84,79,80,80,80,84
,84,80,84,84,84,84,84,84,84,80,80,80,84,84,84,80,80,80,84,80,84,84,80,84
,80,81,81,81,84,84,81,84,84,84,84,84,84,84,81,81,81,84,84,10,81,81,81,84
,81,84,84,81,84,81,82,82,82,84,10,82,84,84,84,84,84,84,84,82,82,82,84,84
,84,82,82,82,10,82,84,84,82,84,82,2,2,84,84,2,10,10,84,84,84,84,2,2,2,2
,84,84,84,2,2,2,84,2,84,10,2,10,2,3,3,84,84,3,84,84,84,84,84,84,84,3,3,3
,84,84,84,3,3,3,41,3,84,41,3,84,3,4,4,84,84,4,84,84,84,84,84,41,84,4,4,4
,84,84,84,4,4,4,84,4,84,84,4,84,4,41,84,84,84,84,84,84,84,84,84,84,84,84
,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84}
,
{1164,56,1424,1452,1480,209,150,34,0,1136,1424,150,313,105,100,210,264,318
,9,156,318,221,1086,372,210,264,243,736,583,53,0,156,31,106,140,152,201
,736,150,106,633,1514,372,426,480,936,786,97,1,30,41,886,47,683,159,121
,173,986,164,259,53,527,1036,836,0,533,202,47,42,19,1142,61,72,107,161,1193
,1222,1251,1280,1309,1338,1367,1396,1136}
,
{
{{44,44}
,{1,1}
,{44,44}
,{44,44}
,{45,45}
,{64,64}
,{64,64}
,{64,64}
,{1,1}
,{60,60}
,{49,49}
,{49,49}
,{49,49}
,{49,49}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{3,3}
,{60,60}
,{3,3}
,{3,3}
,{60,60}
,{3,3}
,{3,3}
,{3,3}
,{3,3}
,{3,3}
,{60,60}
,{3,3}
,{3,3}
,{42,42}
,{11,11}
,{11,11}
,{11,11}
,{42,42}
,{11,11}
,{60,60}
,{15,15}
,{3,3}
,{60,60}
,{3,3}
,{1,1}
,{1,1}
,{1,1}
,{60,60}
,{49,49}
,{65,65}
,{3,3}
,{65,65}
,{3,3}
,{60,60}
,{49,49}
,{49,49}
,{2,2}
,{42,42}
,{3,3}
,{60,60}
,{37,37}
,{49,49}
,{49,49}
,{1,1}
,{60,60}
,{64,64}
,{2,2}
,{3,3}
,{3,3}
,{3,3}
,{3,3}
,{36,36}
,{64,64}
,{2,2}
,{36,36}
,{3,3}
,{45,45}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
,{44,44}
}
,
{0,0,0,0,0,0,0,0,0}
,
{0,0,0,0,0,0,0,0,0}
,
{0,0,0,0,0,0,0,0,0}
}
};


/* Non terminal table *\
\* ------------------ */
typedef  struct {
    UByte2 gto[143];		/* Goto table */
    UByte1 gtoRix[84];		/* Goto row mapping */
    UByte1 lhs[131];		/* Left hand side symbols */
    UByte1 rhsz[131];		/* Size of the RHS */
} NonTermTab;

static NonTermTab gto = {
{0,0,0,762,762,457,754,754,249,249,97,137,250,746,746,554,554,521,521,90
,321,321,546,425,441,441,666,666,225,553,169,762,762,57,754,754,249,249
,258,266,513,746,746,481,554,537,386,378,321,321,433,546,122,385,666,666
,337,313,762,762,74,754,754,249,249,58,458,762,746,746,754,450,249,497,49
,241,506,746,554,474,17,666,674,426,554,546,506,153,554,466,674,546,481
,385,33,546,226,153,569,577,314,114,234,73,145,577,34,106,353,218,89,450
,65,121,361,105,177,25,610,201,322,489,217,418,458,377,113,41,265,545,281
,297,593,210,146,154,162,170,178,186,194,202,42}
,
{79,8,85,88,43,1,64,68,19,87,0,66,80,84,39,0,88,82,3,0,97,2,105,100,2,103
,2,1,55,64,1,123,1,125,1,126,1,29,1,56,28,1,96,98,72,78,38,1,1,1,1,10,1
,9,1,0,1,107,1,75,44,97,4,5,0,1,115,0,0,96,102,0,129,0,126,127,128,129,130
,131,132,133,134,135}
,
{73,81,110,110,93,111,111,103,103,104,104,120,120,107,107,79,79,94,94,94
,94,94,94,94,94,89,90,74,74,72,115,108,108,106,116,116,105,105,95,96,82
,82,82,121,121,121,112,112,109,118,118,119,119,117,117,101,101,99,99,83
,84,88,88,76,76,76,76,87,87,113,113,97,114,91,91,91,86,86,102,102,100,100
,92,92,98,98,98,98,98,98,98,98,80,80,80,80,80,85,85,85,85,85,85,85,85,85
,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,78,77
,75}
,
{7,0,0,2,2,0,2,0,1,0,1,0,1,1,2,0,1,2,2,2,2,2,2,2,2,2,3,1,2,4,3,1,2,5,0,1
,6,3,1,4,0,1,2,0,2,2,1,2,4,0,2,1,2,3,4,1,2,4,4,0,0,0,2,2,5,5,5,1,1,0,2,5
,1,0,1,2,0,1,1,3,1,3,1,2,1,2,2,2,4,5,5,6,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1
,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};


/* Vocabulary *\
\* ---------- */
typedef struct {
    UByte1 scc;			/* Scanner code value */
    UByte1 iCost;		/* Insertion cost */
    UByte1 dCost;		/* Deletion cost */
    char *name;			/* Name string */
    char *psym;			/* Print name */
} VocTab[71];

static VocTab voc = {{1,255,255,"EndOfText",""}
,{2,1,1,"'='",""}
,{3,1,1,"';'",""}
,{4,1,1,"':'",""}
,{5,1,1,"'/'",""}
,{6,1,1,"'!'",""}
,{7,1,1,"'*'",""}
,{8,1,1,"'+'",""}
,{9,1,1,"'?'",""}
,{10,1,1,"'{'",""}
,{11,1,1,"'}'",""}
,{12,1,1,"'-'",""}
,{13,1,1,"'.'",""}
,{14,1,1,"'('",""}
,{15,1,1,"')'",""}
,{16,1,1,"'C'",""}
,{17,1,1,"'K'",""}
,{18,1,1,"'M'",""}
,{19,1,1,"'NO'",""}
,{20,1,1,"'%%'",""}
,{21,1,1,"'ADA'",""}
,{22,1,1,"'COL'",""}
,{23,1,1,"'DES'",""}
,{24,1,1,"'DFA'",""}
,{25,1,1,"'ERR'",""}
,{26,1,1,"'GCS'",""}
,{27,1,1,"'LES'",""}
,{28,1,1,"'MAP'",""}
,{29,1,1,"'NFA'",""}
,{30,1,1,"'POS'",""}
,{31,1,1,"'RDS'",""}
,{32,1,1,"'ROW'",""}
,{33,1,1,"'SCR'",""}
,{34,1,1,"'SET'",""}
,{35,1,1,"'TOK'",""}
,{36,1,1,"Class",""}
,{37,1,1,"'AUTO'",""}
,{38,1,1,"'%%DO'",""}
,{39,1,1,"'BYTE'",""}
,{40,1,1,"'LIST'",""}
,{41,1,1,"String",""}
,{42,1,1,"Number",""}
,{43,1,1,"'%%END'",""}
,{44,1,1,"'%%SET'",""}
,{45,1,1,"'%%MAP'",""}
,{46,1,1,"'TOKEN'",""}
,{47,1,1,"'TRACE'",""}
,{48,1,1,"'%%CODE'",""}
,{49,1,1,"'%%RULE'",""}
,{50,1,1,"'%%SKIP'",""}
,{51,1,1,"'ESCAPE'",""}
,{52,1,1,"'ROWCOL'",""}
,{53,1,1,"'EXCLUDE'",""}
,{54,1,1,"'VERBOSE'",""}
,{55,1,1,"SKIPHEADER",""}
,{56,1,1,"'%%EXPORT'",""}
,{57,1,1,"'%%READER'",""}
,{58,1,1,"'%%ACTION'",""}
,{59,1,1,"'_UNKNOWN'",""}
,{60,1,1,"Identifier",""}
,{61,1,1,"'POSITION'",""}
,{62,1,1,"'%%CONTEXT'",""}
,{63,1,1,"'%%PREHOOK'",""}
,{64,1,1,"'%%SCANNER'",""}
,{65,1,1,"'SCREENING'",""}
,{66,1,1,"'%%POSTHOOK'",""}
,{67,1,1,"'_ENDOFTEXT'",""}
,{68,1,1,"'%%SCREENING'",""}
,{69,1,1,"'%%DEFINITION'",""}
,{70,1,1,"'%%VOCABULARY'",""}
,{71,1,1,"'%%DECLARATION'",""}
}
;


/* Variables used in the parsing process *\
\* ------------------------------------- */
short smkStkP;			/* Stack pointer */
SmkToken smkSySt[PmStkMax];	/* Symbol stack */
smkGrammar smkSeSt[PmStkMax];	/* Semantic stack */
static UByte1 currstat;		/* Current state number */
static UByte1 arg;		/* Argument */
static UByte1 action;		/* Action type */
static PmBoolean endparse;	/* Termination flag */
static ParseStack parsStk;	/* Parse stack */
static UByte1 scIndex[71 + 1]; /* Converts scanner code to internal value */
static SmkToken tokenBuf;	/* Scanner token buffer */
static SmkToken *token = &tokenBuf;	/* Pointer to it for readsymb */


/* Error recovery look-ahead buffer *\
\* -------------------------------- */
static SmkToken la_buff[PmLaMax + 1]; /* Buffer */
static int la_ptr;		/* Current pointer */
static int la_end;		/* Last item */

static jmp_buf pmJmpB;		/* Buffer for long jump */

/* Interface routines *\
\* ------------------ */

extern void smkRPoi();	/* Error recovery - restart point  */
extern void smkISym();	/* Error recovery - insert symbol  */
extern void smkDSym();	/* Error recovery - delete symbol  */
extern void smkMess();	/* Error recovery - error message  */

/* External functions */
void smkPaSema();

/*----------------------------------------------------------------------------
 * paAbort - Abort the parsing process
 *----------------------------------------------------------------------------
 */
static void paAbort(token, eClass, severity)
SmkToken *token;		/* IN current token */
short eClass;			/* IN error classification */
short severity;			/* IN error severity code */
{
    smkMess(token, HALT_REC, eClass, severity);
    longjmp(pmJmpB, PMTRUE);	/* Jump out to top level */
}/*paAbort()*/


/*----------------------------------------------------------------------------
 * SetIns - Add one element to a set
 *----------------------------------------------------------------------------
 */
#define SetIns(set, n) ((set)[(n) >> 3] |= (0x80 >> ((n) & 0x7)))


/*----------------------------------------------------------------------------
 * SetClear - Clear a ParserMaker set
 *----------------------------------------------------------------------------
 */
#define SetClear(set, length) memset((void *)set, 0, ((length) + 7) >> 3)

/*----------------------------------------------------------------------------
 * SetMem - Check member inclusion
 *----------------------------------------------------------------------------
 */
#define SetMem(set, n) ((set)[(n) >> 3] & (0x80 >> ((n) & 0x7)))


/*----------------------------------------------------------------------------
 * paInit - Initialize the parsing process
 *----------------------------------------------------------------------------
 */
static void paInit()
{
    short i;

    la_ptr = 0;
    la_end = 0;
    smkStkP = 0;
    currstat = 1;
    endparse = PMFALSE;
    parsStk[0] = 1;

    /* Scanner interface */
    for (i = 0; i <= SccMax; i++) scIndex[i] = ERR_SYM;
    for (i = TermMin; i <= Terms; i++) scIndex[voc[i - TermMin].scc] = (UByte1)i;
}/*paInit()*/


/*----------------------------------------------------------------------------
 * pushStat[Tok] - Push the current state on the stack and possibly push current
 *        token on the symbol stack.
 *----------------------------------------------------------------------------
 */
#define MOVETOKEN smkSySt[smkStkP] = *token
#define pushStatTok()\
{\
    if (++smkStkP < PmStkMax) {\
    parsStk[smkStkP] = currstat;\
    MOVETOKEN;\
    } else {\
    token->code = voc[token->code-TermMin].scc;\
    paAbort(token, OFLW_ERR, SYS_SEV);\
    }\
}

#define pushStat()\
{\
    if (++smkStkP < PmStkMax) {\
    parsStk[smkStkP] = currstat;\
    } else {\
    token->code = voc[token->code-TermMin].scc;\
    paAbort(token, OFLW_ERR, SYS_SEV);\
    }\
}



/*----------------------------------------------------------------------------
 * actTbl - Do a look-up in the action table
 *----------------------------------------------------------------------------
 */
#define actTbl(st, sy, action, arg)\
{\
    register int actEnt;\
    register int actSt;\
    register int actSy;\
    actSt = st - StateMin;\
    actSy = sy - TermMin;\
    if (act.actCheck[act.actRix[actSt] + actSy] == actSt)\
    actEnt = act.act[act.actRix[actSt] + actSy];\
    else actEnt = ERROR_ACT;\
    *action = actEnt & 0x7;\
    *arg = actEnt >> 3;\
}/*actTbl()*/


/*----------------------------------------------------------------------------
 * gtoTbl - Do a look-up in the goto table
 *----------------------------------------------------------------------------
 */
#define gtoTbl(st, sy, action, arg)\
{\
    register int gtoEnt;\
    register int gtoSt;\
    register int gtoSy;\
    gtoSt = st - StateMin;\
    gtoSy = sy - Terms - 1;\
    gtoEnt = gto.gto[gto.gtoRix[gtoSt] + gtoSy];\
    *action = gtoEnt & 0x7;\
    *arg = gtoEnt >> 3;\
}/*gtoTbl()*/


/*----------------------------------------------------------------------------
 * E R R O R   R E C O V E R Y
 * ---------------------------
 *
 * The error recovery algorithm tries to modify current configuration in such
 * a way that parsing can be resumed correctly. Current configuration is
 * characterized by:
 *
 * w = x t y, where  x = parsed input
 *           t = current token
 *           y = unprocessed input
 *----------------------------------------------------------------------------
 */

typedef struct {
    SmkToken err_tok;
    SmkToken res_tok;
    short method;
    short eClass;
    short severity;
} ERR_REC;

static ERR_REC errdescr;


/*----------------------------------------------------------------------------
 * ePush - Push a state during error recovery
 *----------------------------------------------------------------------------
 */
static void ePush(state, stack, sp)
UByte1 state;			/* IN state to push */
UByte1 stack[];			/* INOUT parser stack */
short *sp;			/* INOUT current stack pointer */
{
    if (++(*sp) < PmStkMax) stack[*sp] = state;
    else paAbort(&errdescr.err_tok, OFLW_ERR, SYS_SEV);
}/*ePush()*/


/*----------------------------------------------------------------------------
 * legalAct - Check if a symbol is legal to shift in current state
 *----------------------------------------------------------------------------
 */
static PmBoolean legalAct(stack, stack_p, sym)
UByte1 stack[];			/* IN current stack */
short stack_p;			/* IN current stack pointer */
UByte1 sym;			/* IN symbol code */
                /* RET true if "symbol" is read (shifted) */
                /*     in current state */
{
    UByte1 state;		/* Current state */
    UByte1 action;		/* Current parser action */
    UByte1 arg;			/* Current parser argument */

    ParseStack t_stk;		/* Temporary parser stack */
    int i;			/* For loop index */

    /* Copy stack
     */
    for (i = 0; i <= stack_p; i++) t_stk[i] = stack[i];

    state = stack[stack_p];

    for (;;) {
    actTbl(state, sym, &action, &arg);
    switch (action) {

    case ERROR_ACT:
        return(PMFALSE);

    case SHIFT_ACT:
    case SHIFTRED_ACT:
    case ACCEPT_ACT:
        return(PMTRUE);

    case REDUCE_ACT:
        do {
        stack_p = stack_p - gto.rhsz[arg - ProdMin];
        gtoTbl(t_stk[stack_p], gto.lhs[arg - ProdMin], &action, &arg);
        ePush(state, t_stk, &stack_p);
        } while (action != SHIFT_ACT);
        state = arg; t_stk[stack_p] = state;
        break;

    }/*switch*/
    }/*for*/
}/*legalAct()*/


/*----------------------------------------------------------------------------
 * gLegSym - Get legal symbols
 *----------------------------------------------------------------------------
 */
static void gLegSym(stack, stack_p, legals)
ParseStack stack;		/* IN current stack */
short stack_p;			/* IN current stack pointer */
TermSet legals;			/* OUT legal symbols in current state */
{
    short sym;			/* Loop index */

    SetClear(legals, Terms + 1);
    for (sym = 1; sym <= Terms; sym++) {
    if (legalAct(stack, stack_p, sym)) SetIns(legals, sym);
    }/*for*/
}/*gLegSym()*/


/*----------------------------------------------------------------------------
 * backup - Backup the parse stack until current symbol is accepted (shifted)
 *      or the parse stack becomes empty
 *----------------------------------------------------------------------------
 */
static short backup(stack, stack_p, sym)
ParseStack stack;		/* IN current stack */
short stack_p;			/* IN current stack pointer */
UByte1 sym;	/* IN recovery symbol */
                /* RET new stack pointer, 0 if symbol is */
                /*     not accepted */
{
    while ((stack_p > 0) && (!legalAct(stack, stack_p, sym))) stack_p--;
    return(stack_p);
}/*backup()*/


/*----------------------------------------------------------------------------
 * delSym - Delete a symbol in the input stream
 *----------------------------------------------------------------------------
 */
static void delSym(token)
SmkToken *token;			/* INOUT symbol to delete, new symbol */
{
    short  t;

    t = token->code - TermMin;
    token->code = voc[t].scc;
    smkDSym(token, voc[t].name, voc[t].psym);
{
    if (la_ptr < la_end) {
    la_ptr++;
    *token = la_buff[la_ptr];
    } else {
    do {
         smkScan(lexContext, token);

        if (token->code > SccMax || token->code < 0) {
        token->code = ERR_SYM;
        } else token->code = scIndex[token->code];
        if (token->code == ERR_SYM) {
        smkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
        }
    } while (token->code == ERR_SYM);
    }
}
    if (errdescr.method == IN_REC) errdescr.method = REP_REC;
    else if (errdescr.method != REP_REC) errdescr.method = DEL_REC;
}/*delSym()*/


/*----------------------------------------------------------------------------
 * inSym - Insert a symbol in the input stream
 *----------------------------------------------------------------------------
 */
static void inSym(isym, gen_symb)
short isym;			/* IN symbol code to insert */
SmkToken *gen_symb;		/* OUT created symbol */
{
    smkISym(voc[isym - TermMin].scc, voc[isym - TermMin].name,
       voc[isym - TermMin].psym, gen_symb);
    if (errdescr.method == DEL_REC) errdescr.method = REP_REC;
    else if (errdescr.method != REP_REC) errdescr.method = IN_REC;

    gen_symb->code = isym;
}/*inSym()*/


/*----------------------------------------------------------------------------
 * M U L T I P L E   R E C O V E R Y
 * ---------------------------------
 *
 * The multiple symbols recovery technique is a "true local corrector", i.e.
 * it will always return a legal configuration for any input. Logically the
 * algorithm can be described as follows:
 *
 * 1) Roerich method (Karlsruhe):
 *    a. Find a continuation "u" of "x", such that "xu" is accepted.
 *    b. De composite "ty" into "qsy'", where q is a string.
 *    c. Delete "q".
 *    d. Insert u' (a prefix of u) between "x" and "sy'" giving xu' s y'.
 *
 * 2) Panic mode:
 *    If "q" contains a fiducial symbol "a"  then:
 *    a. Pop stack until "a" is accepted.
 *    b. If not succeeded resume at step 1.
 *----------------------------------------------------------------------------
 */

typedef struct {
    UByte1 r_state;		/* Recovery state */
    PmBoolean r_sepa;		/* Insert separator? */
    UByte1 r_sstat;		/* Where to insert separator */
} REC_POI;


/*----------------------------------------------------------------------------
 * acceptbl - Check whether "symbol" is reachable from current state using
 *        the continuation grammar.
 *----------------------------------------------------------------------------
 */
static void acceptbl(sym, stack, stack_p, token, found, point)
UByte1 sym;			/* IN terminal symbol code */
ParseStack stack;		/* IN parse stack */
short stack_p;			/* IN stack pointer */
SmkToken *token;			/* IN current token */
PmBoolean *found;		/* OUT "symbol" accepted? */
REC_POI *point;			/* OUT recovery point description */
{
    PmBoolean done;		/* Terminator flag */
    UByte1 state;		/* Current state */
    UByte1 action;		/* Parser action */
    UByte1 sep_act;		/* Parser action separator test */
    UByte1 arg;			/* Parser prod/state */
    UByte1 sep_arg;		/* Parser prod/state separator test */
    PmBoolean sepa_acc;		/* Separator is accepted? */
    ParseStack t_stk;		/* Temporary parser stack */
    short i;			/* Copy loop index */

    for (i = 0; i <= stack_p; i++) t_stk[i] = stack[i];

    state = t_stk[stack_p];
    done = PMFALSE;

    while (!done) {
    actTbl(state, sym, &action, &arg);
    if (legalAct(t_stk, stack_p, sym)) {
        /* Symbol is directly accepted */
        done = PMTRUE;
        *found = PMTRUE;
        point->r_state = state;
    } else {
        /* Use the continuation grammar */
        actTbl(state, act.recover.cont[state - StateMin].tsym, &action,
           &arg);
        actTbl(state, act.recover.cont[state - StateMin].ssym, &sep_act,
           &sep_arg);
        if ((action != sep_act) || (arg != sep_arg)) {
        /* A separator is legal. Check if current symbol is accepted
         * behind the separator
         */
            ParseStack stk;	/* Temporary stack */
            short sp;	/* Temporary stack pointer */

        sp = stack_p;
        for (i = 0; i <= stack_p; i++) stk[i] = t_stk[i];
        sepa_acc = PMFALSE;

        while (!sepa_acc) {
          actTbl(stk[sp], act.recover.cont[state - StateMin].ssym,
             &sep_act, &sep_arg);
            switch (sep_act) {

            case ERROR_ACT:
            case ACCEPT_ACT:
            sepa_acc = PMTRUE;
            break;

            case SHIFT_ACT:
            sepa_acc = PMTRUE;
            ePush(sep_arg, stk, &sp);
            break;

            case SHIFTRED_ACT:
            ePush(1, stk, &sp);
            sepa_acc = PMTRUE;
            goto reduce;

            case REDUCE_ACT:
              reduce:
            do {
                sp -= gto.rhsz[sep_arg-ProdMin];
                gtoTbl(stk[sp], gto.lhs[sep_arg-ProdMin], &sep_act,
                   &sep_arg);
                ePush(1, stk, &sp);
            } while (sep_act != SHIFT_ACT);

            stk[sp] = sep_arg;
            break;
            }/*switch*/
        }/*while*/

        if ((sep_act == SHIFT_ACT) || (sep_act == SHIFTRED_ACT)) {
            if (legalAct(stk, sp, sym)) {
            /* Separator is to be inserted */
            point->r_state = stk[sp];
            point->r_sepa = PMTRUE;
            point->r_sstat = state;
            done = PMTRUE;
            *found = PMTRUE;
            }/*if*/
        }/*if*/
        }/*if*/

        if (!*found) {
        switch (action) {

        case ERROR_ACT:
            paAbort(token, TAB_ERR, SYS_SEV);
            break;

        case ACCEPT_ACT:
            done = PMTRUE;
            break;

        case SHIFT_ACT:
            state = arg;
            ePush(state, t_stk, &stack_p);
            break;

        case SHIFTRED_ACT:
            ePush(state, t_stk, &stack_p);
            goto reduce2;

        case REDUCE_ACT:
          reduce2:
            do {
            stack_p -= gto.rhsz[arg-ProdMin];
            gtoTbl(t_stk[stack_p], gto.lhs[arg-ProdMin], &action,
                   &arg);
            ePush(state, t_stk, &stack_p);
            } while (action != SHIFT_ACT);

            state = arg;
            t_stk[stack_p] = state;
            break;

        }/*switch*/
        }/*if*/
    }/*if*/
    }/*while*/
}/*acceptbl()*/


/*----------------------------------------------------------------------------
 * search - Search recovery point
 *----------------------------------------------------------------------------
 */
static void search(stack, stack_p, token, point)
ParseStack stack;		/* IN current stack */
short *stack_p;			/* INOUT current stack pointer */
SmkToken *token;			/* INOUT current symbol */
REC_POI *point;			/* OUT descriptor of where to restart */
                /*     the parser */
{
    UByte1 state;		/* Current state */
    PmBoolean rp_found;		/* Recovery point found? */
    short new_stkp;		/* Temp stack pointer */

    state = stack[*stack_p];
    point->r_state = state;
    point->r_sepa = PMFALSE;
    point->r_sstat = 1;
    rp_found = PMFALSE;

    do {
    if (!SetMem(act.recover.skip, token->code)) {
        acceptbl(token->code, stack, *stack_p, token, &rp_found, point);
    }/*if*/

    if (!rp_found) {
        new_stkp = 0;
        if (SetMem(act.recover.fiduc, token->code)) {
        new_stkp = backup(stack, *stack_p, token->code);
        }/*if*/
        if (new_stkp > 0) {
        rp_found = PMTRUE;
        *stack_p = new_stkp;
        point->r_state = stack[*stack_p];
        errdescr.method = BAK_REC;
        } else
            delSym(token);
    }/*if*/
    } while (!rp_found);
}/*search()*/


/*----------------------------------------------------------------------------
 * reach - Use the continuation functions and insert symbols upto curr token.
 *----------------------------------------------------------------------------
 */
static void reach(stack, stack_p, token, point)
ParseStack stack;		/* INOUT current stack */
short *stack_p;			/* INOUT current stack pointer */
SmkToken *token;			/* INOUT current symbol */
REC_POI *point;			/* IN recovery point descriptor */
{
    UByte1 state;		/* Current state */
    UByte1 cont_sym;		/* Continuation symbol */
    SmkToken gen_symb;		/* Generated symbol */
    UByte1 action;		/* Current parser action */
    UByte1 arg;			/* Current prod/state */
    PmBoolean sepaAccept;	/* Separator accepted yet? */
    PmBoolean useSepa;		/* Use the separator now? */

    state = stack[*stack_p];
    gen_symb = *token;
    useSepa = PMFALSE;
    while (state != point->r_state) {
    if (point->r_sepa)
        if (state == point->r_sstat) {
        /* Separator state reached, remember to use separator */
        cont_sym = act.recover.cont[state-StateMin].ssym;
        useSepa = PMTRUE;
        } else cont_sym = act.recover.cont[state-StateMin].tsym;
    else cont_sym = act.recover.cont[state-StateMin].tsym;
    sepaAccept = PMFALSE;

    do {
      actTbl(state, cont_sym, &action, &arg);
      switch (action) {

      case ERROR_ACT:
        paAbort(token, TAB_ERR, SYS_SEV);
        break;

      case ACCEPT_ACT:
        break;

      case SHIFT_ACT:
        sepaAccept = PMTRUE;
        state = arg;
        inSym(cont_sym, &gen_symb);
        ePush(state, stack, stack_p);
        smkSySt[*stack_p] = gen_symb;
        break;

      case SHIFTRED_ACT:
        sepaAccept = PMTRUE;
        inSym(cont_sym, &gen_symb);
        ePush(state, stack, stack_p);
        smkSySt[*stack_p] = gen_symb;
        goto reduce;

      case REDUCE_ACT:
        reduce:
        do {
        *stack_p = *stack_p - gto.rhsz[arg-ProdMin];
        smkPaSema(arg);
        gtoTbl(stack[*stack_p], gto.lhs[arg-ProdMin], &action, &arg);
        ePush(state, stack, stack_p);
        } while (action != SHIFT_ACT);
        state = arg;
        stack[*stack_p] = state;
      }/*switch*/
    } while (useSepa && !sepaAccept);
    }/*while*/
}/*reach()*/


/*----------------------------------------------------------------------------
 * global - Global error recovery
 *----------------------------------------------------------------------------
 */
static void multiple(err_stk, err_stkp, err_tok, newstat)
ParseStack err_stk;		/* INOUT current parse stack */
short *err_stkp;		/* INOUT current stack pointer */
SmkToken *err_tok;		/* INOUT current token */
UByte1 *newstat;		/* OUT state after recovery */
{
    REC_POI  point;		/* Recovery point descriptor */

    search(err_stk, err_stkp, err_tok, &point);
    reach(err_stk, err_stkp, err_tok, &point);
    *newstat = err_stk[*err_stkp];
}/*multiple()*/


/*----------------------------------------------------------------------------
 * S I N G L E   R E C O V E R Y
 * -----------------------------
 *
 * The single recovery technique tries to REPAIR the error by finding the
 * least cost single symbol correction. One single symbol of:
 * - insertion
 * - deletion
 * - replacement
 * is concidered. The cost of the repair is the sum of the ADAPTION cost and
 * the MODIFICATION cost. The adaption cost indicates how well a correction
 * fits in the context. The modification cost is based on the
 * insertion/deletion cost given in the input. A correction is applied if
 * the cost is below a predefined threshold value.
 *----------------------------------------------------------------------------
 */

#define ShiftCost (PmCost)	/* The cost of shifting one symbol */
#define InfCost (ShiftCost * (PmLaMax)) /* Infinity */
#define Thresh (((PmLaMax) - 3) * ShiftCost) /* Acceptance cost */


/*----------------------------------------------------------------------------
 * readLa - Read tokens to the look-ahead buffer
 *----------------------------------------------------------------------------
 */
static void readLa(curtok)
SmkToken *curtok;			/* IN current token */
{
    int i;
    SmkToken tokbuf;
    SmkToken *token = &tokbuf;

    la_buff[0] = *curtok;
    *token = *curtok;
    for (i = la_ptr + 1; i <= la_end; i++) {
    /* Move old look_ahead to the beginning of the buffer */
    la_buff[i - la_ptr] = la_buff[i];
    }/*for*/
    la_end = la_end - la_ptr;
    la_ptr = -1;

    while ((la_buff[la_end].code != ENDMARK) && (la_end < PmLaMax)) {
    la_end++;
    do {
             smkScan(lexContext, token);

        if (token->code > SccMax || token->code < 0) {
        token->code = ERR_SYM;
        } else {
        token->code = scIndex[token->code];
        }/*if*/
        if (token->code == ERR_SYM) {
        smkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
        }/*if*/
    } while (token->code == ERR_SYM);
    la_buff[la_end] = *token;
    }/*while*/
}/*readLa()*/


/*----------------------------------------------------------------------------
 * rdLaSym - Fetches the i:th look-ahead symbol code from the look-ahead set
 *----------------------------------------------------------------------------
 */
static UByte1 rdLaSym(index)
char index;			/* IN i:th look-ahead symbol */
                /* RET token code */
{
    if (index > la_end) return(ENDMARK);
    else return(la_buff[(int)index].code);
}/*rdLaSym()*/


/*----------------------------------------------------------------------------
 * laParse - Continue the parsing process by reading tokens from the
 *       look-ahead set. The parse is terminated when:
 *       - out of read ahead
 *       - a new error is encountered
 *       Note! No semantic actions are carried out
 *----------------------------------------------------------------------------
 */
static void laParse(sym, next_la, stack, stack_p, cost)
UByte1 sym;			/* IN current terminal symbol */
char next_la;			/* IN index to next look-ahead symbol */
ParseStack stack;		/* IN parse stack */
short stack_p;			/* IN current stack pointer */
short *cost;			/* OUT adaption cost */
{
    PmBoolean done ;		/* Terminator flag */
    char sh_cnt;		/* Number of shifted symbols */
    UByte1 state;		/* Current state number */
    UByte1 action;		/* Parser action */
    UByte1 arg;      /* Parser argument */
    short i;			/* Loop index */
    ParseStack t_stk;		/* Temporary stack */

    /* Copy stack
     */
    for (i = 0; i <= stack_p; i++) t_stk[i] = stack[i];

    done = PMFALSE;
    sh_cnt = 0;
    state = t_stk[stack_p];

    while (!done) {
    actTbl(state, sym, &action, &arg);

    switch (action) {

    case ERROR_ACT:
        done = PMTRUE;
        break;

    case SHIFT_ACT:
        state = arg;
        ePush(state, t_stk, &stack_p);
        sh_cnt++;
        if (sh_cnt == PmLaMax) done = PMTRUE;
        else {
        sym = rdLaSym(next_la);
        next_la++;
        }/*if*/
        break;

    case SHIFTRED_ACT:
        ePush(state, t_stk, &stack_p);
        sh_cnt++;
        if (sh_cnt == PmLaMax) done = PMTRUE;
        else {
        sym = rdLaSym(next_la);
        if (next_la < PmLaMax) next_la++;
        }/*if*/
        goto reduce;

    case REDUCE_ACT:
      reduce:
        do {
        stack_p -= gto.rhsz[arg-ProdMin];
        gtoTbl(t_stk[stack_p], gto.lhs[arg-ProdMin], &action, &arg);
        ePush(state, t_stk, &stack_p);
        } while (action != SHIFT_ACT);

        state = arg;
        t_stk[stack_p] = state;
        break;

    case ACCEPT_ACT:
        done = PMTRUE;
        sh_cnt = PmLaMax;
        break;

    }/*switch*/
    }/*while*/

    *cost = InfCost - (sh_cnt*ShiftCost);
}/*laParse()*/


/*----------------------------------------------------------------------------
 * tryIn - Tries to insert a symbol from the legal set in front of current
 *	   token: x t y  => x st y, where s becomes current symbol
 *----------------------------------------------------------------------------
 */
static void tryIn(legals, stack, stack_p, sym, cost, choice)
TermSet legals;			/* IN set of legal symbols */
ParseStack stack;		/* IN current parser stack */
short stack_p;			/* IN current stack pointer */
UByte1 *sym;			/* OUT best insertion symbol */
short *cost;			/* OUT best cost so far */
short *choice;			/* OUT best choice so far */
{
    short i;
    short mod_cost;		/* Modification cost */
    short ad_cost;		/* Adaption cost */
    short tot_cost;		/* Total insertion cost */

    for (i = 1; i <= Terms; i++) {
    /* For all legal symbols
     */
    if (SetMem(legals, i)) {
        mod_cost = voc[i - TermMin].iCost;
        if (mod_cost < *cost) {
        laParse(i, 0, stack, stack_p, &ad_cost);
        tot_cost = ad_cost + mod_cost;
        if (tot_cost < *cost) {
            *cost = tot_cost;
            *choice = IN_REC;
            *sym = (UByte1)i;
        }/*if*/
        }/*if*/
    }/*if*/
    }/*for*/
}/*tryIn()*/


/*----------------------------------------------------------------------------
 * tryRep - Tries to replace currrent symbol with a new terminal:
 *      x t y  => x s y, where s becomes current symbol
 *----------------------------------------------------------------------------
 */
static void tryRep(legals, stack, stack_p, sym, cost, choice)
TermSet legals;			/* IN set of legal symbols */
ParseStack stack;		/* IN current parser stack */
short stack_p;			/* IN current stack pointer */
UByte1 *sym;			/* OUT best replacement symbol */
short *cost;			/* OUT best cost so far */
short *choice;			/* OUT best choice so far */
{
    short i;
    short mod_cost;		/* Modification cost */
    short ad_cost;		/* Adaption cost */
    short tot_cost;		/* Total replacment cost */

    for (i = 1; i <= Terms; i++) {
    /* For all legal symbols
     */
    if (SetMem(legals, i)) {
        mod_cost = (short) (voc[i-TermMin].iCost +
            voc[rdLaSym(0)-TermMin].dCost) / 2 + 1;
        if (mod_cost < *cost) {
        laParse(i, 1, stack, stack_p, &ad_cost);
        tot_cost = ad_cost + mod_cost;
        if (tot_cost < *cost) {
            *cost = tot_cost;
            *choice = REP_REC;
            *sym = (UByte1)i;
        }/*if*/
        }/*if*/
    }/*if*/
    }/*for*/
}/*tryRep()*/


/*----------------------------------------------------------------------------
 * tryDel - Tries to delete current symbol: x t y  => x y
 *----------------------------------------------------------------------------
 */
static void tryDel(stack, stack_p, cost, choice)
ParseStack stack;		/* IN current parser stack */
short stack_p;			/* IN current stack pointer */
short *cost;			/* INOUT best cost so far */
short *choice;			/* INOUT best choice so far */
{
    short mod_cost;		/* Modification cost */
    short ad_cost;          /* Adaption cost */
    short tot_cost;		/* Total deletion cost */

    mod_cost = voc[rdLaSym(0) - TermMin].dCost;
    if (mod_cost < *cost) {
    laParse(rdLaSym(1), 2, stack, stack_p, &ad_cost);
    tot_cost = ad_cost + mod_cost;
    if (tot_cost < *cost) {
        *cost = tot_cost;
        *choice = DEL_REC;
    }/*if*/
    }/*if*/
}/*tryDel()*/


/*----------------------------------------------------------------------------
 * _pmInsert
 *----------------------------------------------------------------------------
 */
static void _pmInsert(sym, token)
UByte1 sym;			/* IN symbol code to insert */
SmkToken *token;			/* OUT constructed token */
{
    inSym(sym, token);
}/*_pmInsert()*/


/*----------------------------------------------------------------------------
 * _pmReplace
 *----------------------------------------------------------------------------
 */
static void _pmReplace(sym, token)
UByte1 sym;			/* IN replacement symbol code */
SmkToken *token;			/* OUT constructed token */
{
    delSym(token);
    inSym(sym, token);
}/*_pmReplace()*/


/*----------------------------------------------------------------------------
 * _pmDelete
 *----------------------------------------------------------------------------
 */

static void _pmDelete(token)
SmkToken *token;			/* OUT new token */
{
{
    if (la_ptr < la_end) {
    la_ptr++;
    *token = la_buff[la_ptr];
    } else {
    do {
         smkScan(lexContext, token);

        if (token->code > SccMax || token->code < 0) {
        token->code = ERR_SYM;
        } else token->code = scIndex[token->code];
        if (token->code == ERR_SYM) {
        smkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
        }
    } while (token->code == ERR_SYM);
    }
}
    delSym(token);
}/*_pmDelete()*/


/*----------------------------------------------------------------------------
 * single - Single error recovery
 *----------------------------------------------------------------------------
 */
static void single(leg_sys, err_stk, err_stkp, token, newstat)
TermSet leg_sys;		/* IN legal symbols in current state */
ParseStack err_stk;		/* INOUT current parser stack */
short *err_stkp;		/* INOUT current stack pointer */
SmkToken *token;		/* INOUT current token */
UByte1 *newstat;		/* OUT recovery state */
{
    short choice;		/* Recovery action performed */
    short cost;			/* Best cost so far */
    UByte1 sym;			/* Insert symbol */

    choice = NONE_REC;
    cost = InfCost;
    readLa(token);

    tryIn(leg_sys, err_stk, *err_stkp, &sym, &cost, &choice);
    tryRep(leg_sys, err_stk, *err_stkp, &sym, &cost, &choice);
    tryDel(err_stk, *err_stkp, &cost, &choice);

    if (cost > Thresh) choice = NONE_REC;

    switch (choice) {

    case IN_REC:
    _pmInsert(sym, token);
    break;

    case DEL_REC:
    _pmDelete(token);
    break;

    case REP_REC:
    _pmReplace(sym, token);
    break;

    default:
{
    if (la_ptr < la_end) {
    la_ptr++;
    *token = la_buff[la_ptr];
    } else {
    do {
         smkScan(lexContext, token);

        if (token->code > SccMax || token->code < 0) {
        token->code = ERR_SYM;
        } else token->code = scIndex[token->code];
        if (token->code == ERR_SYM) {
        smkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
        }
    } while (token->code == ERR_SYM);
    }
}
    }/*switch*/

    *newstat = err_stk[*err_stkp];
}/*single()*/



/*----------------------------------------------------------------------------
 * recover - From an error
 *----------------------------------------------------------------------------
 */
static void recover(err_stk, err_stkp, err_symb, rec_stat)
ParseStack err_stk;		/* INOUT updated parse stack */
short *err_stkp;		/* INOUT updated stack pointer */
SmkToken *err_symb;		/* INOUT current token */
UByte1 *rec_stat;		/* OUT state after recovery */
{
    TermSet legal_sy;		/* Legal symbols */

    errdescr.err_tok = *err_symb;
    errdescr.err_tok.code = voc[errdescr.err_tok.code - TermMin].scc;
    errdescr.method = NONE_REC;
    errdescr.eClass = SYN_ERR;
    errdescr.severity = ERR_SEV;
    gLegSym(err_stk, *err_stkp, legal_sy);
    single(legal_sy, err_stk, err_stkp, err_symb, rec_stat);
    if (errdescr.method == NONE_REC) {
    multiple(err_stk, err_stkp, err_symb, rec_stat);
    smkMess(&errdescr.err_tok, errdescr.method, errdescr.eClass,
           errdescr.severity);
    } else {
    smkMess(&errdescr.err_tok, errdescr.method, SYN_ERR, errdescr.severity);
    }/*if*/
    errdescr.res_tok = *err_symb;
    errdescr.res_tok.code = voc[errdescr.res_tok.code - TermMin].scc;
    smkRPoi(&errdescr.res_tok);
}/*recover()*/


/*----------------------------------------------------------------------------
 * smkParse - Parser routine, entry point
 *----------------------------------------------------------------------------
 */
void smkParse()
{
    paInit();
{
    if (la_ptr < la_end) {
    la_ptr++;
    *token = la_buff[la_ptr];
    } else {
    do {
         smkScan(lexContext, token);

        if (token->code > SccMax || token->code < 0) {
        token->code = ERR_SYM;
        } else token->code = scIndex[token->code];
        if (token->code == ERR_SYM) {
        smkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
        }
    } while (token->code == ERR_SYM);
    }
}
    pushStatTok()
    if (setjmp(pmJmpB)) return;

    while (!endparse) {
    actTbl(currstat, token->code, &action, &arg);

    switch (action) {

    case ERROR_ACT:
        recover(parsStk, &smkStkP, token, &currstat);
        if (smkStkP == 0) endparse = PMTRUE;
        break;

    case SHIFT_ACT:
        currstat = arg;
        pushStatTok();
{
    if (la_ptr < la_end) {
    la_ptr++;
    *token = la_buff[la_ptr];
    } else {
    do {
         smkScan(lexContext, token);

        if (token->code > SccMax || token->code < 0) {
        token->code = ERR_SYM;
        } else token->code = scIndex[token->code];
        if (token->code == ERR_SYM) {
        smkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
        }
    } while (token->code == ERR_SYM);
    }
}
        break;

    case SHIFTRED_ACT:
        pushStatTok();
{
    if (la_ptr < la_end) {
    la_ptr++;
    *token = la_buff[la_ptr];
    } else {
    do {
         smkScan(lexContext, token);

        if (token->code > SccMax || token->code < 0) {
        token->code = ERR_SYM;
        } else token->code = scIndex[token->code];
        if (token->code == ERR_SYM) {
        smkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
        }
    } while (token->code == ERR_SYM);
    }
}
        goto reduce;

    case REDUCE_ACT:
      reduce:
        do {
        smkStkP -= gto.rhsz[arg - ProdMin];
        smkPaSema(arg);
        gtoTbl(parsStk[smkStkP], gto.lhs[arg - ProdMin], &action, &arg);
        pushStat();
        } while (action != SHIFT_ACT);

        currstat = arg;
        parsStk[smkStkP] = currstat;
        break;

    case ACCEPT_ACT:
        endparse = PMTRUE;
        break;
    }/*switch*/
    }/*while*/
}/*smkParse()*/


==> smkParse.h <==
#ifndef _smkParse_h_
#define _smkParse_h_
/*----------------------------------------------------------------------*\

  smkParse.h

  Parser interface

\*----------------------------------------------------------------------*/


/* Token and Srcp definition */
#include "smkCommon.h"

/* External functions */
extern void smkParse(); /* Parser */


#endif
