########## pmk ##########
set os = "$argv[1]"
if ("$os" == "PC") then
  dos2unix -ascii pmk.tst.win32 > pmk.tmp
  alias cat dos2unix -ascii
else
  ../pmk pmk > pmk.tmp
endif
echo +++++ pmk.tmk +++++  >> pmk.tmp
\cat pmk.tmk >> pmk.tmp
echo +++++ pmk.pml +++++ >> pmk.tmp
cat pmk.pml >> pmk.tmp
echo +++++ pmk.pmt +++++ >> pmk.tmp
cat pmk.pmt >> pmk.tmp
echo +++++ pmk.voc +++++ >> pmk.tmp
cat pmk.voc >> pmk.tmp
echo +++++ pmkCommon.h +++++ >> pmk.tmp
cat pmkCommon.h >> pmk.tmp
echo +++++ pmkErr.c +++++ >> pmk.tmp
cat pmkErr.c >> pmk.tmp
echo +++++ pmkPaSema.c +++++ >> pmk.tmp
cat pmkPaSema.c >> pmk.tmp
echo +++++ pmkParse.c +++++ >> pmk.tmp
cat pmkParse.c >> pmk.tmp
echo +++++ pmkParse.h +++++ >> pmk.tmp
cat pmkParse.h >> pmk.tmp
\cat pmk.tmp
\rm pmk.tmp
########## /bin/csh -f pmk.tst UNIX ##########

No warnings or errors detected.
1 informational message(s).

+++++ pmk.tmk +++++
%%OPTIONS
--	Os 'SunOS';
	Prefix 'pmk';
	Target 'c';

%%IMPORT
#include "tmkCommon.h"
%%END
%%TOKEN
	NAME PmkToken;
	CODE code   %% int %1%%;
	SRCP srcp   %% TmkSrcp %1%%;
	ATTRIBUTES
	     sval   %% char *%1%%,
	     ival   %% int %1%%,
	     fpos   %% long %1%%,
	     length %% long %1%%;
%%END
%%SRCP
	NAME TmkSrcp;
	COLUMN col;
	ROW    line;
	FILE   file;
%%END
+++++ pmk.pml +++++


                      Summary of the input process
                      ----------------------------

Grammar file name = pmk.pmk
Activated options = Recovery Single, Multiple, Panic;
Optimize Lr0;
Actionpack RDS;
Gotopack RDS;
List Grammar, Items, Tables, Statistics;
Resolve SR;
No Verbose;
Target 'c';
Escape '`';

Productions       = 95
Terminals         = 33
Non terminals     = 59
Attributes        = 19
Semantic actions  = 57

                                 T H E   V O C A B U L A R Y

T E R M I N A L S

  1.  EndOfText                 =   1  (icost = 255, dcost = 255)
  2.  IDENTIFIER                =   2  (icost = 1, dcost = 1, => identifier)
  3.  STRING                    =   3  (icost = 1, dcost = 1)
  4.  ANG_BRACK_STRING          =   4  (icost = 1, dcost = 1)
  5.  INTEGER                   =   5  (icost = 1, dcost = 1)
  6.  '='                       =   6  (icost = 1, dcost = 1)
  7.  ';'                       =   7  (icost = 1, dcost = 1)
  8.  ','                       =   8  (icost = 1, dcost = 1)
  9.  '('                       =   9  (icost = 1, dcost = 1)
 10.  ')'                       =  10  (icost = 1, dcost = 1)
 11.  '!'                       =  11  (icost = 1, dcost = 1)
 12.  '|'                       =  12  (icost = 1, dcost = 1)
 13.  '{'                       =  13  (icost = 1, dcost = 1)
 14.  '}'                       =  14  (icost = 1, dcost = 1)
 15.  '=>'                      =  15  (icost = 1, dcost = 1)
 16.  '%%'                      =  16  (icost = 1, dcost = 1)
 17.  '%+'                      =  17  (icost = 1, dcost = 1)
 18.  '%-'                      =  18  (icost = 1, dcost = 1)
 19.  'META'                    =  19  (icost = 1, dcost = 1)
 20.  'SKIP'                    =  20  (icost = 1, dcost = 1)
 21.  '%%END'                   =  21  (icost = 1, dcost = 1)
 22.  '%%CODE'                  =  22  (icost = 1, dcost = 1)
 23.  '%%RULES'                 =  23  (icost = 1, dcost = 1)
 24.  'FIDUCIAL'                =  24  (icost = 1, dcost = 1)
 25.  '%%EXPORT'                =  25  (icost = 1, dcost = 1)
 26.  SKIPHEADER                =  26  (icost = 1, dcost = 1)
 27.  'SEPARATOR'               =  27  (icost = 1, dcost = 1)
 28.  '%%SCANNER'               =  28  (icost = 1, dcost = 1)
 29.  '%%RECOVERY'              =  29  (icost = 1, dcost = 1)
 30.  '%%TERMINALS'             =  30  (icost = 1, dcost = 1)
 31.  '%%ATTRIBUTES'            =  31  (icost = 1, dcost = 1)
 32.  '%%DECLARATIONS'          =  32  (icost = 1, dcost = 1)
 33.  '%%INSERTSYMBOL'          =  33  (icost = 1, dcost = 1)


N O N   T E R M I N A L S

 34.  rhs
 35.  rule
 36.  rhss
 37.  rules
 38.  endOpt
 39.  symbol
 40.  action
 41.  terminal
 42.  skip_aux
 43.  modifier
 44.  code_part
 45.  attribute
 46.  meta_part
 47.  skip_part
 48.  meta_name
 49.  terminals
 50.  modifiers
 51.  token_code
 52.  attributes
 53.  <+red_aux>
 54.  <-red_aux>
 55.  insert_cost
 56.  delete_cost
 57.  nonterminal
 58.  pmk_document
 59.  skip_section
 60.  rule_section
 61.  print_symbol
 62.  recovery_aux
 63.  fiducial_aux
 64.  Alternatives
 65.  skip_sections
 66.  TERMINALS_aux
 67.  optional_decl
 68.  recovery_part
 69.  fiducial_part
 70.  separator_aux
 71.  recovery_parts
 72.  separator_part
 73.  export_section
 74.  term_or_nonterm
 75.  meta_definition
 76.  repair_terminal
 77.  reduce_modifier
 78.  scanner_section
 79.  declaration_part
 80.  meta_definitions
 81.  symbol_or_action
 82.  program_paragraph
 83.  grammar_paragraph
 84.  attribute_section
 85.  symbols_or_actions
 86.  terminal_definition
 87.  error_recovery_data
 88.  reduce_not_modifier
 89.  terminal_definitions
 90.  insertsymbol_section
 91.  error_handling_section
 92.  scanner_interface_section


A T T R I B U T E S

 93.  srcp
 94.  code
 95.  sval
 96.  ival
 97.  fpos
 98.  length
 99.  sval2
100.  q_str
101.  nullf
102.  icost
103.  dcost
104.  red_set
105.  rhslist
106.  nored_set
107.  altr_node
108.  altr_last
109.  rule_elnode
110.  rhslist_last
111.  rule_elnode_last
                               T H E   P R O D U C T I O N S

  1. pmk_document = skip_sections program_paragraph grammar_paragraph 
                  ;

  2. skip_sections = 
  3.               ! skip_sections skip_section 
                   ;

  4. program_paragraph = declaration_part code_part 
                       ;

  5. code_part = 
  6.           ! '%%CODE' endOpt 
               ;

  7. declaration_part = 
  8.                  ! '%%DECLARATIONS' endOpt 
                      ;

  9. grammar_paragraph = scanner_interface_section attribute_section 
                         error_handling_section rule_section 
                       ;

 10. scanner_interface_section = 
 11.                           ! TERMINALS_aux terminal_definitions endOpt 
                               ;

 12. TERMINALS_aux = '%%TERMINALS' 
                   ;

 13. terminal_definitions = terminal_definition 
 14.                      ! terminal_definitions terminal_definition 
                          ;

 15. terminal_definition = terminal '=' token_code error_recovery_data ';' 
                         ;

 16. terminal = symbol 
              ;

 17. symbol = term_or_nonterm 
 18.        ! STRING 
            ;

 19. term_or_nonterm = IDENTIFIER 
 20.                 ! ANG_BRACK_STRING 
                     ;

 21. token_code = INTEGER 
                ;

 22. error_recovery_data = 
 23.                     ! ',' insert_cost ',' delete_cost print_symbol 
                         ;

 24. insert_cost = 
 25.             ! INTEGER 
                 ;

 26. delete_cost = 
 27.             ! INTEGER 
                 ;

 28. print_symbol = 
 29.              ! '=>' terminal 
                  ;

 30. attribute_section = 
 31.                   ! '%%ATTRIBUTES' attributes ';' endOpt 
                       ;

 32. attributes = attribute 
 33.            ! attributes ',' attribute 
                ;

 34. attribute = IDENTIFIER optional_decl 
               ;

 35. optional_decl = 
 36.               ! '%%' 
                   ;

 37. error_handling_section = 
 38.                        ! recovery_aux recovery_parts endOpt 
                            ;

 39. recovery_aux = '%%RECOVERY' 
                  ;

 40. recovery_parts = 
 41.                ! recovery_parts recovery_part 
                    ;

 42. recovery_part = separator_part 
 43.               ! fiducial_part 
 44.               ! skip_part 
 45.               ! meta_part 
                   ;

 46. meta_part = 'META' meta_definitions 
               ;

 47. meta_definitions = meta_definition 
 48.                  ! meta_definitions meta_definition 
                      ;

 49. meta_definition = meta_name '=' '(' terminals ')' repair_terminal ';' 
                     ;

 50. meta_name = terminal 
               ;

 51. terminals = terminal 
 52.           ! terminals ',' terminal 
               ;

 53. repair_terminal = 
 54.                 ! '=>' terminal 
                     ;

 55. separator_part = separator_aux '(' terminals ')' ';' 
                    ;

 56. separator_aux = 'SEPARATOR' 
                   ;

 57. fiducial_part = fiducial_aux '(' terminals ')' ';' 
                   ;

 58. fiducial_aux = 'FIDUCIAL' 
                  ;

 59. skip_part = skip_aux '(' terminals ')' ';' 
               ;

 60. skip_aux = 'SKIP' 
              ;

 61. rule_section = 
 62.              ! '%%RULES' rules endOpt 
                  ;

 63. rules = rule 
 64.       ! rules rule 
           ;

 65. rule = nonterminal '=' rhss ';' 
          ;

 66. nonterminal = term_or_nonterm 
                 ;

 67. rhss = rhs 
 68.      ! rhss '!' rhs 
          ;

 69. rhs = symbols_or_actions modifiers 
         ;

 70. symbols_or_actions = 
 71.                    ! symbols_or_actions symbol_or_action 
                        ;

 72. Alternatives = modifiers symbols_or_actions modifiers 
 73.              ! Alternatives '|' modifiers symbols_or_actions modifiers 
                  ;

 74. symbol_or_action = symbol 
 75.                  ! modifiers action modifiers 
 76.                  ! '{' modifiers symbols_or_actions modifiers '}' 
 77.                  ! '(' Alternatives ')' 
                      ;

 78. modifiers = 
 79.           ! modifiers modifier 
               ;

 80. modifier = reduce_modifier 
 81.          ! reduce_not_modifier 
              ;

 82. reduce_modifier = <+red_aux> '(' terminals ')' 
                     ;

 83. <+red_aux> = '%+' 
                ;

 84. reduce_not_modifier = <-red_aux> '(' terminals ')' 
                         ;

 85. <-red_aux> = '%-' 
                ;

 86. action = '%%' 
            ;

 87. export_section = '%%EXPORT' endOpt 
                    ;

 88. scanner_section = '%%SCANNER' endOpt 
                     ;

 89. insertsymbol_section = '%%INSERTSYMBOL' endOpt 
                          ;

 90. skip_section = export_section 
 91.              ! scanner_section 
 92.              ! insertsymbol_section 
 93.              ! SKIPHEADER endOpt 
                  ;

 94. endOpt = 
 95.        ! '%%END' 
            ;

                      L A L R ( 1 )  S E T S  O F  I T E M S



State:    1   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           R2 ! skip_sections --> .
              !                   {EndOfText '%%CODE' '%%RULES' '%%EXPORT' 
              !                    SKIPHEADER '%%SCANNER' '%%RECOVERY' 
              !                    '%%TERMINALS' '%%ATTRIBUTES' 
              !                    '%%DECLARATIONS' '%%INSERTSYMBOL' }
            3 ! pmk_document --> .skip_sections program_paragraph 
              !                  grammar_paragraph 
            2 ! Unknown --> .pmk_document 
            3 ! skip_sections --> .skip_sections skip_section 


State:    2   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           R0 ! Unknown --> pmk_document .
              !             {EndOfText }


State:    3   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           R7 ! declaration_part --> .
              !                      {EndOfText '%%CODE' '%%RULES' 
              !                       '%%RECOVERY' '%%TERMINALS' 
              !                       '%%ATTRIBUTES' }
          SR3 ! skip_sections --> skip_sections .skip_section 
           77 ! program_paragraph --> .declaration_part code_part 
            4 ! pmk_document --> skip_sections .program_paragraph 
              !                  grammar_paragraph 
           79 ! declaration_part --> .'%%DECLARATIONS' endOpt 
         SR90 ! skip_section --> .export_section 
           80 ! export_section --> .'%%EXPORT' endOpt 
         SR91 ! skip_section --> .scanner_section 
           81 ! scanner_section --> .'%%SCANNER' endOpt 
         SR92 ! skip_section --> .insertsymbol_section 
           82 ! insertsymbol_section --> .'%%INSERTSYMBOL' endOpt 
           83 ! skip_section --> .SKIPHEADER endOpt 


State:    4   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R10 ! scanner_interface_section --> .
              !                               {EndOfText '%%RULES' 
              !                                '%%RECOVERY' '%%ATTRIBUTES' }
            5 ! grammar_paragraph --> .scanner_interface_section 
              !                       attribute_section error_handling_section 
              !                       rule_section 
          SR1 ! pmk_document --> skip_sections program_paragraph .
              !                  grammar_paragraph 
           66 ! scanner_interface_section --> .TERMINALS_aux 
              !                               terminal_definitions endOpt 
         SR12 ! TERMINALS_aux --> .'%%TERMINALS' 


State:    5   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R30 ! attribute_section --> .
              !                       {EndOfText '%%RULES' '%%RECOVERY' }
            6 ! grammar_paragraph --> scanner_interface_section .
              !                       attribute_section error_handling_section 
              !                       rule_section 
           61 ! attribute_section --> .'%%ATTRIBUTES' attributes ';' endOpt 


State:    6   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R37 ! error_handling_section --> .
              !                            {EndOfText '%%RULES' }
            7 ! grammar_paragraph --> scanner_interface_section 
              !                       attribute_section .
              !                       error_handling_section rule_section 
           38 ! error_handling_section --> .recovery_aux recovery_parts endOpt 
         SR39 ! recovery_aux --> .'%%RECOVERY' 


State:    7   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R61 ! rule_section --> .
              !                  {EndOfText }
          SR9 ! grammar_paragraph --> scanner_interface_section 
              !                       attribute_section error_handling_section .
              !                       rule_section 
            8 ! rule_section --> .'%%RULES' rules endOpt 


State:    8   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            9 ! rule_section --> '%%RULES' .rules endOpt 
         SR63 ! rules --> .rule 
           10 ! rule --> .nonterminal '=' rhss ';' 
         SR66 ! nonterminal --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
            9 ! rules --> .rules rule 


State:    9   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R94 ! endOpt --> .
              !            {EndOfText }
         SR64 ! rules --> rules .rule 
         SR62 ! rule_section --> '%%RULES' rules .endOpt 
         SR95 ! endOpt --> .'%%END' 
           10 ! rule --> .nonterminal '=' rhss ';' 
         SR66 ! nonterminal --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 


State:   10   !  Continuation: '='
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           11 ! rule --> nonterminal .'=' rhss ';' 


State:   11   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R70 ! symbols_or_actions --> .
              !                        {IDENTIFIER STRING ANG_BRACK_STRING ';' 
              !                         '(' '!' '{' '%%' '%+' '%-' }
         SR67 ! rhss --> .rhs 
           14 ! rhs --> .symbols_or_actions modifiers 
           12 ! rule --> nonterminal '=' .rhss ';' 
           14 ! symbols_or_actions --> .symbols_or_actions symbol_or_action 
           12 ! rhss --> .rhss '!' rhs 


State:   12   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR65 ! rule --> nonterminal '=' rhss .';' 
           13 ! rhss --> rhss .'!' rhs 


State:   13   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R70 ! symbols_or_actions --> .
              !                        {IDENTIFIER STRING ANG_BRACK_STRING ';' 
              !                         '(' '!' '{' '%%' '%+' '%-' }
           14 ! rhs --> .symbols_or_actions modifiers 
         SR68 ! rhss --> rhss '!' .rhs 
           14 ! symbols_or_actions --> .symbols_or_actions symbol_or_action 


State:   14   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R78 ! modifiers --> .
              !               {';' '!' '%%' '%+' '%-' }
         SR71 ! symbols_or_actions --> symbols_or_actions .symbol_or_action 
           15 ! rhs --> symbols_or_actions .modifiers 
           15 ! modifiers --> .modifiers modifier 
         SR74 ! symbol_or_action --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           15 ! symbol_or_action --> .modifiers action modifiers 
           25 ! symbol_or_action --> .'{' modifiers symbols_or_actions 
              !                      modifiers '}' 
           29 ! symbol_or_action --> .'(' Alternatives ')' 


State:   15   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R69 ! rhs --> symbols_or_actions modifiers .
              !         {';' '!' }
         SR79 ! modifiers --> modifiers .modifier 
           16 ! symbol_or_action --> modifiers .action modifiers 
         SR80 ! modifier --> .reduce_modifier 
           18 ! reduce_modifier --> .<+red_aux> '(' terminals ')' 
         SR83 ! <+red_aux> --> .'%+' 
         SR81 ! modifier --> .reduce_not_modifier 
           22 ! reduce_not_modifier --> .<-red_aux> '(' terminals ')' 
         SR85 ! <-red_aux> --> .'%-' 
         SR86 ! action --> .'%%' 


State:   16   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R78 ! modifiers --> .
              !               {IDENTIFIER STRING ANG_BRACK_STRING ';' '(' ')' 
              !                '!' '|' '{' '}' '%%' '%+' '%-' }
           17 ! symbol_or_action --> modifiers action .modifiers 
           17 ! modifiers --> .modifiers modifier 

*******  Shift-Reduce conflict in state   17 Symbol: '%+' Production:   75
         Resolved by modification (Shift: '%+')
*******  Shift-Reduce conflict in state   17 Symbol: '%-' Production:   75
         Resolved by modification (Shift: '%-')

State:   17   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R75 ! symbol_or_action --> modifiers action modifiers .
              !                      {IDENTIFIER STRING ANG_BRACK_STRING ';' 
              !                       '(' ')' '!' '|' '{' '}' '%%' }
         SR79 ! modifiers --> modifiers .modifier 
         SR80 ! modifier --> .reduce_modifier 
           18 ! reduce_modifier --> .<+red_aux> '(' terminals ')' 
         SR83 ! <+red_aux> --> .'%+' 
         SR81 ! modifier --> .reduce_not_modifier 
           22 ! reduce_not_modifier --> .<-red_aux> '(' terminals ')' 
         SR85 ! <-red_aux> --> .'%-' 


State:   18   !  Continuation: '('
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           19 ! reduce_modifier --> <+red_aux> .'(' terminals ')' 


State:   19   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           20 ! reduce_modifier --> <+red_aux> '(' .terminals ')' 
         SR51 ! terminals --> .terminal 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           20 ! terminals --> .terminals ',' terminal 


State:   20   !  Continuation: ')'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR82 ! reduce_modifier --> <+red_aux> '(' terminals .')' 
           21 ! terminals --> terminals .',' terminal 


State:   21   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR52 ! terminals --> terminals ',' .terminal 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 


State:   22   !  Continuation: '('
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           23 ! reduce_not_modifier --> <-red_aux> .'(' terminals ')' 


State:   23   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           24 ! reduce_not_modifier --> <-red_aux> '(' .terminals ')' 
         SR51 ! terminals --> .terminal 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           24 ! terminals --> .terminals ',' terminal 


State:   24   !  Continuation: ')'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR84 ! reduce_not_modifier --> <-red_aux> '(' terminals .')' 
           21 ! terminals --> terminals .',' terminal 


State:   25   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R78 ! modifiers --> .
              !               {IDENTIFIER STRING ANG_BRACK_STRING '(' '{' '}' 
              !                '%%' '%+' '%-' }
           26 ! symbol_or_action --> '{' .modifiers symbols_or_actions 
              !                      modifiers '}' 
           26 ! modifiers --> .modifiers modifier 

*******  Shift-Reduce conflict in state   26 Symbol: '%+' Production:   70
         Resolved by modification (Shift: '%+')
*******  Shift-Reduce conflict in state   26 Symbol: '%-' Production:   70
         Resolved by modification (Shift: '%-')

State:   26   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R70 ! symbols_or_actions --> .
              !                        {IDENTIFIER STRING ANG_BRACK_STRING '(' 
              !                         '{' '}' '%%' }
         SR79 ! modifiers --> modifiers .modifier 
           27 ! symbol_or_action --> '{' modifiers .symbols_or_actions 
              !                      modifiers '}' 
           27 ! symbols_or_actions --> .symbols_or_actions symbol_or_action 
         SR80 ! modifier --> .reduce_modifier 
           18 ! reduce_modifier --> .<+red_aux> '(' terminals ')' 
         SR83 ! <+red_aux> --> .'%+' 
         SR81 ! modifier --> .reduce_not_modifier 
           22 ! reduce_not_modifier --> .<-red_aux> '(' terminals ')' 
         SR85 ! <-red_aux> --> .'%-' 


State:   27   !  Continuation: '}'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R78 ! modifiers --> .
              !               {'}' '%%' '%+' '%-' }
         SR71 ! symbols_or_actions --> symbols_or_actions .symbol_or_action 
           28 ! symbol_or_action --> '{' modifiers symbols_or_actions .
              !                      modifiers '}' 
           28 ! modifiers --> .modifiers modifier 
         SR74 ! symbol_or_action --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           28 ! symbol_or_action --> .modifiers action modifiers 
           25 ! symbol_or_action --> .'{' modifiers symbols_or_actions 
              !                      modifiers '}' 
           29 ! symbol_or_action --> .'(' Alternatives ')' 


State:   28   !  Continuation: '}'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR76 ! symbol_or_action --> '{' modifiers symbols_or_actions 
              !                      modifiers .'}' 
         SR79 ! modifiers --> modifiers .modifier 
           16 ! symbol_or_action --> modifiers .action modifiers 
         SR80 ! modifier --> .reduce_modifier 
           18 ! reduce_modifier --> .<+red_aux> '(' terminals ')' 
         SR83 ! <+red_aux> --> .'%+' 
         SR81 ! modifier --> .reduce_not_modifier 
           22 ! reduce_not_modifier --> .<-red_aux> '(' terminals ')' 
         SR85 ! <-red_aux> --> .'%-' 
         SR86 ! action --> .'%%' 


State:   29   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R78 ! modifiers --> .
              !               {IDENTIFIER STRING ANG_BRACK_STRING '(' ')' '|' 
              !                '{' '%%' '%+' '%-' }
           35 ! Alternatives --> .modifiers symbols_or_actions modifiers 
           30 ! symbol_or_action --> '(' .Alternatives ')' 
           35 ! modifiers --> .modifiers modifier 
           30 ! Alternatives --> .Alternatives '|' modifiers 
              !                  symbols_or_actions modifiers 


State:   30   !  Continuation: ')'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR77 ! symbol_or_action --> '(' Alternatives .')' 
           31 ! Alternatives --> Alternatives .'|' modifiers 
              !                  symbols_or_actions modifiers 


State:   31   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R78 ! modifiers --> .
              !               {IDENTIFIER STRING ANG_BRACK_STRING '(' ')' '|' 
              !                '{' '%%' '%+' '%-' }
           32 ! Alternatives --> Alternatives '|' .modifiers 
              !                  symbols_or_actions modifiers 
           32 ! modifiers --> .modifiers modifier 

*******  Shift-Reduce conflict in state   32 Symbol: '%+' Production:   70
         Resolved by modification (Shift: '%+')
*******  Shift-Reduce conflict in state   32 Symbol: '%-' Production:   70
         Resolved by modification (Shift: '%-')

State:   32   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R70 ! symbols_or_actions --> .
              !                        {IDENTIFIER STRING ANG_BRACK_STRING '(' 
              !                         ')' '|' '{' '%%' }
         SR79 ! modifiers --> modifiers .modifier 
           33 ! Alternatives --> Alternatives '|' modifiers .
              !                  symbols_or_actions modifiers 
           33 ! symbols_or_actions --> .symbols_or_actions symbol_or_action 
         SR80 ! modifier --> .reduce_modifier 
           18 ! reduce_modifier --> .<+red_aux> '(' terminals ')' 
         SR83 ! <+red_aux> --> .'%+' 
         SR81 ! modifier --> .reduce_not_modifier 
           22 ! reduce_not_modifier --> .<-red_aux> '(' terminals ')' 
         SR85 ! <-red_aux> --> .'%-' 


State:   33   !  Continuation: ')'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R78 ! modifiers --> .
              !               {')' '|' '%%' '%+' '%-' }
         SR71 ! symbols_or_actions --> symbols_or_actions .symbol_or_action 
           34 ! Alternatives --> Alternatives '|' modifiers symbols_or_actions .
              !                  modifiers 
           34 ! modifiers --> .modifiers modifier 
         SR74 ! symbol_or_action --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           34 ! symbol_or_action --> .modifiers action modifiers 
           25 ! symbol_or_action --> .'{' modifiers symbols_or_actions 
              !                      modifiers '}' 
           29 ! symbol_or_action --> .'(' Alternatives ')' 


State:   34   !  Continuation: ')'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R73 ! Alternatives --> Alternatives '|' modifiers symbols_or_actions 
              !                  modifiers .
              !                  {')' '|' }
         SR79 ! modifiers --> modifiers .modifier 
           16 ! symbol_or_action --> modifiers .action modifiers 
         SR80 ! modifier --> .reduce_modifier 
           18 ! reduce_modifier --> .<+red_aux> '(' terminals ')' 
         SR83 ! <+red_aux> --> .'%+' 
         SR81 ! modifier --> .reduce_not_modifier 
           22 ! reduce_not_modifier --> .<-red_aux> '(' terminals ')' 
         SR85 ! <-red_aux> --> .'%-' 
         SR86 ! action --> .'%%' 

*******  Shift-Reduce conflict in state   35 Symbol: '%+' Production:   70
         Resolved by modification (Shift: '%+')
*******  Shift-Reduce conflict in state   35 Symbol: '%-' Production:   70
         Resolved by modification (Shift: '%-')

State:   35   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R70 ! symbols_or_actions --> .
              !                        {IDENTIFIER STRING ANG_BRACK_STRING '(' 
              !                         ')' '|' '{' '%%' }
         SR79 ! modifiers --> modifiers .modifier 
           36 ! Alternatives --> modifiers .symbols_or_actions modifiers 
           36 ! symbols_or_actions --> .symbols_or_actions symbol_or_action 
         SR80 ! modifier --> .reduce_modifier 
           18 ! reduce_modifier --> .<+red_aux> '(' terminals ')' 
         SR83 ! <+red_aux> --> .'%+' 
         SR81 ! modifier --> .reduce_not_modifier 
           22 ! reduce_not_modifier --> .<-red_aux> '(' terminals ')' 
         SR85 ! <-red_aux> --> .'%-' 


State:   36   !  Continuation: ')'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R78 ! modifiers --> .
              !               {')' '|' '%%' '%+' '%-' }
         SR71 ! symbols_or_actions --> symbols_or_actions .symbol_or_action 
           37 ! Alternatives --> modifiers symbols_or_actions .modifiers 
           37 ! modifiers --> .modifiers modifier 
         SR74 ! symbol_or_action --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           37 ! symbol_or_action --> .modifiers action modifiers 
           25 ! symbol_or_action --> .'{' modifiers symbols_or_actions 
              !                      modifiers '}' 
           29 ! symbol_or_action --> .'(' Alternatives ')' 


State:   37   !  Continuation: ')'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R72 ! Alternatives --> modifiers symbols_or_actions modifiers .
              !                  {')' '|' }
         SR79 ! modifiers --> modifiers .modifier 
           16 ! symbol_or_action --> modifiers .action modifiers 
         SR80 ! modifier --> .reduce_modifier 
           18 ! reduce_modifier --> .<+red_aux> '(' terminals ')' 
         SR83 ! <+red_aux> --> .'%+' 
         SR81 ! modifier --> .reduce_not_modifier 
           22 ! reduce_not_modifier --> .<-red_aux> '(' terminals ')' 
         SR85 ! <-red_aux> --> .'%-' 
         SR86 ! action --> .'%%' 


State:   38   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R40 ! recovery_parts --> .
              !                    {EndOfText 'META' 'SKIP' '%%END' '%%RULES' 
              !                     'FIDUCIAL' 'SEPARATOR' }
           39 ! error_handling_section --> recovery_aux .recovery_parts endOpt 
           39 ! recovery_parts --> .recovery_parts recovery_part 


State:   39   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R94 ! endOpt --> .
              !            {EndOfText '%%RULES' }
         SR41 ! recovery_parts --> recovery_parts .recovery_part 
         SR38 ! error_handling_section --> recovery_aux recovery_parts .endOpt 
         SR95 ! endOpt --> .'%%END' 
         SR42 ! recovery_part --> .separator_part 
           40 ! separator_part --> .separator_aux '(' terminals ')' ';' 
         SR56 ! separator_aux --> .'SEPARATOR' 
         SR43 ! recovery_part --> .fiducial_part 
           44 ! fiducial_part --> .fiducial_aux '(' terminals ')' ';' 
         SR58 ! fiducial_aux --> .'FIDUCIAL' 
         SR44 ! recovery_part --> .skip_part 
           48 ! skip_part --> .skip_aux '(' terminals ')' ';' 
         SR60 ! skip_aux --> .'SKIP' 
         SR45 ! recovery_part --> .meta_part 
           52 ! meta_part --> .'META' meta_definitions 


State:   40   !  Continuation: '('
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           41 ! separator_part --> separator_aux .'(' terminals ')' ';' 


State:   41   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           42 ! separator_part --> separator_aux '(' .terminals ')' ';' 
         SR51 ! terminals --> .terminal 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           42 ! terminals --> .terminals ',' terminal 


State:   42   !  Continuation: ')'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           43 ! separator_part --> separator_aux '(' terminals .')' ';' 
           21 ! terminals --> terminals .',' terminal 


State:   43   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR55 ! separator_part --> separator_aux '(' terminals ')' .';' 


State:   44   !  Continuation: '('
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           45 ! fiducial_part --> fiducial_aux .'(' terminals ')' ';' 


State:   45   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           46 ! fiducial_part --> fiducial_aux '(' .terminals ')' ';' 
         SR51 ! terminals --> .terminal 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           46 ! terminals --> .terminals ',' terminal 


State:   46   !  Continuation: ')'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           47 ! fiducial_part --> fiducial_aux '(' terminals .')' ';' 
           21 ! terminals --> terminals .',' terminal 


State:   47   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR57 ! fiducial_part --> fiducial_aux '(' terminals ')' .';' 


State:   48   !  Continuation: '('
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           49 ! skip_part --> skip_aux .'(' terminals ')' ';' 


State:   49   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           50 ! skip_part --> skip_aux '(' .terminals ')' ';' 
         SR51 ! terminals --> .terminal 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           50 ! terminals --> .terminals ',' terminal 


State:   50   !  Continuation: ')'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           51 ! skip_part --> skip_aux '(' terminals .')' ';' 
           21 ! terminals --> terminals .',' terminal 


State:   51   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR59 ! skip_part --> skip_aux '(' terminals ')' .';' 


State:   52   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           53 ! meta_part --> 'META' .meta_definitions 
         SR47 ! meta_definitions --> .meta_definition 
           54 ! meta_definition --> .meta_name '=' '(' terminals ')' 
              !                     repair_terminal ';' 
         SR50 ! meta_name --> .terminal 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           53 ! meta_definitions --> .meta_definitions meta_definition 


State:   53   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R46 ! meta_part --> 'META' meta_definitions .
              !               {EndOfText 'META' 'SKIP' '%%END' '%%RULES' 
              !                'FIDUCIAL' 'SEPARATOR' }
         SR48 ! meta_definitions --> meta_definitions .meta_definition 
           54 ! meta_definition --> .meta_name '=' '(' terminals ')' 
              !                     repair_terminal ';' 
         SR50 ! meta_name --> .terminal 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 


State:   54   !  Continuation: '='
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           55 ! meta_definition --> meta_name .'=' '(' terminals ')' 
              !                     repair_terminal ';' 


State:   55   !  Continuation: '('
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           56 ! meta_definition --> meta_name '=' .'(' terminals ')' 
              !                     repair_terminal ';' 


State:   56   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           57 ! meta_definition --> meta_name '=' '(' .terminals ')' 
              !                     repair_terminal ';' 
         SR51 ! terminals --> .terminal 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           57 ! terminals --> .terminals ',' terminal 


State:   57   !  Continuation: ')'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           58 ! meta_definition --> meta_name '=' '(' terminals .')' 
              !                     repair_terminal ';' 
           21 ! terminals --> terminals .',' terminal 


State:   58   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R53 ! repair_terminal --> .
              !                     {';' }
           59 ! meta_definition --> meta_name '=' '(' terminals ')' .
              !                     repair_terminal ';' 
           60 ! repair_terminal --> .'=>' terminal 


State:   59   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR49 ! meta_definition --> meta_name '=' '(' terminals ')' 
              !                     repair_terminal .';' 


State:   60   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR54 ! repair_terminal --> '=>' .terminal 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 


State:   61   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           62 ! attribute_section --> '%%ATTRIBUTES' .attributes ';' endOpt 
         SR32 ! attributes --> .attribute 
           65 ! attribute --> .IDENTIFIER optional_decl 
           62 ! attributes --> .attributes ',' attribute 


State:   62   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           63 ! attribute_section --> '%%ATTRIBUTES' attributes .';' endOpt 
           64 ! attributes --> attributes .',' attribute 


State:   63   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R94 ! endOpt --> .
              !            {EndOfText '%%RULES' '%%RECOVERY' }
         SR31 ! attribute_section --> '%%ATTRIBUTES' attributes ';' .endOpt 
         SR95 ! endOpt --> .'%%END' 


State:   64   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR33 ! attributes --> attributes ',' .attribute 
           65 ! attribute --> .IDENTIFIER optional_decl 


State:   65   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R35 ! optional_decl --> .
              !                   {';' ',' }
         SR34 ! attribute --> IDENTIFIER .optional_decl 
         SR36 ! optional_decl --> .'%%' 


State:   66   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           67 ! scanner_interface_section --> TERMINALS_aux .
              !                               terminal_definitions endOpt 
         SR13 ! terminal_definitions --> .terminal_definition 
           68 ! terminal_definition --> .terminal '=' token_code 
              !                         error_recovery_data ';' 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 
           67 ! terminal_definitions --> .terminal_definitions 
              !                          terminal_definition 


State:   67   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R94 ! endOpt --> .
              !            {EndOfText '%%RULES' '%%RECOVERY' '%%ATTRIBUTES' }
         SR14 ! terminal_definitions --> terminal_definitions .
              !                          terminal_definition 
         SR11 ! scanner_interface_section --> TERMINALS_aux 
              !                               terminal_definitions .endOpt 
         SR95 ! endOpt --> .'%%END' 
           68 ! terminal_definition --> .terminal '=' token_code 
              !                         error_recovery_data ';' 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 


State:   68   !  Continuation: '='
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           69 ! terminal_definition --> terminal .'=' token_code 
              !                         error_recovery_data ';' 


State:   69   !  Continuation: INTEGER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           70 ! terminal_definition --> terminal '=' .token_code 
              !                         error_recovery_data ';' 
         SR21 ! token_code --> .INTEGER 


State:   70   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R22 ! error_recovery_data --> .
              !                         {';' }
           71 ! terminal_definition --> terminal '=' token_code .
              !                         error_recovery_data ';' 
           72 ! error_recovery_data --> .',' insert_cost ',' delete_cost 
              !                         print_symbol 


State:   71   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR15 ! terminal_definition --> terminal '=' token_code 
              !                         error_recovery_data .';' 


State:   72   !  Continuation: ','
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R24 ! insert_cost --> .
              !                 {',' }
           73 ! error_recovery_data --> ',' .insert_cost ',' delete_cost 
              !                         print_symbol 
         SR25 ! insert_cost --> .INTEGER 


State:   73   !  Continuation: ','
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           74 ! error_recovery_data --> ',' insert_cost .',' delete_cost 
              !                         print_symbol 


State:   74   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R26 ! delete_cost --> .
              !                 {';' '=>' }
           75 ! error_recovery_data --> ',' insert_cost ',' .delete_cost 
              !                         print_symbol 
         SR27 ! delete_cost --> .INTEGER 


State:   75   !  Continuation: ';'
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R28 ! print_symbol --> .
              !                  {';' }
         SR23 ! error_recovery_data --> ',' insert_cost ',' delete_cost .
              !                         print_symbol 
           76 ! print_symbol --> .'=>' terminal 


State:   76   !  Continuation: IDENTIFIER
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         SR29 ! print_symbol --> '=>' .terminal 
         SR16 ! terminal --> .symbol 
         SR17 ! symbol --> .term_or_nonterm 
         SR19 ! term_or_nonterm --> .IDENTIFIER 
         SR20 ! term_or_nonterm --> .ANG_BRACK_STRING 
         SR18 ! symbol --> .STRING 


State:   77   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           R5 ! code_part --> .
              !               {EndOfText '%%RULES' '%%RECOVERY' '%%TERMINALS' 
              !                '%%ATTRIBUTES' }
          SR4 ! program_paragraph --> declaration_part .code_part 
           78 ! code_part --> .'%%CODE' endOpt 


State:   78   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R94 ! endOpt --> .
              !            {EndOfText '%%RULES' '%%RECOVERY' '%%TERMINALS' 
              !             '%%ATTRIBUTES' }
          SR6 ! code_part --> '%%CODE' .endOpt 
         SR95 ! endOpt --> .'%%END' 


State:   79   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R94 ! endOpt --> .
              !            {EndOfText '%%CODE' '%%RULES' '%%RECOVERY' 
              !             '%%TERMINALS' '%%ATTRIBUTES' }
          SR8 ! declaration_part --> '%%DECLARATIONS' .endOpt 
         SR95 ! endOpt --> .'%%END' 


State:   80   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R94 ! endOpt --> .
              !            {EndOfText '%%CODE' '%%RULES' '%%EXPORT' SKIPHEADER 
              !             '%%SCANNER' '%%RECOVERY' '%%TERMINALS' 
              !             '%%ATTRIBUTES' '%%DECLARATIONS' '%%INSERTSYMBOL' }
         SR87 ! export_section --> '%%EXPORT' .endOpt 
         SR95 ! endOpt --> .'%%END' 


State:   81   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R94 ! endOpt --> .
              !            {EndOfText '%%CODE' '%%RULES' '%%EXPORT' SKIPHEADER 
              !             '%%SCANNER' '%%RECOVERY' '%%TERMINALS' 
              !             '%%ATTRIBUTES' '%%DECLARATIONS' '%%INSERTSYMBOL' }
         SR88 ! scanner_section --> '%%SCANNER' .endOpt 
         SR95 ! endOpt --> .'%%END' 


State:   82   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R94 ! endOpt --> .
              !            {EndOfText '%%CODE' '%%RULES' '%%EXPORT' SKIPHEADER 
              !             '%%SCANNER' '%%RECOVERY' '%%TERMINALS' 
              !             '%%ATTRIBUTES' '%%DECLARATIONS' '%%INSERTSYMBOL' }
         SR89 ! insertsymbol_section --> '%%INSERTSYMBOL' .endOpt 
         SR95 ! endOpt --> .'%%END' 


State:   83   !  Continuation: EndOfText
- - - - - - - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          R94 ! endOpt --> .
              !            {EndOfText '%%CODE' '%%RULES' '%%EXPORT' SKIPHEADER 
              !             '%%SCANNER' '%%RECOVERY' '%%TERMINALS' 
              !             '%%ATTRIBUTES' '%%DECLARATIONS' '%%INSERTSYMBOL' }
         SR93 ! skip_section --> SKIPHEADER .endOpt 
         SR95 ! endOpt --> .'%%END' 




                  T H E  P A R S E R  A C T I O N  T A B L E


  TOP OF STACK                                                        INPUT SYMBOL
STATE NAME                !  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33
--------------------------!---------------------------------------------------------------------------------------------------
  1   Unknown             ! R2  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X R2 R2  X R2 R2  X R2 R2 R2 R2 R2 R2 
  2   pmk_document        !  A  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
  3   skip_sections       ! R7  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X R7 R7  X S80S83 X S81R7 R7 R7 S79S82
  4   program_paragraph   ! R10 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X R10 X  X  X  X  X R10-12R10 X  X 
  5   scanner_interface_se! R30 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * R30 *  *  *  *  * R30 * S61 *  * 
  6   attribute_section   ! R37 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * R37 *  *  *  *  * -39 *  *  *  * 
  7   error_handling_secti! R61 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S8  *  *  *  *  *  *  *  *  *  * 
  8   '%%RULES'           !  X -19 X -20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
  9   rules               ! R94-19 X -20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X -95 X  X  X  X  X  X  X  X  X  X  X  X 
 10   nonterminal         !  X  X  X  X  X S11 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 11   '='                 !  X R70R70R70 X  X R70 X R70 X R70 X R70 X  X R70R70R70 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 12   rhss                !  X  X  X  X  X  X -65 X  X  X S13 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 13   '!'                 !  X R70R70R70 X  X R70 X R70 X R70 X R70 X  X R70R70R70 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 14   symbols_or_actions  !  * -19-18-20 *  * R78 * S29 * R78 * S25 *  * R78R78R78 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 15   modifiers           !  *  *  *  *  *  * R69 *  *  * R69 *  *  *  * -86-83-85 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 16   action              !  X R78R78R78 X  X R78 X R78R78R78R78R78R78 X R78R78R78 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 17   modifiers           !  * R75R75R75 *  * R75 * R75R75R75R75R75R75 * R75-83-85 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 18   <+red_aux>          !  X  X  X  X  X  X  X  X S19 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 19   '('                 !  X -19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 20   terminals           !  X  X  X  X  X  X  X S21 X -82 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 21   ','                 !  X -19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 22   <-red_aux>          !  X  X  X  X  X  X  X  X S23 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 23   '('                 !  X -19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 24   terminals           !  X  X  X  X  X  X  X S21 X -84 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 25   '{'                 !  X R78R78R78 X  X  X  X R78 X  X  X R78R78 X R78R78R78 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 26   modifiers           !  * R70R70R70 *  *  *  * R70 *  *  * R70R70 * R70-83-85 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 27   symbols_or_actions  !  * -19-18-20 *  *  *  * S29 *  *  * S25R78 * R78R78R78 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 28   modifiers           !  *  *  *  *  *  *  *  *  *  *  *  *  * -76 * -86-83-85 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 29   '('                 !  X R78R78R78 X  X  X  X R78R78 X R78R78 X  X R78R78R78 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 30   Alternatives        !  *  *  *  *  *  *  *  *  * -77 * S31 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 31   '|'                 !  X R78R78R78 X  X  X  X R78R78 X R78R78 X  X R78R78R78 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 32   modifiers           !  * R70R70R70 *  *  *  * R70R70 * R70R70 *  * R70-83-85 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 33   symbols_or_actions  !  * -19-18-20 *  *  *  * S29R78 * R78S25 *  * R78R78R78 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 34   modifiers           !  *  *  *  *  *  *  *  *  * R73 * R73 *  *  * -86-83-85 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 35   modifiers           !  * R70R70R70 *  *  *  * R70R70 * R70R70 *  * R70-83-85 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 36   symbols_or_actions  !  * -19-18-20 *  *  *  * S29R78 * R78S25 *  * R78R78R78 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 37   modifiers           !  *  *  *  *  *  *  *  *  * R72 * R72 *  *  * -86-83-85 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 38   recovery_aux        ! R40 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X R40R40R40 X R40R40 X  X R40 X  X  X  X  X  X 
 39   recovery_parts      ! R94 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S52-60-95 * R94-58 *  * -56 *  *  *  *  *  * 
 40   separator_aux       !  X  X  X  X  X  X  X  X S41 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 41   '('                 !  X -19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 42   terminals           !  X  X  X  X  X  X  X S21 X S43 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 43   ')'                 !  X  X  X  X  X  X -55 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 44   fiducial_aux        !  X  X  X  X  X  X  X  X S45 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 45   '('                 !  X -19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 46   terminals           !  X  X  X  X  X  X  X S21 X S47 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 47   ')'                 !  X  X  X  X  X  X -57 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 48   skip_aux            !  X  X  X  X  X  X  X  X S49 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 49   '('                 !  X -19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 50   terminals           !  X  X  X  X  X  X  X S21 X S51 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 51   ')'                 !  X  X  X  X  X  X -59 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 52   'META'              !  X -19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 53   meta_definitions    ! R46-19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X R46R46R46 X R46R46 X  X R46 X  X  X  X  X  X 
 54   meta_name           !  X  X  X  X  X S55 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 55   '='                 !  X  X  X  X  X  X  X  X S56 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 56   '('                 !  X -19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 57   terminals           !  X  X  X  X  X  X  X S21 X S58 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 58   ')'                 !  X  X  X  X  X  X R53 X  X  X  X  X  X  X S60 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 59   repair_terminal     !  *  *  *  *  *  * -49 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 60   '=>'                !  X -19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 61   '%%ATTRIBUTES'      !  X S65 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 62   attributes          !  X  X  X  X  X  X S63S64 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 63   ';'                 ! R94 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X -95 X R94 X  X  X  X  X R94 X  X  X  X 
 64   ','                 !  X S65 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 65   IDENTIFIER          !  X  X  X  X  X  X R35R35 X  X  X  X  X  X  X -36 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 66   TERMINALS_aux       !  X -19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 67   terminal_definitions! R94-19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X -95 X R94 X  X  X  X  X R94 X R94 X  X 
 68   terminal            !  X  X  X  X  X S69 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 69   '='                 !  X  X  X  X -21 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 70   token_code          !  X  X  X  X  X  X R22S72 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 71   error_recovery_data !  *  *  *  *  *  * -15 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 72   ','                 !  X  X  X  X -25 X  X R24 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 73   insert_cost         !  *  *  *  *  *  *  * S74 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 74   ','                 !  X  X  X  X -27 X R26 X  X  X  X  X  X  X R26 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 75   delete_cost         !  *  *  *  *  *  * R28 *  *  *  *  *  *  * S76 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 76   '=>'                !  X -19-18-20 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 
 77   declaration_part    ! R5  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S78R5  *  *  *  *  * R5 R5 R5  *  * 
 78   '%%CODE'            ! R94 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X -95 X R94 X  X  X  X  X R94R94R94 X  X 
 79   '%%DECLARATIONS'    ! R94 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X -95R94R94 X  X  X  X  X R94R94R94 X  X 
 80   '%%EXPORT'          ! R94 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X -95R94R94 X R94R94 X R94R94R94R94R94R94
 81   '%%SCANNER'         ! R94 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X -95R94R94 X R94R94 X R94R94R94R94R94R94
 82   '%%INSERTSYMBOL'    ! R94 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X -95R94R94 X R94R94 X R94R94R94R94R94R94
 83   SKIPHEADER          ! R94 X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X -95R94R94 X R94R94 X R94R94R94R94R94R94



                         T H E  G O T O  T A B L E


  TOP OF STACK                                                                                                  SYMBOL
STATE NAME                ! 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92
--------------------------!---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1   Unknown             !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S2  *  *  *  *  *  * S3  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
  2   pmk_document        !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
  3   skip_sections       !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -3  *  *  *  *  *  *  *  *  *  *  *  *  * -90 *  *  *  * -91S77 *  * S4  *  *  *  *  *  *  * -92 *  * 
  4   program_paragraph   !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S66 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -1  *  *  *  *  *  *  *  * S5 
  5   scanner_interface_se!  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S6  *  *  *  *  *  *  *  * 
  6   attribute_section   !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S38 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S7  * 
  7   error_handling_secti!  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -9  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
  8   '%%RULES'           !  * -63 * S9  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S10 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -66 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
  9   rules               !  * -64 *  * -62 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S10 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -66 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 10   nonterminal         !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 11   '='                 ! -67 * S12 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S14 *  *  *  *  *  *  * 
 12   rhss                !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 13   '!'                 ! -68 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S14 *  *  *  *  *  *  * 
 14   symbols_or_actions  !  *  *  *  *  * -74 *  *  *  *  *  *  *  *  *  * S15 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  * -71 *  *  *  *  *  *  *  *  *  *  * 
 15   modifiers           !  *  *  *  *  *  * S16 *  * -79 *  *  *  *  *  *  *  *  * S18S22 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -80 *  *  *  *  *  *  *  *  *  * -81 *  *  *  * 
 16   action              !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S17 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 17   modifiers           !  *  *  *  *  *  *  *  *  * -79 *  *  *  *  *  *  *  *  * S18S22 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -80 *  *  *  *  *  *  *  *  *  * -81 *  *  *  * 
 18   <+red_aux>          !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 19   '('                 !  *  *  *  *  * -16 * -51 *  *  *  *  *  *  * S20 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 20   terminals           !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 21   ','                 !  *  *  *  *  * -16 * -52 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 22   <-red_aux>          !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 23   '('                 !  *  *  *  *  * -16 * -51 *  *  *  *  *  *  * S24 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 24   terminals           !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 25   '{'                 !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S26 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 26   modifiers           !  *  *  *  *  *  *  *  *  * -79 *  *  *  *  *  *  *  *  * S18S22 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -80 *  *  *  *  *  *  * S27 *  * -81 *  *  *  * 
 27   symbols_or_actions  !  *  *  *  *  * -74 *  *  *  *  *  *  *  *  *  * S28 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  * -71 *  *  *  *  *  *  *  *  *  *  * 
 28   modifiers           !  *  *  *  *  *  * S16 *  * -79 *  *  *  *  *  *  *  *  * S18S22 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -80 *  *  *  *  *  *  *  *  *  * -81 *  *  *  * 
 29   '('                 !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S35 *  *  *  *  *  *  *  *  *  *  *  *  * S30 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 30   Alternatives        !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 31   '|'                 !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S32 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 32   modifiers           !  *  *  *  *  *  *  *  *  * -79 *  *  *  *  *  *  *  *  * S18S22 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -80 *  *  *  *  *  *  * S33 *  * -81 *  *  *  * 
 33   symbols_or_actions  !  *  *  *  *  * -74 *  *  *  *  *  *  *  *  *  * S34 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  * -71 *  *  *  *  *  *  *  *  *  *  * 
 34   modifiers           !  *  *  *  *  *  * S16 *  * -79 *  *  *  *  *  *  *  *  * S18S22 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -80 *  *  *  *  *  *  *  *  *  * -81 *  *  *  * 
 35   modifiers           !  *  *  *  *  *  *  *  *  * -79 *  *  *  *  *  *  *  *  * S18S22 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -80 *  *  *  *  *  *  * S36 *  * -81 *  *  *  * 
 36   symbols_or_actions  !  *  *  *  *  * -74 *  *  *  *  *  *  *  *  *  * S37 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  * -71 *  *  *  *  *  *  *  *  *  *  * 
 37   modifiers           !  *  *  *  *  *  * S16 *  * -79 *  *  *  *  *  *  *  *  * S18S22 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -80 *  *  *  *  *  *  *  *  *  * -81 *  *  *  * 
 38   recovery_aux        !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S39 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 39   recovery_parts      !  *  *  *  * -38 *  *  * S48 *  *  * -45-44 *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S44 *  *  *  * -41-43S40 * -42 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 40   separator_aux       !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 41   '('                 !  *  *  *  *  * -16 * -51 *  *  *  *  *  *  * S42 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 42   terminals           !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 43   ')'                 !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 44   fiducial_aux        !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 45   '('                 !  *  *  *  *  * -16 * -51 *  *  *  *  *  *  * S46 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 46   terminals           !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 47   ')'                 !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 48   skip_aux            !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 49   '('                 !  *  *  *  *  * -16 * -51 *  *  *  *  *  *  * S50 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 50   terminals           !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 51   ')'                 !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 52   'META'              !  *  *  *  *  * -16 * -50 *  *  *  *  *  * S54 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17-47 *  *  *  * S53 *  *  *  *  *  *  *  *  *  *  *  * 
 53   meta_definitions    !  *  *  *  *  * -16 * -50 *  *  *  *  *  * S54 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17-48 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 54   meta_name           !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 55   '='                 !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 56   '('                 !  *  *  *  *  * -16 * -51 *  *  *  *  *  *  * S57 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 57   terminals           !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 58   ')'                 !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S59 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 59   repair_terminal     !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 60   '=>'                !  *  *  *  *  * -16 * -54 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 61   '%%ATTRIBUTES'      !  *  *  *  *  *  *  *  *  *  *  * -32 *  *  *  *  *  * S62 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 62   attributes          !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 63   ';'                 !  *  *  *  * -31 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 64   ','                 !  *  *  *  *  *  *  *  *  *  *  * -33 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 65   IDENTIFIER          !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -34 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 66   TERMINALS_aux       !  *  *  *  *  * -16 * S68 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  *  *  *  *  *  * -13 *  * S67 *  *  * 
 67   terminal_definitions!  *  *  *  * -11-16 * S68 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  *  *  *  *  *  * -14 *  *  *  *  *  * 
 68   terminal            !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 69   '='                 !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S70 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 70   token_code          !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S71 *  *  *  *  * 
 71   error_recovery_data !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 72   ','                 !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S73 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 73   insert_cost         !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 74   ','                 !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * S75 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 75   delete_cost         !  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -23 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 76   '=>'                !  *  *  *  *  * -16 * -29 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * -17 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 77   declaration_part    !  *  *  *  *  *  *  *  *  *  * -4  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 78   '%%CODE'            !  *  *  *  * -6  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 79   '%%DECLARATIONS'    !  *  *  *  * -8  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 80   '%%EXPORT'          !  *  *  *  * -87 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 81   '%%SCANNER'         !  *  *  *  * -88 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 82   '%%INSERTSYMBOL'    !  *  *  *  * -89 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
 83   SKIPHEADER          !  *  *  *  * -93 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 


           Summary of the table generation process
           ---------------------------------------

Number of states =   83
Total table space =  16134 bytes
     T-table =    5493 bytes
     NTS-table =  9984 bytes
     VOC-table =   657 bytes




               T H E   P A C K E D   A C T I O N   T A B L E


               Row Displacement Check Vector

Column       !  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
-------------!------------------------------------------------------------
Row Index    !  2 16 16 16  9  9 16  9 16 16 16 16 16 16 75 16 16 16 17 17 

Column       ! 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
-------------!------------------------------------------------------------
Row Index    ! 17 80 75 17  9 17 17 17 17 17 17 51 17 17 17 81 28 18 28 28 

Column       ! 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60
-------------!------------------------------------------------------------
Row Index    ! 28 80 80 80 72 80 80 72 80 80 80 80 80 80 82 81 81 81 68 81 

Column       ! 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80
-------------!------------------------------------------------------------
Row Index    ! 81 69 81 81 81 81 81 81 83 60 60 60 70 70 82 82 82 43 82 82 

Column       ! 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99100
-------------!------------------------------------------------------------
Row Index    !  1 82 82 82 82 82 82 12 83 83 83 12 83 83  3 83 83 83 83 83 

Column       !101102103104105106107108109110111112113114115116117118119120
-------------!------------------------------------------------------------
Row Index    ! 83  1  1 71  1  1 54  1  1  1  1  1  1 73  7  3  3 55  3  3 

Column       !121122123124125126127128129130131132133134135136137138139140
-------------!------------------------------------------------------------
Row Index    ! 44  3  3  3  3  3  3 31 31 31 23 23 23 22 31 31  7 31 31 65 

Column       !141142143144145146147148149150151152153154155156157158159160
-------------!------------------------------------------------------------
Row Index    ! 65 31 31 31 32 32 32 74 65 74 10 32 32 59 32 32 47 74 32 32 

Column       !161162163164165166167168169170171172173174175176177178179180
-------------!------------------------------------------------------------
Row Index    ! 32 33 33 33 66 66 66 61 33 33 48 33 33 62 62 33 33 33 35 35 

Column       !181182183184185186187188189190191192193194195196197198199200
-------------!------------------------------------------------------------
Row Index    ! 35 76 76 76 40 35 35 64 35 35  X  X 35 35 35 36 36 36 53 53 

Column       !201202203204205206207208209210211212213214215216217218219220
-------------!------------------------------------------------------------
Row Index    ! 53 53 36 36 15 36 36  5 15 36 36 36  X 15 15 15 53 53 53  X 

Column       !221222223224225226227228229230231232233234235236237238239240
-------------!------------------------------------------------------------
Row Index    ! 53 53  X  X 53 14 14 14  X  5 14 24 14 24 14  5 14  5  X 14 

Column       !241242243244245246247248249250251252253254255256257258259260
-------------!------------------------------------------------------------
Row Index    ! 14 14 11 11 11  X 46 11 46 11 30 11 30 11 58  X 11 11 11 13 

Column       !261262263264265266267268269270271272273274275276277278279280
-------------!------------------------------------------------------------
Row Index    ! 13 13 58 50 13 50 13 20 13 20 13  X  X 13 13 13 29 29 29 19 

Column       !281282283284285286287288289290291292293294295296297298299300
-------------!------------------------------------------------------------
Row Index    ! 19 19  X 29 29  X 29 29  X  X 29 29 29 27 27 27 41 41 41  X 

Column       !301302303304305306307308309310311312313314315316317318319320
-------------!------------------------------------------------------------
Row Index    ! 27 45 45 45 27 27  X 27 27 27 25 25 25 49 49 49  X 25  6  X 

Column       !321322323324325326327328329330331332333334335336337338339340
-------------!------------------------------------------------------------
Row Index    !  X 25 25  X 25 25 25 26 26 26 67 67 67 67 26 52 52 52 26 26 

Column       !341342343344345346347348349350351352353354355356357358359360
-------------!------------------------------------------------------------
Row Index    !  6 26 26 26 39  X  6 77  X  X 67 79 67 21 21 21  X 57 67 57 

Column       !361362363364365366367368369370371372373374375376377378379380
-------------!------------------------------------------------------------
Row Index    ! 67  X 39 39 39 38 39 39 77 77 39 79 79 79 78 77 77 77  X 79 

Column       !381382383384385386387388389390391392393394395396397398399400
-------------!------------------------------------------------------------
Row Index    ! 79 79  X 38 38 38  4 38 38  X  8 38  8 37 78 37 78 63  X 37 

Column       !401402403404405406407408409410411412413414415416417418419420
-------------!------------------------------------------------------------
Row Index    ! 37 37 78 78 78 34  X 34  4  X  X 34 34 34  4  4  4 63  X 63 

Column       !421422423424425426427428429430431432433434435436437438439440
-------------!------------------------------------------------------------
Row Index    ! 56 56 56  X 42 63 42  X  X  X  X  X  X  X  X  X  X  X  X  X 

Column       !441442443444445446447448449450451452
-------------!------------------------------------
Row Index    !  X  X  X  X  X  X  X  X  X  X  X  X 

               Row mapping vector

Row          !  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83
-------------!---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Index        ! 81  1 95387208319115390  5146242 82259225199  1 18 30279261353126130225310327293 24276242127144161397178195385366345177296418 72113301240151163313257 26335199102110420351249148 69167168398187134164331 54 58 67 98 41107144  9181348375352 22 36 55 69

               Compressed ACTION table

Index        !  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
-------------!------------------------------------------------------------
Entry        !  A R78R78R78R94-19R78-20R78R78R78R78R78R78R28R78R78R78R75R75

Index        ! 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
-------------!------------------------------------------------------------
Entry        ! R75R94S76R75-95R75R75R75R75R75R75-59R75-83-85R94-76S19-86-83

Index        ! 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60
-------------!------------------------------------------------------------
Entry        ! -85-95R94R94-25R94R94R24R94R94R94R94R94R94R94-95R94R94S69R94

Index        ! 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80
-------------!------------------------------------------------------------
Entry        ! R94-21R94R94R94R94R94R94R94-19-18-20R22S72-95R94R94-55R94R94

Index        ! 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99100
-------------!------------------------------------------------------------
Entry        ! R2 R94R94R94R94R94R94-65-95R94R94S13R94R94R7 R94R94R94R94R94

Index        !101102103104105106107108109110111112113114115116117118119120
-------------!------------------------------------------------------------
Entry        ! R94R2 R2 -15R2 R2 S55R2 R2 R2 R2 R2 R2 S74R61R7 R7 S56S80S83

Index        !121122123124125126127128129130131132133134135136137138139140
-------------!------------------------------------------------------------
Entry        ! S45S81R7 R7 R7 S79S82R78R78R78-19-18-20S23R78R78S8 R78R78R35

Index        !141142143144145146147148149150151152153154155156157158159160
-------------!------------------------------------------------------------
Entry        ! R35R78R78R78R70R70R70-27-36R26S11R70R70-49R70R70-57R26R70-83

Index        !161162163164165166167168169170171172173174175176177178179180
-------------!------------------------------------------------------------
Entry        ! -85-19-18-20-19-18-20S65S29R78S49R78S25S63S64R78R78R78R70R70

Index        !181182183184185186187188189190191192193194195196197198199200
-------------!------------------------------------------------------------
Entry        ! R70-19-18-20S41R70R70S65R70R70 X  X R70-83-85-19-18-20R46-19

Index        !201202203204205206207208209210211212213214215216217218219220
-------------!------------------------------------------------------------
Entry        ! -18-20S29R78R69R78S25R30R69R78R78R78 X -86-83-85R46R46R46 X 

Index        !221222223224225226227228229230231232233234235236237238239240
-------------!------------------------------------------------------------
Entry        ! R46R46 X  X R46-19-18-20 X R30R78S21S29-84R78R30S25S61 X R78

Index        !241242243244245246247248249250251252253254255256257258259260
-------------!------------------------------------------------------------
Entry        ! R78R78R70R70R70 X S21R70S47R70-77R70S31R70R53 X R70R70R70R70

Index        !261262263264265266267268269270271272273274275276277278279280
-------------!------------------------------------------------------------
Entry        ! R70R70S60S21R70S51R70S21R70-82R70 X  X R70R70R70R78R78R78-19

Index        !281282283284285286287288289290291292293294295296297298299300
-------------!------------------------------------------------------------
Entry        ! -18-20 X R78R78 X R78R78 X  X R78R78R78-19-18-20-19-18-20 X 

Index        !301302303304305306307308309310311312313314315316317318319320
-------------!------------------------------------------------------------
Entry        ! S29-19-18-20S25R78 X R78R78R78R78R78R78-19-18-20 X R78R37 X 

Index        !321322323324325326327328329330331332333334335336337338339340
-------------!------------------------------------------------------------
Entry        !  X R78R78 X R78R78R78R70R70R70R94-19-18-20R70-19-18-20R70R70

Index        !341342343344345346347348349350351352353354355356357358359360
-------------!------------------------------------------------------------
Entry        ! R37R70-83-85R94 X -39R5  X  X -95R94R94-19-18-20 X S21R94S58

Index        !361362363364365366367368369370371372373374375376377378379380
-------------!------------------------------------------------------------
Entry        ! R94 X S52-60-95R40R94-58S78R5 -56-95R94R94R94R5 R5 R5  X R94

Index        !381382383384385386387388389390391392393394395396397398399400
-------------!------------------------------------------------------------
Entry        ! R94R94 X R40R40R40R10R40R40 X -19R40-20R72-95R72R94R94 X -86

Index        !401402403404405406407408409410411412413414415416417418419420
-------------!------------------------------------------------------------
Entry        ! -83-85R94R94R94R73 X R73R10 X  X -86-83-85R10-12R10-95 X R94

Index        !421422423424425426427
-------------!---------------------
Entry        ! -19-18-20 X S21R94S43




                   T H E   P A C K E D   G O T O   T A B L E


               Row mapping vector

Row          !  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83
-------------!---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Index        ! 34 40 68165 34113 79170127 40 71 39 41138 34 51101 38191 38184 38132 38 65 36141 42 36 37 87 40179 80 55135 95123 34 35154 35 35 35159 35 35 35172 35 35112122 35 35185 35 38 34 71 39 34 35 71 69 90128 34 91 65 34104 34126129196 34161172179182198200

               Compressed GOTO table

Index        ! 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53
-------------!------------------------------------------------------------
Entry        !  X  X  X  X -38-31S16-68S48-79-4 -79-45-44S16-79-32-79S35S18

Index        ! 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73
-------------!------------------------------------------------------------
Entry        ! S22S18S22S62S2 S18S22S18S22S44-79S3 S30S17-41-43S40-67-42S12

Index        ! 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93
-------------!------------------------------------------------------------
Entry        ! S18S22-16-80-54-80S59S26-33-80S6 -80S16S27-81-79-81S33S14-3 

Index        ! 94 95 96 97 98 99100101102103104105106107108109110111112113
-------------!------------------------------------------------------------
Entry        ! -81-16-81S68-80S18S22S16-34S32-79-9 S36-90S70-81-79-17-91S77

Index        !114115116117118119120121122123124125126127128129130131132133
-------------!------------------------------------------------------------
Entry        ! S18S22S4 -16S71-50S18S22S14-80-92S73S54-16-64-50-17-62-11-16

Index        !134135136137138139140141142143144145146147148149150151152153
-------------!------------------------------------------------------------
Entry        ! -81S68S54-16-80-51-74S38-13-74-80S67-74S24S75-81S10S37-17-47

Index        !154155156157158159160161162163164165166167168169170171172173
-------------!------------------------------------------------------------
Entry        ! S15-81-23S28S53-16S39-51-17-48-16-6 -51-66-17S42S7 -63-17S9 

Index        !174175176177178179180181182183184185186187188189190191192193
-------------!------------------------------------------------------------
Entry        ! S46-17-8 -16-17-51-14-17-71-87-74-71-88S50-71-16-16-52-51S10

Index        !194195196197198199200201202203204205206207208209210211212213
-------------!------------------------------------------------------------
Entry        ! -17S34-16S66-51-17S57-16-89-29-93 X S20 X  X  X -66 X -17 X 

Index        !214215216217218219220221222223224225226227228229230231232233
-------------!------------------------------------------------------------
Entry        ! -1  X  X  X  X -17 X  X  X S5 -17-17-71 X  X  X  X -17 X  X 

Index        !234235236
-------------!---------
Entry        !  X  X -17



                    Summary of the packing process
                    ------------------------------

Total table space =   2823 bytes
     T-table   =  1487 bytes
     NTS-table =   679 bytes
     VOC-table =   657 bytes

+++++ pmk.pmt +++++
%%SET tmkTokenName("PmkToken")
%%SET tmkTokenCode("code")
%%SET tmkTokenSrcp("srcp")
%%SET tmkTokenDecl (" int code", " TmkSrcp srcp", " char *sval", " int ival", " long fpos", " long length")
%%SET tmkSrcpName("TmkSrcp")
%%SET tmkSrcpRow("line")
%%SET tmkSrcpCol("col")
%%SET tmkSrcpFile("file")
%%BEGIN(tmkImport)

#include "tmkCommon.h"
%%END(tmkImport)
%%SET tmkForce(0)
%%SET tmkOs("SunOS")
%%SET pmkOs("SunOS")
%%SET currentOs("SunOS")
%%SET tmkTarget("c")
%%SET pmkTarget("c")
%%SET tmkLibrary("%%(TMHOME)/lib/%%(tmkTarget)/")
%%SET pmkLibrary("..")
%%SET tmkPrefix("pmk")
%%SET parserPrefix("pmk")
%%SET listerPrefix("pmk")
%%SET tmkCodeDecl(" int code")
%%SET tmkGrmAttrDecl(" prod_elnode *rule_elnode_last", " prod_elnode *rule_elnode /* list of rhs elements (see prod_elnode's def) */", " rhs_node *rhslist_last /* last element in the list above. This used to
                                        to avoid making a reversed list */", " rhs_node *rhslist /* list of alternative righthand sides */", " altr_lst *altr_last", " altr_lst *altr_node /* list of alternatives (in EBNF alternation) */", " SymSet nored_set /* modifier sets */", " SymSet red_set /* modifier sets */", " int code /* terminals code value given in TERMINAL section */", " int dcost /* Delete cost given in TERMINAL section */", " int icost /* Insert cost given in TERMINAL section */", " Boolean n
ullf /* null flag */", " Boolean q_str /* quoted_ string flag */", " TmkSrcp srcp", " char *sval2", " char *sval", " int ival")
%%SET tmkGrmAttrNames("rule_elnode_last", "rule_elnode", "rhslist_last", "rhslist", "altr_last", "altr_node", "nored_set", "red_set", "code", "dcost", "icost", "nullf", "q_str", "srcp", "sval2", "sval", "ival")
%%BEGIN(pmkImport)


#include <stdio.h>

#include "pws.h"
#include "pmkList.h"
#include "pwsLexCode.h"
#include "set.h"
#include "pmk_i.h"
#include "tmk.h"
#include "pwSymSet.h"
#include "pwsGrm.h"
#include "pmkScan.h"
extern pmkContext pmkCtxt;
%%END(pmkImport)
%%PROCESS("%%(tmkLibrary)/Common.imp")
%%SET pmStackMax(32)
%%SET pmLookAheadMax(5)
%%SET pmCost(5)
%%BEGIN(pmIScan)
 pmkScan(pmkCtxt, token);
%%END(pmIScan)
%%BEGIN(pmISym)


    /* Create the requested token */
    sym->code = code;

    switch (code) {

    case 2:			/* IDENTIFIER */
    case 3:			/* QUOTED_STRING */
    case 4:			/* ANGLE_BRACKETED_STRING */
	if (*pstr != '\0') {
	    sym->sval = (char *)malloc(strlen(pstr) + 1);
	    strcpy(sym->sval, pstr);
	} else {
	    sym->sval = (char *)malloc(strlen(sstr) + 1);
	    strcpy(sym->sval, sstr);
	}/*if*/
	sym->ival = 0;
	break;

    case 5:			/* INTEGER */
	sym->ival = 0;
	break;
    }/*switch*/

%%END(pmISym)
%%SET pmOptimize(Lr0)
%%SET pmActPack(RDS)
%%SET pmGtoPack(RDS)
%%SET pmRec(Single, Multiple, Panic)
%%BEGIN(pmDecl)
static Boolean optimizeObsolete = FALSE;
StrListP grmAttrDecls, grmAttrNames;
CodeNodeP pmkImportSection = NULL,
	  exportSection = NULL,
	  declSection = NULL,
	  scannerSection = NULL,
	  insertSymbSection = NULL;

static search_kind searchResult; /* Variable used for lookup calls */
static SETDEF(sym_kind_set, unknown_symb + 1); /* For lookup calls */
int symRef;        /* Variable used for lookup calls */

static int i;
static attr_kind reading_attr_class = nts_attr; /* Type of attributes when reading */
                                     /* attribute section.              */
static SymSet occupied_code_values = NULL; /* Occupied terminal code values */
static SymSet terminals_set = NULL;        /* Variable used to read a list  */
                                            /* of terminals.                 */
static SymSet modify_intersect_set = NULL; /* Variable used to keep         */
                                            /* intersection of red and nored */
                                            /* sets modifiers.               */
static prod_elnode * temp_lhs;              /* lhs of current production     */
static char * syms_str;                  /* Variable used to construct    */
                                            /* error messages.               */
static char numStr[20];

/*-----------------------------------------------------------------------------
 * makeSymStr - makes a string of symbols in the set s separated by commas.
 *-----------------------------------------------------------------------------
 */
static char *makeSymStr(s)
SymSet s;
{
    char *temp;
    int totlen = 0;
    int nr = 0;
    int i;

    for (i = 0; i < SymSetSize(s); i++) {
	if (SymSetMem(s,i)) {
	    totlen += strlen(vocabulary[i]->name) + 3;
	}/*if*/
    }/*for*/

    temp = (char *)calloc(totlen, sizeof(char));
    nr=0;
    for (i = 0; i < SymSetSize(s); i++) {
	if (SymSetMem(s, i)) {
	    if (nr > 0) strcat(temp, ", ");
	    strcat(temp, vocabulary[i]->name);
	    nr++;
	}/*if*/
    }/*for*/
    return(temp);
}/*makeSymStr()*/

%%END(pmDecl)
%%SET pmStates(83)
%%SET pmStateTyp(1)
%%SET pmTerms(33)
%%SET pmTermTyp(1)
%%SET pmActTyp(2)
%%SET pmArgTyp(1)
%%SET pmActRDSvectorLen(427)
%%BEGIN(pmActTab)
{4,627,627,627,755,154,627,162,627,627,627,627,627,627,227,627,627,627,603
,603,603,755,609,603,762,603,603,603,603,603,603,474,603,666,682,755,610
,153,690,666,682,762,755,755,202,755,755,195,755,755,755,755,755,755,755
,762,755,755,553,755,755,170,755,755,755,755,755,755,755,154,146,162,179
,577,762,755,755,442,755,755,19,755,755,755,755,755,755,522,762,755,755
,105,755,755,59,755,755,755,755,755,755,19,19,122,19,19,441,19,19,19,19
,19,19,593,491,59,59,449,641,665,361,649,59,59,59,633,657,627,627,627,154
,146,162,185,627,627,65,627,627,283,283,627,627,627,563,563,563,218,290
,211,89,563,563,394,563,563,458,211,563,666,682,154,146,162,154,146,162
,521,233,627,393,627,201,505,513,627,627,627,563,563,563,154,146,162,329
,563,563,521,563,563,0,0,563,666,682,154,146,162,371,154,146,162,233,627
,555,627,201,243,555,627,627,627,0,690,666,682,371,371,371,0,371,371,0,0
,371,154,146,162,0,243,627,169,233,674,627,243,201,489,0,627,627,627,563
,563,563,0,169,563,377,563,618,563,249,563,427,0,563,563,563,563,563,563
,481,169,563,409,563,169,563,658,563,0,0,563,563,563,627,627,627,154,146
,162,0,627,627,0,627,627,0,0,627,627,627,154,146,162,154,146,162,0,233,154
,146,162,201,627,0,627,627,627,627,627,627,154,146,162,0,627,299,0,0,627
,627,0,627,627,627,563,563,563,755,154,146,162,563,154,146,162,563,563,299
,563,666,682,755,0,314,43,0,0,762,755,755,154,146,162,0,169,755,465,755
,0,417,482,762,323,755,466,625,43,450,762,755,755,755,43,43,43,0,755,755
,755,0,323,323,323,83,323,323,0,154,323,162,579,762,579,755,755,0,690,666
,682,755,755,755,587,0,587,83,0,0,690,666,682,83,98,83,762,0,755,154,146
,162,0,169,755,345}
%%END(pmActTab)
%%SET pmActRDScheckLen(452)
%%SET pmRDScheckTyp(1)
%%SET pmActRowMapTyp(2)
%%BEGIN(pmRDScheck)
{1,15,15,15,8,8,15,8,15,15,15,15,15,15,74,15,15,15,16,16,16,79,74,16,8,16
,16,16,16,16,16,50,16,16,16,80,27,17,27,27,27,79,79,79,71,79,79,71,79,79
,79,79,79,79,81,80,80,80,67,80,80,68,80,80,80,80,80,80,82,59,59,59,69,69
,81,81,81,42,81,81,0,81,81,81,81,81,81,11,82,82,82,11,82,82,2,82,82,82,82
,82,82,0,0,70,0,0,53,0,0,0,0,0,0,72,6,2,2,54,2,2,43,2,2,2,2,2,2,30,30,30
,22,22,22,21,30,30,6,30,30,64,64,30,30,30,31,31,31,73,64,73,9,31,31,58,31
,31,46,73,31,31,31,32,32,32,65,65,65,60,32,32,47,32,32,61,61,32,32,32,34
,34,34,75,75,75,39,34,34,63,34,34,83,83,34,34,34,35,35,35,52,52,52,52,35
,35,14,35,35,4,14,35,35,35,83,14,14,14,52,52,52,83,52,52,83,83,52,13,13
,13,83,4,13,23,13,23,13,4,13,4,83,13,13,13,10,10,10,83,45,10,45,10,29,10
,29,10,57,83,10,10,10,12,12,12,57,49,12,49,12,19,12,19,12,83,83,12,12,12
,28,28,28,18,18,18,83,28,28,83,28,28,83,83,28,28,28,26,26,26,40,40,40,83
,26,44,44,44,26,26,83,26,26,26,24,24,24,48,48,48,83,24,5,83,83,24,24,83
,24,24,24,25,25,25,66,66,66,66,25,51,51,51,25,25,5,25,25,25,38,83,5,76,83
,83,66,78,66,20,20,20,83,56,66,56,66,83,38,38,38,37,38,38,76,76,38,78,78
,78,77,76,76,76,83,78,78,78,83,37,37,37,3,37,37,83,7,37,7,36,77,36,77,62
,83,36,36,36,77,77,77,33,83,33,3,83,83,33,33,33,3,3,3,62,83,62,55,55,55
,83,41,62,41,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83
,83,83,83,83,83}
%%END(pmRDScheck)
%%BEGIN(pmActRowMap)
{80,0,94,386,207,318,114,389,4,145,241,81,258,224,198,0,17,29,278,260,352
,125,129,224,309,326,292,23,275,241,126,143,160,396,177,194,384,365,344
,176,295,417,71,112,300,239,150,162,312,256,25,334,198,101,109,419,350,248
,147,68,166,167,397,186,133,163,330,53,57,66,97,40,106,143,8,180,347,374
,351,21,35,54,68}
%%END(pmActRowMap)
%%BEGIN(pmContTab)
{{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{2,2}
,{1,1}
,{6,6}
,{2,2}
,{7,7}
,{2,2}
,{7,7}
,{7,7}
,{2,2}
,{2,2}
,{9,9}
,{2,2}
,{10,10}
,{2,2}
,{9,9}
,{2,2}
,{10,10}
,{2,2}
,{2,2}
,{14,14}
,{14,14}
,{2,2}
,{10,10}
,{2,2}
,{2,2}
,{10,10}
,{10,10}
,{2,2}
,{10,10}
,{10,10}
,{1,1}
,{1,1}
,{9,9}
,{2,2}
,{10,10}
,{7,7}
,{9,9}
,{2,2}
,{10,10}
,{7,7}
,{9,9}
,{2,2}
,{10,10}
,{7,7}
,{2,2}
,{1,1}
,{6,6}
,{9,9}
,{2,2}
,{10,10}
,{7,7}
,{7,7}
,{2,2}
,{2,2}
,{7,7}
,{1,1}
,{2,2}
,{7,7}
,{2,2}
,{1,1}
,{6,6}
,{5,5}
,{7,7}
,{7,7}
,{8,8}
,{8,8}
,{7,7}
,{7,7}
,{2,2}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
}
%%END(pmContTab)
%%BEGIN(pmSeparators)
{0,0,0,0,0}
%%END(pmSeparators)
%%BEGIN(pmFiducials)
{0,0,0,0,0}
%%END(pmFiducials)
%%BEGIN(pmSkips)
{0,0,0,0,0}
%%END(pmSkips)
%%SET pmNonTerms(59)
%%SET pmNonTermTyp(1)
%%SET pmGtoTyp(2)
%%SET pmGtoRDSvectorLen(203)
%%BEGIN(pmGtoTab)
{0,0,0,0,306,250,129,546,385,634,34,634,362,354,129,634,258,634,281,145
,177,145,177,497,17,145,177,145,177,353,634,25,241,137,330,346,321,538,338
,97,145,177,130,642,434,642,473,209,266,642,49,642,129,217,650,634,650,265
,113,26,650,130,650,545,642,145,177,129,274,257,634,74,289,722,561,650,634
,138,730,617,145,177,33,130,569,402,145,177,113,642,738,585,433,130,514
,402,138,498,90,130,650,545,433,130,642,410,594,305,106,594,642,537,594
,193,601,650,81,297,138,378,121,650,186,225,425,130,313,410,138,386,130
,50,410,530,138,337,57,506,138,73,369,138,66,130,138,410,114,138,570,698
,594,570,706,401,570,130,130,418,410,81,138,273,130,529,410,138,457,130
,714,234,746,0,161,0,0,0,530,0,138,0,10,0,0,0,0,138,0,0,0,41,138,138,570
,0,0,0,0,138,0,0,0,0,138}
%%END(pmGtoTab)
%%SET pmGtoRowMapTyp(1)
%%BEGIN(pmGtoRowMap)
{0,6,34,131,0,79,45,136,93,6,37,5,7,104,0,17,67,4,157,4,150,4,98,4,31,2
,107,8,2,3,53,6,145,46,21,101,61,89,0,1,120,1,1,1,125,1,1,1,138,1,1,78,88
,1,1,151,1,4,0,37,5,0,1,37,35,56,94,0,57,31,0,70,0,92,95,162,0,127,138,145
,148,164,166}
%%END(pmGtoRowMap)
%%SET pmProds(95)
%%SET pmLhsTyp(1)
%%SET pmRhszTyp(1)
%%BEGIN(pmLhs)
{58,65,65,82,44,44,79,79,83,92,92,66,89,89,86,41,39,39,74,74,51,87,87,55
,55,56,56,61,61,84,84,52,52,45,67,67,91,91,62,71,71,68,68,68,68,46,80,80
,75,48,49,49,76,76,72,70,69,63,47,42,60,60,37,37,35,57,36,36,34,85,85,64
,64,81,81,81,81,50,50,43,43,77,53,88,54,40,73,78,90,59,59,59,59,38,38}
%%END(pmLhs)
%%BEGIN(pmRhsz)
{3,0,2,2,0,2,0,2,4,0,3,1,1,2,5,1,1,1,1,1,1,0,5,0,1,0,1,0,2,0,4,1,3,2,0,1
,0,3,1,0,2,1,1,1,1,2,1,2,7,1,1,3,0,2,5,1,5,1,5,1,0,3,1,2,4,1,1,3,2,0,2,3
,5,1,3,5,3,0,2,1,1,4,1,4,1,1,2,2,2,1,1,1,2,0,1}
%%END(pmRhsz)
%%SET pmSccMax(33)
%%SET pmSccTyp(1)
%%SET pmICostTyp(1)
%%SET pmDCostTyp(1)
%%BEGIN(pmVocTab)
{{1,255,255,"EndOfText",""}
,{2,1,1,"IDENTIFIER","identifier"}
,{3,1,1,"STRING",""}
,{4,1,1,"ANG_BRACK_STRING",""}
,{5,1,1,"INTEGER",""}
,{6,1,1,"'='",""}
,{7,1,1,"';'",""}
,{8,1,1,"','",""}
,{9,1,1,"'('",""}
,{10,1,1,"')'",""}
,{11,1,1,"'!'",""}
,{12,1,1,"'|'",""}
,{13,1,1,"'{'",""}
,{14,1,1,"'}'",""}
,{15,1,1,"'=>'",""}
,{16,1,1,"'`%`%'",""}
,{17,1,1,"'`%+'",""}
,{18,1,1,"'`%-'",""}
,{19,1,1,"'META'",""}
,{20,1,1,"'SKIP'",""}
,{21,1,1,"'`%`%END'",""}
,{22,1,1,"'`%`%CODE'",""}
,{23,1,1,"'`%`%RULES'",""}
,{24,1,1,"'FIDUCIAL'",""}
,{25,1,1,"'`%`%EXPORT'",""}
,{26,1,1,"SKIPHEADER",""}
,{27,1,1,"'SEPARATOR'",""}
,{28,1,1,"'`%`%SCANNER'",""}
,{29,1,1,"'`%`%RECOVERY'",""}
,{30,1,1,"'`%`%TERMINALS'",""}
,{31,1,1,"'`%`%ATTRIBUTES'",""}
,{32,1,1,"'`%`%DECLARATIONS'",""}
,{33,1,1,"'`%`%INSERTSYMBOL'",""}
}
%%END(pmVocTab)
%%SET pmSem(On)
%%BEGIN(pmSemantics)
    switch (rule) {
          case 4: { /* program_paragraph = declaration_part code_part; */

	    init_action_structs(TRUE);
	  	break;}
    case 8: { /* declaration_part = '`%`%DECLARATIONS' endOpt; */

	  if (declSection)
	    pmkLog(%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp, 60, sevERR, "");
	  else
  	    declSection = tmkNewCode(%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].fpos, %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].length);
		break;}
    case 9: { /* grammar_paragraph = scanner_interface_section attribute_section error_handling_section rule_section; */

	    if (!SeriousErr) order_gram();
	  	break;}
    case 10: { /* scanner_interface_section =; */

	    term_sec_given = FALSE;
	  	break;}
    case 12: { /* TERMINALS_aux = '`%`%TERMINALS'; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ival = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].ival;
	    occupied_code_values = SymSetAlloc();
	    SymSetIns(occupied_code_values, 0);
	    SymSetIns(occupied_code_values, 1);
	    term_sec_given = TRUE;
	  	break;}
    case 15: { /* terminal_definition = terminal '=' token_code error_recovery_data ';'; */

	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, t_symb);
	    lookup(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval, sym_kind_set, &symRef, &searchResult);
	    if (searchResult == new_search || searchResult == found_search) {
		if (searchResult == found_search) {
		    /* ERROR terminal defined twice, old definition overridden
		     */
		    pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, 121, sevWAR,
			  vocabulary[symRef]->name);
		}/*if*/
		vocabulary[symRef]->symbol_typ = t_symb;
		vocabulary[symRef]->code = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].ival;
		SymSetIns(occupied_code_values, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].ival);
		if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].ival > tc_val) tc_val = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].ival;

		if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].nullf)) {
		    vocabulary[symRef]->syminfo.ter_info.icost =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].icost;
		    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].icost > icostMax) {
			icostMax = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].icost;
		    }/*if*/
		    vocabulary[symRef]->syminfo.ter_info.dcost =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].dcost;
		    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].dcost > dcostMax) {
			dcostMax = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].dcost;
		    }/*if*/
		    vocabulary[symRef]->syminfo.ter_info.psymb =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].sval;
  		} else {
		    vocabulary[symRef]->syminfo.ter_info.icost = 1;
		    vocabulary[symRef]->syminfo.ter_info.dcost = 1;
		    vocabulary[symRef]->syminfo.ter_info.psymb = NULL;
		}/*if*/
	    } else if (searchResult == confl_search) {
		/* ERROR Ambiguous symbol, Terminal expected.
		 * This error should'nt happen since no other
		 * symbol kinds can ocurr before scanner interface.
		 */
     		pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, 123, sevSYS,
		      vocabulary[symRef]->name);
	    }/*if*/
	  	break;}
    case 17: { /* symbol = term_or_nonterm; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].q_str = FALSE;
	  	break;}
    case 18: { /* symbol = STRING; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].sval;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].q_str = TRUE;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp;
	  	break;}
    case 19: { /* term_or_nonterm = IDENTIFIER; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].sval;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp;
	  	break;}
    case 20: { /* term_or_nonterm = ANG_BRACK_STRING; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].sval;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp;
	  	break;}
    case 21: { /* token_code = INTEGER; */

	    if (SymSetMem(occupied_code_values, %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].ival)) {
		/* ERROR Terminal code already in use
		 */
		sprintf(numStr, "`%u", %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].ival);
		pmkLog(&%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp, 120, sevERR, numStr);
	    } else {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].ival = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].ival;
	    }/*if*/
	  	break;}
    case 22: { /* error_recovery_data =; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = TRUE;
	  	break;}
    case 23: { /* error_recovery_data = ',' insert_cost ',' delete_cost print_symbol; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].icost = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].icost;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].dcost = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].dcost;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].sval;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = FALSE;
	  	break;}
    case 24: { /* insert_cost =; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].icost = 1;
	  	break;}
    case 25: { /* insert_cost = INTEGER; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].icost = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].ival;
	  	break;}
    case 26: { /* delete_cost =; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].dcost = 1;
	  	break;}
    case 27: { /* delete_cost = INTEGER; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].dcost = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].ival;
	  	break;}
    case 28: { /* print_symbol =; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval = NULL;
	  	break;}
    case 29: { /* print_symbol = '=>' terminal; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].sval;
	  	break;}
    case 32: { /* attributes = attribute; */

	  grmAttrDecls = appendStrList(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval, NULL);
	  grmAttrNames = appendStrList(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval2, NULL);
		break;}
    case 33: { /* attributes = attributes ',' attribute; */

	  grmAttrDecls = appendStrList(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].sval, grmAttrDecls);
	  grmAttrNames = appendStrList(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].sval2, grmAttrNames);
		break;}
    case 34: { /* attribute = IDENTIFIER optional_decl; */

            %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].sval;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval2 = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].sval;
	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, attr_symb);
	    lookup(%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].sval, sym_kind_set, &symRef, &searchResult);
	    if (new_search == searchResult) {
		vocabulary[symRef]->symbol_typ = attr_symb;
		vocabulary[symRef]->syminfo.attr_class = nts_attr;
	    } else if (found_search == searchResult) {
  		if (vocabulary[symRef]->syminfo.attr_class != nts_attr &&	
		    vocabulary[symRef]->syminfo.attr_class != unk_attr)	{
		    vocabulary[symRef]->syminfo.attr_class = voc_attr;
		} else if (vocabulary[symRef]->syminfo.attr_class == nts_attr) {
		    /* ERROR Attribute defined twice
		     */
		    pmkLog(&%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp, 119, sevWAR, %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].sval);
		}/*if*/
	    } else {
		/* ERROR Ambiguous symbol. Attribute expected.
		 */
    		pmkLog(&%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp, 118, sevERR, %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].sval);
	    }/*if*/
	  	break;}
    case 35: { /* optional_decl =; */

	  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval = NULL;
		break;}
    case 36: { /* optional_decl = '`%`%'; */

	  %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].sval;
		break;}
    case 51: { /* terminals = terminal; */

	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, t_symb);
	    lookup(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval, sym_kind_set, &symRef, &searchResult);
	    if (new_search == searchResult || searchResult == found_search) {
		if (searchResult == new_search) {
		    vocabulary[symRef]->symbol_typ = t_symb;
		    vocabulary[symRef]->syminfo.ter_info.icost = 1;
		    vocabulary[symRef]->syminfo.ter_info.dcost = 1;
		    vocabulary[symRef]->syminfo.ter_info.psymb = NULL;
		}/*if*/
		SymSetIns(terminals_set, symRef);
	    } else if (searchResult == confl_search) {
		/* ERROR Ambiguous symbol, Terminal expected.
		 */
		pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, 117, sevERR, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval);
		SymSetIns(terminals_set, symRef);
	    }/*if*/
	  	break;}
    case 52: { /* terminals = terminals ',' terminal; */

	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, t_symb);
	    lookup(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].sval, sym_kind_set, &symRef, &searchResult);
	    if (new_search == searchResult || searchResult == found_search) {
		if (searchResult == new_search) {
		    vocabulary[symRef]->symbol_typ = t_symb;
		    vocabulary[symRef]->syminfo.ter_info.icost = 1;
		    vocabulary[symRef]->syminfo.ter_info.dcost = 1;
		    vocabulary[symRef]->syminfo.ter_info.psymb = NULL;
		}/*if*/
		SymSetIns(terminals_set, symRef);
	    } else if (searchResult == confl_search) {
		/* ERROR Ambiguous symbol, Terminal expected.
		 */
		pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].srcp, 117, sevERR, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].sval);
		SymSetIns(terminals_set, symRef);
	    }/*if*/
	  	break;}
    case 55: { /* separator_part = separator_aux '(' terminals ')' ';'; */

	    recovery_spec.separators = terminals_set;
	  	break;}
    case 56: { /* separator_aux = 'SEPARATOR'; */

	    terminals_set = SymSetAlloc();
	  	break;}
    case 57: { /* fiducial_part = fiducial_aux '(' terminals ')' ';'; */

	    recovery_spec.fiducials = terminals_set;
	  	break;}
    case 58: { /* fiducial_aux = 'FIDUCIAL'; */

	    terminals_set = SymSetAlloc();
	  	break;}
    case 59: { /* skip_part = skip_aux '(' terminals ')' ';'; */

	    recovery_spec.skips = terminals_set;
	  	break;}
    case 60: { /* skip_aux = 'SKIP'; */

	    terminals_set = SymSetAlloc();
	  	break;}
    case 65: { /* rule = nonterminal '=' rhss ';'; */

	    /* Main routine for analysis of rhss associated with a single lhs
	     */
	    if (!SeriousErr) analyze_rhss(temp_lhs, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rhslist);
	  	break;}
    case 66: { /* nonterminal = term_or_nonterm; */

	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, nts_symb);
	    lookup(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval, sym_kind_set, &symRef,
		   &searchResult);
	    if (new_search == searchResult) {
		vocabulary[symRef]->symbol_typ = nts_symb;
		vocabulary[symRef]->syminfo.firstp = -1;
	    }/*if*/
	    temp_lhs = prod_elnodeAlloc();
	    temp_lhs->node_kind = sym_node_kind;
	    temp_lhs->node_info.sym_node.sym_ind = symRef;
	    temp_lhs->node_info.sym_node.lhs_sym = TRUE;
	    temp_lhs->node_info.sym_node.newnont = FALSE;
	    if (confl_search == searchResult) {
		pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, 116, sevERR,
		      %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval);
	    }/*if*/
	  	break;}
    case 67: { /* rhss = rhs; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rhslist_last = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rhslist;
	  	break;}
    case 68: { /* rhss = rhss '!' rhs; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rhslist_last->nxtrhs = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rhslist;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rhslist = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rhslist;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rhslist_last = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rhslist;
	  	break;}
    case 69: { /* rhs = symbols_or_actions modifiers; */

	    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf) {
		/* Allocated a null node
		 */
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_kind = null_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode;
	    }/*if*/
	    if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nullf)) {
		/* Allocate a modifier node
		 */
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode->node_kind = mod_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode->node_info.modify_node->red =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].red_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode->node_info.modify_node->nored =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nored_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last->nxtnode =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode;
	    }/*if*/

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rhslist = rhs_nodeAlloc();
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rhslist->rhs = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode;
	  	break;}
    case 70: { /* symbols_or_actions =; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = TRUE;
	  	break;}
    case 71: { /* symbols_or_actions = symbols_or_actions symbol_or_action; */

	    /* Make list
	     */
	    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf) {
		if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nullf) {
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = TRUE;
		} else {
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = FALSE;
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode;
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode_last;
		}/*if*/
	    } else if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nullf) {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = FALSE;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last;
	    } else {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = FALSE;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last->nxtnode =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode_last;
	    }/*if*/
	  	break;}
    case 73: { /* Alternatives = Alternatives '|' modifiers symbols_or_actions modifiers; */

	    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].nullf) {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode->node_kind = null_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode_last =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode;
		if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].nullf) && !(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nullf)) {
		    /* Test red and nored sets intersection
		     */
		    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].red_set != NULL &&
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].nored_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].red_set, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].srcp, 113, sevERR, syms_str);
			    free(syms_str);
			    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].red_set = NULL;
			}/*if*/
		    }/*if*/
		    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nored_set != NULL &&
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].red_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].red_set, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].srcp, 113, sevERR, syms_str);
			    free(syms_str);
			    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].red_set = NULL;
			}/*if*/
		    }/*if*/
		}/*if*/
	    }/*if*/

	    /* Make list
	     */
	    if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].nullf)) {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].rule_elnode->node_kind = mod_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].rule_elnode->node_info.modify_node->red =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].red_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].rule_elnode->node_info.modify_node->nored =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].nored_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode_last->nxtnode =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode_last = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+5].rule_elnode;
	    }/*if*/

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_last->nxtalt = altr_lstAlloc();

	    if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nullf)) {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_kind = mod_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_info.modify_node->red =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].red_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_info.modify_node->nored =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nored_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->nxtnode =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_last->nxtalt->altr =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode;
	    } else {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_last->nxtalt->altr =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode;
	    }/*if*/

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_node = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_node;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_last = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_last->nxtalt;
	  	break;}
    case 72: { /* Alternatives = modifiers symbols_or_actions modifiers; */

	    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nullf) {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode->node_kind = null_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode_last =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode;
		if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nullf) && !(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf)) {
		    /* Test red and nored sets intersection
		     */
		    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set != NULL &&
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nored_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].srcp, 113, sevERR, syms_str);
			    free(syms_str);
			    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set = NULL;
			}/*if*/
		    }/*if*/

		    /* Test red and nored sets intersection
		     */
		    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set != NULL &&
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].red_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].srcp,113,sevERR,syms_str);
			    free(syms_str);
			    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set = NULL;
			}/*if*/
		    }/*if*/
		}/*if*/
	    }/*if*/

	    if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nullf)) {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_kind = mod_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_info.modify_node->red =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].red_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_info.modify_node->nored =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nored_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode_last->nxtnode =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode_last =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode;
	    }/*if*/

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_node = altr_lstAlloc();

	    if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf)) {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_kind = mod_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.modify_node->red =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.modify_node->nored =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->nxtnode =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_node->altr = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode;
	    } else {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_node->altr =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode;
	    }/*if*/

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_last = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].altr_node;
	  	break;}
    case 74: { /* symbol_or_action = symbol; */

	    SetClear(sym_kind_set, unknown_symb + 1);
	    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].q_str) {
		SetIns(sym_kind_set, t_symb);
	    } else {
		SetIns(sym_kind_set, t_symb);
		SetIns(sym_kind_set, nts_symb);
	    }/*if*/

	    lookup(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval, sym_kind_set, &symRef, &searchResult);
	    if (confl_search == searchResult) {
		/* ERROR Ambiguous symbol Terminal or non terminal expected
		 */
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = TRUE;
		pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp, 115, sevERR, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].sval);
	    } else {
		SymSetIns(on_right, symRef);
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_kind = sym_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.sym_ind =
		    symRef;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.lhs_sym =
		    FALSE;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.newnont =
		    FALSE;
		SymSetIns(on_right, symRef);
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = FALSE;
	    }/*if*/
	  	break;}
    case 76: { /* symbol_or_action = '{' modifiers symbols_or_actions modifiers '}'; */

	    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nullf) {
		/* ERROR Repetition of Null string ignored
		 */
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = TRUE;
		pmkLog(&%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp,114,sevWAR,"");
	    } else {
		/* Generate a new symbol node (with a new symbol).
		 * Keep symbols_or_actions's rule_nodelist in the symbol node
		 */
		SetClear(sym_kind_set, unknown_symb + 1);
		SetIns(sym_kind_set, nts_symb);
		lookup(gensym(), sym_kind_set, &symRef, &searchResult);
		vocabulary[symRef]->symbol_typ = nts_symb;
		vocabulary[symRef]->syminfo.firstp = -1;
		if (confl_search == searchResult ||
		    found_search == searchResult)
		{
		    /* This should'nt happen
		     */
		    printf(
"Non terminal generated by PMK is equal to user's symbol");
		}/*if*/

		/* Make list
		 */
		if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].nullf)) {
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode = prod_elnodeAlloc();
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode->node_kind = mod_node_kind;
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode->node_info.modify_node =
			modify_recAlloc();
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode->node_info.modify_node->red =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].red_set;
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode->node_info.modify_node->nored =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].nored_set;
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode_last->nxtnode =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode;
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode_last =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+4].rule_elnode;
		}/*if*/
		SymSetIns(on_right, symRef);
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_kind = sym_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.sym_ind =
		    symRef;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.newnont =
		    TRUE;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.rplc_info =
		    rept_rplc;
		if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nullf)) {
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode = prod_elnodeAlloc();
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode->node_kind = mod_node_kind;
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode->node_info.modify_node =
			modify_recAlloc();
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode->node_info.modify_node->red =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].red_set;
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode->node_info.modify_node->nored =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nored_set;
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode->nxtnode =
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode;
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.rplc_seq=
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode;
		} else {
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.rplc_seq=
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode;
		}/*if*/
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = FALSE;
	    }/*if*/
	  	break;}
    case 77: { /* symbol_or_action = '(' Alternatives ')'; */

	    /* Generate a new symbol node (with a new symbol)
	     * keep symbols_or_actions's rule_nodelist in the symbol node
	     */
	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, nts_symb);
	    lookup(gensym(), sym_kind_set, &symRef, &searchResult);
	    vocabulary[symRef]->symbol_typ = nts_symb;
	    vocabulary[symRef]->syminfo.firstp = -1;
	    if (confl_search == searchResult || found_search == searchResult) {
		/* This should'nt happen
		 */
		printf(
"Non terminal generated by PMK is equal to user's symbol");
	    }/*if*/

	    /* Make list
	     */
	    SymSetIns(on_right, symRef);
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode = prod_elnodeAlloc();
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_kind = sym_node_kind;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.sym_ind = symRef;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.newnont = TRUE;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.rplc_info =
		altrs_rplc;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.sym_node.altrs_seq =
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].altr_node;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = FALSE;
	  	break;}
    case 75: { /* symbol_or_action = modifiers action modifiers; */

	    if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nullf) && !(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf)) {
		/* Test red and nored sets intersection
		 */
		if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set != NULL &&
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nored_set != NULL)
		{
		    if (modify_intersect_set == NULL) {
			modify_intersect_set = SymSetAlloc();
		    }/*if*/
		    SymSetClear(modify_intersect_set);
		    SymSetInter(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set,
				modify_intersect_set);
		    if (!(SymSetEmpty(modify_intersect_set))) {
			syms_str = makeSymStr(modify_intersect_set);
			pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].srcp, 113, sevERR, syms_str);
			free(syms_str);
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set = NULL;
		    }/*if*/
		}/*if*/
		if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set != NULL &&
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].red_set != NULL)
		{
		    if (modify_intersect_set == NULL) {
			modify_intersect_set = SymSetAlloc();
		    }/*if*/
		    SymSetClear(modify_intersect_set);
		    SymSetInter(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set,
				modify_intersect_set);
		    if (!(SymSetEmpty(modify_intersect_set))) {
			syms_str = makeSymStr(modify_intersect_set);
			pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].srcp, 113, sevERR, syms_str);
			free(syms_str);
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set = NULL;
		    }/*if*/
		}/*if*/
	    }/*if*/
     
	    if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nullf)) {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_kind = mod_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_info.modify_node->red =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].red_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode->node_info.modify_node->nored =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].nored_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode->nxtnode = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode_last = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].rule_elnode;
	    }/*if*/

	    if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf)) {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode = prod_elnodeAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_kind = mod_node_kind;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.modify_node->red =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.modify_node->nored =
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->nxtnode = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode_last;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = FALSE;
	    } else {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].rule_elnode_last;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = FALSE;
	    }/*if*/
	  	break;}
    case 78: { /* modifiers =; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = TRUE;
	  	break;}
    case 79: { /* modifiers = modifiers modifier; */

	    /* Merge modifier sets
	     */
	    if (!(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf)) {
		if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set == NULL) {
		    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].red_set != NULL) {
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].red_set;
		    }/*if*/
		} else if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].red_set == NULL) {
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set;
		} else {
		    SymSetUnion(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].red_set,
				%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set);
		}/*if*/
		if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set == NULL) {
		    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nored_set != NULL) {
			%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nored_set;
		    }/*if*/
		} else if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nored_set == NULL) {
		    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set;
		} else {
		    SymSetUnion(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nored_set,
				%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set);
		}/*if*/
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = FALSE;
	    } else {
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].red_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].nored_set;
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nullf = FALSE;
	    }/*if*/

	    /* Test red and nored sets intersection
	     */
	    if (%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set != NULL &&
		%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set != NULL)
	    {
		if (modify_intersect_set == NULL) {
		    modify_intersect_set = SymSetAlloc();
		}/*if*/
		SymSetClear(modify_intersect_set);
		SymSetInter(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set, %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set,
			    modify_intersect_set);
		if (!(SymSetEmpty(modify_intersect_set))) {
		     syms_str = makeSymStr(modify_intersect_set);
		     pmkLog(&%%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].srcp, 113, sevERR, syms_str);
		     free(syms_str);
		     %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set = NULL;
		}/*if*/
	    }/*if*/
	  	break;}
    case 80: { /* modifier = reduce_modifier; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set = NULL;
	  	break;}
    case 81: { /* modifier = reduce_not_modifier; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set = NULL;
	  	break;}
    case 82: { /* reduce_modifier = <+red_aux> '(' terminals ')'; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].red_set = terminals_set;
	  	break;}
    case 83: { /* <+red_aux> = '`%+'; */

	    terminals_set = SymSetAlloc();
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp;
	  	break;}
    case 84: { /* reduce_not_modifier = <-red_aux> '(' terminals ')'; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].nored_set = terminals_set;
	  	break;}
    case 85: { /* <-red_aux> = '`%-'; */

	    terminals_set = SymSetAlloc();
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].srcp = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp;
	  	break;}
    case 86: { /* action = '`%`%'; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode = prod_elnodeAlloc();
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_kind = act_node_kind;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.act_node.act_srcp = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.act_node.act_start = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].fpos;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode->node_info.act_node.act_length = %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].length;
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode_last = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].rule_elnode;
	  	break;}
    case 87: { /* export_section = '`%`%EXPORT' endOpt; */

	  if (exportSection)
	    pmkLog(%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp, 60, sevERR, "");
	  else
  	    exportSection = tmkNewCode(%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].fpos, %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].length);
		break;}
    case 88: { /* scanner_section = '`%`%SCANNER' endOpt; */

	  if (scannerSection)
	    pmkLog(%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp, 60, sevERR, "");
	  else
  	    scannerSection = tmkNewCode(%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].fpos, %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].length);
		break;}
    case 89: { /* insertsymbol_section = '`%`%INSERTSYMBOL' endOpt; */

	  if (insertSymbSection)
	    pmkLog(%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].srcp, 60, sevERR, "");
	  else
  	    insertSymbSection = tmkNewCode(%%(parserPrefix)SySt[%%(parserPrefix)StkP+1].fpos, %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].length);
		break;}
%%END(pmSemantics)
%%SET vocFileName ("pmk.voc")
%%BEGIN (pmVoc)
   0    0 Unknown                   main
   1    1 EndOfText                 main
   2    2 IDENTIFIER                main
   3    3 STRING                    main
   4    4 ANG_BRACK_STRING          main
   5    5 INTEGER                   main
   6    6 '='                       main
   7    7 ';'                       main
   8    8 ','                       main
   9    9 '('                       main
  10   10 ')'                       main
  11   11 '!'                       main
  12   12 '|'                       main
  13   13 '{'                       main
  14   14 '}'                       main
  15   15 '=>'                      main
  16   16 '`%`%'                      main
  17   17 '`%+'                      main
  18   18 '`%-'                      main
  19   19 'META'                    main
  20   20 'SKIP'                    main
  21   21 '`%`%END'                   main
  22   22 '`%`%CODE'                  main
  23   23 '`%`%RULES'                 main
  24   24 'FIDUCIAL'                main
  25   25 '`%`%EXPORT'                main
  26   26 SKIPHEADER                main
  27   27 'SEPARATOR'               main
  28   28 '`%`%SCANNER'               main
  29   29 '`%`%RECOVERY'              main
  30   30 '`%`%TERMINALS'             main
  31   31 '`%`%ATTRIBUTES'            main
  32   32 '`%`%DECLARATIONS'          main
  33   33 '`%`%INSERTSYMBOL'          main
%%END (pmVoc)
%%PROCESS("%%(pmkLibrary)/Parse.imp")
%%PROCESS("%%(pmkLibrary)/Err.imp")
+++++ pmk.voc +++++
   0    0 Unknown                   main
   1    1 EndOfText                 main
   2    2 IDENTIFIER                main
   3    3 STRING                    main
   4    4 ANG_BRACK_STRING          main
   5    5 INTEGER                   main
   6    6 '='                       main
   7    7 ';'                       main
   8    8 ','                       main
   9    9 '('                       main
  10   10 ')'                       main
  11   11 '!'                       main
  12   12 '|'                       main
  13   13 '{'                       main
  14   14 '}'                       main
  15   15 '=>'                      main
  16   16 '%%'                      main
  17   17 '%+'                      main
  18   18 '%-'                      main
  19   19 'META'                    main
  20   20 'SKIP'                    main
  21   21 '%%END'                   main
  22   22 '%%CODE'                  main
  23   23 '%%RULES'                 main
  24   24 'FIDUCIAL'                main
  25   25 '%%EXPORT'                main
  26   26 SKIPHEADER                main
  27   27 'SEPARATOR'               main
  28   28 '%%SCANNER'               main
  29   29 '%%RECOVERY'              main
  30   30 '%%TERMINALS'             main
  31   31 '%%ATTRIBUTES'            main
  32   32 '%%DECLARATIONS'          main
  33   33 '%%INSERTSYMBOL'          main
+++++ pmkCommon.h +++++
#ifndef _pmkCommon_H_
#define _pmkCommon_H_
/* pmkCommon.h

   Common definitions for pmk

   This file is generated from information in 'pmk.tmk'

*/

/* The import section (%%IMPORT) */

#include "tmkCommon.h"

/* The source position type (%%SRCP) */

      /* ... must be imported! */


/* The token type (%%TOKEN) */

typedef struct PmkToken {
    int code;
    TmkSrcp srcp;
    char *sval;
    int ival;
    long fpos;
    long length;
} PmkToken;

#endif

+++++ pmkErr.c +++++
/*----------------------------------------------------------------------*\

  pmkErr.c

  Parser error handler 

\*----------------------------------------------------------------------*/

/* %%IMPORT */


#include <stdio.h>

#include "pws.h"
#include "pmkList.h"
#include "pwsLexCode.h"
#include "set.h"
#include "pmk_i.h"
#include "tmk.h"
#include "pwSymSet.h"
#include "pwsGrm.h"
#include "pmkScan.h"
extern pmkContext pmkCtxt;
/* END %%IMPORT */

#include "pmkList.h"
#include "pmkCommon.h"

#define MaxTokens 5


static char insStr[101] = "";	/* Inserted symbol strings */
static int insToks = 0;

static char delStr[201] = "";	/* Deleted symbol strings */
static int delToks = 0;

/*-----------------------------------------------------------------------------
 * pmkRPoi - Recovery point, output a message indicating the position.
 *-----------------------------------------------------------------------------
 */
void pmkRPoi(token)
    PmkToken *token;		/* IN the restart symbol */
{
    if (delToks > MaxTokens) {
       /* Output a recovery point error message
       */
       pmkLog(&(token->srcp), 100, sevINF, "");
    }/*if*/

    /* Clear both token print strings */
    insStr[0] = '\0';
    delStr[0] = '\0';

    insToks = 0;
    delToks = 0;
}/*pmkRPoi()*/


/*-----------------------------------------------------------------------------
 * pmkISym - A symbol is to be inserted, collect it for later output, and
 *	    construct the requested token for use by the parser.
 *-----------------------------------------------------------------------------
 */
void pmkISym(code, symString, printString, token)
     int code;	/* IN terminal code number */
    char *symString;			/* IN terminal string */
    char *printString;			/* IN the terminals print symbol */
    PmkToken *token;		/* OUT the created scanner symbol */
{
    if (insToks < MaxTokens) {
	/* Concatenate the token string
	 */
	if (insToks > 0) strcat(insStr, " ");
	if (code == 0) strcat(insStr, "Unknown Token");
	else if (code == 1) strcat(insStr, "End Of File");
	else if (*printString != '\0') strcat(insStr, printString);
	else strcat(insStr, symString);
    } else if (insToks == MaxTokens) {
	strcat(insStr, " ...");
    }/*if*/
    insToks++;
#define sym token
#define sstr symString
#define pstr printString


    /* Create the requested token */
    sym->code = code;

    switch (code) {

    case 2:			/* IDENTIFIER */
    case 3:			/* QUOTED_STRING */
    case 4:			/* ANGLE_BRACKETED_STRING */
	if (*pstr != '\0') {
	    sym->sval = (char *)malloc(strlen(pstr) + 1);
	    strcpy(sym->sval, pstr);
	} else {
	    sym->sval = (char *)malloc(strlen(sstr) + 1);
	    strcpy(sym->sval, sstr);
	}/*if*/
	sym->ival = 0;
	break;

    case 5:			/* INTEGER */
	sym->ival = 0;
	break;
    }/*switch*/

#undef sym
#undef sstr
#undef pstr
}/*pmkISym()*/


/*-----------------------------------------------------------------------------
 * pmkDSym - The indicated symbol is deleted by the parser, collect its string
 *	    for later output.
 *-----------------------------------------------------------------------------
 */
void pmkDSym(token, symString, printString)
    PmkToken *token;		/* IN terminal */
    char *symString;			/* IN terminal string */
    char *printString;			/* IN terminals print string */
{
    if (delToks < MaxTokens) {
	/* Concatenate the symbol strings */
	if (delToks > 0) strcat(delStr, " ");
	if (token->code == 0) strcat(delStr, "Unknown Token");
	else if (token->code == 1) strcat(delStr, "End Of File");
	else if (*printString != '\0') strcat(delStr, printString);
	else strcat(delStr, symString);
    } else if (delToks == MaxTokens) {
	strcat(delStr, " ...");
    }/*if*/
    delToks++;
}/*pmkDSym()*/


/*-----------------------------------------------------------------------------
 * pmkMess - An error message should be output, symbol indicates point of error.
 *-----------------------------------------------------------------------------
 * Method:	1 = Symbol(s) insertion	       Message:	% inserted
 *		2 = Symbol(s) deletion			% deleted
 *		3 = Symbol(s) replacement		% replaced by %
 *	        4 = Stack backup			Malformed phrase
 *		5 = Halted				%. System halted
 *
 * Code:	1 = Unknown token (error token from scanner)
 *		2 = Syntax error
 *		3 = Parse stack overflow
 *		4 = Table error
 *
 * Severity:	1 = Warning
 *		2 = Error (repairable)
 *		3 = Fatal error
 *		4 = System error & Limit error
 *-----------------------------------------------------------------------------
 */
void pmkMess(sym, method, code, severity)
    PmkToken *sym;	/* IN error token */
    int method;			/* IN recovery method */
    int code;			/* IN error classification */
    int severity;		/* IN error severity code */
{
    pmkSev sev;

    switch (severity) {
    case 1: sev = sevWAR; break;
    case 2: sev = sevERR; break;
    case 3: sev = sevFAT; break;
    case 4: sev = sevSYS; break;
    default: sev = sevSYS; break;
    }

    switch (code) {

    case 1:
	/* Unknown symbol, deleted */
	pmkLog(&(sym->srcp), 102, sev, "Unknown Token");
	break;

    case 2:
	/* Syntax Error */
	switch (method) {

	case 1:
	    /* Insert */
	    pmkLog(&(sym->srcp), 101, sev, insStr);
	    break;

	case 2:
	    /* Delete */
	    pmkLog(&(sym->srcp), 102, sev, delStr);
	    break;

	case 3:
	    /* Replace */
	    delStr[strlen(delStr)+1] = '\0';
	    delStr[strlen(delStr)] = pmkSEPARATOR; /* Separator */
	    strcat(delStr, insStr);
	    pmkLog(&(sym->srcp), 103, sev, delStr);
	    break;

	case 4:
	    /* Stack backed up */
	    pmkLog(&(sym->srcp), 104, sev, "");
	    break;

	case 5:
	    /* Syntax error, system halted */
	    pmkLog(&(sym->srcp), 105, sev, "");
	    break;
	}
	break;

    case 3:
	/* Parse stack overflow */
	pmkLog(&(sym->srcp), 106, sev, "");
	break;

    case 4:
	/* Parse table error */
	pmkLog(&(sym->srcp), 107, sev, "");
	break;
    }

    if (method == 5) {
	/* System halted, output informational message */
	pmkLog(&(sym->srcp), 108, sevINF, "");
    }
}/*pmkMess()*/
+++++ pmkPaSema.c +++++
/*----------------------------------------------------------------------*\

	pmkPaSema.c

	ParserMaker generated semantic actions

\*----------------------------------------------------------------------*/

/* %%IMPORT */


#include <stdio.h>

#include "pws.h"
#include "pmkList.h"
#include "pwsLexCode.h"
#include "set.h"
#include "pmk_i.h"
#include "tmk.h"
#include "pwSymSet.h"
#include "pwsGrm.h"
#include "pmkScan.h"
extern pmkContext pmkCtxt;
/* END %%IMPORT */

/* System dependencies
 * -------------------
 */

/* These datatypes should be defined to be unsigned integers of length 1, 2
 * and 4 bytes respectively.
 */
typedef unsigned char UByte1;
typedef unsigned short UByte2;
typedef unsigned int UByte4;

/* Token and Srcp definition */
#include "pmkCommon.h"

/* Attribute stacks *\
\* ---------------- */
/* %%ATTRIBUTES */
/* The semantic attributes for grammar symbols */
typedef struct pmkGrammar {
    prod_elnode *rule_elnode_last;
    prod_elnode *rule_elnode /* list of rhs elements (see prod_elnode's def) */;
    rhs_node *rhslist_last /* last element in the list above. This used to
                                        to avoid making a reversed list */;
    rhs_node *rhslist /* list of alternative righthand sides */;
    altr_lst *altr_last;
    altr_lst *altr_node /* list of alternatives (in EBNF alternation) */;
    SymSet nored_set /* modifier sets */;
    SymSet red_set /* modifier sets */;
    int code /* terminals code value given in TERMINAL section */;
    int dcost /* Delete cost given in TERMINAL section */;
    int icost /* Insert cost given in TERMINAL section */;
    Boolean nullf /* null flag */;
    Boolean q_str /* quoted_ string flag */;
    TmkSrcp srcp;
    char *sval2;
    char *sval;
    int ival;
} pmkGrammar;

/* END %%ATTRIBUTES */

extern short pmkStkP;
extern PmkToken pmkSySt[];
extern pmkGrammar pmkSeSt[];

/* %%DECLARATIONS - User data and routines */

static Boolean optimizeObsolete = FALSE;
StrListP grmAttrDecls, grmAttrNames;
CodeNodeP pmkImportSection = NULL,
	  exportSection = NULL,
	  declSection = NULL,
	  scannerSection = NULL,
	  insertSymbSection = NULL;

static search_kind searchResult; /* Variable used for lookup calls */
static SETDEF(sym_kind_set, unknown_symb + 1); /* For lookup calls */
int symRef;        /* Variable used for lookup calls */

static int i;
static attr_kind reading_attr_class = nts_attr; /* Type of attributes when reading */
                                     /* attribute section.              */
static SymSet occupied_code_values = NULL; /* Occupied terminal code values */
static SymSet terminals_set = NULL;        /* Variable used to read a list  */
                                            /* of terminals.                 */
static SymSet modify_intersect_set = NULL; /* Variable used to keep         */
                                            /* intersection of red and nored */
                                            /* sets modifiers.               */
static prod_elnode * temp_lhs;              /* lhs of current production     */
static char * syms_str;                  /* Variable used to construct    */
                                            /* error messages.               */
static char numStr[20];

/*-----------------------------------------------------------------------------
 * makeSymStr - makes a string of symbols in the set s separated by commas.
 *-----------------------------------------------------------------------------
 */
static char *makeSymStr(s)
SymSet s;
{
    char *temp;
    int totlen = 0;
    int nr = 0;
    int i;

    for (i = 0; i < SymSetSize(s); i++) {
	if (SymSetMem(s,i)) {
	    totlen += strlen(vocabulary[i]->name) + 3;
	}/*if*/
    }/*for*/

    temp = (char *)calloc(totlen, sizeof(char));
    nr=0;
    for (i = 0; i < SymSetSize(s); i++) {
	if (SymSetMem(s, i)) {
	    if (nr > 0) strcat(temp, ", ");
	    strcat(temp, vocabulary[i]->name);
	    nr++;
	}/*if*/
    }/*for*/
    return(temp);
}/*makeSymStr()*/


/* END %%DECLARATIONS */


/*----------------------------------------------------------------------------
 * pmkPaSema - The semantic actions
 *----------------------------------------------------------------------------
 */
void pmkPaSema(rule)
int rule;			/* IN production number */
{
    switch (rule) {
          case 4: { /* program_paragraph = declaration_part code_part; */

	    init_action_structs(TRUE);
	  	break;}
    case 8: { /* declaration_part = '%%DECLARATIONS' endOpt; */

	  if (declSection)
	    pmkLog(pmkSySt[pmkStkP+1].srcp, 60, sevERR, "");
	  else
  	    declSection = tmkNewCode(pmkSySt[pmkStkP+1].fpos, pmkSySt[pmkStkP+1].length);
		break;}
    case 9: { /* grammar_paragraph = scanner_interface_section attribute_section error_handling_section rule_section; */

	    if (!SeriousErr) order_gram();
	  	break;}
    case 10: { /* scanner_interface_section =; */

	    term_sec_given = FALSE;
	  	break;}
    case 12: { /* TERMINALS_aux = '%%TERMINALS'; */

	    pmkSeSt[pmkStkP+1].ival = pmkSySt[pmkStkP+1].ival;
	    occupied_code_values = SymSetAlloc();
	    SymSetIns(occupied_code_values, 0);
	    SymSetIns(occupied_code_values, 1);
	    term_sec_given = TRUE;
	  	break;}
    case 15: { /* terminal_definition = terminal '=' token_code error_recovery_data ';'; */

	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, t_symb);
	    lookup(pmkSeSt[pmkStkP+1].sval, sym_kind_set, &symRef, &searchResult);
	    if (searchResult == new_search || searchResult == found_search) {
		if (searchResult == found_search) {
		    /* ERROR terminal defined twice, old definition overridden
		     */
		    pmkLog(&pmkSeSt[pmkStkP+1].srcp, 121, sevWAR,
			  vocabulary[symRef]->name);
		}/*if*/
		vocabulary[symRef]->symbol_typ = t_symb;
		vocabulary[symRef]->code = pmkSeSt[pmkStkP+3].ival;
		SymSetIns(occupied_code_values, pmkSeSt[pmkStkP+3].ival);
		if (pmkSeSt[pmkStkP+3].ival > tc_val) tc_val = pmkSeSt[pmkStkP+3].ival;

		if (!(pmkSeSt[pmkStkP+4].nullf)) {
		    vocabulary[symRef]->syminfo.ter_info.icost =
			pmkSeSt[pmkStkP+4].icost;
		    if (pmkSeSt[pmkStkP+4].icost > icostMax) {
			icostMax = pmkSeSt[pmkStkP+4].icost;
		    }/*if*/
		    vocabulary[symRef]->syminfo.ter_info.dcost =
			pmkSeSt[pmkStkP+4].dcost;
		    if (pmkSeSt[pmkStkP+4].dcost > dcostMax) {
			dcostMax = pmkSeSt[pmkStkP+4].dcost;
		    }/*if*/
		    vocabulary[symRef]->syminfo.ter_info.psymb =
			pmkSeSt[pmkStkP+4].sval;
  		} else {
		    vocabulary[symRef]->syminfo.ter_info.icost = 1;
		    vocabulary[symRef]->syminfo.ter_info.dcost = 1;
		    vocabulary[symRef]->syminfo.ter_info.psymb = NULL;
		}/*if*/
	    } else if (searchResult == confl_search) {
		/* ERROR Ambiguous symbol, Terminal expected.
		 * This error should'nt happen since no other
		 * symbol kinds can ocurr before scanner interface.
		 */
     		pmkLog(&pmkSeSt[pmkStkP+1].srcp, 123, sevSYS,
		      vocabulary[symRef]->name);
	    }/*if*/
	  	break;}
    case 17: { /* symbol = term_or_nonterm; */

	    pmkSeSt[pmkStkP+1].q_str = FALSE;
	  	break;}
    case 18: { /* symbol = STRING; */

	    pmkSeSt[pmkStkP+1].sval = pmkSySt[pmkStkP+1].sval;
	    pmkSeSt[pmkStkP+1].q_str = TRUE;
	    pmkSeSt[pmkStkP+1].srcp = pmkSySt[pmkStkP+1].srcp;
	  	break;}
    case 19: { /* term_or_nonterm = IDENTIFIER; */

	    pmkSeSt[pmkStkP+1].sval = pmkSySt[pmkStkP+1].sval;
	    pmkSeSt[pmkStkP+1].srcp = pmkSySt[pmkStkP+1].srcp;
	  	break;}
    case 20: { /* term_or_nonterm = ANG_BRACK_STRING; */

	    pmkSeSt[pmkStkP+1].sval = pmkSySt[pmkStkP+1].sval;
	    pmkSeSt[pmkStkP+1].srcp = pmkSySt[pmkStkP+1].srcp;
	  	break;}
    case 21: { /* token_code = INTEGER; */

	    if (SymSetMem(occupied_code_values, pmkSySt[pmkStkP+1].ival)) {
		/* ERROR Terminal code already in use
		 */
		sprintf(numStr, "%u", pmkSySt[pmkStkP+1].ival);
		pmkLog(&pmkSySt[pmkStkP+1].srcp, 120, sevERR, numStr);
	    } else {
		pmkSeSt[pmkStkP+1].ival = pmkSySt[pmkStkP+1].ival;
	    }/*if*/
	  	break;}
    case 22: { /* error_recovery_data =; */

	    pmkSeSt[pmkStkP+1].nullf = TRUE;
	  	break;}
    case 23: { /* error_recovery_data = ',' insert_cost ',' delete_cost print_symbol; */

	    pmkSeSt[pmkStkP+1].icost = pmkSeSt[pmkStkP+2].icost;
	    pmkSeSt[pmkStkP+1].dcost = pmkSeSt[pmkStkP+4].dcost;
	    pmkSeSt[pmkStkP+1].sval = pmkSeSt[pmkStkP+5].sval;
	    pmkSeSt[pmkStkP+1].nullf = FALSE;
	  	break;}
    case 24: { /* insert_cost =; */

	    pmkSeSt[pmkStkP+1].icost = 1;
	  	break;}
    case 25: { /* insert_cost = INTEGER; */

	    pmkSeSt[pmkStkP+1].icost = pmkSySt[pmkStkP+1].ival;
	  	break;}
    case 26: { /* delete_cost =; */

	    pmkSeSt[pmkStkP+1].dcost = 1;
	  	break;}
    case 27: { /* delete_cost = INTEGER; */

	    pmkSeSt[pmkStkP+1].dcost = pmkSySt[pmkStkP+1].ival;
	  	break;}
    case 28: { /* print_symbol =; */

	    pmkSeSt[pmkStkP+1].sval = NULL;
	  	break;}
    case 29: { /* print_symbol = '=>' terminal; */

	    pmkSeSt[pmkStkP+1].sval = pmkSeSt[pmkStkP+2].sval;
	  	break;}
    case 32: { /* attributes = attribute; */

	  grmAttrDecls = appendStrList(pmkSeSt[pmkStkP+1].sval, NULL);
	  grmAttrNames = appendStrList(pmkSeSt[pmkStkP+1].sval2, NULL);
		break;}
    case 33: { /* attributes = attributes ',' attribute; */

	  grmAttrDecls = appendStrList(pmkSeSt[pmkStkP+3].sval, grmAttrDecls);
	  grmAttrNames = appendStrList(pmkSeSt[pmkStkP+3].sval2, grmAttrNames);
		break;}
    case 34: { /* attribute = IDENTIFIER optional_decl; */

            pmkSeSt[pmkStkP+1].sval = pmkSeSt[pmkStkP+2].sval;
	    pmkSeSt[pmkStkP+1].sval2 = pmkSySt[pmkStkP+1].sval;
	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, attr_symb);
	    lookup(pmkSySt[pmkStkP+1].sval, sym_kind_set, &symRef, &searchResult);
	    if (new_search == searchResult) {
		vocabulary[symRef]->symbol_typ = attr_symb;
		vocabulary[symRef]->syminfo.attr_class = nts_attr;
	    } else if (found_search == searchResult) {
  		if (vocabulary[symRef]->syminfo.attr_class != nts_attr &&	
		    vocabulary[symRef]->syminfo.attr_class != unk_attr)	{
		    vocabulary[symRef]->syminfo.attr_class = voc_attr;
		} else if (vocabulary[symRef]->syminfo.attr_class == nts_attr) {
		    /* ERROR Attribute defined twice
		     */
		    pmkLog(&pmkSySt[pmkStkP+1].srcp, 119, sevWAR, pmkSySt[pmkStkP+1].sval);
		}/*if*/
	    } else {
		/* ERROR Ambiguous symbol. Attribute expected.
		 */
    		pmkLog(&pmkSySt[pmkStkP+1].srcp, 118, sevERR, pmkSySt[pmkStkP+1].sval);
	    }/*if*/
	  	break;}
    case 35: { /* optional_decl =; */

	  pmkSeSt[pmkStkP+1].sval = NULL;
		break;}
    case 36: { /* optional_decl = '%%'; */

	  pmkSeSt[pmkStkP+1].sval = pmkSySt[pmkStkP+1].sval;
		break;}
    case 51: { /* terminals = terminal; */

	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, t_symb);
	    lookup(pmkSeSt[pmkStkP+1].sval, sym_kind_set, &symRef, &searchResult);
	    if (new_search == searchResult || searchResult == found_search) {
		if (searchResult == new_search) {
		    vocabulary[symRef]->symbol_typ = t_symb;
		    vocabulary[symRef]->syminfo.ter_info.icost = 1;
		    vocabulary[symRef]->syminfo.ter_info.dcost = 1;
		    vocabulary[symRef]->syminfo.ter_info.psymb = NULL;
		}/*if*/
		SymSetIns(terminals_set, symRef);
	    } else if (searchResult == confl_search) {
		/* ERROR Ambiguous symbol, Terminal expected.
		 */
		pmkLog(&pmkSeSt[pmkStkP+1].srcp, 117, sevERR, pmkSeSt[pmkStkP+1].sval);
		SymSetIns(terminals_set, symRef);
	    }/*if*/
	  	break;}
    case 52: { /* terminals = terminals ',' terminal; */

	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, t_symb);
	    lookup(pmkSeSt[pmkStkP+3].sval, sym_kind_set, &symRef, &searchResult);
	    if (new_search == searchResult || searchResult == found_search) {
		if (searchResult == new_search) {
		    vocabulary[symRef]->symbol_typ = t_symb;
		    vocabulary[symRef]->syminfo.ter_info.icost = 1;
		    vocabulary[symRef]->syminfo.ter_info.dcost = 1;
		    vocabulary[symRef]->syminfo.ter_info.psymb = NULL;
		}/*if*/
		SymSetIns(terminals_set, symRef);
	    } else if (searchResult == confl_search) {
		/* ERROR Ambiguous symbol, Terminal expected.
		 */
		pmkLog(&pmkSeSt[pmkStkP+3].srcp, 117, sevERR, pmkSeSt[pmkStkP+3].sval);
		SymSetIns(terminals_set, symRef);
	    }/*if*/
	  	break;}
    case 55: { /* separator_part = separator_aux '(' terminals ')' ';'; */

	    recovery_spec.separators = terminals_set;
	  	break;}
    case 56: { /* separator_aux = 'SEPARATOR'; */

	    terminals_set = SymSetAlloc();
	  	break;}
    case 57: { /* fiducial_part = fiducial_aux '(' terminals ')' ';'; */

	    recovery_spec.fiducials = terminals_set;
	  	break;}
    case 58: { /* fiducial_aux = 'FIDUCIAL'; */

	    terminals_set = SymSetAlloc();
	  	break;}
    case 59: { /* skip_part = skip_aux '(' terminals ')' ';'; */

	    recovery_spec.skips = terminals_set;
	  	break;}
    case 60: { /* skip_aux = 'SKIP'; */

	    terminals_set = SymSetAlloc();
	  	break;}
    case 65: { /* rule = nonterminal '=' rhss ';'; */

	    /* Main routine for analysis of rhss associated with a single lhs
	     */
	    if (!SeriousErr) analyze_rhss(temp_lhs, pmkSeSt[pmkStkP+3].rhslist);
	  	break;}
    case 66: { /* nonterminal = term_or_nonterm; */

	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, nts_symb);
	    lookup(pmkSeSt[pmkStkP+1].sval, sym_kind_set, &symRef,
		   &searchResult);
	    if (new_search == searchResult) {
		vocabulary[symRef]->symbol_typ = nts_symb;
		vocabulary[symRef]->syminfo.firstp = -1;
	    }/*if*/
	    temp_lhs = prod_elnodeAlloc();
	    temp_lhs->node_kind = sym_node_kind;
	    temp_lhs->node_info.sym_node.sym_ind = symRef;
	    temp_lhs->node_info.sym_node.lhs_sym = TRUE;
	    temp_lhs->node_info.sym_node.newnont = FALSE;
	    if (confl_search == searchResult) {
		pmkLog(&pmkSeSt[pmkStkP+1].srcp, 116, sevERR,
		      pmkSeSt[pmkStkP+1].sval);
	    }/*if*/
	  	break;}
    case 67: { /* rhss = rhs; */

	    pmkSeSt[pmkStkP+1].rhslist_last = pmkSeSt[pmkStkP+1].rhslist;
	  	break;}
    case 68: { /* rhss = rhss '!' rhs; */

	    pmkSeSt[pmkStkP+1].rhslist_last->nxtrhs = pmkSeSt[pmkStkP+3].rhslist;
	    pmkSeSt[pmkStkP+1].rhslist = pmkSeSt[pmkStkP+1].rhslist;
	    pmkSeSt[pmkStkP+1].rhslist_last = pmkSeSt[pmkStkP+3].rhslist;
	  	break;}
    case 69: { /* rhs = symbols_or_actions modifiers; */

	    if (pmkSeSt[pmkStkP+1].nullf) {
		/* Allocated a null node
		 */
		pmkSeSt[pmkStkP+1].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+1].rule_elnode->node_kind = null_node_kind;
		pmkSeSt[pmkStkP+1].rule_elnode_last =
		    pmkSeSt[pmkStkP+1].rule_elnode;
	    }/*if*/
	    if (!(pmkSeSt[pmkStkP+2].nullf)) {
		/* Allocate a modifier node
		 */
		pmkSeSt[pmkStkP+2].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+2].rule_elnode->node_kind = mod_node_kind;
		pmkSeSt[pmkStkP+2].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		pmkSeSt[pmkStkP+2].rule_elnode->node_info.modify_node->red =
		    pmkSeSt[pmkStkP+2].red_set;
		pmkSeSt[pmkStkP+2].rule_elnode->node_info.modify_node->nored =
		    pmkSeSt[pmkStkP+2].nored_set;
		pmkSeSt[pmkStkP+1].rule_elnode_last->nxtnode =
		    pmkSeSt[pmkStkP+2].rule_elnode;
	    }/*if*/

	    pmkSeSt[pmkStkP+1].rhslist = rhs_nodeAlloc();
	    pmkSeSt[pmkStkP+1].rhslist->rhs = pmkSeSt[pmkStkP+1].rule_elnode;
	  	break;}
    case 70: { /* symbols_or_actions =; */

	    pmkSeSt[pmkStkP+1].nullf = TRUE;
	  	break;}
    case 71: { /* symbols_or_actions = symbols_or_actions symbol_or_action; */

	    /* Make list
	     */
	    if (pmkSeSt[pmkStkP+1].nullf) {
		if (pmkSeSt[pmkStkP+2].nullf) {
		    pmkSeSt[pmkStkP+1].nullf = TRUE;
		} else {
		    pmkSeSt[pmkStkP+1].nullf = FALSE;
		    pmkSeSt[pmkStkP+1].rule_elnode =
			pmkSeSt[pmkStkP+2].rule_elnode;
		    pmkSeSt[pmkStkP+1].rule_elnode_last =
			pmkSeSt[pmkStkP+2].rule_elnode_last;
		}/*if*/
	    } else if (pmkSeSt[pmkStkP+2].nullf) {
		pmkSeSt[pmkStkP+1].nullf = FALSE;
		pmkSeSt[pmkStkP+1].rule_elnode =
		    pmkSeSt[pmkStkP+1].rule_elnode;
		pmkSeSt[pmkStkP+1].rule_elnode_last =
		    pmkSeSt[pmkStkP+1].rule_elnode_last;
	    } else {
		pmkSeSt[pmkStkP+1].nullf = FALSE;
		pmkSeSt[pmkStkP+1].rule_elnode_last->nxtnode =
		    pmkSeSt[pmkStkP+2].rule_elnode;
		pmkSeSt[pmkStkP+1].rule_elnode =
		    pmkSeSt[pmkStkP+1].rule_elnode;
		pmkSeSt[pmkStkP+1].rule_elnode_last =
		    pmkSeSt[pmkStkP+2].rule_elnode_last;
	    }/*if*/
	  	break;}
    case 73: { /* Alternatives = Alternatives '|' modifiers symbols_or_actions modifiers; */

	    if (pmkSeSt[pmkStkP+4].nullf) {
		pmkSeSt[pmkStkP+4].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+4].rule_elnode->node_kind = null_node_kind;
		pmkSeSt[pmkStkP+4].rule_elnode_last =
		    pmkSeSt[pmkStkP+4].rule_elnode;
		if (!(pmkSeSt[pmkStkP+5].nullf) && !(pmkSeSt[pmkStkP+3].nullf)) {
		    /* Test red and nored sets intersection
		     */
		    if (pmkSeSt[pmkStkP+3].red_set != NULL &&
			pmkSeSt[pmkStkP+5].nored_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(pmkSeSt[pmkStkP+3].red_set, pmkSeSt[pmkStkP+3].nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&pmkSeSt[pmkStkP+5].srcp, 113, sevERR, syms_str);
			    free(syms_str);
			    pmkSeSt[pmkStkP+3].red_set = NULL;
			}/*if*/
		    }/*if*/
		    if (pmkSeSt[pmkStkP+3].nored_set != NULL &&
			pmkSeSt[pmkStkP+5].red_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(pmkSeSt[pmkStkP+3].red_set, pmkSeSt[pmkStkP+3].nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&pmkSeSt[pmkStkP+5].srcp, 113, sevERR, syms_str);
			    free(syms_str);
			    pmkSeSt[pmkStkP+3].red_set = NULL;
			}/*if*/
		    }/*if*/
		}/*if*/
	    }/*if*/

	    /* Make list
	     */
	    if (!(pmkSeSt[pmkStkP+5].nullf)) {
		pmkSeSt[pmkStkP+5].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+5].rule_elnode->node_kind = mod_node_kind;
		pmkSeSt[pmkStkP+5].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		pmkSeSt[pmkStkP+5].rule_elnode->node_info.modify_node->red =
		    pmkSeSt[pmkStkP+5].red_set;
		pmkSeSt[pmkStkP+5].rule_elnode->node_info.modify_node->nored =
		    pmkSeSt[pmkStkP+5].nored_set;
		pmkSeSt[pmkStkP+4].rule_elnode_last->nxtnode =
		    pmkSeSt[pmkStkP+5].rule_elnode;
		pmkSeSt[pmkStkP+4].rule_elnode_last = pmkSeSt[pmkStkP+5].rule_elnode;
	    }/*if*/

	    pmkSeSt[pmkStkP+1].altr_last->nxtalt = altr_lstAlloc();

	    if (!(pmkSeSt[pmkStkP+3].nullf)) {
		pmkSeSt[pmkStkP+3].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+3].rule_elnode->node_kind = mod_node_kind;
		pmkSeSt[pmkStkP+3].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		pmkSeSt[pmkStkP+3].rule_elnode->node_info.modify_node->red =
		    pmkSeSt[pmkStkP+3].red_set;
		pmkSeSt[pmkStkP+3].rule_elnode->node_info.modify_node->nored =
		    pmkSeSt[pmkStkP+3].nored_set;
		pmkSeSt[pmkStkP+3].rule_elnode->nxtnode =
		    pmkSeSt[pmkStkP+4].rule_elnode;
		pmkSeSt[pmkStkP+1].altr_last->nxtalt->altr =
		    pmkSeSt[pmkStkP+3].rule_elnode;
	    } else {
		pmkSeSt[pmkStkP+1].altr_last->nxtalt->altr =
		    pmkSeSt[pmkStkP+4].rule_elnode;
	    }/*if*/

	    pmkSeSt[pmkStkP+1].altr_node = pmkSeSt[pmkStkP+1].altr_node;
	    pmkSeSt[pmkStkP+1].altr_last = pmkSeSt[pmkStkP+1].altr_last->nxtalt;
	  	break;}
    case 72: { /* Alternatives = modifiers symbols_or_actions modifiers; */

	    if (pmkSeSt[pmkStkP+2].nullf) {
		pmkSeSt[pmkStkP+2].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+2].rule_elnode->node_kind = null_node_kind;
		pmkSeSt[pmkStkP+2].rule_elnode_last =
		    pmkSeSt[pmkStkP+2].rule_elnode;
		if (!(pmkSeSt[pmkStkP+3].nullf) && !(pmkSeSt[pmkStkP+1].nullf)) {
		    /* Test red and nored sets intersection
		     */
		    if (pmkSeSt[pmkStkP+1].red_set != NULL &&
			pmkSeSt[pmkStkP+3].nored_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(pmkSeSt[pmkStkP+1].red_set, pmkSeSt[pmkStkP+1].nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&pmkSeSt[pmkStkP+3].srcp, 113, sevERR, syms_str);
			    free(syms_str);
			    pmkSeSt[pmkStkP+1].red_set = NULL;
			}/*if*/
		    }/*if*/

		    /* Test red and nored sets intersection
		     */
		    if (pmkSeSt[pmkStkP+1].nored_set != NULL &&
			pmkSeSt[pmkStkP+3].red_set != NULL)
		    {
			if (modify_intersect_set == NULL) {
			    modify_intersect_set = SymSetAlloc();
			}/*if*/
			SymSetClear(modify_intersect_set);
			SymSetInter(pmkSeSt[pmkStkP+1].red_set, pmkSeSt[pmkStkP+1].nored_set,
				    modify_intersect_set);
			if (!(SymSetEmpty(modify_intersect_set))) {
			    syms_str = makeSymStr(modify_intersect_set);
			    pmkLog(&pmkSeSt[pmkStkP+3].srcp,113,sevERR,syms_str);
			    free(syms_str);
			    pmkSeSt[pmkStkP+1].red_set = NULL;
			}/*if*/
		    }/*if*/
		}/*if*/
	    }/*if*/

	    if (!(pmkSeSt[pmkStkP+3].nullf)) {
		pmkSeSt[pmkStkP+3].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+3].rule_elnode->node_kind = mod_node_kind;
		pmkSeSt[pmkStkP+3].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		pmkSeSt[pmkStkP+3].rule_elnode->node_info.modify_node->red =
		    pmkSeSt[pmkStkP+3].red_set;
		pmkSeSt[pmkStkP+3].rule_elnode->node_info.modify_node->nored =
		    pmkSeSt[pmkStkP+3].nored_set;
		pmkSeSt[pmkStkP+2].rule_elnode_last->nxtnode =
		    pmkSeSt[pmkStkP+3].rule_elnode;
		pmkSeSt[pmkStkP+2].rule_elnode_last =
		    pmkSeSt[pmkStkP+3].rule_elnode;
	    }/*if*/

	    pmkSeSt[pmkStkP+1].altr_node = altr_lstAlloc();

	    if (!(pmkSeSt[pmkStkP+1].nullf)) {
		pmkSeSt[pmkStkP+1].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+1].rule_elnode->node_kind = mod_node_kind;
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.modify_node->red =
		    pmkSeSt[pmkStkP+1].red_set;
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.modify_node->nored =
		    pmkSeSt[pmkStkP+1].nored_set;
		pmkSeSt[pmkStkP+1].rule_elnode->nxtnode =
		    pmkSeSt[pmkStkP+2].rule_elnode;
		pmkSeSt[pmkStkP+1].altr_node->altr = pmkSeSt[pmkStkP+1].rule_elnode;
	    } else {
		pmkSeSt[pmkStkP+1].altr_node->altr =
		    pmkSeSt[pmkStkP+2].rule_elnode;
	    }/*if*/

	    pmkSeSt[pmkStkP+1].altr_last = pmkSeSt[pmkStkP+1].altr_node;
	  	break;}
    case 74: { /* symbol_or_action = symbol; */

	    SetClear(sym_kind_set, unknown_symb + 1);
	    if (pmkSeSt[pmkStkP+1].q_str) {
		SetIns(sym_kind_set, t_symb);
	    } else {
		SetIns(sym_kind_set, t_symb);
		SetIns(sym_kind_set, nts_symb);
	    }/*if*/

	    lookup(pmkSeSt[pmkStkP+1].sval, sym_kind_set, &symRef, &searchResult);
	    if (confl_search == searchResult) {
		/* ERROR Ambiguous symbol Terminal or non terminal expected
		 */
		pmkSeSt[pmkStkP+1].nullf = TRUE;
		pmkLog(&pmkSeSt[pmkStkP+1].srcp, 115, sevERR, pmkSeSt[pmkStkP+1].sval);
	    } else {
		SymSetIns(on_right, symRef);
		pmkSeSt[pmkStkP+1].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+1].rule_elnode->node_kind = sym_node_kind;
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.sym_ind =
		    symRef;
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.lhs_sym =
		    FALSE;
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.newnont =
		    FALSE;
		SymSetIns(on_right, symRef);
		pmkSeSt[pmkStkP+1].rule_elnode_last =
		    pmkSeSt[pmkStkP+1].rule_elnode;
		pmkSeSt[pmkStkP+1].nullf = FALSE;
	    }/*if*/
	  	break;}
    case 76: { /* symbol_or_action = '{' modifiers symbols_or_actions modifiers '}'; */

	    if (pmkSeSt[pmkStkP+3].nullf) {
		/* ERROR Repetition of Null string ignored
		 */
		pmkSeSt[pmkStkP+1].nullf = TRUE;
		pmkLog(&pmkSySt[pmkStkP+1].srcp,114,sevWAR,"");
	    } else {
		/* Generate a new symbol node (with a new symbol).
		 * Keep symbols_or_actions's rule_nodelist in the symbol node
		 */
		SetClear(sym_kind_set, unknown_symb + 1);
		SetIns(sym_kind_set, nts_symb);
		lookup(gensym(), sym_kind_set, &symRef, &searchResult);
		vocabulary[symRef]->symbol_typ = nts_symb;
		vocabulary[symRef]->syminfo.firstp = -1;
		if (confl_search == searchResult ||
		    found_search == searchResult)
		{
		    /* This should'nt happen
		     */
		    printf(
"Non terminal generated by PMK is equal to user's symbol");
		}/*if*/

		/* Make list
		 */
		if (!(pmkSeSt[pmkStkP+4].nullf)) {
		    pmkSeSt[pmkStkP+4].rule_elnode = prod_elnodeAlloc();
		    pmkSeSt[pmkStkP+4].rule_elnode->node_kind = mod_node_kind;
		    pmkSeSt[pmkStkP+4].rule_elnode->node_info.modify_node =
			modify_recAlloc();
		    pmkSeSt[pmkStkP+4].rule_elnode->node_info.modify_node->red =
			pmkSeSt[pmkStkP+4].red_set;
		    pmkSeSt[pmkStkP+4].rule_elnode->node_info.modify_node->nored =
			pmkSeSt[pmkStkP+4].nored_set;
		    pmkSeSt[pmkStkP+3].rule_elnode_last->nxtnode =
			pmkSeSt[pmkStkP+4].rule_elnode;
		    pmkSeSt[pmkStkP+3].rule_elnode_last =
			pmkSeSt[pmkStkP+4].rule_elnode;
		}/*if*/
		SymSetIns(on_right, symRef);
		pmkSeSt[pmkStkP+1].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+1].rule_elnode->node_kind = sym_node_kind;
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.sym_ind =
		    symRef;
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.newnont =
		    TRUE;
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.rplc_info =
		    rept_rplc;
		if (!(pmkSeSt[pmkStkP+2].nullf)) {
		    pmkSeSt[pmkStkP+2].rule_elnode = prod_elnodeAlloc();
		    pmkSeSt[pmkStkP+2].rule_elnode->node_kind = mod_node_kind;
		    pmkSeSt[pmkStkP+2].rule_elnode->node_info.modify_node =
			modify_recAlloc();
		    pmkSeSt[pmkStkP+2].rule_elnode->node_info.modify_node->red =
			pmkSeSt[pmkStkP+2].red_set;
		    pmkSeSt[pmkStkP+2].rule_elnode->node_info.modify_node->nored =
			pmkSeSt[pmkStkP+2].nored_set;
		    pmkSeSt[pmkStkP+2].rule_elnode->nxtnode =
			pmkSeSt[pmkStkP+3].rule_elnode;
		    pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.rplc_seq=
			pmkSeSt[pmkStkP+2].rule_elnode;
		} else {
		    pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.rplc_seq=
			pmkSeSt[pmkStkP+3].rule_elnode;
		}/*if*/
		pmkSeSt[pmkStkP+1].rule_elnode_last =
		    pmkSeSt[pmkStkP+1].rule_elnode;
		pmkSeSt[pmkStkP+1].nullf = FALSE;
	    }/*if*/
	  	break;}
    case 77: { /* symbol_or_action = '(' Alternatives ')'; */

	    /* Generate a new symbol node (with a new symbol)
	     * keep symbols_or_actions's rule_nodelist in the symbol node
	     */
	    SetClear(sym_kind_set, unknown_symb + 1);
	    SetIns(sym_kind_set, nts_symb);
	    lookup(gensym(), sym_kind_set, &symRef, &searchResult);
	    vocabulary[symRef]->symbol_typ = nts_symb;
	    vocabulary[symRef]->syminfo.firstp = -1;
	    if (confl_search == searchResult || found_search == searchResult) {
		/* This should'nt happen
		 */
		printf(
"Non terminal generated by PMK is equal to user's symbol");
	    }/*if*/

	    /* Make list
	     */
	    SymSetIns(on_right, symRef);
	    pmkSeSt[pmkStkP+1].rule_elnode = prod_elnodeAlloc();
	    pmkSeSt[pmkStkP+1].rule_elnode->node_kind = sym_node_kind;
	    pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.sym_ind = symRef;
	    pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.newnont = TRUE;
	    pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.rplc_info =
		altrs_rplc;
	    pmkSeSt[pmkStkP+1].rule_elnode->node_info.sym_node.altrs_seq =
		pmkSeSt[pmkStkP+2].altr_node;
	    pmkSeSt[pmkStkP+1].rule_elnode_last = pmkSeSt[pmkStkP+1].rule_elnode;
	    pmkSeSt[pmkStkP+1].nullf = FALSE;
	  	break;}
    case 75: { /* symbol_or_action = modifiers action modifiers; */

	    if (!(pmkSeSt[pmkStkP+3].nullf) && !(pmkSeSt[pmkStkP+1].nullf)) {
		/* Test red and nored sets intersection
		 */
		if (pmkSeSt[pmkStkP+1].red_set != NULL &&
		    pmkSeSt[pmkStkP+3].nored_set != NULL)
		{
		    if (modify_intersect_set == NULL) {
			modify_intersect_set = SymSetAlloc();
		    }/*if*/
		    SymSetClear(modify_intersect_set);
		    SymSetInter(pmkSeSt[pmkStkP+1].red_set, pmkSeSt[pmkStkP+1].nored_set,
				modify_intersect_set);
		    if (!(SymSetEmpty(modify_intersect_set))) {
			syms_str = makeSymStr(modify_intersect_set);
			pmkLog(&pmkSeSt[pmkStkP+3].srcp, 113, sevERR, syms_str);
			free(syms_str);
			pmkSeSt[pmkStkP+1].red_set = NULL;
		    }/*if*/
		}/*if*/
		if (pmkSeSt[pmkStkP+1].nored_set != NULL &&
		    pmkSeSt[pmkStkP+3].red_set != NULL)
		{
		    if (modify_intersect_set == NULL) {
			modify_intersect_set = SymSetAlloc();
		    }/*if*/
		    SymSetClear(modify_intersect_set);
		    SymSetInter(pmkSeSt[pmkStkP+1].red_set, pmkSeSt[pmkStkP+1].nored_set,
				modify_intersect_set);
		    if (!(SymSetEmpty(modify_intersect_set))) {
			syms_str = makeSymStr(modify_intersect_set);
			pmkLog(&pmkSeSt[pmkStkP+3].srcp, 113, sevERR, syms_str);
			free(syms_str);
			pmkSeSt[pmkStkP+1].red_set = NULL;
		    }/*if*/
		}/*if*/
	    }/*if*/
     
	    if (!(pmkSeSt[pmkStkP+3].nullf)) {
		pmkSeSt[pmkStkP+3].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+3].rule_elnode->node_kind = mod_node_kind;
		pmkSeSt[pmkStkP+3].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		pmkSeSt[pmkStkP+3].rule_elnode->node_info.modify_node->red =
		    pmkSeSt[pmkStkP+3].red_set;
		pmkSeSt[pmkStkP+3].rule_elnode->node_info.modify_node->nored =
		    pmkSeSt[pmkStkP+3].nored_set;
		pmkSeSt[pmkStkP+2].rule_elnode->nxtnode = pmkSeSt[pmkStkP+3].rule_elnode;
		pmkSeSt[pmkStkP+2].rule_elnode_last = pmkSeSt[pmkStkP+3].rule_elnode;
	    }/*if*/

	    if (!(pmkSeSt[pmkStkP+1].nullf)) {
		pmkSeSt[pmkStkP+1].rule_elnode = prod_elnodeAlloc();
		pmkSeSt[pmkStkP+1].rule_elnode->node_kind = mod_node_kind;
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.modify_node =
		    modify_recAlloc();
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.modify_node->red =
		    pmkSeSt[pmkStkP+1].red_set;
		pmkSeSt[pmkStkP+1].rule_elnode->node_info.modify_node->nored =
		    pmkSeSt[pmkStkP+1].nored_set;
		pmkSeSt[pmkStkP+1].rule_elnode->nxtnode = pmkSeSt[pmkStkP+2].rule_elnode;
		pmkSeSt[pmkStkP+1].rule_elnode = pmkSeSt[pmkStkP+1].rule_elnode;
		pmkSeSt[pmkStkP+1].rule_elnode_last = pmkSeSt[pmkStkP+2].rule_elnode_last;
		pmkSeSt[pmkStkP+1].nullf = FALSE;
	    } else {
		pmkSeSt[pmkStkP+1].rule_elnode = pmkSeSt[pmkStkP+2].rule_elnode;
		pmkSeSt[pmkStkP+1].rule_elnode_last = pmkSeSt[pmkStkP+2].rule_elnode_last;
		pmkSeSt[pmkStkP+1].nullf = FALSE;
	    }/*if*/
	  	break;}
    case 78: { /* modifiers =; */

	    pmkSeSt[pmkStkP+1].nullf = TRUE;
	  	break;}
    case 79: { /* modifiers = modifiers modifier; */

	    /* Merge modifier sets
	     */
	    if (!(pmkSeSt[pmkStkP+1].nullf)) {
		if (pmkSeSt[pmkStkP+1].red_set == NULL) {
		    if (pmkSeSt[pmkStkP+2].red_set != NULL) {
			pmkSeSt[pmkStkP+1].red_set = pmkSeSt[pmkStkP+2].red_set;
		    }/*if*/
		} else if (pmkSeSt[pmkStkP+2].red_set == NULL) {
		    pmkSeSt[pmkStkP+1].red_set = pmkSeSt[pmkStkP+1].red_set;
		} else {
		    SymSetUnion(pmkSeSt[pmkStkP+1].red_set, pmkSeSt[pmkStkP+2].red_set,
				pmkSeSt[pmkStkP+1].red_set);
		}/*if*/
		if (pmkSeSt[pmkStkP+1].nored_set == NULL) {
		    if (pmkSeSt[pmkStkP+2].nored_set != NULL) {
			pmkSeSt[pmkStkP+1].nored_set = pmkSeSt[pmkStkP+2].nored_set;
		    }/*if*/
		} else if (pmkSeSt[pmkStkP+2].nored_set == NULL) {
		    pmkSeSt[pmkStkP+1].nored_set = pmkSeSt[pmkStkP+1].nored_set;
		} else {
		    SymSetUnion(pmkSeSt[pmkStkP+1].nored_set, pmkSeSt[pmkStkP+2].nored_set,
				pmkSeSt[pmkStkP+1].nored_set);
		}/*if*/
		pmkSeSt[pmkStkP+1].nullf = FALSE;
	    } else {
		pmkSeSt[pmkStkP+1].red_set = pmkSeSt[pmkStkP+2].red_set;
		pmkSeSt[pmkStkP+1].nored_set = pmkSeSt[pmkStkP+2].nored_set;
		pmkSeSt[pmkStkP+1].nullf = FALSE;
	    }/*if*/

	    /* Test red and nored sets intersection
	     */
	    if (pmkSeSt[pmkStkP+1].red_set != NULL &&
		pmkSeSt[pmkStkP+1].nored_set != NULL)
	    {
		if (modify_intersect_set == NULL) {
		    modify_intersect_set = SymSetAlloc();
		}/*if*/
		SymSetClear(modify_intersect_set);
		SymSetInter(pmkSeSt[pmkStkP+1].red_set, pmkSeSt[pmkStkP+1].nored_set,
			    modify_intersect_set);
		if (!(SymSetEmpty(modify_intersect_set))) {
		     syms_str = makeSymStr(modify_intersect_set);
		     pmkLog(&pmkSeSt[pmkStkP+2].srcp, 113, sevERR, syms_str);
		     free(syms_str);
		     pmkSeSt[pmkStkP+1].red_set = NULL;
		}/*if*/
	    }/*if*/
	  	break;}
    case 80: { /* modifier = reduce_modifier; */

	    pmkSeSt[pmkStkP+1].red_set = pmkSeSt[pmkStkP+1].red_set;
	    pmkSeSt[pmkStkP+1].nored_set = NULL;
	  	break;}
    case 81: { /* modifier = reduce_not_modifier; */

	    pmkSeSt[pmkStkP+1].nored_set = pmkSeSt[pmkStkP+1].nored_set;
	    pmkSeSt[pmkStkP+1].red_set = NULL;
	  	break;}
    case 82: { /* reduce_modifier = <+red_aux> '(' terminals ')'; */

	    pmkSeSt[pmkStkP+1].red_set = terminals_set;
	  	break;}
    case 83: { /* <+red_aux> = '%+'; */

	    terminals_set = SymSetAlloc();
	    pmkSeSt[pmkStkP+1].srcp = pmkSySt[pmkStkP+1].srcp;
	  	break;}
    case 84: { /* reduce_not_modifier = <-red_aux> '(' terminals ')'; */

	    pmkSeSt[pmkStkP+1].nored_set = terminals_set;
	  	break;}
    case 85: { /* <-red_aux> = '%-'; */

	    terminals_set = SymSetAlloc();
	    pmkSeSt[pmkStkP+1].srcp = pmkSySt[pmkStkP+1].srcp;
	  	break;}
    case 86: { /* action = '%%'; */

	    pmkSeSt[pmkStkP+1].rule_elnode = prod_elnodeAlloc();
	    pmkSeSt[pmkStkP+1].rule_elnode->node_kind = act_node_kind;
	    pmkSeSt[pmkStkP+1].rule_elnode->node_info.act_node.act_srcp = pmkSySt[pmkStkP+1].srcp;
	    pmkSeSt[pmkStkP+1].rule_elnode->node_info.act_node.act_start = pmkSySt[pmkStkP+1].fpos;
	    pmkSeSt[pmkStkP+1].rule_elnode->node_info.act_node.act_length = pmkSySt[pmkStkP+1].length;
	    pmkSeSt[pmkStkP+1].rule_elnode_last = pmkSeSt[pmkStkP+1].rule_elnode;
	  	break;}
    case 87: { /* export_section = '%%EXPORT' endOpt; */

	  if (exportSection)
	    pmkLog(pmkSySt[pmkStkP+1].srcp, 60, sevERR, "");
	  else
  	    exportSection = tmkNewCode(pmkSySt[pmkStkP+1].fpos, pmkSySt[pmkStkP+1].length);
		break;}
    case 88: { /* scanner_section = '%%SCANNER' endOpt; */

	  if (scannerSection)
	    pmkLog(pmkSySt[pmkStkP+1].srcp, 60, sevERR, "");
	  else
  	    scannerSection = tmkNewCode(pmkSySt[pmkStkP+1].fpos, pmkSySt[pmkStkP+1].length);
		break;}
    case 89: { /* insertsymbol_section = '%%INSERTSYMBOL' endOpt; */

	  if (insertSymbSection)
	    pmkLog(pmkSySt[pmkStkP+1].srcp, 60, sevERR, "");
	  else
  	    insertSymbSection = tmkNewCode(pmkSySt[pmkStkP+1].fpos, pmkSySt[pmkStkP+1].length);
		break;}
    default: break; }
}/*pmkPaSema()*/

+++++ pmkParse.c +++++
/*----------------------------------------------------------------------*\

	pmkParse.c

	ParserMaker generated parser

\*----------------------------------------------------------------------*/

/* %%IMPORT */


#include <stdio.h>

#include "pws.h"
#include "pmkList.h"
#include "pwsLexCode.h"
#include "set.h"
#include "pmk_i.h"
#include "tmk.h"
#include "pwSymSet.h"
#include "pwsGrm.h"
#include "pmkScan.h"
extern pmkContext pmkCtxt;
/* END %%IMPORT */

#include <strings.h>
#include <memory.h>
#include <setjmp.h>

#include "pmkParse.h"

#define PMTRUE 1
#define PMFALSE 0
typedef unsigned char PmBoolean; /* For logical values */

/* System dependencies */

/* These datatypes should be defined to be unsigned integers of length 1, 2
 * and 4 bytes respectively.
 */
typedef unsigned char UByte1;
typedef unsigned short UByte2;
typedef unsigned int UByte4;

/* Token definition */
#include "pmkCommon.h"

/* %%ATTRIBUTES - The semantic attributes for grammar symbols */
typedef struct pmkGrammar {
    prod_elnode *rule_elnode_last;
    prod_elnode *rule_elnode /* list of rhs elements (see prod_elnode's def) */;
    rhs_node *rhslist_last /* last element in the list above. This used to
                                        to avoid making a reversed list */;
    rhs_node *rhslist /* list of alternative righthand sides */;
    altr_lst *altr_last;
    altr_lst *altr_node /* list of alternatives (in EBNF alternation) */;
    SymSet nored_set /* modifier sets */;
    SymSet red_set /* modifier sets */;
    int code /* terminals code value given in TERMINAL section */;
    int dcost /* Delete cost given in TERMINAL section */;
    int icost /* Insert cost given in TERMINAL section */;
    Boolean nullf /* null flag */;
    Boolean q_str /* quoted_ string flag */;
    TmkSrcp srcp;
    char *sval2;
    char *sval;
    int ival;
} pmkGrammar;

/* END %%ATTRIBUTES */

/* Parser constants *\
\* ---------------- */
#define ERROR_ACT 0			/* Action - Error */
#define SHIFT_ACT 1			/* Action - Shift */
#define SHIFTRED_ACT 2		/* Action - Shift_Reduce */
#define REDUCE_ACT 3		/* Action - Reduce */
#define ACCEPT_ACT 4		/* Action - Accept */

#define ERR_SYM 0		/* Error token */
#define ENDMARK 1		/* End of file token code */

/* Recovery method *\
\* --------------- */
#define NONE_REC 0		/* No recovery found */
#define IN_REC 1		/* Insertion of symbol(s) */
#define DEL_REC 2		/* Deletion of symbol(s) */
#define REP_REC 3		/* Replacement of symbol(s) */
#define BAK_REC 4		/* Stack backup */
#define HALT_REC 5		/* System halted */

/* Error class *\
\* ----------- */
#define LEX_ERR 1		/* Non valid scanner symbol found */
#define SYN_ERR 2		/* Normal syntax error */
#define OFLW_ERR 3		/* Parse stack overflow */
#define TAB_ERR 4		/* Parse table error */
	   
/* Error severity *\
\* -------------- */
#define WAR_SEV 1		/* Warnings */
#define ERR_SEV 2		/* Repairable error */
#define FAT_SEV 3		/* Fatal error */
#define SYS_SEV 4		/* System & limit error */

/* Parser constants *\
\* ---------------- */
#define SccMax 33		/* Max scanner code value */
#define TermMin 1		/* Minimum terminal number */
#define Terms 33		/* Number of terminals in grammar */
#define StateMin 1		/* Minimum state number */
#define States 83		/* Number of states */
#define ProdMin 1		/* Minimum production number */
#define Prods 95		/* Number of productions */
#define PmStkMax 32		/* Parse stack size */
#define	PmLaMax 5		/* Look-ahead length */
#define	PmCost 5		/* Shifting cost */

/* Types *\
\* ----- */
typedef unsigned char TermSet[(Terms + TermMin + 7) >> 3]; /* Terminal set */
typedef UByte1 ParseStack[PmStkMax]; /* Parse stack */

/* Terminal table *\
\* -------------- */

typedef struct {
    UByte1 tsym;		/* Normal continuation */
    UByte1 ssym;		/* Separator continuation */
} ContRec;

typedef struct {
    ContRec cont[83];		/* Continuation function */
    TermSet sepa;		/* Separator symbols */
    TermSet fiduc;		/* Fiducial symbols */
    TermSet skip;		/* Symbols to skip */
} RecTab;

typedef struct  {
    UByte2 act[427];		/* Action table */
    UByte1 actCheck[452];	/* Row Displacement Check Vector*/
    UByte2 actRix[83];		/* Action row mapping */
    RecTab recover;		/* Error recovery info */
} TermTab;

static TermTab act = {
{4,627,627,627,755,154,627,162,627,627,627,627,627,627,227,627,627,627,603
,603,603,755,609,603,762,603,603,603,603,603,603,474,603,666,682,755,610
,153,690,666,682,762,755,755,202,755,755,195,755,755,755,755,755,755,755
,762,755,755,553,755,755,170,755,755,755,755,755,755,755,154,146,162,179
,577,762,755,755,442,755,755,19,755,755,755,755,755,755,522,762,755,755
,105,755,755,59,755,755,755,755,755,755,19,19,122,19,19,441,19,19,19,19
,19,19,593,491,59,59,449,641,665,361,649,59,59,59,633,657,627,627,627,154
,146,162,185,627,627,65,627,627,283,283,627,627,627,563,563,563,218,290
,211,89,563,563,394,563,563,458,211,563,666,682,154,146,162,154,146,162
,521,233,627,393,627,201,505,513,627,627,627,563,563,563,154,146,162,329
,563,563,521,563,563,0,0,563,666,682,154,146,162,371,154,146,162,233,627
,555,627,201,243,555,627,627,627,0,690,666,682,371,371,371,0,371,371,0,0
,371,154,146,162,0,243,627,169,233,674,627,243,201,489,0,627,627,627,563
,563,563,0,169,563,377,563,618,563,249,563,427,0,563,563,563,563,563,563
,481,169,563,409,563,169,563,658,563,0,0,563,563,563,627,627,627,154,146
,162,0,627,627,0,627,627,0,0,627,627,627,154,146,162,154,146,162,0,233,154
,146,162,201,627,0,627,627,627,627,627,627,154,146,162,0,627,299,0,0,627
,627,0,627,627,627,563,563,563,755,154,146,162,563,154,146,162,563,563,299
,563,666,682,755,0,314,43,0,0,762,755,755,154,146,162,0,169,755,465,755
,0,417,482,762,323,755,466,625,43,450,762,755,755,755,43,43,43,0,755,755
,755,0,323,323,323,83,323,323,0,154,323,162,579,762,579,755,755,0,690,666
,682,755,755,755,587,0,587,83,0,0,690,666,682,83,98,83,762,0,755,154,146
,162,0,169,755,345}
,
{1,15,15,15,8,8,15,8,15,15,15,15,15,15,74,15,15,15,16,16,16,79,74,16,8,16
,16,16,16,16,16,50,16,16,16,80,27,17,27,27,27,79,79,79,71,79,79,71,79,79
,79,79,79,79,81,80,80,80,67,80,80,68,80,80,80,80,80,80,82,59,59,59,69,69
,81,81,81,42,81,81,0,81,81,81,81,81,81,11,82,82,82,11,82,82,2,82,82,82,82
,82,82,0,0,70,0,0,53,0,0,0,0,0,0,72,6,2,2,54,2,2,43,2,2,2,2,2,2,30,30,30
,22,22,22,21,30,30,6,30,30,64,64,30,30,30,31,31,31,73,64,73,9,31,31,58,31
,31,46,73,31,31,31,32,32,32,65,65,65,60,32,32,47,32,32,61,61,32,32,32,34
,34,34,75,75,75,39,34,34,63,34,34,83,83,34,34,34,35,35,35,52,52,52,52,35
,35,14,35,35,4,14,35,35,35,83,14,14,14,52,52,52,83,52,52,83,83,52,13,13
,13,83,4,13,23,13,23,13,4,13,4,83,13,13,13,10,10,10,83,45,10,45,10,29,10
,29,10,57,83,10,10,10,12,12,12,57,49,12,49,12,19,12,19,12,83,83,12,12,12
,28,28,28,18,18,18,83,28,28,83,28,28,83,83,28,28,28,26,26,26,40,40,40,83
,26,44,44,44,26,26,83,26,26,26,24,24,24,48,48,48,83,24,5,83,83,24,24,83
,24,24,24,25,25,25,66,66,66,66,25,51,51,51,25,25,5,25,25,25,38,83,5,76,83
,83,66,78,66,20,20,20,83,56,66,56,66,83,38,38,38,37,38,38,76,76,38,78,78
,78,77,76,76,76,83,78,78,78,83,37,37,37,3,37,37,83,7,37,7,36,77,36,77,62
,83,36,36,36,77,77,77,33,83,33,3,83,83,33,33,33,3,3,3,62,83,62,55,55,55
,83,41,62,41,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83
,83,83,83,83,83}
,
{80,0,94,386,207,318,114,389,4,145,241,81,258,224,198,0,17,29,278,260,352
,125,129,224,309,326,292,23,275,241,126,143,160,396,177,194,384,365,344
,176,295,417,71,112,300,239,150,162,312,256,25,334,198,101,109,419,350,248
,147,68,166,167,397,186,133,163,330,53,57,66,97,40,106,143,8,180,347,374
,351,21,35,54,68}
,
{
{{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{2,2}
,{1,1}
,{6,6}
,{2,2}
,{7,7}
,{2,2}
,{7,7}
,{7,7}
,{2,2}
,{2,2}
,{9,9}
,{2,2}
,{10,10}
,{2,2}
,{9,9}
,{2,2}
,{10,10}
,{2,2}
,{2,2}
,{14,14}
,{14,14}
,{2,2}
,{10,10}
,{2,2}
,{2,2}
,{10,10}
,{10,10}
,{2,2}
,{10,10}
,{10,10}
,{1,1}
,{1,1}
,{9,9}
,{2,2}
,{10,10}
,{7,7}
,{9,9}
,{2,2}
,{10,10}
,{7,7}
,{9,9}
,{2,2}
,{10,10}
,{7,7}
,{2,2}
,{1,1}
,{6,6}
,{9,9}
,{2,2}
,{10,10}
,{7,7}
,{7,7}
,{2,2}
,{2,2}
,{7,7}
,{1,1}
,{2,2}
,{7,7}
,{2,2}
,{1,1}
,{6,6}
,{5,5}
,{7,7}
,{7,7}
,{8,8}
,{8,8}
,{7,7}
,{7,7}
,{2,2}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
,{1,1}
}
,
{0,0,0,0,0}
,
{0,0,0,0,0}
,
{0,0,0,0,0}
}
};


/* Non terminal table *\
\* ------------------ */
typedef  struct {
    UByte2 gto[203];		/* Goto table */
    UByte1 gtoRix[83];		/* Goto row mapping */
    UByte1 lhs[95];		/* Left hand side symbols */
    UByte1 rhsz[95];		/* Size of the RHS */
} NonTermTab;

static NonTermTab gto = {
{0,0,0,0,306,250,129,546,385,634,34,634,362,354,129,634,258,634,281,145
,177,145,177,497,17,145,177,145,177,353,634,25,241,137,330,346,321,538,338
,97,145,177,130,642,434,642,473,209,266,642,49,642,129,217,650,634,650,265
,113,26,650,130,650,545,642,145,177,129,274,257,634,74,289,722,561,650,634
,138,730,617,145,177,33,130,569,402,145,177,113,642,738,585,433,130,514
,402,138,498,90,130,650,545,433,130,642,410,594,305,106,594,642,537,594
,193,601,650,81,297,138,378,121,650,186,225,425,130,313,410,138,386,130
,50,410,530,138,337,57,506,138,73,369,138,66,130,138,410,114,138,570,698
,594,570,706,401,570,130,130,418,410,81,138,273,130,529,410,138,457,130
,714,234,746,0,161,0,0,0,530,0,138,0,10,0,0,0,0,138,0,0,0,41,138,138,570
,0,0,0,0,138,0,0,0,0,138}
,
{0,6,34,131,0,79,45,136,93,6,37,5,7,104,0,17,67,4,157,4,150,4,98,4,31,2
,107,8,2,3,53,6,145,46,21,101,61,89,0,1,120,1,1,1,125,1,1,1,138,1,1,78,88
,1,1,151,1,4,0,37,5,0,1,37,35,56,94,0,57,31,0,70,0,92,95,162,0,127,138,145
,148,164,166}
,
{58,65,65,82,44,44,79,79,83,92,92,66,89,89,86,41,39,39,74,74,51,87,87,55
,55,56,56,61,61,84,84,52,52,45,67,67,91,91,62,71,71,68,68,68,68,46,80,80
,75,48,49,49,76,76,72,70,69,63,47,42,60,60,37,37,35,57,36,36,34,85,85,64
,64,81,81,81,81,50,50,43,43,77,53,88,54,40,73,78,90,59,59,59,59,38,38}
,
{3,0,2,2,0,2,0,2,4,0,3,1,1,2,5,1,1,1,1,1,1,0,5,0,1,0,1,0,2,0,4,1,3,2,0,1
,0,3,1,0,2,1,1,1,1,2,1,2,7,1,1,3,0,2,5,1,5,1,5,1,0,3,1,2,4,1,1,3,2,0,2,3
,5,1,3,5,3,0,2,1,1,4,1,4,1,1,2,2,2,1,1,1,2,0,1}
};


/* Vocabulary *\
\* ---------- */
typedef struct {
    UByte1 scc;			/* Scanner code value */
    UByte1 iCost;		/* Insertion cost */
    UByte1 dCost;		/* Deletion cost */
    char *name;			/* Name string */
    char *psym;			/* Print name */
} VocTab[33];
			     
static VocTab voc = {{1,255,255,"EndOfText",""}
,{2,1,1,"IDENTIFIER","identifier"}
,{3,1,1,"STRING",""}
,{4,1,1,"ANG_BRACK_STRING",""}
,{5,1,1,"INTEGER",""}
,{6,1,1,"'='",""}
,{7,1,1,"';'",""}
,{8,1,1,"','",""}
,{9,1,1,"'('",""}
,{10,1,1,"')'",""}
,{11,1,1,"'!'",""}
,{12,1,1,"'|'",""}
,{13,1,1,"'{'",""}
,{14,1,1,"'}'",""}
,{15,1,1,"'=>'",""}
,{16,1,1,"'%%'",""}
,{17,1,1,"'%+'",""}
,{18,1,1,"'%-'",""}
,{19,1,1,"'META'",""}
,{20,1,1,"'SKIP'",""}
,{21,1,1,"'%%END'",""}
,{22,1,1,"'%%CODE'",""}
,{23,1,1,"'%%RULES'",""}
,{24,1,1,"'FIDUCIAL'",""}
,{25,1,1,"'%%EXPORT'",""}
,{26,1,1,"SKIPHEADER",""}
,{27,1,1,"'SEPARATOR'",""}
,{28,1,1,"'%%SCANNER'",""}
,{29,1,1,"'%%RECOVERY'",""}
,{30,1,1,"'%%TERMINALS'",""}
,{31,1,1,"'%%ATTRIBUTES'",""}
,{32,1,1,"'%%DECLARATIONS'",""}
,{33,1,1,"'%%INSERTSYMBOL'",""}
}
;


/* Variables used in the parsing process *\
\* ------------------------------------- */
short pmkStkP;			/* Stack pointer */
PmkToken pmkSySt[PmStkMax];	/* Symbol stack */
pmkGrammar pmkSeSt[PmStkMax];	/* Semantic stack */ 
static UByte1 currstat;		/* Current state number */
static UByte1 arg;		/* Argument */
static UByte1 action;		/* Action type */
static PmBoolean endparse;	/* Termination flag */
static ParseStack parsStk;	/* Parse stack */
static UByte1 scIndex[33 + 1]; /* Converts scanner code to internal value */
static PmkToken tokenBuf;	/* Scanner token buffer */
static PmkToken *token = &tokenBuf;	/* Pointer to it for readsymb */


/* Error recovery look-ahead buffer *\
\* -------------------------------- */
static PmkToken la_buff[PmLaMax + 1]; /* Buffer */
static int la_ptr;		/* Current pointer */
static int la_end;		/* Last item */

static jmp_buf pmJmpB;		/* Buffer for long jump */

/* Interface routines *\
\* ------------------ */

extern void pmkRPoi();	/* Error recovery - restart point  */
extern void pmkISym();	/* Error recovery - insert symbol  */
extern void pmkDSym();	/* Error recovery - delete symbol  */
extern void pmkMess();	/* Error recovery - error message  */

/* External functions */
void pmkPaSema();

/*----------------------------------------------------------------------------
 * paAbort - Abort the parsing process
 *----------------------------------------------------------------------------
 */
static void paAbort(token, eClass, severity) 
PmkToken *token;		/* IN current token */
short eClass;			/* IN error classification */
short severity;			/* IN error severity code */
{
    pmkMess(token, HALT_REC, eClass, severity);
    longjmp(pmJmpB, PMTRUE);	/* Jump out to top level */
}/*paAbort()*/


/*----------------------------------------------------------------------------
 * SetIns - Add one element to a set
 *----------------------------------------------------------------------------
 */
#define SetIns(set, n) ((set)[(n) >> 3] |= (0x80 >> ((n) & 0x7)))


/*----------------------------------------------------------------------------
 * SetClear - Clear a ParserMaker set
 *----------------------------------------------------------------------------
 */
#define SetClear(set, length) memset((void *)set, 0, ((length) + 7) >> 3)

/*----------------------------------------------------------------------------
 * SetMem - Check member inclusion
 *----------------------------------------------------------------------------
 */
#define SetMem(set, n) ((set)[(n) >> 3] & (0x80 >> ((n) & 0x7)))


/*----------------------------------------------------------------------------
 * paInit - Initialize the parsing process
 *----------------------------------------------------------------------------
 */
static void paInit()
{
    short i;

    la_ptr = 0;
    la_end = 0;
    pmkStkP = 0;
    currstat = 1;
    endparse = PMFALSE;
    parsStk[0] = 1;

    /* Scanner interface */
    for (i = 0; i <= SccMax; i++) scIndex[i] = ERR_SYM;
    for (i = TermMin; i <= Terms; i++) scIndex[voc[i - TermMin].scc] = (UByte1)i;
}/*paInit()*/


/*----------------------------------------------------------------------------
 * pushStat[Tok] - Push the current state on the stack and possibly push current
 *	      token on the symbol stack.
 *----------------------------------------------------------------------------
 */
#define MOVETOKEN pmkSySt[pmkStkP] = *token
#define pushStatTok()\
{\
    if (++pmkStkP < PmStkMax) {\
	parsStk[pmkStkP] = currstat;\
	MOVETOKEN;\
    } else {\
	token->code = voc[token->code-TermMin].scc;\
	paAbort(token, OFLW_ERR, SYS_SEV);\
    }\
} 

#define pushStat()\
{\
    if (++pmkStkP < PmStkMax) {\
	parsStk[pmkStkP] = currstat;\
    } else {\
	token->code = voc[token->code-TermMin].scc;\
	paAbort(token, OFLW_ERR, SYS_SEV);\
    }\
} 



/*----------------------------------------------------------------------------
 * actTbl - Do a look-up in the action table
 *----------------------------------------------------------------------------
 */
#define actTbl(st, sy, action, arg)\
{\
    register int actEnt;\
    register int actSt;\
    register int actSy;\
    actSt = st - StateMin;\
    actSy = sy - TermMin;\
    if (act.actCheck[act.actRix[actSt] + actSy] == actSt)\
	actEnt = act.act[act.actRix[actSt] + actSy];\
    else actEnt = ERROR_ACT;\
    *action = actEnt & 0x7;\
    *arg = actEnt >> 3;\
}/*actTbl()*/


/*----------------------------------------------------------------------------
 * gtoTbl - Do a look-up in the goto table
 *----------------------------------------------------------------------------
 */
#define gtoTbl(st, sy, action, arg)\
{\
    register int gtoEnt;\
    register int gtoSt;\
    register int gtoSy;\
    gtoSt = st - StateMin;\
    gtoSy = sy - Terms - 1;\
	gtoEnt = gto.gto[gto.gtoRix[gtoSt] + gtoSy];\
    *action = gtoEnt & 0x7;\
    *arg = gtoEnt >> 3;\
}/*gtoTbl()*/


/*----------------------------------------------------------------------------
 * E R R O R   R E C O V E R Y
 * ---------------------------
 *
 * The error recovery algorithm tries to modify current configuration in such
 * a way that parsing can be resumed correctly. Current configuration is
 * characterized by:
 *
 * w = x t y, where  x = parsed input
 *		     t = current token
 *		     y = unprocessed input
 *----------------------------------------------------------------------------
 */

typedef struct {
    PmkToken err_tok;
    PmkToken res_tok;
    short method;
    short eClass;
    short severity;
} ERR_REC;

static ERR_REC errdescr; 


/*----------------------------------------------------------------------------
 * ePush - Push a state during error recovery
 *----------------------------------------------------------------------------
 */
static void ePush(state, stack, sp)
UByte1 state;			/* IN state to push */
UByte1 stack[];			/* INOUT parser stack */
short *sp;			/* INOUT current stack pointer */
{
    if (++(*sp) < PmStkMax) stack[*sp] = state;
    else paAbort(&errdescr.err_tok, OFLW_ERR, SYS_SEV);
}/*ePush()*/


/*----------------------------------------------------------------------------
 * legalAct - Check if a symbol is legal to shift in current state
 *----------------------------------------------------------------------------
 */
static PmBoolean legalAct(stack, stack_p, sym)
UByte1 stack[];			/* IN current stack */
short stack_p;			/* IN current stack pointer */
UByte1 sym;			/* IN symbol code */
				/* RET true if "symbol" is read (shifted) */
				/*     in current state */
{
    UByte1 state;		/* Current state */
    UByte1 action;		/* Current parser action */
    UByte1 arg;			/* Current parser argument */

    ParseStack t_stk;		/* Temporary parser stack */
    int i;			/* For loop index */

    /* Copy stack
     */
    for (i = 0; i <= stack_p; i++) t_stk[i] = stack[i]; 

    state = stack[stack_p];

    for (;;) {
	actTbl(state, sym, &action, &arg);
	switch (action) {

	case ERROR_ACT:
	    return(PMFALSE);

	case SHIFT_ACT:
	case SHIFTRED_ACT:	
	case ACCEPT_ACT:
	    return(PMTRUE);

	case REDUCE_ACT:
	    do {
		stack_p = stack_p - gto.rhsz[arg - ProdMin];
		gtoTbl(t_stk[stack_p], gto.lhs[arg - ProdMin], &action, &arg);
		ePush(state, t_stk, &stack_p);
	    } while (action != SHIFT_ACT);
	    state = arg; t_stk[stack_p] = state;
	    break;

	}/*switch*/
    }/*for*/
}/*legalAct()*/
			     
	
/*----------------------------------------------------------------------------
 * gLegSym - Get legal symbols
 *----------------------------------------------------------------------------
 */
static void gLegSym(stack, stack_p, legals)
ParseStack stack;		/* IN current stack */
short stack_p;			/* IN current stack pointer */
TermSet legals;			/* OUT legal symbols in current state */
{
    short sym;			/* Loop index */

    SetClear(legals, Terms + 1);
    for (sym = 1; sym <= Terms; sym++) {
	if (legalAct(stack, stack_p, sym)) SetIns(legals, sym);
    }/*for*/
}/*gLegSym()*/


/*----------------------------------------------------------------------------
 * backup - Backup the parse stack until current symbol is accepted (shifted)
 *	    or the parse stack becomes empty
 *----------------------------------------------------------------------------
 */
static short backup(stack, stack_p, sym)
ParseStack stack;		/* IN current stack */
short stack_p;			/* IN current stack pointer */
UByte1 sym;	/* IN recovery symbol */
				/* RET new stack pointer, 0 if symbol is */
				/*     not accepted */
{
    while ((stack_p > 0) && (!legalAct(stack, stack_p, sym))) stack_p--;
    return(stack_p);
}/*backup()*/


/*----------------------------------------------------------------------------
 * delSym - Delete a symbol in the input stream
 *----------------------------------------------------------------------------
 */
static void delSym(token)
PmkToken *token;			/* INOUT symbol to delete, new symbol */
{
    short  t;

    t = token->code - TermMin;
    token->code = voc[t].scc;
    pmkDSym(token, voc[t].name, voc[t].psym);
{
    if (la_ptr < la_end) {
	la_ptr++;
	*token = la_buff[la_ptr];
    } else {
	do {
	     pmkScan(pmkCtxt, token);

	    if (token->code > SccMax || token->code < 0) {
		token->code = ERR_SYM;
	    } else token->code = scIndex[token->code];
	    if (token->code == ERR_SYM) {
		pmkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
		}
	} while (token->code == ERR_SYM);
    }
}
    if (errdescr.method == IN_REC) errdescr.method = REP_REC;
    else if (errdescr.method != REP_REC) errdescr.method = DEL_REC;
}/*delSym()*/


/*----------------------------------------------------------------------------
 * inSym - Insert a symbol in the input stream
 *----------------------------------------------------------------------------
 */
static void inSym(isym, gen_symb)
short isym;			/* IN symbol code to insert */
PmkToken *gen_symb;		/* OUT created symbol */
{
    pmkISym(voc[isym - TermMin].scc, voc[isym - TermMin].name,
	   voc[isym - TermMin].psym, gen_symb);
    if (errdescr.method == DEL_REC) errdescr.method = REP_REC;
    else if (errdescr.method != REP_REC) errdescr.method = IN_REC; 

    gen_symb->code = isym;
}/*inSym()*/


/*----------------------------------------------------------------------------
 * M U L T I P L E   R E C O V E R Y
 * ---------------------------------
 *
 * The multiple symbols recovery technique is a "true local corrector", i.e.
 * it will always return a legal configuration for any input. Logically the
 * algorithm can be described as follows:
 *
 * 1) Roerich method (Karlsruhe):
 *    a. Find a continuation "u" of "x", such that "xu" is accepted.
 *    b. De composite "ty" into "qsy'", where q is a string.
 *    c. Delete "q".
 *    d. Insert u' (a prefix of u) between "x" and "sy'" giving xu' s y'.
 *
 * 2) Panic mode:
 *    If "q" contains a fiducial symbol "a"  then:
 *    a. Pop stack until "a" is accepted.
 *    b. If not succeeded resume at step 1.
 *----------------------------------------------------------------------------
 */

typedef struct {
    UByte1 r_state;		/* Recovery state */
    PmBoolean r_sepa;		/* Insert separator? */
    UByte1 r_sstat;		/* Where to insert separator */
} REC_POI;


/*----------------------------------------------------------------------------
 * acceptbl - Check whether "symbol" is reachable from current state using
 *	      the continuation grammar.
 *----------------------------------------------------------------------------
 */
static void acceptbl(sym, stack, stack_p, token, found, point)
UByte1 sym;			/* IN terminal symbol code */
ParseStack stack;		/* IN parse stack */
short stack_p;			/* IN stack pointer */
PmkToken *token;			/* IN current token */
PmBoolean *found;		/* OUT "symbol" accepted? */
REC_POI *point;			/* OUT recovery point description */
{
    PmBoolean done;		/* Terminator flag */
    UByte1 state;		/* Current state */
    UByte1 action;		/* Parser action */
    UByte1 sep_act;		/* Parser action separator test */
    UByte1 arg;			/* Parser prod/state */
    UByte1 sep_arg;		/* Parser prod/state separator test */
    PmBoolean sepa_acc;		/* Separator is accepted? */
    ParseStack t_stk;		/* Temporary parser stack */
    short i;			/* Copy loop index */

    for (i = 0; i <= stack_p; i++) t_stk[i] = stack[i];

    state = t_stk[stack_p];
    done = PMFALSE;

    while (!done) {
	actTbl(state, sym, &action, &arg);
	if (legalAct(t_stk, stack_p, sym)) {
	    /* Symbol is directly accepted */
	    done = PMTRUE;
	    *found = PMTRUE;
	    point->r_state = state;
	} else {
	    /* Use the continuation grammar */
	    actTbl(state, act.recover.cont[state - StateMin].tsym, &action,
		   &arg);
	    actTbl(state, act.recover.cont[state - StateMin].ssym, &sep_act,
		   &sep_arg);
	    if ((action != sep_act) || (arg != sep_arg)) {
		/* A separator is legal. Check if current symbol is accepted
		 * behind the separator
		 */
	        ParseStack stk;	/* Temporary stack */
	        short sp;	/* Temporary stack pointer */

		sp = stack_p; 
		for (i = 0; i <= stack_p; i++) stk[i] = t_stk[i];
		sepa_acc = PMFALSE;

		while (!sepa_acc) {
		  actTbl(stk[sp], act.recover.cont[state - StateMin].ssym,
			 &sep_act, &sep_arg);
		    switch (sep_act) {

		    case ERROR_ACT:
		    case ACCEPT_ACT:
			sepa_acc = PMTRUE;
			break;

		    case SHIFT_ACT: 
			sepa_acc = PMTRUE;
			ePush(sep_arg, stk, &sp);
			break;

		    case SHIFTRED_ACT:
			ePush(1, stk, &sp);
			sepa_acc = PMTRUE;
			goto reduce;

		    case REDUCE_ACT:
		      reduce:
			do {
			    sp -= gto.rhsz[sep_arg-ProdMin];
			    gtoTbl(stk[sp], gto.lhs[sep_arg-ProdMin], &sep_act,
				   &sep_arg);
			    ePush(1, stk, &sp);
			} while (sep_act != SHIFT_ACT);

			stk[sp] = sep_arg;
			break;
		    }/*switch*/
		}/*while*/

		if ((sep_act == SHIFT_ACT) || (sep_act == SHIFTRED_ACT)) {
		    if (legalAct(stk, sp, sym)) {
			/* Separator is to be inserted */
			point->r_state = stk[sp];
			point->r_sepa = PMTRUE;
			point->r_sstat = state;
			done = PMTRUE;
			*found = PMTRUE;
		    }/*if*/
		}/*if*/
	    }/*if*/
		  
	    if (!*found) {
		switch (action) {

		case ERROR_ACT: 
		    paAbort(token, TAB_ERR, SYS_SEV);
		    break;

		case ACCEPT_ACT:
		    done = PMTRUE;
		    break;

		case SHIFT_ACT:
		    state = arg;
		    ePush(state, t_stk, &stack_p);
		    break;

		case SHIFTRED_ACT:
		    ePush(state, t_stk, &stack_p);
		    goto reduce2;

		case REDUCE_ACT:
		  reduce2:
		    do {
			stack_p -= gto.rhsz[arg-ProdMin];
			gtoTbl(t_stk[stack_p], gto.lhs[arg-ProdMin], &action,
			       &arg);
			ePush(state, t_stk, &stack_p);
		    } while (action != SHIFT_ACT);

		    state = arg;
		    t_stk[stack_p] = state;
		    break;

		}/*switch*/
	    }/*if*/
	}/*if*/
    }/*while*/
}/*acceptbl()*/


/*----------------------------------------------------------------------------
 * search - Search recovery point
 *----------------------------------------------------------------------------
 */
static void search(stack, stack_p, token, point)
ParseStack stack;		/* IN current stack */
short *stack_p;			/* INOUT current stack pointer */
PmkToken *token;			/* INOUT current symbol */
REC_POI *point;			/* OUT descriptor of where to restart */
				/*     the parser */
{
    UByte1 state;		/* Current state */
    PmBoolean rp_found;		/* Recovery point found? */
    short new_stkp;		/* Temp stack pointer */

    state = stack[*stack_p];
    point->r_state = state;
    point->r_sepa = PMFALSE;
    point->r_sstat = 1;
    rp_found = PMFALSE;

    do {
	if (!SetMem(act.recover.skip, token->code)) {
	    acceptbl(token->code, stack, *stack_p, token, &rp_found, point);
	}/*if*/

	if (!rp_found) {
	    new_stkp = 0;
	    if (SetMem(act.recover.fiduc, token->code)) {
		new_stkp = backup(stack, *stack_p, token->code);
	    }/*if*/
	    if (new_stkp > 0) {
		rp_found = PMTRUE;
		*stack_p = new_stkp;
		point->r_state = stack[*stack_p];
		errdescr.method = BAK_REC;
	    } else 
	        delSym(token);
	}/*if*/
    } while (!rp_found);
}/*search()*/


/*----------------------------------------------------------------------------
 * reach - Use the continuation functions and insert symbols upto curr token.
 *----------------------------------------------------------------------------
 */
static void reach(stack, stack_p, token, point)
ParseStack stack;		/* INOUT current stack */
short *stack_p;			/* INOUT current stack pointer */	
PmkToken *token;			/* INOUT current symbol */
REC_POI *point;			/* IN recovery point descriptor */
{
    UByte1 state;		/* Current state */
    UByte1 cont_sym;		/* Continuation symbol */
    PmkToken gen_symb;		/* Generated symbol */
    UByte1 action;		/* Current parser action */
    UByte1 arg;			/* Current prod/state */
    PmBoolean sepaAccept;	/* Separator accepted yet? */
    PmBoolean useSepa;		/* Use the separator now? */

    state = stack[*stack_p];
    gen_symb = *token;
    useSepa = PMFALSE;
    while (state != point->r_state) {
	if (point->r_sepa)
	    if (state == point->r_sstat) {
		/* Separator state reached, remember to use separator */
		cont_sym = act.recover.cont[state-StateMin].ssym;
		useSepa = PMTRUE;
	    } else cont_sym = act.recover.cont[state-StateMin].tsym;
	else cont_sym = act.recover.cont[state-StateMin].tsym;
	sepaAccept = PMFALSE;

	do {
	  actTbl(state, cont_sym, &action, &arg);
	  switch (action) {

	  case ERROR_ACT:
	    paAbort(token, TAB_ERR, SYS_SEV);
	    break;

	  case ACCEPT_ACT:
	    break;

	  case SHIFT_ACT:
	    sepaAccept = PMTRUE;
	    state = arg;
	    inSym(cont_sym, &gen_symb);
	    ePush(state, stack, stack_p);
	    pmkSySt[*stack_p] = gen_symb;
	    break;

	  case SHIFTRED_ACT:
	    sepaAccept = PMTRUE;
	    inSym(cont_sym, &gen_symb);
	    ePush(state, stack, stack_p);
	    pmkSySt[*stack_p] = gen_symb;
	    goto reduce;

	  case REDUCE_ACT:
	    reduce:
	    do {
		*stack_p = *stack_p - gto.rhsz[arg-ProdMin];
		pmkPaSema(arg);
		gtoTbl(stack[*stack_p], gto.lhs[arg-ProdMin], &action, &arg);
		ePush(state, stack, stack_p);
	    } while (action != SHIFT_ACT);
	    state = arg;
	    stack[*stack_p] = state;
	  }/*switch*/
	} while (useSepa && !sepaAccept);
    }/*while*/
}/*reach()*/


/*----------------------------------------------------------------------------
 * global - Global error recovery
 *----------------------------------------------------------------------------
 */
static void multiple(err_stk, err_stkp, err_tok, newstat)
ParseStack err_stk;		/* INOUT current parse stack */
short *err_stkp;		/* INOUT current stack pointer */
PmkToken *err_tok;		/* INOUT current token */
UByte1 *newstat;		/* OUT state after recovery */	
{
    REC_POI  point;		/* Recovery point descriptor */

    search(err_stk, err_stkp, err_tok, &point);
    reach(err_stk, err_stkp, err_tok, &point);
    *newstat = err_stk[*err_stkp];
}/*multiple()*/


/*----------------------------------------------------------------------------
 * S I N G L E   R E C O V E R Y
 * -----------------------------
 *
 * The single recovery technique tries to REPAIR the error by finding the
 * least cost single symbol correction. One single symbol of:
 * - insertion
 * - deletion
 * - replacement
 * is concidered. The cost of the repair is the sum of the ADAPTION cost and
 * the MODIFICATION cost. The adaption cost indicates how well a correction
 * fits in the context. The modification cost is based on the
 * insertion/deletion cost given in the input. A correction is applied if
 * the cost is below a predefined threshold value.
 *----------------------------------------------------------------------------
 */

#define ShiftCost (PmCost)	/* The cost of shifting one symbol */
#define InfCost (ShiftCost * (PmLaMax)) /* Infinity */
#define Thresh (((PmLaMax) - 3) * ShiftCost) /* Acceptance cost */


/*----------------------------------------------------------------------------
 * readLa - Read tokens to the look-ahead buffer
 *----------------------------------------------------------------------------
 */
static void readLa(curtok)
PmkToken *curtok;			/* IN current token */
{
    int i;
    PmkToken tokbuf;
    PmkToken *token = &tokbuf;

    la_buff[0] = *curtok;
    *token = *curtok;
    for (i = la_ptr + 1; i <= la_end; i++) {
	/* Move old look_ahead to the beginning of the buffer */
	la_buff[i - la_ptr] = la_buff[i];
    }/*for*/
    la_end = la_end - la_ptr;
    la_ptr = -1;

    while ((la_buff[la_end].code != ENDMARK) && (la_end < PmLaMax)) {
	la_end++;
	do {
             pmkScan(pmkCtxt, token);

	    if (token->code > SccMax || token->code < 0) {
		token->code = ERR_SYM;
	    } else {
		token->code = scIndex[token->code];
	    }/*if*/
	    if (token->code == ERR_SYM) {
		pmkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
	    }/*if*/
	} while (token->code == ERR_SYM);
	la_buff[la_end] = *token;
    }/*while*/
}/*readLa()*/


/*----------------------------------------------------------------------------
 * rdLaSym - Fetches the i:th look-ahead symbol code from the look-ahead set
 *----------------------------------------------------------------------------
 */
static UByte1 rdLaSym(index)
char index;			/* IN i:th look-ahead symbol */
				/* RET token code */
{
    if (index > la_end) return(ENDMARK);
    else return(la_buff[(int)index].code);
}/*rdLaSym()*/


/*----------------------------------------------------------------------------
 * laParse - Continue the parsing process by reading tokens from the
 *	     look-ahead set. The parse is terminated when:
 *	     - out of read ahead
 *	     - a new error is encountered
 *	     Note! No semantic actions are carried out
 *----------------------------------------------------------------------------
 */
static void laParse(sym, next_la, stack, stack_p, cost)
UByte1 sym;			/* IN current terminal symbol */
char next_la;			/* IN index to next look-ahead symbol */
ParseStack stack;		/* IN parse stack */
short stack_p;			/* IN current stack pointer */
short *cost;			/* OUT adaption cost */
{
    PmBoolean done ;		/* Terminator flag */
    char sh_cnt;		/* Number of shifted symbols */
    UByte1 state;		/* Current state number */
    UByte1 action;		/* Parser action */
    UByte1 arg; 		/* Parser argument */
    short i;			/* Loop index */
    ParseStack t_stk;		/* Temporary stack */

    /* Copy stack
     */
    for (i = 0; i <= stack_p; i++) t_stk[i] = stack[i];	

    done = PMFALSE;
    sh_cnt = 0;
    state = t_stk[stack_p];

    while (!done) {
	actTbl(state, sym, &action, &arg);
	
	switch (action) {

	case ERROR_ACT: 
	    done = PMTRUE;
	    break;

	case SHIFT_ACT:
	    state = arg;
	    ePush(state, t_stk, &stack_p);
	    sh_cnt++;
	    if (sh_cnt == PmLaMax) done = PMTRUE;
	    else {
		sym = rdLaSym(next_la);
		next_la++;
	    }/*if*/
	    break;

	case SHIFTRED_ACT:
	    ePush(state, t_stk, &stack_p);
	    sh_cnt++;
	    if (sh_cnt == PmLaMax) done = PMTRUE;
	    else {
		sym = rdLaSym(next_la);
		if (next_la < PmLaMax) next_la++;
	    }/*if*/
	    goto reduce;

	case REDUCE_ACT:
	  reduce:
	    do {
		stack_p -= gto.rhsz[arg-ProdMin];
		gtoTbl(t_stk[stack_p], gto.lhs[arg-ProdMin], &action, &arg);
		ePush(state, t_stk, &stack_p);
	    } while (action != SHIFT_ACT); 

	    state = arg;
	    t_stk[stack_p] = state;
	    break;

	case ACCEPT_ACT:
	    done = PMTRUE;
	    sh_cnt = PmLaMax;
	    break;

	}/*switch*/
    }/*while*/

    *cost = InfCost - (sh_cnt*ShiftCost);
}/*laParse()*/


/*----------------------------------------------------------------------------
 * tryIn - Tries to insert a symbol from the legal set in front of current
 *	   token: x t y  => x st y, where s becomes current symbol
 *----------------------------------------------------------------------------
 */
static void tryIn(legals, stack, stack_p, sym, cost, choice)
TermSet legals;			/* IN set of legal symbols */
ParseStack stack;		/* IN current parser stack */
short stack_p;			/* IN current stack pointer */
UByte1 *sym;			/* OUT best insertion symbol */
short *cost;			/* OUT best cost so far */
short *choice;			/* OUT best choice so far */
{
    short i;
    short mod_cost;		/* Modification cost */
    short ad_cost;		/* Adaption cost */
    short tot_cost;		/* Total insertion cost */

    for (i = 1; i <= Terms; i++) {
	/* For all legal symbols
	 */
	if (SetMem(legals, i)) {
	    mod_cost = voc[i - TermMin].iCost;
	    if (mod_cost < *cost) {
		laParse(i, 0, stack, stack_p, &ad_cost);
		tot_cost = ad_cost + mod_cost;
		if (tot_cost < *cost) {
		    *cost = tot_cost;
		    *choice = IN_REC;
		    *sym = (UByte1)i;
		}/*if*/
	    }/*if*/
	}/*if*/
    }/*for*/
}/*tryIn()*/


/*----------------------------------------------------------------------------
 * tryRep - Tries to replace currrent symbol with a new terminal:
 *	    x t y  => x s y, where s becomes current symbol
 *----------------------------------------------------------------------------
 */
static void tryRep(legals, stack, stack_p, sym, cost, choice)
TermSet legals;			/* IN set of legal symbols */
ParseStack stack;		/* IN current parser stack */
short stack_p;			/* IN current stack pointer */
UByte1 *sym;			/* OUT best replacement symbol */
short *cost;			/* OUT best cost so far */
short *choice;			/* OUT best choice so far */
{
    short i;
    short mod_cost;		/* Modification cost */
    short ad_cost;		/* Adaption cost */
    short tot_cost;		/* Total replacment cost */

    for (i = 1; i <= Terms; i++) {
	/* For all legal symbols
	 */
	if (SetMem(legals, i)) {
	    mod_cost = (short) (voc[i-TermMin].iCost +
			voc[rdLaSym(0)-TermMin].dCost) / 2 + 1;
	    if (mod_cost < *cost) {
		laParse(i, 1, stack, stack_p, &ad_cost);
		tot_cost = ad_cost + mod_cost;
		if (tot_cost < *cost) {
		    *cost = tot_cost;
		    *choice = REP_REC;
		    *sym = (UByte1)i;
		}/*if*/
	    }/*if*/
	}/*if*/
    }/*for*/
}/*tryRep()*/


/*----------------------------------------------------------------------------
 * tryDel - Tries to delete current symbol: x t y  => x y
 *----------------------------------------------------------------------------
 */
static void tryDel(stack, stack_p, cost, choice)
ParseStack stack;		/* IN current parser stack */
short stack_p;			/* IN current stack pointer */
short *cost;			/* INOUT best cost so far */
short *choice;			/* INOUT best choice so far */
{
    short mod_cost;		/* Modification cost */
    short ad_cost;  		/* Adaption cost */
    short tot_cost;		/* Total deletion cost */

    mod_cost = voc[rdLaSym(0) - TermMin].dCost;
    if (mod_cost < *cost) {
	laParse(rdLaSym(1), 2, stack, stack_p, &ad_cost);
	tot_cost = ad_cost + mod_cost;
	if (tot_cost < *cost) {
	    *cost = tot_cost;
	    *choice = DEL_REC;
	}/*if*/
    }/*if*/
}/*tryDel()*/


/*----------------------------------------------------------------------------
 * _pmInsert
 *----------------------------------------------------------------------------
 */
static void _pmInsert(sym, token)
UByte1 sym;			/* IN symbol code to insert */
PmkToken *token;			/* OUT constructed token */
{
    inSym(sym, token);
}/*_pmInsert()*/


/*----------------------------------------------------------------------------
 * _pmReplace
 *----------------------------------------------------------------------------
 */
static void _pmReplace(sym, token)
UByte1 sym;			/* IN replacement symbol code */
PmkToken *token;			/* OUT constructed token */
{
    delSym(token);
    inSym(sym, token);
}/*_pmReplace()*/


/*----------------------------------------------------------------------------
 * _pmDelete
 *----------------------------------------------------------------------------
 */

static void _pmDelete(token)
PmkToken *token;			/* OUT new token */
{
{
    if (la_ptr < la_end) {
	la_ptr++;
	*token = la_buff[la_ptr];
    } else {
	do {
	     pmkScan(pmkCtxt, token);

	    if (token->code > SccMax || token->code < 0) {
		token->code = ERR_SYM;
	    } else token->code = scIndex[token->code];
	    if (token->code == ERR_SYM) {
		pmkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
		}
	} while (token->code == ERR_SYM);
    }
}
    delSym(token);
}/*_pmDelete()*/


/*----------------------------------------------------------------------------
 * single - Single error recovery
 *----------------------------------------------------------------------------
 */
static void single(leg_sys, err_stk, err_stkp, token, newstat)
TermSet leg_sys;		/* IN legal symbols in current state */
ParseStack err_stk;		/* INOUT current parser stack */
short *err_stkp;		/* INOUT current stack pointer */
PmkToken *token;		/* INOUT current token */
UByte1 *newstat;		/* OUT recovery state */
{
    short choice;		/* Recovery action performed */
    short cost;			/* Best cost so far */
    UByte1 sym;			/* Insert symbol */

    choice = NONE_REC;
    cost = InfCost;
    readLa(token);

    tryIn(leg_sys, err_stk, *err_stkp, &sym, &cost, &choice);
    tryRep(leg_sys, err_stk, *err_stkp, &sym, &cost, &choice);
    tryDel(err_stk, *err_stkp, &cost, &choice);

    if (cost > Thresh) choice = NONE_REC;

    switch (choice) {

    case IN_REC:
	_pmInsert(sym, token);
	break;

    case DEL_REC:  
	_pmDelete(token);
	break;

    case REP_REC: 
	_pmReplace(sym, token);
	break;

    default:
{
    if (la_ptr < la_end) {
	la_ptr++;
	*token = la_buff[la_ptr];
    } else {
	do {
	     pmkScan(pmkCtxt, token);

	    if (token->code > SccMax || token->code < 0) {
		token->code = ERR_SYM;
	    } else token->code = scIndex[token->code];
	    if (token->code == ERR_SYM) {
		pmkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
		}
	} while (token->code == ERR_SYM);
    }
}
    }/*switch*/

    *newstat = err_stk[*err_stkp];
}/*single()*/



/*----------------------------------------------------------------------------
 * recover - From an error
 *----------------------------------------------------------------------------
 */
static void recover(err_stk, err_stkp, err_symb, rec_stat)
ParseStack err_stk;		/* INOUT updated parse stack */
short *err_stkp;		/* INOUT updated stack pointer */
PmkToken *err_symb;		/* INOUT current token */
UByte1 *rec_stat;		/* OUT state after recovery */
{
    TermSet legal_sy;		/* Legal symbols */

    errdescr.err_tok = *err_symb;
    errdescr.err_tok.code = voc[errdescr.err_tok.code - TermMin].scc;
    errdescr.method = NONE_REC;
    errdescr.eClass = SYN_ERR;
    errdescr.severity = ERR_SEV;
    gLegSym(err_stk, *err_stkp, legal_sy);
    single(legal_sy, err_stk, err_stkp, err_symb, rec_stat);
    if (errdescr.method == NONE_REC) {
	multiple(err_stk, err_stkp, err_symb, rec_stat);
	pmkMess(&errdescr.err_tok, errdescr.method, errdescr.eClass, 
	       errdescr.severity); 
    } else {
	pmkMess(&errdescr.err_tok, errdescr.method, SYN_ERR, errdescr.severity);
    }/*if*/
    errdescr.res_tok = *err_symb;
    errdescr.res_tok.code = voc[errdescr.res_tok.code - TermMin].scc;
    pmkRPoi(&errdescr.res_tok);
}/*recover()*/


/*----------------------------------------------------------------------------
 * pmkParse - Parser routine, entry point
 *----------------------------------------------------------------------------
 */
void pmkParse()
{
    paInit();
{
    if (la_ptr < la_end) {
	la_ptr++;
	*token = la_buff[la_ptr];
    } else {
	do {
	     pmkScan(pmkCtxt, token);

	    if (token->code > SccMax || token->code < 0) {
		token->code = ERR_SYM;
	    } else token->code = scIndex[token->code];
	    if (token->code == ERR_SYM) {
		pmkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
		}
	} while (token->code == ERR_SYM);
    }
}
    pushStatTok()
    if (setjmp(pmJmpB)) return;

    while (!endparse) {
	actTbl(currstat, token->code, &action, &arg);

	switch (action) {

	case ERROR_ACT:
	    recover(parsStk, &pmkStkP, token, &currstat);
	    if (pmkStkP == 0) endparse = PMTRUE;
	    break;

	case SHIFT_ACT:
	    currstat = arg;
	    pushStatTok();
{
    if (la_ptr < la_end) {
	la_ptr++;
	*token = la_buff[la_ptr];
    } else {
	do {
	     pmkScan(pmkCtxt, token);

	    if (token->code > SccMax || token->code < 0) {
		token->code = ERR_SYM;
	    } else token->code = scIndex[token->code];
	    if (token->code == ERR_SYM) {
		pmkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
		}
	} while (token->code == ERR_SYM);
    }
}
	    break;

	case SHIFTRED_ACT:
	    pushStatTok();
{
    if (la_ptr < la_end) {
	la_ptr++;
	*token = la_buff[la_ptr];
    } else {
	do {
	     pmkScan(pmkCtxt, token);

	    if (token->code > SccMax || token->code < 0) {
		token->code = ERR_SYM;
	    } else token->code = scIndex[token->code];
	    if (token->code == ERR_SYM) {
		pmkMess(token, DEL_REC, LEX_ERR, FAT_SEV);
		}
	} while (token->code == ERR_SYM);
    }
}
	    goto reduce;

 	case REDUCE_ACT:
	  reduce:
	    do {
		pmkStkP -= gto.rhsz[arg - ProdMin];	
		pmkPaSema(arg);
		gtoTbl(parsStk[pmkStkP], gto.lhs[arg - ProdMin], &action, &arg);
		pushStat();
	    } while (action != SHIFT_ACT);

	    currstat = arg;
	    parsStk[pmkStkP] = currstat;
	    break;

	case ACCEPT_ACT:
	    endparse = PMTRUE;
	    break;
	}/*switch*/
    }/*while*/
}/*pmkParse()*/

+++++ pmkParse.h +++++
#ifndef _pmkParse_h_
#define _pmkParse_h_
/*----------------------------------------------------------------------*\

  pmkParse.h

  Parser interface

\*----------------------------------------------------------------------*/


/* Token and Srcp definition */
#include "pmkCommon.h"

/* External functions */
extern void pmkParse(); /* Parser */


#endif
