########## skipcode ##########
set os = "$argv[1]"
if ("$os" == "PC") then
  dos2unix -ascii skipcode.tst.win32 > skipcode.tmp
  alias cat dos2unix -ascii
else
  ../pmk skipcode > skipcode.tmp
endif
echo +++++ skipcode.tmk +++++  >> skipcode.tmp
\cat skipcode.tmk >> skipcode.tmp
echo +++++ skipcode.pml +++++ >> skipcode.tmp
cat skipcode.pml >> skipcode.tmp
echo +++++ skipcode.pmt +++++ >> skipcode.tmp
cat skipcode.pmt >> skipcode.tmp
echo +++++ skipcode.voc +++++ >> skipcode.tmp
cat skipcode.voc >> skipcode.tmp
\cat skipcode.tmp
\rm skipcode.tmp
########## /bin/csh -f skipcode.tst UNIX ##########
+++++ skipcode.tmk +++++
----------------------------------------------------------------------------
-- tt.tmk 			Date: 1993-06-07/toolmake
-- 
-- Common ANSI-C definitions for all ToolMaker tools.
--
----------------------------------------------------------------------------
-- Created:   1993-04-27/reibert@roo
-- Generated: 1993-06-07 14:36:09/toolmake v2,r0,c5
----------------------------------------------------------------------------

%%OPTIONS
--	Os 'SunOS';

%%IMPORT
typedef int TmNatural;     /* A natural number of "reasonable" length. */
typedef int TmCode;        /* The type of a token code. */
%%END

%%SRCP Name TmSrcp;
    Row line %% TmNatural %1 %%;
    Column col %% TmNatural %1 %%;
    File file %% TmNatural %1 %%;
%%END

%%TOKEN Name TmToken;
    Code code %% TmCode %1 %%;
    Srcp srcp %% TmSrcp %1 %%;
    Attributes
        stringValue %% char %1[256] %%,
        integerValue %% int %1 %%;
%%END

+++++ skipcode.pml +++++
+++++ skipcode.pmt +++++
%%SET tmkTokenName("TmToken")
%%SET tmkTokenCode("code")
%%SET tmkTokenSrcp("srcp")
%%SET tmkTokenDecl (" TmCode code ", " TmSrcp srcp ", " char stringValue[256] ", " int integerValue ")
%%SET tmkSrcpName("TmSrcp")
%%SET tmkSrcpRow("line")
%%SET tmkSrcpCol("col")
%%SET tmkSrcpFile("file")
%%SET tmkSrcpDecl(" TmNatural line ", " TmNatural col ", " TmNatural file ")
%%BEGIN(tmkImport)

typedef int TmNatural;     /* A natural number of "reasonable" length. */
typedef int TmCode;        /* The type of a token code. */
%%END(tmkImport)
%%SET tmkForce(0)
%%SET tmkOs("SunOS")
%%SET pmkOs("SunOS")
%%SET currentOs("SunOS")
%%SET tmkTarget("ansi-c")
%%SET pmkTarget("ansi-c")
%%SET tmkLibrary("%%(TMHOME)/lib/%%(tmkTarget)/")
%%SET pmkLibrary("..")
%%SET tmkPrefix("tm")
%%SET parserPrefix("pm")
%%SET listerPrefix("tm")
%%SET tmkCodeDecl(" TmCode code ")
%%SET tmkGrmAttrDecl(" int integerValue ", " char stringValue[256] ", " Node* list ", " TmSrcp srcp ")
%%SET tmkGrmAttrNames("integerValue", "stringValue", "list", "srcp")
%%BEGIN(pmkImport)

#include <stdio.h>
#include <strings.h>

#include "ttParse.h"
#include "ttList.h"
#include "ttScan.h"
extern ttScContext lexContext;

%%END(pmkImport)
%%BEGIN(pmkExport)

/* Semantic attribute interface */
 
/* Internal node type */
typedef struct Node {
    char *string;
    int value;
    struct Node *next;
} Node;
 
%%END(pmkExport)
%%PROCESS("%%(tmkLibrary)/Common.imp")
%%SET pmStackMax(32)
%%SET pmLookAheadMax(5)
%%SET pmCost(5)
%%BEGIN(pmISym)


    /* Make the requested token */
    sym->code = code;

%%END(pmISym)
%%SET pmOptimize(Lr0)
%%SET pmActPack(RDS)
%%SET pmGtoPack(RDS)
%%SET pmRec(Single, Multiple, Panic)
%%BEGIN(pmDecl)

/* Counters for the various contructs */
static int constants, variables, procedures, statements;

/* The node constituting the program */
static Node *program;


/*-----------------------------------------------------------------------------
    makeNode()

    Make a new list node and initialize it.

 */
static Node *makeNode(char *string, int value)
{
    Node *temp;

    temp = (Node *)malloc(sizeof(Node));
    temp->string = (char *)malloc(strlen(string) + 1);
    strcpy(temp->string, string);
    temp->value = value;
    temp->next = NULL;
    return temp;
}


/*-----------------------------------------------------------------------------
    append()

    Append two lists of nodes.

 */
static Node *append(Node *list1, Node *list2)
{
   if (list1->next) return append(list1->next, list2);
    else {
	list1->next = list2;
	return list1;
    }
}


/*-----------------------------------------------------------------------------
    summary()

    Print a summary of the PL/0 program using the Lister.

 */
void summary()
{
  Node *node;
  char buf[256];

  sprintf(buf, "Number of constants:  `%u", constants);
  ttLiPrint(buf);
  for (node = program; node; node = node->next) {
    sprintf(buf,"  `%s = `%d", node->string, node->value);
    ttLiPrint(buf);
  }
  ttLiPrint("");
  sprintf(buf, "Number of variables:  `%u", variables);
  ttLiPrint(buf);
  sprintf(buf, "Number of procedures: `%u", procedures);
  ttLiPrint(buf);
  sprintf(buf, "Number of statements: `%u", statements);
  ttLiPrint(buf);
} 


%%END(pmDecl)
%%SET pmStates(42)
%%SET pmStateTyp(1)
%%SET pmTerms(30)
%%SET pmTermTyp(1)
%%SET pmActTyp(2)
%%SET pmArgTyp(1)
%%SET pmActRDSvectorLen(251)
%%BEGIN(pmActTab)
{4,338,346,315,315,65,315,315,315,315,315,315,129,315,315,315,402,410,186
,315,194,315,42,297,338,346,307,307,315,307,307,307,307,307,307,129,307
,307,307,402,410,169,307,193,307,82,337,338,346,299,299,307,299,299,299
,299,299,299,129,299,386,394,35,257,35,299,265,299,354,122,75,305,75,75
,299,81,305,313,35,35,66,35,90,281,35,35,35,321,35,10,35,98,75,75,75,35
,75,0,75,281,35,35,35,0,35,73,35,131,131,0,0,0,107,0,107,107,0,0,0,27,0
,27,27,131,0,0,0,49,177,0,0,153,0,41,107,107,107,0,107,0,107,27,27,249,0
,27,73,27,131,131,0,0,0,73,0,131,131,0,0,0,73,0,0,131,131,0,0,73,49,177
,131,0,153,0,41,49,177,0,131,153,0,41,49,177,0,131,153,0,41,49,177,363,363
,153,0,41,250,266,274,258,282,290,363,0,370,378,363,363,0,0,201,0,0,363
,363,0,0,363,0,370,378,363,363,0,363,201,370,378,363,363,0,0,363,0,370,378
,363,363,0,363,0,370,378,0,0,0,0,363,0,370,378}
%%END(pmActTab)
%%SET pmActRDScheckLen(265)
%%SET pmRDScheckTyp(1)
%%SET pmActRowMapTyp(1)
%%BEGIN(pmRDScheck)
{1,10,10,13,13,6,13,13,13,13,13,13,10,13,13,13,13,13,4,13,6,13,35,35,14
,14,17,17,13,17,17,17,17,17,17,14,17,17,17,17,17,19,17,22,17,40,40,12,12
,11,11,17,11,11,11,11,11,11,12,11,11,11,0,30,0,11,31,11,16,33,27,34,27,27
,11,8,36,37,32,0,38,32,39,0,0,0,0,27,0,2,0,41,27,27,27,32,27,42,27,32,32
,32,32,42,32,20,32,20,20,42,42,42,28,42,28,28,42,42,42,29,42,29,29,20,42
,42,42,20,20,42,42,20,42,20,28,28,28,42,28,42,28,29,29,29,42,29,23,29,23
,23,42,42,42,3,42,3,3,42,42,42,5,42,42,5,23,42,42,7,23,23,7,42,23,42,23
,3,3,42,5,3,42,3,5,5,42,7,5,42,5,7,7,18,18,7,42,7,25,25,25,25,25,25,18,42
,18,18,21,21,42,42,18,42,42,9,9,42,42,21,42,21,21,24,24,42,9,21,9,9,15,15
,42,42,24,42,24,24,26,26,42,15,42,15,15,42,42,42,42,26,42,26,26,42,42,42
,42,42,42,42,42,42,42,42,42,42,42}
%%END(pmRDScheck)
%%BEGIN(pmActRowMap)
{61,0,86,152,17,159,1,166,49,212,0,46,46,0,23,227,55,23,190,20,104,205,15
,145,220,190,235,69,111,118,62,62,77,65,70,18,75,71,78,81,41,90}
%%END(pmActRowMap)
%%BEGIN(pmContTab)
{{2,2}
,{1,1}
,{4,4}
,{4,5}
,{2,2}
,{5,5}
,{20,5}
,{5,5}
,{27,27}
,{2,2}
,{2,2}
,{4,5}
,{2,2}
,{4,5}
,{2,2}
,{2,2}
,{14,14}
,{4,5}
,{21,21}
,{22,22}
,{4,5}
,{21,21}
,{29,29}
,{4,5}
,{2,2}
,{7,7}
,{2,2}
,{2,5}
,{2,5}
,{2,5}
,{2,2}
,{5,5}
,{2,5}
,{5,5}
,{2,2}
,{5,6}
,{2,2}
,{7,7}
,{3,3}
,{2,2}
,{5,6}
,{2,2}
}
%%END(pmContTab)
%%BEGIN(pmSeparators)
{6,0,0,0}
%%END(pmSeparators)
%%BEGIN(pmFiducials)
{0,0,17,234}
%%END(pmFiducials)
%%BEGIN(pmSkips)
{0,0,0,0}
%%END(pmSkips)
%%SET pmNonTerms(26)
%%SET pmNonTermTyp(1)
%%SET pmGtoTyp(2)
%%SET pmGtoRDSvectorLen(73)
%%BEGIN(pmGtoTab)
{145,25,217,97,105,121,322,17,202,185,209,57,330,33,162,89,138,170,146,18
,225,137,233,154,114,162,89,138,170,146,210,161,209,241,154,121,162,89,138
,170,146,218,58,178,329,154,0,162,89,138,170,146,226,273,234,0,154,0,162
,89,138,170,146,242,113,33,50,154,89,289,322,0,225}
%%END(pmGtoTab)
%%SET pmGtoRowMapTyp(1)
%%BEGIN(pmGtoRowMap)
{0,6,6,11,6,0,3,22,3,33,0,0,64,0,6,11,1,30,22,1,33,0,1,44,44,0,53,1,8,0
,0,0,52,0,47,0,23,0,0,32,0,0}
%%END(pmGtoRowMap)
%%SET pmProds(51)
%%SET pmLhsTyp(1)
%%SET pmRhszTyp(1)
%%BEGIN(pmLhs)
{38,32,44,51,51,53,53,50,52,52,43,43,56,56,55,39,39,39,39,39,39,54,47,49
,42,42,45,48,40,40,33,33,33,33,33,33,41,34,34,31,31,37,37,37,46,46,46,35
,35,36,36}
%%END(pmLhs)
%%BEGIN(pmRhsz)
{2,2,3,0,3,1,3,3,0,3,1,3,0,2,5,0,1,1,1,1,1,3,2,3,1,3,4,4,2,3,1,1,1,1,1,1
,2,1,3,1,3,1,1,3,0,1,1,1,1,1,1}
%%END(pmRhsz)
%%SET pmSccMax(36)
%%SET pmSccTyp(1)
%%SET pmICostTyp(1)
%%SET pmDCostTyp(1)
%%BEGIN(pmVocTab)
{{1,255,255,"EndOfText",""}
,{2,1,1,"IDENTIFIER","<id>"}
,{3,1,1,"NUMBER","0"}
,{4,1,1,"'.'",""}
,{5,1,1,"';'",""}
,{6,1,1,"','",""}
,{7,1,1,"'='",""}
,{8,1,1,"'<'",""}
,{9,1,1,"'>'",""}
,{10,1,1,"'<>'",""}
,{11,1,1,"'<='",""}
,{12,1,1,"'>='",""}
,{13,1,1,"'('",""}
,{14,1,1,"')'",""}
,{15,1,1,"'+'",""}
,{16,1,1,"'-'",""}
,{17,1,1,"'*'",""}
,{18,1,1,"'/'",""}
,{25,1,1,"'VAR'",""}
,{26,1,1,"'END'",""}
,{27,1,1,"'ODD'",""}
,{28,1,1,"'THEN'",""}
,{29,1,1,"'CONST'",""}
,{30,1,1,"'BEGIN'",""}
,{31,1,1,"'WHILE'",""}
,{32,1,1,"'PROCEDURE'",""}
,{33,1,1,"':='",""}
,{34,1,1,"'IF'",""}
,{35,1,1,"'DO'",""}
,{36,1,1,"'CALL'",""}
}
%%END(pmVocTab)
%%SET pmSem(On)
%%BEGIN(pmSemantics)
    switch (rule) {
          case 1: { /* <program> = <block> '.'; */

            program = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].list;
          	break;}
    case 2: { /* <block> = <declarations> <statement>; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].list = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].list;
	  	break;}
    case 3: { /* <declarations> = <constant declaration> <variable declaration> <procedure declarations>; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].list = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].list;
	  	break;}
    case 5: { /* <constant declaration> = 'CONST' <constant definitions> ';'; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].list = %%(parserPrefix)SeSt[%%(parserPrefix)StkP+2].list;
	  	break;}
    case 4: { /* <constant declaration> =; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].list = NULL;
	  	break;}
    case 7: { /* <constant definitions> = <constant definitions> ',' <constant definition>; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].list =
		append(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].list,
		       makeNode(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].stringValue,
				%%(parserPrefix)SeSt[%%(parserPrefix)StkP+3].integerValue));
	  	break;}
    case 6: { /* <constant definitions> = <constant definition>; */

	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].list = 
		makeNode(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].stringValue,
			 %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].integerValue);
	  	break;}
    case 8: { /* <constant definition> = IDENTIFIER '=' NUMBER; */

	    constants++;
	    strcpy(%%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].stringValue, %%(parserPrefix)SySt[%%(parserPrefix)StkP+1].stringValue);
	    %%(parserPrefix)SeSt[%%(parserPrefix)StkP+1].integerValue = %%(parserPrefix)SySt[%%(parserPrefix)StkP+3].integerValue;
	  	break;}
    case 12: { /* <identifiers> = <identifiers> ',' IDENTIFIER; */

	    variables++;
	  	break;}
    case 11: { /* <identifiers> = IDENTIFIER; */

	    variables++;
	  	break;}
    case 15: { /* <procedure declaration> = 'PROCEDURE' IDENTIFIER ';' <block> ';'; */

	    procedures++;
	  	break;}
    case 19: { /* <statement> = <assignment statement>; */

	    statements++;
	  	break;}
    case 17: { /* <statement> = <call statement>; */

	    statements++;
	  	break;}
    case 18: { /* <statement> = <compound statement>; */

	    statements++;
	  	break;}
    case 20: { /* <statement> = <if statement>; */

	    statements++;
	  	break;}
    case 21: { /* <statement> = <while statement>; */

	    statements++;
	  	break;}
%%END(pmSemantics)
%%SET vocFileName ("skipcode.voc")
%%BEGIN (pmVoc)
   0    0 Unknown                  main
   1    1 EndOfText                main
   2    2 IDENTIFIER               main
   3    3 NUMBER                   main
   4    4 '.'                      main
   5    5 ';'                      main
   6    6 ','                      main
   7    7 '='                      main
   8    8 '<'                      main
   9    9 '>'                      main
  10   10 '<>'                     main
  11   11 '<='                     main
  12   12 '>='                     main
  13   13 '('                      main
  14   14 ')'                      main
  15   15 '+'                      main
  16   16 '-'                      main
  17   17 '*'                      main
  18   18 '/'                      main
  19   25 'VAR'                    main
  20   26 'END'                    main
  21   27 'ODD'                    main
  22   28 'THEN'                   main
  23   29 'CONST'                  main
  24   30 'BEGIN'                  main
  25   31 'WHILE'                  main
  26   32 'PROCEDURE'              main
  27   33 ':='                     main
  28   34 'IF'                     main
  29   35 'DO'                     main
  30   36 'CALL'                   main
%%END (pmVoc)
%%PROCESS("%%(pmkLibrary)/Parse.imp")
%%PROCESS("%%(pmkLibrary)/Err.imp")
+++++ skipcode.voc +++++
   0    0 Unknown                  main
   1    1 EndOfText                main
   2    2 IDENTIFIER               main
   3    3 NUMBER                   main
   4    4 '.'                      main
   5    5 ';'                      main
   6    6 ','                      main
   7    7 '='                      main
   8    8 '<'                      main
   9    9 '>'                      main
  10   10 '<>'                     main
  11   11 '<='                     main
  12   12 '>='                     main
  13   13 '('                      main
  14   14 ')'                      main
  15   15 '+'                      main
  16   16 '-'                      main
  17   17 '*'                      main
  18   18 '/'                      main
  19   25 'VAR'                    main
  20   26 'END'                    main
  21   27 'ODD'                    main
  22   28 'THEN'                   main
  23   29 'CONST'                  main
  24   30 'BEGIN'                  main
  25   31 'WHILE'                  main
  26   32 'PROCEDURE'              main
  27   33 ':='                     main
  28   34 'IF'                     main
  29   35 'DO'                     main
  30   36 'CALL'                   main
